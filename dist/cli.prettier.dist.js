#!/usr/bin/env node
function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var require$$0 = _interopDefault(require('path'));
var util = _interopDefault(require('util'));
var events = _interopDefault(require('events'));
var require$$0$1 = _interopDefault(require('assert'));
var readline = _interopDefault(require('readline'));

var stdin$1 = process.stdin;

var index = function () {
	var ret = '';

	return new Promise(function (resolve) {
		if (stdin$1.isTTY) {
			resolve(ret);
			return;
		}

		stdin$1.setEncoding('utf8');

		stdin$1.on('readable', function () {
			var chunk;

			while ((chunk = stdin$1.read())) {
				ret += chunk;
			}
		});

		stdin$1.on('end', function () {
			resolve(ret);
		});
	});
};

var buffer = function () {
	var ret = [];
	var len = 0;

	return new Promise(function (resolve) {
		if (stdin$1.isTTY) {
			resolve(new Buffer(''));
			return;
		}

		stdin$1.on('readable', function () {
			var chunk;

			while ((chunk = stdin$1.read())) {
				ret.push(chunk);
				len += chunk.length;
			}
		});

		stdin$1.on('end', function () {
			resolve(Buffer.concat(ret, len));
		});
	});
};

index.buffer = buffer;

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = require$$0;
var isWindows = process.platform === 'win32';
var fs$4 = fs;

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

var realpathSync$1 = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs$4.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs$4.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs$4.statSync(base);
        linkTarget = fs$4.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


var realpath$1 = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs$4.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs$4.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs$4.stat(base, function(err) {
      if (err) return cb(err);

      fs$4.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};

var old$1 = {
	realpathSync: realpathSync$1,
	realpath: realpath$1
};

var index$2 = realpath;
realpath.realpath = realpath;
realpath.sync = realpathSync;
realpath.realpathSync = realpathSync;
realpath.monkeypatch = monkeypatch;
realpath.unmonkeypatch = unmonkeypatch;

var fs$3 = fs;
var origRealpath = fs$3.realpath;
var origRealpathSync = fs$3.realpathSync;

var version = process.version;
var ok = /^v[0-5]\./.test(version);
var old = old$1;

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache;
    cache = null;
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb);
    } else {
      cb(er, result);
    }
  });
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs$3.realpath = realpath;
  fs$3.realpathSync = realpathSync;
}

function unmonkeypatch () {
  fs$3.realpath = origRealpath;
  fs$3.realpathSync = origRealpathSync;
}

var index$6 = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var index$8 = balanced$1;
function balanced$1(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced$1.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}

var concatMap = index$6;
var balanced = index$8;

var index$4 = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand$1(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand$1(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand$1(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand$1(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand$1(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand$1(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length);
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand$1(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}

var minimatch_1 = minimatch$1;
minimatch$1.Minimatch = Minimatch$1;

var path$1 = { sep: '/' };
try {
  path$1 = require$$0;
} catch (er) {}

var GLOBSTAR = minimatch$1.GLOBSTAR = Minimatch$1.GLOBSTAR = {};
var expand = index$4;

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
};

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]';

// * => any number of characters
var star = qmark + '*?';

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?';

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?';

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!');

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true;
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/;

minimatch$1.filter = filter;
function filter (pattern, options) {
  options = options || {};
  return function (p, i, list) {
    return minimatch$1(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {};
  b = b || {};
  var t = {};
  Object.keys(b).forEach(function (k) {
    t[k] = b[k];
  });
  Object.keys(a).forEach(function (k) {
    t[k] = a[k];
  });
  return t
}

minimatch$1.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch$1

  var orig = minimatch$1;

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  };

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  };

  return m
};

Minimatch$1.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch$1
  return minimatch$1.defaults(def).Minimatch
};

function minimatch$1 (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch$1(pattern, options).match(p)
}

function Minimatch$1 (pattern, options) {
  if (!(this instanceof Minimatch$1)) {
    return new Minimatch$1(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {};
  pattern = pattern.trim();

  // windows support: need to use /, not \
  if (path$1.sep !== '/') {
    pattern = pattern.split(path$1.sep).join('/');
  }

  this.options = options;
  this.set = [];
  this.pattern = pattern;
  this.regexp = null;
  this.negate = false;
  this.comment = false;
  this.empty = false;

  // make the set of regexps etc.
  this.make();
}

Minimatch$1.prototype.debug = function () {};

Minimatch$1.prototype.make = make;
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern;
  var options = this.options;

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true;
    return
  }
  if (!pattern) {
    this.empty = true;
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate();

  // step 2: expand braces
  var set = this.globSet = this.braceExpand();

  if (options.debug) this.debug = console.error;

  this.debug(this.pattern, set);

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  });

  this.debug(this.pattern, set);

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this);

  this.debug(this.pattern, set);

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  });

  this.debug(this.pattern, set);

  this.set = set;
}

Minimatch$1.prototype.parseNegate = parseNegate;
function parseNegate () {
  var pattern = this.pattern;
  var negate = false;
  var options = this.options;
  var negateOffset = 0;

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate;
    negateOffset++;
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset);
  this.negate = negate;
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch$1.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
};

Minimatch$1.prototype.braceExpand = braceExpand;

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch$1) {
      options = this.options;
    } else {
      options = {};
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern;

  if (typeof pattern === 'undefined') {
    throw new TypeError('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch$1.prototype.parse = parse;
var SUBPARSE = {};
function parse (pattern, isSub) {
  if (pattern.length > 1024 * 64) {
    throw new TypeError('pattern is too long')
  }

  var options = this.options;

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = '';
  var hasMagic = !!options.nocase;
  var escaping = false;
  // ? => one single character
  var patternListStack = [];
  var negativeLists = [];
  var stateChar;
  var inClass = false;
  var reClassStart = -1;
  var classStart = -1;
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)';
  var self = this;

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star;
          hasMagic = true;
        break
        case '?':
          re += qmark;
          hasMagic = true;
        break
        default:
          re += '\\' + stateChar;
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re);
      stateChar = false;
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c);

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c;
      escaping = false;
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar();
        escaping = true;
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c);

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class');
          if (c === '!' && i === classStart + 1) c = '^';
          re += c;
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar);
        clearStateChar();
        stateChar = c;
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar();
      continue

      case '(':
        if (inClass) {
          re += '(';
          continue
        }

        if (!stateChar) {
          re += '\\(';
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        });
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
        this.debug('plType %j %j', stateChar, re);
        stateChar = false;
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)';
          continue
        }

        clearStateChar();
        hasMagic = true;
        var pl = patternListStack.pop();
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close;
        if (pl.type === '!') {
          negativeLists.push(pl);
        }
        pl.reEnd = re.length;
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|';
          escaping = false;
          continue
        }

        clearStateChar();
        re += '|';
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar();

        if (inClass) {
          re += '\\' + c;
          continue
        }

        inClass = true;
        classStart = i;
        reClassStart = re.length;
        re += c;
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c;
          escaping = false;
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i);
          try {
            RegExp('[' + cs + ']');
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE);
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
            hasMagic = hasMagic || sp[1];
            inClass = false;
            continue
          }
        }

        // finish up the class.
        hasMagic = true;
        inClass = false;
        re += c;
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar();

        if (escaping) {
          // no need
          escaping = false;
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\';
        }

        re += c;

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1);
    sp = this.parse(cs, SUBPARSE);
    re = re.substr(0, reClassStart) + '\\[' + sp[0];
    hasMagic = hasMagic || sp[1];
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length);
    this.debug('setting tail', re, pl);
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\';
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    });

    this.debug('tail=%j\n   %s', tail, tail, pl, re);
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type;

    hasMagic = true;
    re = re.slice(0, pl.reStart) + t + '\\(' + tail;
  }

  // handle trailing things that only matter at the very end.
  clearStateChar();
  if (escaping) {
    // trailing \\
    re += '\\\\';
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false;
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true;
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n];

    var nlBefore = re.slice(0, nl.reStart);
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
    var nlAfter = re.slice(nl.reEnd);

    nlLast += nlAfter;

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1;
    var cleanAfter = nlAfter;
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
    }
    nlAfter = cleanAfter;

    var dollar = '';
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$';
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
    re = newRe;
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re;
  }

  if (addPatternStart) {
    re = patternStart + re;
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : '';
  try {
    var regExp = new RegExp('^' + re + '$', flags);
  } catch (er) {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern;
  regExp._src = re;

  return regExp
}

minimatch$1.makeRe = function (pattern, options) {
  return new Minimatch$1(pattern, options || {}).makeRe()
};

Minimatch$1.prototype.makeRe = makeRe;
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set;

  if (!set.length) {
    this.regexp = false;
    return this.regexp
  }
  var options = this.options;

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot;
  var flags = options.nocase ? 'i' : '';

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|');

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$';

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$';

  try {
    this.regexp = new RegExp(re, flags);
  } catch (ex) {
    this.regexp = false;
  }
  return this.regexp
}

minimatch$1.match = function (list, pattern, options) {
  options = options || {};
  var mm = new Minimatch$1(pattern, options);
  list = list.filter(function (f) {
    return mm.match(f)
  });
  if (mm.options.nonull && !list.length) {
    list.push(pattern);
  }
  return list
};

Minimatch$1.prototype.match = match;
function match (f, partial) {
  this.debug('match', f, this.pattern);
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options;

  // windows: need to use /, not \
  if (path$1.sep !== '/') {
    f = f.split(path$1.sep).join('/');
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit);
  this.debug(this.pattern, 'split', f);

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set;
  this.debug(this.pattern, 'set', set);

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  var i;
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i];
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i];
    var file = f;
    if (options.matchBase && pattern.length === 1) {
      file = [filename];
    }
    var hit = this.matchOne(file, pattern, partial);
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch$1.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options;

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern });

  this.debug('matchOne', file.length, pattern.length);

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop');
    var p = pattern[pi];
    var f = file[fi];

    this.debug(pattern, p, f);

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f]);

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi;
      var pr = pi + 1;
      if (pr === pl) {
        this.debug('** at the end');
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr];

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee);
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr);
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue');
          fr++;
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit;
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase();
      } else {
        hit = f === p;
      }
      this.debug('string match', p, f, hit);
    } else {
      hit = f.match(p);
      this.debug('pattern match', p, f, hit);
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '');
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
};

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
});

var inherits$1 = createCommonjsModule(function (module) {
try {
  var util$$1 = util;
  if (typeof util$$1.inherits !== 'function') throw '';
  module.exports = util$$1.inherits;
} catch (e) {
  module.exports = inherits_browser;
}
});

function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

var index$10 = process.platform === 'win32' ? win32 : posix;
var posix_1 = posix;
var win32_1 = win32;

index$10.posix = posix_1;
index$10.win32 = win32_1;

var alphasort_1 = alphasort$2;
var alphasorti_1 = alphasorti$2;
var setopts_1 = setopts$2;
var ownProp_1 = ownProp$2;
var makeAbs_1 = makeAbs;
var finish_1 = finish;
var mark_1 = mark;
var isIgnored_1 = isIgnored$2;
var childrenIgnored_1 = childrenIgnored$2;

function ownProp$2 (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var path$3 = require$$0;
var minimatch$3 = minimatch_1;
var isAbsolute$2 = index$10;
var Minimatch$3 = minimatch$3.Minimatch;

function alphasorti$2 (a, b) {
  return a.toLowerCase().localeCompare(b.toLowerCase())
}

function alphasort$2 (a, b) {
  return a.localeCompare(b)
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || [];

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore];

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap);
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null;
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '');
    gmatcher = new Minimatch$3(gpattern, { dot: true });
  }

  return {
    matcher: new Minimatch$3(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts$2 (self, pattern, options) {
  if (!options)
    options = {};

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern;
  }

  self.silent = !!options.silent;
  self.pattern = pattern;
  self.strict = options.strict !== false;
  self.realpath = !!options.realpath;
  self.realpathCache = options.realpathCache || Object.create(null);
  self.follow = !!options.follow;
  self.dot = !!options.dot;
  self.mark = !!options.mark;
  self.nodir = !!options.nodir;
  if (self.nodir)
    self.mark = true;
  self.sync = !!options.sync;
  self.nounique = !!options.nounique;
  self.nonull = !!options.nonull;
  self.nosort = !!options.nosort;
  self.nocase = !!options.nocase;
  self.stat = !!options.stat;
  self.noprocess = !!options.noprocess;
  self.absolute = !!options.absolute;

  self.maxLength = options.maxLength || Infinity;
  self.cache = options.cache || Object.create(null);
  self.statCache = options.statCache || Object.create(null);
  self.symlinks = options.symlinks || Object.create(null);

  setupIgnores(self, options);

  self.changedCwd = false;
  var cwd = process.cwd();
  if (!ownProp$2(options, "cwd"))
    self.cwd = cwd;
  else {
    self.cwd = path$3.resolve(options.cwd);
    self.changedCwd = self.cwd !== cwd;
  }

  self.root = options.root || path$3.resolve(self.cwd, "/");
  self.root = path$3.resolve(self.root);
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/");

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute$2(self.cwd) ? self.cwd : makeAbs(self, self.cwd);
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/");
  self.nomount = !!options.nomount;

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true;
  options.nocomment = true;

  self.minimatch = new Minimatch$3(pattern, options);
  self.options = self.minimatch.options;
}

function finish (self) {
  var nou = self.nounique;
  var all = nou ? [] : Object.create(null);

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i];
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i];
        if (nou)
          all.push(literal);
        else
          all[literal] = true;
      }
    } else {
      // had matches
      var m = Object.keys(matches);
      if (nou)
        all.push.apply(all, m);
      else
        m.forEach(function (m) {
          all[m] = true;
        });
    }
  }

  if (!nou)
    all = Object.keys(all);

  if (!self.nosort)
    all = all.sort(self.nocase ? alphasorti$2 : alphasort$2);

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i]);
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e));
        var c = self.cache[e] || self.cache[makeAbs(self, e)];
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c);
        return notDir
      });
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored$2(self, m)
    });

  self.found = all;
}

function mark (self, p) {
  var abs = makeAbs(self, p);
  var c = self.cache[abs];
  var m = p;
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c);
    var slash = p.slice(-1) === '/';

    if (isDir && !slash)
      m += '/';
    else if (!isDir && slash)
      m = m.slice(0, -1);

    if (m !== p) {
      var mabs = makeAbs(self, m);
      self.statCache[mabs] = self.statCache[abs];
      self.cache[mabs] = self.cache[abs];
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f;
  if (f.charAt(0) === '/') {
    abs = path$3.join(self.root, f);
  } else if (isAbsolute$2(f) || f === '') {
    abs = f;
  } else if (self.changedCwd) {
    abs = path$3.resolve(self.cwd, f);
  } else {
    abs = path$3.resolve(f);
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/');

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored$2 (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored$2 (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}

var common$2 = {
	alphasort: alphasort_1,
	alphasorti: alphasorti_1,
	setopts: setopts_1,
	ownProp: ownProp_1,
	makeAbs: makeAbs_1,
	finish: finish_1,
	mark: mark_1,
	isIgnored: isIgnored_1,
	childrenIgnored: childrenIgnored_1
};

var sync = globSync$1;
globSync$1.GlobSync = GlobSync$1;

var fs$5 = fs;
var rp$1 = index$2;
var minimatch$2 = minimatch_1;
var path$2 = require$$0;
var assert$1 = require$$0$1;
var isAbsolute$1 = index$10;
var common$1 = common$2;
var setopts$1 = common$1.setopts;
var ownProp$1 = common$1.ownProp;
var childrenIgnored$1 = common$1.childrenIgnored;
var isIgnored$1 = common$1.isIgnored;

function globSync$1 (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync$1(pattern, options).found
}

function GlobSync$1 (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync$1))
    return new GlobSync$1(pattern, options)

  setopts$1(this, pattern, options);

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length;
  this.matches = new Array(n);
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false);
  }
  this._finish();
}

GlobSync$1.prototype._finish = function () {
  assert$1(this instanceof GlobSync$1);
  if (this.realpath) {
    var self = this;
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null);
      for (var p in matchset) {
        try {
          p = self._makeAbs(p);
          var real = rp$1.realpathSync(p, self.realpathCache);
          set[real] = true;
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true;
          else
            throw er
        }
      }
    });
  }
  common$1.finish(this);
};


GlobSync$1.prototype._process = function (pattern, index, inGlobStar) {
  assert$1(this instanceof GlobSync$1);

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n ++;
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (isAbsolute$1(prefix) || isAbsolute$1(pattern.join('/'))) {
    if (!prefix || !isAbsolute$1(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip processing
  if (childrenIgnored$1(this, read))
    return

  var isGlobStar = remain[0] === minimatch$2.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
};


GlobSync$1.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar);

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path$2.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix)
      newPattern = [prefix, e];
    else
      newPattern = [e];
    this._process(newPattern.concat(remain), index, inGlobStar);
  }
};


GlobSync$1.prototype._emitMatch = function (index, e) {
  if (isIgnored$1(this, e))
    return

  var abs = this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute) {
    e = abs;
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  if (this.stat)
    this._stat(e);
};


GlobSync$1.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries;
  var lstat;
  var stat;
  try {
    lstat = fs$5.lstatSync(abs);
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink();
  this.symlinks[abs] = isSym;

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE';
  else
    entries = this._readdir(abs, false);

  return entries
};

GlobSync$1.prototype._readdir = function (abs, inGlobStar) {
  var entries;

  if (inGlobStar && !ownProp$1(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, fs$5.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er);
    return null
  }
};

GlobSync$1.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;

  // mark and cache dir-ness
  return entries
};

GlobSync$1.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er);
      break
  }
};

GlobSync$1.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar);

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [ prefix ] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false);

  var len = entries.length;
  var isSym = this.symlinks[abs];

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true);
  }
};

GlobSync$1.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix);

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute$1(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path$2.join(this.root, prefix);
    } else {
      prefix = path$2.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
};

// Returns either 'DIR', 'FILE', or false
GlobSync$1.prototype._stat = function (f) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp$1(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (!stat) {
    var lstat;
    try {
      lstat = fs$5.lstatSync(abs);
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false;
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = fs$5.statSync(abs);
      } catch (er) {
        stat = lstat;
      }
    } else {
      stat = lstat;
    }
  }

  this.statCache[abs] = stat;

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';

  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return false

  return c
};

GlobSync$1.prototype._mark = function (p) {
  return common$1.mark(this, p)
};

GlobSync$1.prototype._makeAbs = function (f) {
  return common$1.makeAbs(this, f)
};

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
var wrappy_1 = wrappy$1;
function wrappy$1 (fn, cb) {
  if (fn && cb) return wrappy$1(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k];
  });

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    var ret = fn.apply(this, args);
    var cb = args[args.length-1];
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k];
      });
    }
    return ret
  }
}

var wrappy$2 = wrappy_1;
var once_1 = wrappy$2(once$2);
var strict = wrappy$2(onceStrict);

once$2.proto = once$2(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once$2(this)
    },
    configurable: true
  });

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  });
});

function once$2 (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  f.called = false;
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true;
    return f.value = fn.apply(this, arguments)
  };
  var name = fn.name || 'Function wrapped with `once`';
  f.onceError = name + " shouldn't be called more than once";
  f.called = false;
  return f
}

once_1.strict = strict;

var wrappy = wrappy_1;
var reqs = Object.create(null);
var once$1 = once_1;

var inflight_1 = wrappy(inflight$1);

function inflight$1 (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb);
    return null
  } else {
    reqs[key] = [cb];
    return makeres(key)
  }
}

function makeres (key) {
  return once$1(function RES () {
    var cbs = reqs[key];
    var len = cbs.length;
    var args = slice(arguments);

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args);
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len);
        process.nextTick(function () {
          RES.apply(null, args);
        });
      } else {
        delete reqs[key];
      }
    }
  })
}

function slice (args) {
  var length = args.length;
  var array = [];

  for (var i = 0; i < length; i++) array[i] = args[i];
  return array
}

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

var glob_1 = glob$1;

var fs$2 = fs;
var rp = index$2;
var minimatch = minimatch_1;
var inherits = inherits$1;
var EE = events.EventEmitter;
var path = require$$0;
var assert = require$$0$1;
var isAbsolute = index$10;
var globSync = sync;
var common = common$2;
var setopts = common.setopts;
var ownProp = common.ownProp;
var inflight = inflight_1;
var childrenIgnored = common.childrenIgnored;
var isIgnored = common.isIgnored;

var once = once_1;

function glob$1 (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {};
  if (!options) options = {};

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob$1.sync = globSync;
var GlobSync = glob$1.GlobSync = globSync.GlobSync;

// old api surface
glob$1.glob = glob$1;

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin
}

glob$1.hasMagic = function (pattern, options_) {
  var options = extend({}, options_);
  options.noprocess = true;

  var g = new Glob(pattern, options);
  var set = g.minimatch.set;

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
};

glob$1.Glob = Glob;
inherits(Glob, EE);
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options;
    options = null;
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options);
  this._didRealPath = false;

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length;

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n);

  if (typeof cb === 'function') {
    cb = once(cb);
    this.on('error', cb);
    this.on('end', function (matches) {
      cb(null, matches);
    });
  }

  var self = this;
  var n = this.minimatch.set.length;
  this._processing = 0;
  this.matches = new Array(n);

  this._emitQueue = [];
  this._processQueue = [];
  this.paused = false;

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync$$1 = true;
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done);
  }
  sync$$1 = false;

  function done () {
    --self._processing;
    if (self._processing <= 0) {
      if (sync$$1) {
        process.nextTick(function () {
          self._finish();
        });
      } else {
        self._finish();
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob);
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this);
  this.emit('end', this.found);
};

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true;

  var n = this.matches.length;
  if (n === 0)
    return this._finish()

  var self = this;
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next);

  function next () {
    if (--n === 0)
      self._finish();
  }
};

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index];
  if (!matchset)
    return cb()

  var found = Object.keys(matchset);
  var self = this;
  var n = found.length;

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null);
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p);
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true;
      else if (er.syscall === 'stat')
        set[p] = true;
      else
        self.emit('error', er); // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set;
        cb();
      }
    });
  });
};

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
};

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
};

Glob.prototype.abort = function () {
  this.aborted = true;
  this.emit('abort');
};

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true;
    this.emit('pause');
  }
};

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume');
    this.paused = false;
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0);
      this._emitQueue.length = 0;
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i];
        this._emitMatch(e[0], e[1]);
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0);
      this._processQueue.length = 0;
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i];
        this._processing--;
        this._process(p[0], p[1], p[2], p[3]);
      }
    }
  }
};

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob);
  assert(typeof cb === 'function');

  if (this.aborted)
    return

  this._processing++;
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb]);
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0;
  while (typeof pattern[n] === 'string') {
    n ++;
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix;
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb);
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null;
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/');
      break
  }

  var remain = pattern.slice(n);

  // get the list of entries.
  var read;
  if (prefix === null)
    read = '.';
  else if (isAbsolute(prefix) || isAbsolute(pattern.join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix;
    read = prefix;
  } else
    read = prefix;

  var abs = this._makeAbs(read);

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR;
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
};

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  });
};

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0];
  var negate = !!this.minimatch.negate;
  var rawGlob = pn._glob;
  var dotOk = this.dot || rawGlob.charAt(0) === '.';

  var matchedEntries = [];
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i];
    if (e.charAt(0) !== '.' || dotOk) {
      var m;
      if (negate && !prefix) {
        m = !e.match(pn);
      } else {
        m = e.match(pn);
      }
      if (m)
        matchedEntries.push(e);
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length;
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i];
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e;
        else
          e = prefix + e;
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e);
      }
      this._emitMatch(index, e);
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift();
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i];
    var newPattern;
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e;
      else
        e = prefix + e;
    }
    this._process([e].concat(remain), index, inGlobStar, cb);
  }
  cb();
};

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e]);
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e);

  if (this.mark)
    e = this._mark(e);

  if (this.absolute)
    e = abs;

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs];
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true;

  var st = this.statCache[abs];
  if (st)
    this.emit('stat', e, st);

  this.emit('match', e);
};

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs;
  var self = this;
  var lstatcb = inflight(lstatkey, lstatcb_);

  if (lstatcb)
    fs$2.lstat(abs, lstatcb);

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink();
    self.symlinks[abs] = isSym;

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE';
      cb();
    } else
      self._readdir(abs, false, cb);
  }
};

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb);
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs];
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this;
  fs$2.readdir(abs, readdirCb(this, abs, cb));
};

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb);
    else
      self._readdirEntries(abs, entries, cb);
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i];
      if (abs === '/')
        e = abs + e;
      else
        e = abs + '/' + e;
      this.cache[e] = true;
    }
  }

  this.cache[abs] = entries;
  return cb(null, entries)
};

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f);
      this.cache[abs] = 'FILE';
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd);
        error.path = this.cwd;
        error.code = er.code;
        this.emit('error', error);
        this.abort();
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false;
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false;
      if (this.strict) {
        this.emit('error', er);
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort();
      }
      if (!this.silent)
        console.error('glob error', er);
      break
  }

  return cb()
};

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this;
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
  });
};


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1);
  var gspref = prefix ? [ prefix ] : [];
  var noGlobStar = gspref.concat(remainWithoutGlobStar);

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb);

  var isSym = this.symlinks[abs];
  var len = entries.length;

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i];
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar);
    this._process(instead, index, true, cb);

    var below = gspref.concat(entries[i], remain);
    this._process(below, index, true, cb);
  }

  cb();
};

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this;
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb);
  });
};
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null);

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix);
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix);
    } else {
      prefix = path.resolve(this.root, prefix);
      if (trail)
        prefix += '/';
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/');

  // Mark this as a match
  this._emitMatch(index, prefix);
  cb();
};

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f);
  var needDir = f.slice(-1) === '/';

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs];

    if (Array.isArray(c))
      c = 'DIR';

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists;
  var stat = this.statCache[abs];
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE';
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this;
  var statcb = inflight('stat\0' + abs, lstatcb_);
  if (statcb)
    fs$2.lstat(abs, statcb);

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return fs$2.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb);
        else
          self._stat2(f, abs, er, stat, cb);
      })
    } else {
      self._stat2(f, abs, er, lstat, cb);
    }
  }
};

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false;
    return cb()
  }

  var needDir = f.slice(-1) === '/';
  this.statCache[abs] = stat;

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true;
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE';
  this.cache[abs] = this.cache[abs] || c;

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

var index$14 = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

var index$16 = createCommonjsModule(function (module) {
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
});

var index$20 = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
};

var ansiRegex = index$20();

var index$18 = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

var ansiRegex$1 = index$20;
var re = new RegExp(ansiRegex$1().source); // remove the `g` flag
var index$22 = re.test.bind(re);

var argv$1 = process.argv;

var terminator = argv$1.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv$1.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

var index$24 = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

var escapeStringRegexp = index$14;
var ansiStyles = index$16;
var stripAnsi = index$18;
var hasAnsi = index$22;
var supportsColor = index$24;
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

var index$12 = new Chalk();
var styles_1 = ansiStyles;
var hasColor = hasAnsi;
var stripColor = stripAnsi;
var supportsColor_1 = supportsColor;

index$12.styles = styles_1;
index$12.hasColor = hasColor;
index$12.stripColor = stripColor;
index$12.supportsColor = supportsColor_1;

var index$26 = function (args, opts) {
    if (!opts) opts = {};
    
    var flags = { bools : {}, strings : {}, unknownFn: null };

    if (typeof opts['unknown'] === 'function') {
        flags.unknownFn = opts['unknown'];
    }

    if (typeof opts['boolean'] === 'boolean' && opts['boolean']) {
      flags.allBools = true;
    } else {
      [].concat(opts['boolean']).filter(Boolean).forEach(function (key) {
          flags.bools[key] = true;
      });
    }
    
    var aliases = {};
    Object.keys(opts.alias || {}).forEach(function (key) {
        aliases[key] = [].concat(opts.alias[key]);
        aliases[key].forEach(function (x) {
            aliases[x] = [key].concat(aliases[key].filter(function (y) {
                return x !== y;
            }));
        });
    });

    [].concat(opts.string).filter(Boolean).forEach(function (key) {
        flags.strings[key] = true;
        if (aliases[key]) {
            flags.strings[aliases[key]] = true;
        }
     });

    var defaults = opts['default'] || {};
    
    var argv = { _ : [] };
    Object.keys(flags.bools).forEach(function (key) {
        setArg(key, defaults[key] === undefined ? false : defaults[key]);
    });
    
    var notFlags = [];

    if (args.indexOf('--') !== -1) {
        notFlags = args.slice(args.indexOf('--')+1);
        args = args.slice(0, args.indexOf('--'));
    }

    function argDefined(key, arg) {
        return (flags.allBools && /^--[^=]+$/.test(arg)) ||
            flags.strings[key] || flags.bools[key] || aliases[key];
    }

    function setArg (key, val, arg) {
        if (arg && flags.unknownFn && !argDefined(key, arg)) {
            if (flags.unknownFn(arg) === false) return;
        }

        var value = !flags.strings[key] && isNumber(val)
            ? Number(val) : val;
        setKey(argv, key.split('.'), value);
        
        (aliases[key] || []).forEach(function (x) {
            setKey(argv, x.split('.'), value);
        });
    }

    function setKey (obj, keys, value) {
        var o = obj;
        keys.slice(0,-1).forEach(function (key) {
            if (o[key] === undefined) o[key] = {};
            o = o[key];
        });

        var key = keys[keys.length - 1];
        if (o[key] === undefined || flags.bools[key] || typeof o[key] === 'boolean') {
            o[key] = value;
        }
        else if (Array.isArray(o[key])) {
            o[key].push(value);
        }
        else {
            o[key] = [ o[key], value ];
        }
    }
    
    function aliasIsBoolean(key) {
      return aliases[key].some(function (x) {
          return flags.bools[x];
      });
    }

    for (var i = 0; i < args.length; i++) {
        var arg = args[i];
        
        if (/^--.+=/.test(arg)) {
            // Using [\s\S] instead of . because js doesn't support the
            // 'dotall' regex modifier. See:
            // http://stackoverflow.com/a/1068308/13216
            var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
            var key = m[1];
            var value = m[2];
            if (flags.bools[key]) {
                value = value !== 'false';
            }
            setArg(key, value, arg);
        }
        else if (/^--no-.+/.test(arg)) {
            var key = arg.match(/^--no-(.+)/)[1];
            setArg(key, false, arg);
        }
        else if (/^--.+/.test(arg)) {
            var key = arg.match(/^--(.+)/)[1];
            var next = args[i + 1];
            if (next !== undefined && !/^-/.test(next)
            && !flags.bools[key]
            && !flags.allBools
            && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                setArg(key, next, arg);
                i++;
            }
            else if (/^(true|false)$/.test(next)) {
                setArg(key, next === 'true', arg);
                i++;
            }
            else {
                setArg(key, flags.strings[key] ? '' : true, arg);
            }
        }
        else if (/^-[^-]+/.test(arg)) {
            var letters = arg.slice(1,-1).split('');
            
            var broken = false;
            for (var j = 0; j < letters.length; j++) {
                var next = arg.slice(j+2);
                
                if (next === '-') {
                    setArg(letters[j], next, arg);
                    continue;
                }
                
                if (/[A-Za-z]/.test(letters[j]) && /=/.test(next)) {
                    setArg(letters[j], next.split('=')[1], arg);
                    broken = true;
                    break;
                }
                
                if (/[A-Za-z]/.test(letters[j])
                && /-?\d+(\.\d*)?(e-?\d+)?$/.test(next)) {
                    setArg(letters[j], next, arg);
                    broken = true;
                    break;
                }
                
                if (letters[j+1] && letters[j+1].match(/\W/)) {
                    setArg(letters[j], arg.slice(j+2), arg);
                    broken = true;
                    break;
                }
                else {
                    setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
                }
            }
            
            var key = arg.slice(-1)[0];
            if (!broken && key !== '-') {
                if (args[i+1] && !/^(-|--)[^-]/.test(args[i+1])
                && !flags.bools[key]
                && (aliases[key] ? !aliasIsBoolean(key) : true)) {
                    setArg(key, args[i+1], arg);
                    i++;
                }
                else if (args[i+1] && /true|false/.test(args[i+1])) {
                    setArg(key, args[i+1] === 'true', arg);
                    i++;
                }
                else {
                    setArg(key, flags.strings[key] ? '' : true, arg);
                }
            }
        }
        else {
            if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
                argv._.push(
                    flags.strings['_'] || !isNumber(arg) ? arg : Number(arg)
                );
            }
            if (opts.stopEarly) {
                argv._.push.apply(argv._, args.slice(i + 1));
                break;
            }
        }
    }
    
    Object.keys(defaults).forEach(function (key) {
        if (!hasKey(argv, key.split('.'))) {
            setKey(argv, key.split('.'), defaults[key]);
            
            (aliases[key] || []).forEach(function (x) {
                setKey(argv, x.split('.'), defaults[key]);
            });
        }
    });
    
    if (opts['--']) {
        argv['--'] = new Array();
        notFlags.forEach(function(key) {
            argv['--'].push(key);
        });
    }
    else {
        notFlags.forEach(function(key) {
            argv._.push(key);
        });
    }

    return argv;
};

function hasKey (obj, keys) {
    var o = obj;
    keys.slice(0,-1).forEach(function (key) {
        o = (o[key] || {});
    });

    var key = keys[keys.length - 1];
    return key in o;
}

function isNumber (x) {
    if (typeof x === 'number') return true;
    if (/^0x[0-9a-f]+$/i.test(x)) return true;
    return /^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}

var index$32 = createCommonjsModule(function (module, exports) {
// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
});

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0]};
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4]);
  else if (match[ 5]) token.type = "comment";
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7];
  else if (match[ 8]) token.type = "regex";
  else if (match[ 9]) token.type = "number";
  else if (match[10]) token.type = "name";
  else if (match[11]) token.type = "punctuator";
  else if (match[12]) token.type = "whitespace";
  return token
};
});

var ast = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var code = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var keyword = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code$$1 = code;

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code$$1.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code$$1.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code$$1.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code$$1.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var utils = createCommonjsModule(function (module, exports) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = ast;
    exports.code = code;
    exports.keyword = keyword;
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var index$30 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

exports.default = function (rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  colNumber = Math.max(colNumber, 0);

  var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
  var chalk = _chalk2.default;
  if (opts.forceColor) {
    chalk = new _chalk2.default.constructor({ enabled: true });
  }
  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };
  var defs = getDefs(chalk);
  if (highlighted) rawLines = highlight(defs, rawLines);

  var linesAbove = opts.linesAbove || 2;
  var linesBelow = opts.linesBelow || 3;

  var lines = rawLines.split(NEWLINE);
  var start = Math.max(lineNumber - (linesAbove + 1), 0);
  var end = Math.min(lines.length, lineNumber + linesBelow);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  var numberMaxWidth = String(end).length;

  var frame = lines.slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = (" " + number).slice(-numberMaxWidth);
    var gutter = " " + paddedNumber + " | ";
    if (number === lineNumber) {
      var markerLine = "";
      if (colNumber) {
        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^")].join("");
      }
      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " " + maybeHighlight(defs.gutter, gutter) + line;
    }
  }).join("\n");

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
};

var _jsTokens = index$32;

var _jsTokens2 = _interopRequireDefault(_jsTokens);

var _esutils = utils;

var _esutils2 = _interopRequireDefault(_esutils);

var _chalk = index$12;

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,

    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold,
    gutter: chalk.grey,
    marker: chalk.red.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

var JSX_TAG = /^[a-z][\w-]*$/i;

var BRACKET = /^[()\[\]{}]$/;

function getTokenType(match) {
  var _match$slice = match.slice(-2),
      offset = _match$slice[0],
      text = _match$slice[1];

  var token = (0, _jsTokens.matchToToken)(match);

  if (token.type === "name") {
    if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  return token.type;
}

function highlight(defs, text) {
  return text.replace(_jsTokens2.default, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = getTokenType(args);
    var colorize = defs[type];
    if (colorize) {
      return args[0].split(NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

module.exports = exports["default"];
});

var Ap = Array.prototype;
var slice$1 = Ap.slice;
var Op = Object.prototype;
var objToStr = Op.toString;
var funObjStr = objToStr.call(function(){});
var strObjStr = objToStr.call("");
var hasOwn = Op.hasOwnProperty;

var types$1 = function () {

    var exports = {};

    // A type is an object with a .check method that takes a value and returns
    // true or false according to whether the value matches the type.

    function Type(check, name) {
        var self = this;
        if (!(self instanceof Type)) {
            throw new Error("Type constructor cannot be invoked without 'new'");
        }

        // Unfortunately we can't elegantly reuse isFunction and isString,
        // here, because this code is executed while defining those types.
        if (objToStr.call(check) !== funObjStr) {
            throw new Error(check + " is not a function");
        }

        // The `name` parameter can be either a function or a string.
        var nameObjStr = objToStr.call(name);
        if (!(nameObjStr === funObjStr ||
          nameObjStr === strObjStr)) {
            throw new Error(name + " is neither a function nor a string");
        }

        Object.defineProperties(self, {
            name: {value: name},
            check: {
                value: function (value, deep) {
                    var result = check.call(self, value, deep);
                    if (!result && deep && objToStr.call(deep) === funObjStr)
                        deep(self, value);
                    return result;
                }
            }
        });
    }

    var Tp = Type.prototype;

    // Throughout this file we use Object.defineProperty to prevent
    // redefinition of exported properties.
    exports.Type = Type;

    // Like .check, except that failure triggers an AssertionError.
    Tp.assert = function (value, deep) {
        if (!this.check(value, deep)) {
            var str = shallowStringify(value);
            throw new Error(str + " does not match type " + this);
        }
        return true;
    };

    function shallowStringify(value) {
        if (isObject.check(value))
            return "{" + Object.keys(value).map(function (key) {
                  return key + ": " + value[key];
              }).join(", ") + "}";

        if (isArray.check(value))
            return "[" + value.map(shallowStringify).join(", ") + "]";

        return JSON.stringify(value);
    }

    Tp.toString = function () {
        var name = this.name;

        if (isString.check(name))
            return name;

        if (isFunction.check(name))
            return name.call(this) + "";

        return name + " type";
    };

    var builtInCtorFns = [];
    var builtInCtorTypes = [];
    var builtInTypes = {};
    exports.builtInTypes = builtInTypes;

    function defBuiltInType(example, name) {
        var objStr = objToStr.call(example);

        var type = new Type(function (value) {
            return objToStr.call(value) === objStr;
        }, name);

        builtInTypes[name] = type;

        if (example && typeof example.constructor === "function") {
            builtInCtorFns.push(example.constructor);
            builtInCtorTypes.push(type);
        }

        return type;
    }

    // These types check the underlying [[Class]] attribute of the given
    // value, rather than using the problematic typeof operator. Note however
    // that no subtyping is considered; so, for instance, isObject.check
    // returns false for [], /./, new Date, and null.
    var isString = defBuiltInType("truthy", "string");
    var isFunction = defBuiltInType(function () {}, "function");
    var isArray = defBuiltInType([], "array");
    var isObject = defBuiltInType({}, "object");
    var isRegExp = defBuiltInType(/./, "RegExp");
    var isDate = defBuiltInType(new Date, "Date");
    var isNumber = defBuiltInType(3, "number");
    var isBoolean = defBuiltInType(true, "boolean");
    var isNull = defBuiltInType(null, "null");
    var isUndefined = defBuiltInType(void 0, "undefined");

    // There are a number of idiomatic ways of expressing types, so this
    // function serves to coerce them all to actual Type objects. Note that
    // providing the name argument is not necessary in most cases.
    function toType(from, name) {
        // The toType function should of course be idempotent.
        if (from instanceof Type)
            return from;

        // The Def type is used as a helper for constructing compound
        // interface types for AST nodes.
        if (from instanceof Def)
            return from.type;

        // Support [ElemType] syntax.
        if (isArray.check(from))
            return Type.fromArray(from);

        // Support { someField: FieldType, ... } syntax.
        if (isObject.check(from))
            return Type.fromObject(from);

        if (isFunction.check(from)) {
            var bicfIndex = builtInCtorFns.indexOf(from);
            if (bicfIndex >= 0) {
                return builtInCtorTypes[bicfIndex];
            }

            // If isFunction.check(from), and from is not a built-in
            // constructor, assume from is a binary predicate function we can
            // use to define the type.
            return new Type(from, name);
        }

        // As a last resort, toType returns a type that matches any value that
        // is === from. This is primarily useful for literal values like
        // toType(null), but it has the additional advantage of allowing
        // toType to be a total function.
        return new Type(function (value) {
            return value === from;
        }, isUndefined.check(name) ? function () {
            return from + "";
        } : name);
    }

    // Returns a type that matches the given value iff any of type1, type2,
    // etc. match the value.
    Type.or = function (/* type1, type2, ... */) {
        var types = [];
        var len = arguments.length;
        for (var i = 0; i < len; ++i)
            types.push(toType(arguments[i]));

        return new Type(function (value, deep) {
            for (var i = 0; i < len; ++i)
                if (types[i].check(value, deep))
                    return true;
            return false;
        }, function () {
            return types.join(" | ");
        });
    };

    Type.fromArray = function (arr) {
        if (!isArray.check(arr)) {
            throw new Error("");
        }
        if (arr.length !== 1) {
            throw new Error("only one element type is permitted for typed arrays");
        }
        return toType(arr[0]).arrayOf();
    };

    Tp.arrayOf = function () {
        var elemType = this;
        return new Type(function (value, deep) {
            return isArray.check(value) && value.every(function (elem) {
                  return elemType.check(elem, deep);
              });
        }, function () {
            return "[" + elemType + "]";
        });
    };

    Type.fromObject = function (obj) {
        var fields = Object.keys(obj).map(function (name) {
            return new Field(name, obj[name]);
        });

        return new Type(function (value, deep) {
            return isObject.check(value) && fields.every(function (field) {
                  return field.type.check(value[field.name], deep);
              });
        }, function () {
            return "{ " + fields.join(", ") + " }";
        });
    };

    function Field(name, type, defaultFn, hidden) {
        var self = this;

        if (!(self instanceof Field)) {
            throw new Error("Field constructor cannot be invoked without 'new'");
        }
        isString.assert(name);

        type = toType(type);

        var properties = {
            name: {value: name},
            type: {value: type},
            hidden: {value: !!hidden}
        };

        if (isFunction.check(defaultFn)) {
            properties.defaultFn = {value: defaultFn};
        }

        Object.defineProperties(self, properties);
    }

    var Fp = Field.prototype;

    Fp.toString = function () {
        return JSON.stringify(this.name) + ": " + this.type;
    };

    Fp.getValue = function (obj) {
        var value = obj[this.name];

        if (!isUndefined.check(value))
            return value;

        if (this.defaultFn)
            value = this.defaultFn.call(obj);

        return value;
    };

    // Define a type whose name is registered in a namespace (the defCache) so
    // that future definitions will return the same type given the same name.
    // In particular, this system allows for circular and forward definitions.
    // The Def object d returned from Type.def may be used to configure the
    // type d.type by calling methods such as d.bases, d.build, and d.field.
    Type.def = function (typeName) {
        isString.assert(typeName);
        return hasOwn.call(defCache, typeName)
          ? defCache[typeName]
          : defCache[typeName] = new Def(typeName);
    };

    // In order to return the same Def instance every time Type.def is called
    // with a particular name, those instances need to be stored in a cache.
    var defCache = Object.create(null);

    function Def(typeName) {
        var self = this;
        if (!(self instanceof Def)) {
            throw new Error("Def constructor cannot be invoked without 'new'");
        }

        Object.defineProperties(self, {
            typeName: {value: typeName},
            baseNames: {value: []},
            ownFields: {value: Object.create(null)},

            // These two are populated during finalization.
            allSupertypes: {value: Object.create(null)}, // Includes own typeName.
            supertypeList: {value: []}, // Linear inheritance hierarchy.
            allFields: {value: Object.create(null)}, // Includes inherited fields.
            fieldNames: {value: []}, // Non-hidden keys of allFields.

            type: {
                value: new Type(function (value, deep) {
                    return self.check(value, deep);
                }, typeName)
            }
        });
    }

    Def.fromValue = function (value) {
        if (value && typeof value === "object") {
            var type = value.type;
            if (typeof type === "string" &&
              hasOwn.call(defCache, type)) {
                var d = defCache[type];
                if (d.finalized) {
                    return d;
                }
            }
        }

        return null;
    };

    var Dp = Def.prototype;

    Dp.isSupertypeOf = function (that) {
        if (that instanceof Def) {
            if (this.finalized !== true ||
              that.finalized !== true) {
                throw new Error("");
            }
            return hasOwn.call(that.allSupertypes, this.typeName);
        } else {
            throw new Error(that + " is not a Def");
        }
    };

    // Note that the list returned by this function is a copy of the internal
    // supertypeList, *without* the typeName itself as the first element.
    exports.getSupertypeNames = function (typeName) {
        if (!hasOwn.call(defCache, typeName)) {
            throw new Error("");
        }
        var d = defCache[typeName];
        if (d.finalized !== true) {
            throw new Error("");
        }
        return d.supertypeList.slice(1);
    };

    // Returns an object mapping from every known type in the defCache to the
    // most specific supertype whose name is an own property of the candidates
    // object.
    exports.computeSupertypeLookupTable = function (candidates) {
        var table = {};
        var typeNames = Object.keys(defCache);
        var typeNameCount = typeNames.length;

        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("" + typeName);
            }
            for (var j = 0; j < d.supertypeList.length; ++j) {
                var superTypeName = d.supertypeList[j];
                if (hasOwn.call(candidates, superTypeName)) {
                    table[typeName] = superTypeName;
                    break;
                }
            }
        }

        return table;
    };

    Dp.checkAllFields = function (value, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
            throw new Error("" + this.typeName);
        }

        function checkFieldByName(name) {
            var field = allFields[name];
            var type = field.type;
            var child = field.getValue(value);
            return type.check(child, deep);
        }

        return isObject.check(value)
          && Object.keys(allFields).every(checkFieldByName);
    };

    Dp.check = function (value, deep) {
        if (this.finalized !== true) {
            throw new Error(
              "prematurely checking unfinalized type " + this.typeName
            );
        }

        // A Def type can only match an object value.
        if (!isObject.check(value))
            return false;

        var vDef = Def.fromValue(value);
        if (!vDef) {
            // If we couldn't infer the Def associated with the given value,
            // and we expected it to be a SourceLocation or a Position, it was
            // probably just missing a "type" field (because Esprima does not
            // assign a type property to such nodes). Be optimistic and let
            // this.checkAllFields make the final decision.
            if (this.typeName === "SourceLocation" ||
              this.typeName === "Position") {
                return this.checkAllFields(value, deep);
            }

            // Calling this.checkAllFields for any other type of node is both
            // bad for performance and way too forgiving.
            return false;
        }

        // If checking deeply and vDef === this, then we only need to call
        // checkAllFields once. Calling checkAllFields is too strict when deep
        // is false, because then we only care about this.isSupertypeOf(vDef).
        if (deep && vDef === this)
            return this.checkAllFields(value, deep);

        // In most cases we rely exclusively on isSupertypeOf to make O(1)
        // subtyping determinations. This suffices in most situations outside
        // of unit tests, since interface conformance is checked whenever new
        // instances are created using builder functions.
        if (!this.isSupertypeOf(vDef))
            return false;

        // The exception is when deep is true; then, we recursively check all
        // fields.
        if (!deep)
            return true;

        // Use the more specific Def (vDef) to perform the deep check, but
        // shallow-check fields defined by the less specific Def (this).
        return vDef.checkAllFields(value, deep)
          && this.checkAllFields(value, false);
    };

    Dp.bases = function () {
        var args = slice$1.call(arguments);
        var bases = this.baseNames;

        if (this.finalized) {
            if (args.length !== bases.length) {
                throw new Error("");
            }
            for (var i = 0; i < args.length; i++) {
                if (args[i] !== bases[i]) {
                    throw new Error("");
                }
            }
            return this;
        }

        args.forEach(function (baseName) {
            isString.assert(baseName);

            // This indexOf lookup may be O(n), but the typical number of base
            // names is very small, and indexOf is a native Array method.
            if (bases.indexOf(baseName) < 0)
                bases.push(baseName);
        });

        return this; // For chaining.
    };

    // False by default until .build(...) is called on an instance.
    Object.defineProperty(Dp, "buildable", {value: false});

    var builders = {};
    exports.builders = builders;

    // This object is used as prototype for any node created by a builder.
    var nodePrototype = {};

    // Call this function to define a new method to be shared by all AST
     // nodes. The replaced method (if any) is returned for easy wrapping.
    exports.defineMethod = function (name, func) {
        var old = nodePrototype[name];

        // Pass undefined as func to delete nodePrototype[name].
        if (isUndefined.check(func)) {
            delete nodePrototype[name];

        } else {
            isFunction.assert(func);

            Object.defineProperty(nodePrototype, name, {
                enumerable: true, // For discoverability.
                configurable: true, // For delete proto[name].
                value: func
            });
        }

        return old;
    };

    var isArrayOfString = isString.arrayOf();

    // Calling the .build method of a Def simultaneously marks the type as
    // buildable (by defining builders[getBuilderName(typeName)]) and
    // specifies the order of arguments that should be passed to the builder
    // function to create an instance of the type.
    Dp.build = function (/* param1, param2, ... */) {
        var self = this;

        var newBuildParams = slice$1.call(arguments);
        isArrayOfString.assert(newBuildParams);

        // Calling Def.prototype.build multiple times has the effect of merely
        // redefining this property.
        Object.defineProperty(self, "buildParams", {
            value: newBuildParams,
            writable: false,
            enumerable: false,
            configurable: true
        });

        if (self.buildable) {
            // If this Def is already buildable, update self.buildParams and
            // continue using the old builder function.
            return self;
        }

        // Every buildable type will have its "type" field filled in
        // automatically. This includes types that are not subtypes of Node,
        // like SourceLocation, but that seems harmless (TODO?).
        self.field("type", String, function () { return self.typeName });

        // Override Dp.buildable for this Def instance.
        Object.defineProperty(self, "buildable", {value: true});

        Object.defineProperty(builders, getBuilderName(self.typeName), {
            enumerable: true,

            value: function () {
                var args = arguments;
                var argc = args.length;
                var built = Object.create(nodePrototype);

                if (!self.finalized) {
                    throw new Error(
                      "attempting to instantiate unfinalized type " +
                      self.typeName
                    );
                }

                function add(param, i) {
                    if (hasOwn.call(built, param))
                        return;

                    var all = self.allFields;
                    if (!hasOwn.call(all, param)) {
                        throw new Error("" + param);
                    }

                    var field = all[param];
                    var type = field.type;
                    var value;

                    if (isNumber.check(i) && i < argc) {
                        value = args[i];
                    } else if (field.defaultFn) {
                        // Expose the partially-built object to the default
                        // function as its `this` object.
                        value = field.defaultFn.call(built);
                    } else {
                        var message = "no value or default function given for field " +
                          JSON.stringify(param) + " of " + self.typeName + "(" +
                          self.buildParams.map(function (name) {
                              return all[name];
                          }).join(", ") + ")";
                        throw new Error(message);
                    }

                    if (!type.check(value)) {
                        throw new Error(
                          shallowStringify(value) +
                          " does not match field " + field +
                          " of type " + self.typeName
                        );
                    }

                    // TODO Could attach getters and setters here to enforce
                    // dynamic type safety.
                    built[param] = value;
                }

                self.buildParams.forEach(function (param, i) {
                    add(param, i);
                });

                Object.keys(self.allFields).forEach(function (param) {
                    add(param); // Use the default value.
                });

                // Make sure that the "type" field was filled automatically.
                if (built.type !== self.typeName) {
                    throw new Error("");
                }

                return built;
            }
        });

        return self; // For chaining.
    };

    function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {
            var len = upperCasePrefix.length;
            switch (len) {
                case 0: return "";
                // If there's only one initial capital letter, just lower-case it.
                case 1: return upperCasePrefix.toLowerCase();
                default:
                    // If there's more than one initial capital letter, lower-case
                    // all but the last one, so that XMLDefaultDeclaration (for
                    // example) becomes xmlDefaultDeclaration.
                    return upperCasePrefix.slice(
                        0, len - 1).toLowerCase() +
                      upperCasePrefix.charAt(len - 1);
            }
        });
    }
    exports.getBuilderName = getBuilderName;

    function getStatementBuilderName(typeName) {
        typeName = getBuilderName(typeName);
        return typeName.replace(/(Expression)?$/, "Statement");
    }
    exports.getStatementBuilderName = getStatementBuilderName;

    // The reason fields are specified using .field(...) instead of an object
    // literal syntax is somewhat subtle: the object literal syntax would
    // support only one key and one value, but with .field(...) we can pass
    // any number of arguments to specify the field.
    Dp.field = function (name, type, defaultFn, hidden) {
        if (this.finalized) {
            console.error("Ignoring attempt to redefine field " +
              JSON.stringify(name) + " of finalized type " +
              JSON.stringify(this.typeName));
            return this;
        }
        this.ownFields[name] = new Field(name, type, defaultFn, hidden);
        return this; // For chaining.
    };

    var namedTypes = {};
    exports.namedTypes = namedTypes;

    // Like Object.keys, but aware of what fields each AST type should have.
    function getFieldNames(object) {
        var d = Def.fromValue(object);
        if (d) {
            return d.fieldNames.slice(0);
        }

        if ("type" in object) {
            throw new Error(
              "did not recognize object of type " +
              JSON.stringify(object.type)
            );
        }

        return Object.keys(object);
    }
    exports.getFieldNames = getFieldNames;

    // Get the value of an object property, taking object.type and default
    // functions into account.
    function getFieldValue(object, fieldName) {
        var d = Def.fromValue(object);
        if (d) {
            var field = d.allFields[fieldName];
            if (field) {
                return field.getValue(object);
            }
        }

        return object && object[fieldName];
    }
    exports.getFieldValue = getFieldValue;

    // Iterate over all defined fields of an object, including those missing
    // or undefined, passing each field name and effective value (as returned
    // by getFieldValue) to the callback. If the object has no corresponding
    // Def, the callback will never be called.
    exports.eachField = function (object, callback, context) {
        getFieldNames(object).forEach(function (name) {
            callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // Similar to eachField, except that iteration stops as soon as the
    // callback returns a truthy value. Like Array.prototype.some, the final
    // result is either true or false to indicates whether the callback
    // returned true for any element or not.
    exports.someField = function (object, callback, context) {
        return getFieldNames(object).some(function (name) {
            return callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // This property will be overridden as true by individual Def instances
    // when they are finalized.
    Object.defineProperty(Dp, "finalized", {value: false});

    Dp.finalize = function () {
        var self = this;

        // It's not an error to finalize a type more than once, but only the
        // first call to .finalize does anything.
        if (!self.finalized) {
            var allFields = self.allFields;
            var allSupertypes = self.allSupertypes;

            self.baseNames.forEach(function (name) {
                var def = defCache[name];
                if (def instanceof Def) {
                    def.finalize();
                    extend(allFields, def.allFields);
                    extend(allSupertypes, def.allSupertypes);
                } else {
                    var message = "unknown supertype name " +
                      JSON.stringify(name) +
                      " for subtype " +
                      JSON.stringify(self.typeName);
                    throw new Error(message);
                }
            });

            // TODO Warn if fields are overridden with incompatible types.
            extend(allFields, self.ownFields);
            allSupertypes[self.typeName] = self;

            self.fieldNames.length = 0;
            for (var fieldName in allFields) {
                if (hasOwn.call(allFields, fieldName) &&
                    !allFields[fieldName].hidden) {
                        self.fieldNames.push(fieldName);
                }
            }

            // Types are exported only once they have been finalized.
            Object.defineProperty(namedTypes, self.typeName, {
                enumerable: true,
                value: self.type
            });

            Object.defineProperty(self, "finalized", {value: true});

            // A linearization of the inheritance hierarchy.
            populateSupertypeList(self.typeName, self.supertypeList);

            if (self.buildable && self.supertypeList.lastIndexOf("Expression") >= 0) {
                wrapExpressionBuilderWithStatement(self.typeName);
            }
        }
    };

    // Adds an additional builder for Expression subtypes
    // that wraps the built Expression in an ExpressionStatements.
    function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);

        // skip if the builder already exists
        if (builders[wrapperName]) return;

        // the builder function to wrap with builders.ExpressionStatement
        var wrapped = builders[getBuilderName(typeName)];

        // skip if there is nothing to wrap
        if (!wrapped) return;

        builders[wrapperName] = function () {
            return builders.expressionStatement(wrapped.apply(builders, arguments));
        };
    }

    function populateSupertypeList(typeName, list) {
        list.length = 0;
        list.push(typeName);

        var lastSeen = Object.create(null);

        for (var pos = 0; pos < list.length; ++pos) {
            typeName = list[pos];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("");
            }

            // If we saw typeName earlier in the breadth-first traversal,
            // delete the last-seen occurrence.
            if (hasOwn.call(lastSeen, typeName)) {
                delete list[lastSeen[typeName]];
            }

            // Record the new index of the last-seen occurrence of typeName.
            lastSeen[typeName] = pos;

            // Enqueue the base names of this type.
            list.push.apply(list, d.baseNames);
        }

        // Compaction loop to remove array holes.
        for (var to = 0, from = to, len = list.length; from < len; ++from) {
            if (hasOwn.call(list, from)) {
                list[to++] = list[from];
            }
        }

        list.length = to;
    }

    function extend(into, from) {
        Object.keys(from).forEach(function (name) {
            into[name] = from[name];
        });

        return into;
    }

    exports.finalize = function () {
        Object.keys(defCache).forEach(function (name) {
            defCache[name].finalize();
        });
    };

    return exports;
};

var equiv = function (fork) {
    var types = fork.use(types$1);
    var getFieldNames = types.getFieldNames;
    var getFieldValue = types.getFieldValue;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isDate = types.builtInTypes.Date;
    var isRegExp = types.builtInTypes.RegExp;
    var hasOwn = Object.prototype.hasOwnProperty;

    function astNodesAreEquivalent(a, b, problemPath) {
        if (isArray.check(problemPath)) {
            problemPath.length = 0;
        } else {
            problemPath = null;
        }

        return areEquivalent(a, b, problemPath);
    }

    astNodesAreEquivalent.assert = function (a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath)) {
            if (problemPath.length === 0) {
                if (a !== b) {
                    throw new Error("Nodes must be equal");
                }
            } else {
                throw new Error(
                  "Nodes differ in the following path: " +
                  problemPath.map(subscriptForProperty).join("")
                );
            }
        }
    };

    function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
            return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
    }

    function areEquivalent(a, b, problemPath) {
        if (a === b) {
            return true;
        }

        if (isArray.check(a)) {
            return arraysAreEquivalent(a, b, problemPath);
        }

        if (isObject.check(a)) {
            return objectsAreEquivalent(a, b, problemPath);
        }

        if (isDate.check(a)) {
            return isDate.check(b) && (+a === +b);
        }

        if (isRegExp.check(a)) {
            return isRegExp.check(b) && (
                a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
              );
        }

        return a == b;
    }

    function arraysAreEquivalent(a, b, problemPath) {
        isArray.assert(a);
        var aLength = a.length;

        if (!isArray.check(b) || b.length !== aLength) {
            if (problemPath) {
                problemPath.push("length");
            }
            return false;
        }

        for (var i = 0; i < aLength; ++i) {
            if (problemPath) {
                problemPath.push(i);
            }

            if (i in a !== i in b) {
                return false;
            }

            if (!areEquivalent(a[i], b[i], problemPath)) {
                return false;
            }

            if (problemPath) {
                var problemPathTail = problemPath.pop();
                if (problemPathTail !== i) {
                    throw new Error("" + problemPathTail);
                }
            }
        }

        return true;
    }

    function objectsAreEquivalent(a, b, problemPath) {
        isObject.assert(a);
        if (!isObject.check(b)) {
            return false;
        }

        // Fast path for a common property of AST nodes.
        if (a.type !== b.type) {
            if (problemPath) {
                problemPath.push("type");
            }
            return false;
        }

        var aNames = getFieldNames(a);
        var aNameCount = aNames.length;

        var bNames = getFieldNames(b);
        var bNameCount = bNames.length;

        if (aNameCount === bNameCount) {
            for (var i = 0; i < aNameCount; ++i) {
                var name = aNames[i];
                var aChild = getFieldValue(a, name);
                var bChild = getFieldValue(b, name);

                if (problemPath) {
                    problemPath.push(name);
                }

                if (!areEquivalent(aChild, bChild, problemPath)) {
                    return false;
                }

                if (problemPath) {
                    var problemPathTail = problemPath.pop();
                    if (problemPathTail !== name) {
                        throw new Error("" + problemPathTail);
                    }
                }
            }

            return true;
        }

        if (!problemPath) {
            return false;
        }

        // Since aNameCount !== bNameCount, we need to find some name that's
        // missing in aNames but present in bNames, or vice-versa.

        var seenNames = Object.create(null);

        for (i = 0; i < aNameCount; ++i) {
            seenNames[aNames[i]] = true;
        }

        for (i = 0; i < bNameCount; ++i) {
            name = bNames[i];

            if (!hasOwn.call(seenNames, name)) {
                problemPath.push(name);
                return false;
            }

            delete seenNames[name];
        }

        for (name in seenNames) {
            problemPath.push(name);
            break;
        }

        return false;
    }
    
    return astNodesAreEquivalent;
};

var Op$1 = Object.prototype;
var hasOwn$1 = Op$1.hasOwnProperty;

var path$4 = function (fork) {
    var types = fork.use(types$1);
    var isArray = types.builtInTypes.array;
    var isNumber = types.builtInTypes.number;

    function Path(value, parentPath, name) {
        if (!(this instanceof Path)) {
            throw new Error("Path constructor cannot be invoked without 'new'");
        }

        if (parentPath) {
            if (!(parentPath instanceof Path)) {
                throw new Error("");
            }
        } else {
            parentPath = null;
            name = null;
        }

        // The value encapsulated by this Path, generally equal to
        // parentPath.value[name] if we have a parentPath.
        this.value = value;

        // The immediate parent Path of this Path.
        this.parentPath = parentPath;

        // The name of the property of parentPath.value through which this
        // Path's value was reached.
        this.name = name;

        // Calling path.get("child") multiple times always returns the same
        // child Path object, for both performance and consistency reasons.
        this.__childCache = null;
    }

    var Pp = Path.prototype;

    function getChildCache(path) {
        // Lazily create the child cache. This also cheapens cache
        // invalidation, since you can just reset path.__childCache to null.
        return path.__childCache || (path.__childCache = Object.create(null));
    }

    function getChildPath(path, name) {
        var cache = getChildCache(path);
        var actualChildValue = path.getValueProperty(name);
        var childPath = cache[name];
        if (!hasOwn$1.call(cache, name) ||
          // Ensure consistency between cache and reality.
          childPath.value !== actualChildValue) {
            childPath = cache[name] = new path.constructor(
              actualChildValue, path, name
            );
        }
        return childPath;
    }

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
    Pp.getValueProperty = function getValueProperty(name) {
        return this.value[name];
    };

    Pp.get = function get(name) {
        var path = this;
        var names = arguments;
        var count = names.length;

        for (var i = 0; i < count; ++i) {
            path = getChildPath(path, names[i]);
        }

        return path;
    };

    Pp.each = function each(callback, context) {
        var childPaths = [];
        var len = this.value.length;
        var i = 0;

        // Collect all the original child paths before invoking the callback.
        for (var i = 0; i < len; ++i) {
            if (hasOwn$1.call(this.value, i)) {
                childPaths[i] = this.get(i);
            }
        }

        // Invoke the callback on just the original child paths, regardless of
        // any modifications made to the array by the callback. I chose these
        // semantics over cleverly invoking the callback on new elements because
        // this way is much easier to reason about.
        context = context || this;
        for (i = 0; i < len; ++i) {
            if (hasOwn$1.call(childPaths, i)) {
                callback.call(context, childPaths[i]);
            }
        }
    };

    Pp.map = function map(callback, context) {
        var result = [];

        this.each(function (childPath) {
            result.push(callback.call(this, childPath));
        }, context);

        return result;
    };

    Pp.filter = function filter(callback, context) {
        var result = [];

        this.each(function (childPath) {
            if (callback.call(this, childPath)) {
                result.push(childPath);
            }
        }, context);

        return result;
    };

    function emptyMoves() {}
    function getMoves(path, offset, start, end) {
        isArray.assert(path.value);

        if (offset === 0) {
            return emptyMoves;
        }

        var length = path.value.length;
        if (length < 1) {
            return emptyMoves;
        }

        var argc = arguments.length;
        if (argc === 2) {
            start = 0;
            end = length;
        } else if (argc === 3) {
            start = Math.max(start, 0);
            end = length;
        } else {
            start = Math.max(start, 0);
            end = Math.min(end, length);
        }

        isNumber.assert(start);
        isNumber.assert(end);

        var moves = Object.create(null);
        var cache = getChildCache(path);

        for (var i = start; i < end; ++i) {
            if (hasOwn$1.call(path.value, i)) {
                var childPath = path.get(i);
                if (childPath.name !== i) {
                    throw new Error("");
                }
                var newIndex = i + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                delete cache[i];
            }
        }

        delete cache.length;

        return function () {
            for (var newIndex in moves) {
                var childPath = moves[newIndex];
                if (childPath.name !== +newIndex) {
                    throw new Error("");
                }
                cache[newIndex] = childPath;
                path.value[newIndex] = childPath.value;
            }
        };
    }

    Pp.shift = function shift() {
        var move = getMoves(this, -1);
        var result = this.value.shift();
        move();
        return result;
    };

    Pp.unshift = function unshift(node) {
        var move = getMoves(this, arguments.length);
        var result = this.value.unshift.apply(this.value, arguments);
        move();
        return result;
    };

    Pp.push = function push(node) {
        isArray.assert(this.value);
        delete getChildCache(this).length;
        return this.value.push.apply(this.value, arguments);
    };

    Pp.pop = function pop() {
        isArray.assert(this.value);
        var cache = getChildCache(this);
        delete cache[this.value.length - 1];
        delete cache.length;
        return this.value.pop();
    };

    Pp.insertAt = function insertAt(index, node) {
        var argc = arguments.length;
        var move = getMoves(this, argc - 1, index);
        if (move === emptyMoves) {
            return this;
        }

        index = Math.max(index, 0);

        for (var i = 1; i < argc; ++i) {
            this.value[index + i - 1] = arguments[i];
        }

        move();

        return this;
    };

    Pp.insertBefore = function insertBefore(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    Pp.insertAfter = function insertAfter(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name + 1];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    function repairRelationshipWithParent(path) {
        if (!(path instanceof Path)) {
            throw new Error("");
        }

        var pp = path.parentPath;
        if (!pp) {
            // Orphan paths have no relationship to repair.
            return path;
        }

        var parentValue = pp.value;
        var parentCache = getChildCache(pp);

        // Make sure parentCache[path.name] is populated.
        if (parentValue[path.name] === path.value) {
            parentCache[path.name] = path;
        } else if (isArray.check(parentValue)) {
            // Something caused path.name to become out of date, so attempt to
            // recover by searching for path.value in parentValue.
            var i = parentValue.indexOf(path.value);
            if (i >= 0) {
                parentCache[path.name = i] = path;
            }
        } else {
            // If path.value disagrees with parentValue[path.name], and
            // path.name is not an array index, let path.value become the new
            // parentValue[path.name] and update parentCache accordingly.
            parentValue[path.name] = path.value;
            parentCache[path.name] = path;
        }

        if (parentValue[path.name] !== path.value) {
            throw new Error("");
        }
        if (path.parentPath.get(path.name) !== path) {
            throw new Error("");
        }

        return path;
    }

    Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;

        repairRelationshipWithParent(this);

        if (isArray.check(parentValue)) {
            var originalLength = parentValue.length;
            var move = getMoves(this.parentPath, count - 1, this.name + 1);

            var spliceArgs = [this.name, 1];
            for (var i = 0; i < count; ++i) {
                spliceArgs.push(arguments[i]);
            }

            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

            if (splicedOut[0] !== this.value) {
                throw new Error("");
            }
            if (parentValue.length !== (originalLength - 1 + count)) {
                throw new Error("");
            }

            move();

            if (count === 0) {
                delete this.value;
                delete parentCache[this.name];
                this.__childCache = null;

            } else {
                if (parentValue[this.name] !== replacement) {
                    throw new Error("");
                }

                if (this.value !== replacement) {
                    this.value = replacement;
                    this.__childCache = null;
                }

                for (i = 0; i < count; ++i) {
                    results.push(this.parentPath.get(this.name + i));
                }

                if (results[0] !== this) {
                    throw new Error("");
                }
            }

        } else if (count === 1) {
            if (this.value !== replacement) {
                this.__childCache = null;
            }
            this.value = parentValue[this.name] = replacement;
            results.push(this);

        } else if (count === 0) {
            delete parentValue[this.name];
            delete this.value;
            this.__childCache = null;

            // Leave this path cached as parentCache[this.name], even though
            // it no longer has a value defined.

        } else {
            throw new Error("Could not replace path");
        }

        return results;
    };

    return Path;
};

var hasOwn$2 = Object.prototype.hasOwnProperty;

var scope = function (fork) {
    var types = fork.use(types$1);
    var Type = types.Type;
    var namedTypes = types.namedTypes;
    var Node = namedTypes.Node;
    var Expression = namedTypes.Expression;
    var isArray = types.builtInTypes.array;
    var b = types.builders;

    function Scope(path, parentScope) {
        if (!(this instanceof Scope)) {
            throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        if (!(path instanceof fork.use(nodePath))) {
            throw new Error("");
        }
        ScopeType.assert(path.value);

        var depth;

        if (parentScope) {
            if (!(parentScope instanceof Scope)) {
                throw new Error("");
            }
            depth = parentScope.depth + 1;
        } else {
            parentScope = null;
            depth = 0;
        }

        Object.defineProperties(this, {
            path: { value: path },
            node: { value: path.value },
            isGlobal: { value: !parentScope, enumerable: true },
            depth: { value: depth },
            parent: { value: parentScope },
            bindings: { value: {} },
            types: { value: {} },
        });
    }

    var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes.Program,

        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes.Function,

        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes.CatchClause
    ];

    var ScopeType = Type.or.apply(Type, scopeTypes);

    Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node);
    };

    var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
    Sp.didScan = false;

    Sp.declares = function(name) {
        this.scan();
        return hasOwn$2.call(this.bindings, name);
    };

    Sp.declaresType = function(name) {
        this.scan();
        return hasOwn$2.call(this.types, name);
    };

    Sp.declareTemporary = function(prefix) {
        if (prefix) {
            if (!/^[a-z$_]/i.test(prefix)) {
                throw new Error("");
            }
        } else {
            prefix = "t$";
        }

        // Include this.depth in the name to make sure the name does not
        // collide with any variables in nested/enclosing scopes.
        prefix += this.depth.toString(36) + "$";

        this.scan();

        var index = 0;
        while (this.declares(prefix + index)) {
            ++index;
        }

        var name = prefix + index;
        return this.bindings[name] = types.builders.identifier(name);
    };

    Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());

        var bodyPath = this.path.get("body");
        if (namedTypes.BlockStatement.check(bodyPath.value)) {
            bodyPath = bodyPath.get("body");
        }

        bodyPath.unshift(
          b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
          )
        );

        return identifier;
    };

    Sp.scan = function(force) {
        if (force || !this.didScan) {
            for (var name in this.bindings) {
                // Empty out this.bindings, just in cases.
                delete this.bindings[name];
            }
            scanScope(this.path, this.bindings, this.types);
            this.didScan = true;
        }
    };

    Sp.getBindings = function () {
        this.scan();
        return this.bindings;
    };

    Sp.getTypes = function () {
        this.scan();
        return this.types;
    };

    function scanScope(path, bindings, scopeTypes) {
        var node = path.value;
        ScopeType.assert(node);

        if (namedTypes.CatchClause.check(node)) {
            // A catch clause establishes a new scope but the only variable
            // bound in that scope is the catch parameter. Any other
            // declarations create bindings in the outer scope.
            addPattern(path.get("param"), bindings);

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function recursiveScanScope(path, bindings, scopeTypes) {
        var node = path.value;

        if (path.parent &&
          namedTypes.FunctionExpression.check(path.parent.node) &&
          path.parent.node.id) {
            addPattern(path.parent.get("id"), bindings);
        }

        if (!node) {
            // None of the remaining cases matter if node is falsy.

        } else if (isArray.check(node)) {
            path.each(function(childPath) {
                recursiveScanChild(childPath, bindings, scopeTypes);
            });

        } else if (namedTypes.Function.check(node)) {
            path.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
            });

            recursiveScanChild(path.get("body"), bindings, scopeTypes);

        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {
            addTypePattern(path.get("id"), scopeTypes);

        } else if (namedTypes.VariableDeclarator.check(node)) {
            addPattern(path.get("id"), bindings);
            recursiveScanChild(path.get("init"), bindings, scopeTypes);

        } else if (node.type === "ImportSpecifier" ||
          node.type === "ImportNamespaceSpecifier" ||
          node.type === "ImportDefaultSpecifier") {
            addPattern(
              // Esprima used to use the .name field to refer to the local
              // binding identifier for ImportSpecifier nodes, but .id for
              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
              // ESTree/Acorn/ESpree use .local for all three node types.
              path.get(node.local ? "local" :
                node.name ? "name" : "id"),
              bindings
            );

        } else if (Node.check(node) && !Expression.check(node)) {
            types.eachField(node, function(name, child) {
                var childPath = path.get(name);
                if (!pathHasValue(childPath, child)) {
                    throw new Error("");
                }
                recursiveScanChild(childPath, bindings, scopeTypes);
            });
        }
    }

    function pathHasValue(path, value) {
        if (path.value === value) {
            return true;
        }

        // Empty arrays are probably produced by defaults.emptyArray, in which
        // case is makes sense to regard them as equivalent, if not ===.
        if (Array.isArray(path.value) &&
          path.value.length === 0 &&
          Array.isArray(value) &&
          value.length === 0) {
            return true;
        }

        return false;
    }

    function recursiveScanChild(path, bindings, scopeTypes) {
        var node = path.value;

        if (!node || Expression.check(node)) {
            // Ignore falsy values and Expressions.

        } else if (namedTypes.FunctionDeclaration.check(node) &&
                   node.id !== null) {
            addPattern(path.get("id"), bindings);

        } else if (namedTypes.ClassDeclaration &&
          namedTypes.ClassDeclaration.check(node)) {
            addPattern(path.get("id"), bindings);

        } else if (ScopeType.check(node)) {
            if (namedTypes.CatchClause.check(node)) {
                var catchParamName = node.param.name;
                var hadBinding = hasOwn$2.call(bindings, catchParamName);

                // Any declarations that occur inside the catch body that do
                // not have the same name as the catch parameter should count
                // as bindings in the outer scope.
                recursiveScanScope(path.get("body"), bindings, scopeTypes);

                // If a new binding matching the catch parameter name was
                // created while scanning the catch body, ignore it because it
                // actually refers to the catch parameter and not the outer
                // scope that we're currently scanning.
                if (!hadBinding) {
                    delete bindings[catchParamName];
                }
            }

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn$2.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
            } else {
                bindings[pattern.name] = [patternPath];
            }

        } else if (namedTypes.ObjectPattern &&
          namedTypes.ObjectPattern.check(pattern)) {
            patternPath.get('properties').each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes.Pattern.check(property)) {
                    addPattern(propertyPath, bindings);
                } else  if (namedTypes.Property.check(property)) {
                    addPattern(propertyPath.get('value'), bindings);
                } else if (namedTypes.SpreadProperty &&
                  namedTypes.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get('argument'), bindings);
                }
            });

        } else if (namedTypes.ArrayPattern &&
          namedTypes.ArrayPattern.check(pattern)) {
            patternPath.get('elements').each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes.Pattern.check(element)) {
                    addPattern(elementPath, bindings);
                } else if (namedTypes.SpreadElement &&
                  namedTypes.SpreadElement.check(element)) {
                    addPattern(elementPath.get("argument"), bindings);
                }
            });

        } else if (namedTypes.PropertyPattern &&
          namedTypes.PropertyPattern.check(pattern)) {
            addPattern(patternPath.get('pattern'), bindings);

        } else if ((namedTypes.SpreadElementPattern &&
          namedTypes.SpreadElementPattern.check(pattern)) ||
          (namedTypes.SpreadPropertyPattern &&
          namedTypes.SpreadPropertyPattern.check(pattern))) {
            addPattern(patternPath.get('argument'), bindings);
        }
    }

    function addTypePattern(patternPath, types) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn$2.call(types, pattern.name)) {
                types[pattern.name].push(patternPath);
            } else {
                types[pattern.name] = [patternPath];
            }

        }
    }

    Sp.lookup = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declares(name))
                break;
        return scope;
    };

    Sp.lookupType = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declaresType(name))
                break;
        return scope;
    };

    Sp.getGlobalScope = function() {
        var scope = this;
        while (!scope.isGlobal)
            scope = scope.parent;
        return scope;
    };

    return Scope;
};

var nodePath = function (fork) {
    var types = fork.use(types$1);
    var n = types.namedTypes;
    var b = types.builders;
    var isNumber = types.builtInTypes.number;
    var isArray = types.builtInTypes.array;
    var Path = fork.use(path$4);
    var Scope = fork.use(scope);

    function NodePath(value, parentPath, name) {
        if (!(this instanceof NodePath)) {
            throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name);
    }

    var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
            value: NodePath,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    Object.defineProperties(NPp, {
        node: {
            get: function () {
                Object.defineProperty(this, "node", {
                    configurable: true, // Enable deletion.
                    value: this._computeNode()
                });

                return this.node;
            }
        },

        parent: {
            get: function () {
                Object.defineProperty(this, "parent", {
                    configurable: true, // Enable deletion.
                    value: this._computeParent()
                });

                return this.parent;
            }
        },

        scope: {
            get: function () {
                Object.defineProperty(this, "scope", {
                    configurable: true, // Enable deletion.
                    value: this._computeScope()
                });

                return this.scope;
            }
        }
    });

    NPp.replace = function () {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
    };

    NPp.prune = function () {
        var remainingNodePath = this.parent;

        this.replace();

        return cleanUpNodesAfterPrune(remainingNodePath);
    };

    // The value of the first ancestor Path whose value is a Node.
    NPp._computeNode = function () {
        var value = this.value;
        if (n.Node.check(value)) {
            return value;
        }

        var pp = this.parentPath;
        return pp && pp.node || null;
    };

    // The first ancestor Path whose value is a Node distinct from this.node.
    NPp._computeParent = function () {
        var value = this.value;
        var pp = this.parentPath;

        if (!n.Node.check(value)) {
            while (pp && !n.Node.check(pp.value)) {
                pp = pp.parentPath;
            }

            if (pp) {
                pp = pp.parentPath;
            }
        }

        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        return pp || null;
    };

    // The closest enclosing scope that governs this node.
    NPp._computeScope = function () {
        var value = this.value;
        var pp = this.parentPath;
        var scope$$1 = pp && pp.scope;

        if (n.Node.check(value) &&
          Scope.isEstablishedBy(value)) {
            scope$$1 = new Scope(this, scope$$1);
        }

        return scope$$1 || null;
    };

    NPp.getValueProperty = function (name) {
        return types.getFieldValue(this.value, name);
    };

    /**
     * Determine whether this.node needs to be wrapped in parentheses in order
     * for a parser to reproduce the same local AST structure.
     *
     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
     * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
     * parse differently.
     *
     * If assumeExpressionContext === true, we don't worry about edge cases
     * like an anonymous FunctionExpression appearing lexically first in its
     * enclosing statement and thus needing parentheses to avoid being parsed
     * as a FunctionDeclaration with a missing name.
     */
    NPp.needsParens = function (assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
            return false;
        }

        var node = this.value;

        // Only expressions need parentheses.
        if (!n.Expression.check(node)) {
            return false;
        }

        // Identifiers never need parentheses.
        if (node.type === "Identifier") {
            return false;
        }

        while (!n.Node.check(pp.value)) {
            pp = pp.parentPath;
            if (!pp) {
                return false;
            }
        }

        var parent = pp.value;

        switch (node.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
                return parent.type === "MemberExpression"
                  && this.name === "object"
                  && parent.object === node;

            case "BinaryExpression":
            case "LogicalExpression":
                switch (parent.type) {
                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                        return true;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    case "BinaryExpression":
                    case "LogicalExpression":
                        var po = parent.operator;
                        var pp = PRECEDENCE[po];
                        var no = node.operator;
                        var np = PRECEDENCE[no];

                        if (pp > np) {
                            return true;
                        }

                        if (pp === np && this.name === "right") {
                            if (parent.right !== node) {
                                throw new Error("Nodes must be equal");
                            }
                            return true;
                        }

                    default:
                        return false;
                }

            case "SequenceExpression":
                switch (parent.type) {
                    case "ForStatement":
                        // Although parentheses wouldn't hurt around sequence
                        // expressions in the head of for loops, traditional style
                        // dictates that e.g. i++, j++ should not be wrapped with
                        // parentheses.
                        return false;

                    case "ExpressionStatement":
                        return this.name !== "expression";

                    default:
                        // Otherwise err on the side of overparenthesization, adding
                        // explicit exceptions above if this proves overzealous.
                        return true;
                }

            case "YieldExpression":
                switch (parent.type) {
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "CallExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ConditionalExpression":
                    case "YieldExpression":
                        return true;

                    default:
                        return false;
                }

            case "Literal":
                return parent.type === "MemberExpression"
                  && isNumber.check(node.value)
                  && this.name === "object"
                  && parent.object === node;

            case "AssignmentExpression":
            case "ConditionalExpression":
                switch (parent.type) {
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                        return true;

                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "ConditionalExpression":
                        return this.name === "test"
                          && parent.test === node;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    default:
                        return false;
                }

            default:
                if (parent.type === "NewExpression" &&
                  this.name === "callee" &&
                  parent.callee === node) {
                    return containsCallExpression(node);
                }
        }

        if (assumeExpressionContext !== true &&
          !this.canBeFirstInStatement() &&
          this.firstInStatement())
            return true;

        return false;
    };

    function isBinary(node) {
        return n.BinaryExpression.check(node)
          || n.LogicalExpression.check(node);
    }

    var PRECEDENCE = {};
    [["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ].forEach(function (tier, i) {
        tier.forEach(function (op) {
            PRECEDENCE[op] = i;
        });
    });

    function containsCallExpression(node) {
        if (n.CallExpression.check(node)) {
            return true;
        }

        if (isArray.check(node)) {
            return node.some(containsCallExpression);
        }

        if (n.Node.check(node)) {
            return types.someField(node, function (name, child) {
                return containsCallExpression(child);
            });
        }

        return false;
    }

    NPp.canBeFirstInStatement = function () {
        var node = this.node;
        return !n.FunctionExpression.check(node)
          && !n.ObjectExpression.check(node);
    };

    NPp.firstInStatement = function () {
        return firstInStatement(this);
    };

    function firstInStatement(path) {
        for (var node, parent; path.parent; path = path.parent) {
            node = path.node;
            parent = path.parent.node;

            if (n.BlockStatement.check(parent) &&
              path.parent.name === "body" &&
              path.name === 0) {
                if (parent.body[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.ExpressionStatement.check(parent) &&
              path.name === "expression") {
                if (parent.expression !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.SequenceExpression.check(parent) &&
              path.parent.name === "expressions" &&
              path.name === 0) {
                if (parent.expressions[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.CallExpression.check(parent) &&
              path.name === "callee") {
                if (parent.callee !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.MemberExpression.check(parent) &&
              path.name === "object") {
                if (parent.object !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.ConditionalExpression.check(parent) &&
              path.name === "test") {
                if (parent.test !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (isBinary(parent) &&
              path.name === "left") {
                if (parent.left !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.UnaryExpression.check(parent) &&
              !parent.prefix &&
              path.name === "argument") {
                if (parent.argument !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            return false;
        }

        return true;
    }

    /**
     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
     */
    function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
            var declarations = remainingNodePath.get('declarations').value;
            if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
            }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
            if (!remainingNodePath.get('expression').value) {
                return remainingNodePath.prune();
            }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
            cleanUpIfStatementAfterPrune(remainingNodePath);
        }

        return remainingNodePath;
    }

    function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get('test').value;
        var alternate = ifStatement.get('alternate').value;
        var consequent = ifStatement.get('consequent').value;

        if (!consequent && !alternate) {
            var testExpressionStatement = b.expressionStatement(testExpression);

            ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
            var negatedTestExpression = b.unaryExpression('!', testExpression, true);

            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
                negatedTestExpression = testExpression.argument;
            }

            ifStatement.get("test").replace(negatedTestExpression);
            ifStatement.get("consequent").replace(alternate);
            ifStatement.get("alternate").replace();
        }
    }

    return NodePath;
};

var hasOwn$3 = Object.prototype.hasOwnProperty;

var pathVisitor = function (fork) {
    var types = fork.use(types$1);
    var NodePath = fork.use(nodePath);
    var Printable = types.namedTypes.Printable;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isFunction = types.builtInTypes.function;
    var undefined;

    function PathVisitor() {
        if (!(this instanceof PathVisitor)) {
            throw new Error(
              "PathVisitor constructor cannot be invoked without 'new'"
            );
        }

        // Permanent state.
        this._reusableContextStack = [];

        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments =
          hasOwn$3.call(this._methodNameTable, "Block") ||
          hasOwn$3.call(this._methodNameTable, "Line");

        this.Context = makeContextConstructor(this);

        // State reset every time PathVisitor.prototype.visit is called.
        this._visiting = false;
        this._changeReported = false;
    }

    function computeMethodNameTable(visitor) {
        var typeNames = Object.create(null);

        for (var methodName in visitor) {
            if (/^visit[A-Z]/.test(methodName)) {
                typeNames[methodName.slice("visit".length)] = true;
            }
        }

        var supertypeTable = types.computeSupertypeLookupTable(typeNames);
        var methodNameTable = Object.create(null);

        var typeNames = Object.keys(supertypeTable);
        var typeNameCount = typeNames.length;
        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            methodName = "visit" + supertypeTable[typeName];
            if (isFunction.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
            }
        }

        return methodNameTable;
    }

    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
        if (methods instanceof PathVisitor) {
            return methods;
        }

        if (!isObject.check(methods)) {
            // An empty visitor?
            return new PathVisitor;
        }

        function Visitor() {
            if (!(this instanceof Visitor)) {
                throw new Error(
                  "Visitor constructor cannot be invoked without 'new'"
                );
            }
            PathVisitor.call(this);
        }

        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;

        extend(Vp, methods);
        extend(Visitor, PathVisitor);

        isFunction.assert(Visitor.fromMethodsObject);
        isFunction.assert(Visitor.visit);

        return new Visitor;
    };

    function extend(target, source) {
        for (var property in source) {
            if (hasOwn$3.call(source, property)) {
                target[property] = source[property];
            }
        }

        return target;
    }

    PathVisitor.visit = function visit(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
    };

    var PVp = PathVisitor.prototype;

    PVp.visit = function () {
        if (this._visiting) {
            throw new Error(
              "Recursively calling visitor.visit(path) resets visitor state. " +
              "Try this.visit(path) or this.traverse(path) instead."
            );
        }

        // Private state that needs to be reset before every traversal.
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;

        var argc = arguments.length;
        var args = new Array(argc);
        for (var i = 0; i < argc; ++i) {
            args[i] = arguments[i];
        }

        if (!(args[0] instanceof NodePath)) {
            args[0] = new NodePath({root: args[0]}).get("root");
        }

        // Called with the same arguments as .visit.
        this.reset.apply(this, args);

        try {
            var root = this.visitWithoutReset(args[0]);
            var didNotThrow = true;
        } finally {
            this._visiting = false;

            if (!didNotThrow && this._abortRequested) {
                // If this.visitWithoutReset threw an exception and
                // this._abortRequested was set to true, return the root of
                // the AST instead of letting the exception propagate, so that
                // client code does not have to provide a try-catch block to
                // intercept the AbortRequest exception.  Other kinds of
                // exceptions will propagate without being intercepted and
                // rethrown by a catch block, so their stacks will accurately
                // reflect the original throwing context.
                return args[0].value;
            }
        }

        return root;
    };

    PVp.AbortRequest = function AbortRequest() {};
    PVp.abort = function () {
        var visitor = this;
        visitor._abortRequested = true;
        var request = new visitor.AbortRequest();

        // If you decide to catch this exception and stop it from propagating,
        // make sure to call its cancel method to avoid silencing other
        // exceptions that might be thrown later in the traversal.
        request.cancel = function () {
            visitor._abortRequested = false;
        };

        throw request;
    };

    PVp.reset = function (path/*, additional arguments */) {
        // Empty stub; may be reassigned or overridden by subclasses.
    };

    PVp.visitWithoutReset = function (path) {
        if (this instanceof this.Context) {
            // Since this.Context.prototype === this, there's a chance we
            // might accidentally call context.visitWithoutReset. If that
            // happens, re-invoke the method against context.visitor.
            return this.visitor.visitWithoutReset(path);
        }

        if (!(path instanceof NodePath)) {
            throw new Error("");
        }

        var value = path.value;

        var methodName = value &&
          typeof value === "object" &&
          typeof value.type === "string" &&
          this._methodNameTable[value.type];

        if (methodName) {
            var context = this.acquireContext(path);
            try {
                return context.invokeVisitorMethod(methodName);
            } finally {
                this.releaseContext(context);
            }

        } else {
            // If there was no visitor method to call, visit the children of
            // this node generically.
            return visitChildren(path, this);
        }
    };

    function visitChildren(path, visitor) {
        if (!(path instanceof NodePath)) {
            throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        var value = path.value;

        if (isArray.check(value)) {
            path.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject.check(value)) {
            // No children to visit.
        } else {
            var childNames = types.getFieldNames(value);

            // The .comments field of the Node type is hidden, so we only
            // visit it if the visitor defines visitBlock or visitLine, and
            // value.comments is defined.
            if (visitor._shouldVisitComments &&
              value.comments &&
              childNames.indexOf("comments") < 0) {
                childNames.push("comments");
            }

            var childCount = childNames.length;
            var childPaths = [];

            for (var i = 0; i < childCount; ++i) {
                var childName = childNames[i];
                if (!hasOwn$3.call(value, childName)) {
                    value[childName] = types.getFieldValue(value, childName);
                }
                childPaths.push(path.get(childName));
            }

            for (var i = 0; i < childCount; ++i) {
                visitor.visitWithoutReset(childPaths[i]);
            }
        }

        return path.value;
    }

    PVp.acquireContext = function (path) {
        if (this._reusableContextStack.length === 0) {
            return new this.Context(path);
        }
        return this._reusableContextStack.pop().reset(path);
    };

    PVp.releaseContext = function (context) {
        if (!(context instanceof this.Context)) {
            throw new Error("");
        }
        this._reusableContextStack.push(context);
        context.currentPath = null;
    };

    PVp.reportChanged = function () {
        this._changeReported = true;
    };

    PVp.wasChangeReported = function () {
        return this._changeReported;
    };

    function makeContextConstructor(visitor) {
        function Context(path) {
            if (!(this instanceof Context)) {
                throw new Error("");
            }
            if (!(this instanceof PathVisitor)) {
                throw new Error("");
            }
            if (!(path instanceof NodePath)) {
                throw new Error("");
            }

            Object.defineProperty(this, "visitor", {
                value: visitor,
                writable: false,
                enumerable: true,
                configurable: false
            });

            this.currentPath = path;
            this.needToCallTraverse = true;

            Object.seal(this);
        }

        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        // Note that the visitor object is the prototype of Context.prototype,
        // so all visitor methods are inherited by context objects.
        var Cp = Context.prototype = Object.create(visitor);

        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);

        return Context;
    }

// Every PathVisitor has a different this.Context constructor and
// this.Context.prototype object, but those prototypes can all use the
// same reset, invokeVisitorMethod, and traverse function objects.
    var sharedContextProtoMethods = Object.create(null);

    sharedContextProtoMethods.reset =
      function reset(path) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }

          this.currentPath = path;
          this.needToCallTraverse = true;

          return this;
      };

    sharedContextProtoMethods.invokeVisitorMethod =
      function invokeVisitorMethod(methodName) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          var result = this.visitor[methodName].call(this, this.currentPath);

          if (result === false) {
              // Visitor methods return false to indicate that they have handled
              // their own traversal needs, and we should not complain if
              // this.needToCallTraverse is still true.
              this.needToCallTraverse = false;

          } else if (result !== undefined) {
              // Any other non-undefined value returned from the visitor method
              // is interpreted as a replacement value.
              this.currentPath = this.currentPath.replace(result)[0];

              if (this.needToCallTraverse) {
                  // If this.traverse still hasn't been called, visit the
                  // children of the replacement node.
                  this.traverse(this.currentPath);
              }
          }

          if (this.needToCallTraverse !== false) {
              throw new Error(
                "Must either call this.traverse or return false in " + methodName
              );
          }

          var path = this.currentPath;
          return path && path.value;
      };

    sharedContextProtoMethods.traverse =
      function traverse(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return visitChildren(path, PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ));
      };

    sharedContextProtoMethods.visit =
      function visit(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ).visitWithoutReset(path);
      };

    sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
    };

    sharedContextProtoMethods.abort = function abort() {
        this.needToCallTraverse = false;
        this.visitor.abort();
    };

    return PathVisitor;
};

var fork = function (defs) {
    var used = [];
    var usedResult = [];
    var fork = {};

    function use(plugin) {
        var idx = used.indexOf(plugin);
        if (idx === -1) {
            idx = used.length;
            used.push(plugin);
            usedResult[idx] = plugin(fork);
        }
        return usedResult[idx];
    }

    fork.use = use;

    var types = use(types$1);

    defs.forEach(use);

    types.finalize();

    var exports = {
        Type: types.Type,
        builtInTypes: types.builtInTypes,
        namedTypes: types.namedTypes,
        builders: types.builders,
        defineMethod: types.defineMethod,
        getFieldNames: types.getFieldNames,
        getFieldValue: types.getFieldValue,
        eachField: types.eachField,
        someField: types.someField,
        getSupertypeNames: types.getSupertypeNames,
        astNodesAreEquivalent: use(equiv),
        finalize: types.finalize,
        Path: use(path$4),
        NodePath: use(nodePath),
        PathVisitor: use(pathVisitor),
        use: use
    };

    exports.visit = exports.PathVisitor.visit;

    return exports;
};

var shared = function (fork) {
    var exports = {};
    var types = fork.use(types$1);
    var Type = types.Type;
    var builtin = types.builtInTypes;
    var isNumber = builtin.number;

    // An example of constructing a new type with arbitrary constraints from
    // an existing type.
    exports.geq = function (than) {
        return new Type(function (value) {
            return isNumber.check(value) && value >= than;
        }, isNumber + " >= " + than);
    };

    // Default value-returning functions that may optionally be passed as a
    // third argument to Def.prototype.field.
    exports.defaults = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        "null": function () { return null },
        "emptyArray": function () { return [] },
        "false": function () { return false },
        "true": function () { return true },
        "undefined": function () {}
    };

    var naiveIsPrimitive = Type.or(
      builtin.string,
      builtin.number,
      builtin.boolean,
      builtin.null,
      builtin.undefined
    );

    exports.isPrimitive = new Type(function (value) {
        if (value === null)
            return true;
        var type = typeof value;
        return !(type === "object" ||
        type === "function");
    }, naiveIsPrimitive.toString());

    return exports;
};

var core = function (fork) {
    var types = fork.use(types$1);
    var Type = types.Type;
    var def = Type.def;
    var or = Type.or;
    var shared$$1 = fork.use(shared);
    var defaults = shared$$1.defaults;
    var geq = shared$$1.geq;

    // Abstract supertype of all syntactic entities that are allowed to have a
    // .loc field.
    def("Printable")
        .field("loc", or(
            def("SourceLocation"),
            null
        ), defaults["null"], true);

    def("Node")
        .bases("Printable")
        .field("type", String)
        .field("comments", or(
            [def("Comment")],
            null
        ), defaults["null"], true);

    def("SourceLocation")
        .build("start", "end", "source")
        .field("start", def("Position"))
        .field("end", def("Position"))
        .field("source", or(String, null), defaults["null"]);

    def("Position")
        .build("line", "column")
        .field("line", geq(1))
        .field("column", geq(0));

    def("File")
        .bases("Node")
        .build("program", "name")
        .field("program", def("Program"))
        .field("name", or(String, null), defaults["null"]);

    def("Program")
        .bases("Node")
        .build("body")
        .field("body", [def("Statement")]);

    def("Function")
        .bases("Node")
        .field("id", or(def("Identifier"), null), defaults["null"])
        .field("params", [def("Pattern")])
        .field("body", def("BlockStatement"));

    def("Statement").bases("Node");

// The empty .build() here means that an EmptyStatement can be constructed
// (i.e. it's not abstract) but that it needs no arguments.
    def("EmptyStatement").bases("Statement").build();

    def("BlockStatement")
        .bases("Statement")
        .build("body")
        .field("body", [def("Statement")]);

    // TODO Figure out how to silently coerce Expressions to
    // ExpressionStatements where a Statement was expected.
    def("ExpressionStatement")
        .bases("Statement")
        .build("expression")
        .field("expression", def("Expression"));

    def("IfStatement")
        .bases("Statement")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Statement"))
        .field("alternate", or(def("Statement"), null), defaults["null"]);

    def("LabeledStatement")
        .bases("Statement")
        .build("label", "body")
        .field("label", def("Identifier"))
        .field("body", def("Statement"));

    def("BreakStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("ContinueStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("WithStatement")
        .bases("Statement")
        .build("object", "body")
        .field("object", def("Expression"))
        .field("body", def("Statement"));

    def("SwitchStatement")
        .bases("Statement")
        .build("discriminant", "cases", "lexical")
        .field("discriminant", def("Expression"))
        .field("cases", [def("SwitchCase")])
        .field("lexical", Boolean, defaults["false"]);

    def("ReturnStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", or(def("Expression"), null));

    def("ThrowStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", def("Expression"));

    def("TryStatement")
        .bases("Statement")
        .build("block", "handler", "finalizer")
        .field("block", def("BlockStatement"))
        .field("handler", or(def("CatchClause"), null), function () {
            return this.handlers && this.handlers[0] || null;
        })
        .field("handlers", [def("CatchClause")], function () {
            return this.handler ? [this.handler] : [];
        }, true) // Indicates this field is hidden from eachField iteration.
        .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
        .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);

    def("CatchClause")
        .bases("Node")
        .build("param", "guard", "body")
        .field("param", def("Pattern"))
        .field("guard", or(def("Expression"), null), defaults["null"])
        .field("body", def("BlockStatement"));

    def("WhileStatement")
        .bases("Statement")
        .build("test", "body")
        .field("test", def("Expression"))
        .field("body", def("Statement"));

    def("DoWhileStatement")
        .bases("Statement")
        .build("body", "test")
        .field("body", def("Statement"))
        .field("test", def("Expression"));

    def("ForStatement")
        .bases("Statement")
        .build("init", "test", "update", "body")
        .field("init", or(
            def("VariableDeclaration"),
            def("Expression"),
            null))
        .field("test", or(def("Expression"), null))
        .field("update", or(def("Expression"), null))
        .field("body", def("Statement"));

    def("ForInStatement")
        .bases("Statement")
        .build("left", "right", "body")
        .field("left", or(
            def("VariableDeclaration"),
            def("Expression")))
        .field("right", def("Expression"))
        .field("body", def("Statement"));

    def("DebuggerStatement").bases("Statement").build();

    def("Declaration").bases("Statement");

    def("FunctionDeclaration")
        .bases("Function", "Declaration")
        .build("id", "params", "body")
        .field("id", def("Identifier"));

    def("FunctionExpression")
        .bases("Function", "Expression")
        .build("id", "params", "body");

    def("VariableDeclaration")
        .bases("Declaration")
        .build("kind", "declarations")
        .field("kind", or("var", "let", "const"))
        .field("declarations", [def("VariableDeclarator")]);

    def("VariableDeclarator")
        .bases("Node")
        .build("id", "init")
        .field("id", def("Pattern"))
        .field("init", or(def("Expression"), null));

    // TODO Are all Expressions really Patterns?
    def("Expression").bases("Node", "Pattern");

    def("ThisExpression").bases("Expression").build();

    def("ArrayExpression")
        .bases("Expression")
        .build("elements")
        .field("elements", [or(def("Expression"), null)]);

    def("ObjectExpression")
        .bases("Expression")
        .build("properties")
        .field("properties", [def("Property")]);

    // TODO Not in the Mozilla Parser API, but used by Esprima.
    def("Property")
        .bases("Node") // Want to be able to visit Property Nodes.
        .build("kind", "key", "value")
        .field("kind", or("init", "get", "set"))
        .field("key", or(def("Literal"), def("Identifier")))
        .field("value", def("Expression"));

    def("SequenceExpression")
        .bases("Expression")
        .build("expressions")
        .field("expressions", [def("Expression")]);

    var UnaryOperator = or(
        "-", "+", "!", "~",
        "typeof", "void", "delete");

    def("UnaryExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UnaryOperator)
        .field("argument", def("Expression"))
        // Esprima doesn't bother with this field, presumably because it's
        // always true for unary operators.
        .field("prefix", Boolean, defaults["true"]);

    var BinaryOperator = or(
        "==", "!=", "===", "!==",
        "<", "<=", ">", ">=",
        "<<", ">>", ">>>",
        "+", "-", "*", "/", "%",
        "&", // TODO Missing from the Parser API.
        "|", "^", "in",
        "instanceof", "..");

    def("BinaryExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", BinaryOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    var AssignmentOperator = or(
        "=", "+=", "-=", "*=", "/=", "%=",
        "<<=", ">>=", ">>>=",
        "|=", "^=", "&=");

    def("AssignmentExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", AssignmentOperator)
        .field("left", def("Pattern"))
        .field("right", def("Expression"));

    var UpdateOperator = or("++", "--");

    def("UpdateExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UpdateOperator)
        .field("argument", def("Expression"))
        .field("prefix", Boolean);

    var LogicalOperator = or("||", "&&");

    def("LogicalExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", LogicalOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("ConditionalExpression")
        .bases("Expression")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Expression"))
        .field("alternate", def("Expression"));

    def("NewExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // The Mozilla Parser API gives this type as [or(def("Expression"),
        // null)], but null values don't really make sense at the call site.
        // TODO Report this nonsense.
        .field("arguments", [def("Expression")]);

    def("CallExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // See comment for NewExpression above.
        .field("arguments", [def("Expression")]);

    def("MemberExpression")
        .bases("Expression")
        .build("object", "property", "computed")
        .field("object", def("Expression"))
        .field("property", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean, function () {
            var type = this.property.type;
            if (type === 'Literal' ||
                type === 'MemberExpression' ||
                type === 'BinaryExpression') {
                return true;
            }
            return false;
        });

    def("Pattern").bases("Node");

    def("SwitchCase")
        .bases("Node")
        .build("test", "consequent")
        .field("test", or(def("Expression"), null))
        .field("consequent", [def("Statement")]);

    def("Identifier")
        // But aren't Expressions and Patterns already Nodes? TODO Report this.
        .bases("Node", "Expression", "Pattern")
        .build("name")
        .field("name", String);

    def("Literal")
        // But aren't Expressions already Nodes? TODO Report this.
        .bases("Node", "Expression")
        .build("value")
        .field("value", or(String, Boolean, null, Number, RegExp))
        .field("regex", or({
            pattern: String,
            flags: String
        }, null), function () {
            if (this.value instanceof RegExp) {
                var flags = "";

                if (this.value.ignoreCase) flags += "i";
                if (this.value.multiline) flags += "m";
                if (this.value.global) flags += "g";

                return {
                    pattern: this.value.source,
                    flags: flags
                };
            }

            return null;
        });

    // Abstract (non-buildable) comment supertype. Not a Node.
    def("Comment")
        .bases("Printable")
        .field("value", String)
        // A .leading comment comes before the node, whereas a .trailing
        // comment comes after it. These two fields should not both be true,
        // but they might both be false when the comment falls inside a node
        // and the node has no children for the comment to lead or trail,
        // e.g. { /*dangling*/ }.
        .field("leading", Boolean, defaults["true"])
        .field("trailing", Boolean, defaults["false"]);
};

var es6 = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(shared).defaults;

    def("Function")
      .field("generator", Boolean, defaults["false"])
      .field("expression", Boolean, defaults["false"])
      .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
      // TODO This could be represented as a RestElement in .params.
      .field("rest", or(def("Identifier"), null), defaults["null"]);

    // The ESTree way of representing a ...rest parameter.
    def("RestElement")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("SpreadElementPattern")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("FunctionDeclaration")
      .build("id", "params", "body", "generator", "expression");

    def("FunctionExpression")
      .build("id", "params", "body", "generator", "expression");

    // The Parser API calls this ArrowExpression, but Esprima and all other
    // actual parsers use ArrowFunctionExpression.
    def("ArrowFunctionExpression")
      .bases("Function", "Expression")
      .build("params", "body", "expression")
      // The forced null value here is compatible with the overridden
      // definition of the "id" field in the Function interface.
      .field("id", null, defaults["null"])
      // Arrow function bodies are allowed to be expressions.
      .field("body", or(def("BlockStatement"), def("Expression")))
      // The current spec forbids arrow generators, so I have taken the
      // liberty of enforcing that. TODO Report this.
      .field("generator", false, defaults["false"]);

    def("YieldExpression")
      .bases("Expression")
      .build("argument", "delegate")
      .field("argument", or(def("Expression"), null))
      .field("delegate", Boolean, defaults["false"]);

    def("GeneratorExpression")
      .bases("Expression")
      .build("body", "blocks", "filter")
      .field("body", def("Expression"))
      .field("blocks", [def("ComprehensionBlock")])
      .field("filter", or(def("Expression"), null));

    def("ComprehensionExpression")
      .bases("Expression")
      .build("body", "blocks", "filter")
      .field("body", def("Expression"))
      .field("blocks", [def("ComprehensionBlock")])
      .field("filter", or(def("Expression"), null));

    def("ComprehensionBlock")
      .bases("Node")
      .build("left", "right", "each")
      .field("left", def("Pattern"))
      .field("right", def("Expression"))
      .field("each", Boolean);

    def("Property")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("value", or(def("Expression"), def("Pattern")))
      .field("method", Boolean, defaults["false"])
      .field("shorthand", Boolean, defaults["false"])
      .field("computed", Boolean, defaults["false"]);

    def("PropertyPattern")
      .bases("Pattern")
      .build("key", "pattern")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("pattern", def("Pattern"))
      .field("computed", Boolean, defaults["false"]);

    def("ObjectPattern")
      .bases("Pattern")
      .build("properties")
      .field("properties", [or(def("PropertyPattern"), def("Property"))]);

    def("ArrayPattern")
      .bases("Pattern")
      .build("elements")
      .field("elements", [or(def("Pattern"), null)]);

    def("MethodDefinition")
      .bases("Declaration")
      .build("kind", "key", "value", "static")
      .field("kind", or("constructor", "method", "get", "set"))
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("value", def("Function"))
      .field("computed", Boolean, defaults["false"])
      .field("static", Boolean, defaults["false"]);

    def("SpreadElement")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ArrayExpression")
      .field("elements", [or(
        def("Expression"),
        def("SpreadElement"),
        def("RestElement"),
        null
      )]);

    def("NewExpression")
      .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

    def("CallExpression")
      .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

    // Note: this node type is *not* an AssignmentExpression with a Pattern on
    // the left-hand side! The existing AssignmentExpression type already
    // supports destructuring assignments. AssignmentPattern nodes may appear
    // wherever a Pattern is allowed, and the right-hand side represents a
    // default value to be destructured against the left-hand side, if no
    // value is otherwise provided. For example: default parameter values.
    def("AssignmentPattern")
      .bases("Pattern")
      .build("left", "right")
      .field("left", def("Pattern"))
      .field("right", def("Expression"));

    var ClassBodyElement = or(
      def("MethodDefinition"),
      def("VariableDeclarator"),
      def("ClassPropertyDefinition"),
      def("ClassProperty")
    );

    def("ClassProperty")
      .bases("Declaration")
      .build("key")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("computed", Boolean, defaults["false"]);

    def("ClassPropertyDefinition") // static property
      .bases("Declaration")
      .build("definition")
      // Yes, Virginia, circular definitions are permitted.
      .field("definition", ClassBodyElement);

    def("ClassBody")
      .bases("Declaration")
      .build("body")
      .field("body", [ClassBodyElement]);

    def("ClassDeclaration")
      .bases("Declaration")
      .build("id", "body", "superClass")
      .field("id", or(def("Identifier"), null))
      .field("body", def("ClassBody"))
      .field("superClass", or(def("Expression"), null), defaults["null"]);

    def("ClassExpression")
      .bases("Expression")
      .build("id", "body", "superClass")
      .field("id", or(def("Identifier"), null), defaults["null"])
      .field("body", def("ClassBody"))
      .field("superClass", or(def("Expression"), null), defaults["null"])
      .field("implements", [def("ClassImplements")], defaults.emptyArray);

    def("ClassImplements")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("superClass", or(def("Expression"), null), defaults["null"]);

    // Specifier and ModuleSpecifier are abstract non-standard types
    // introduced for definitional convenience.
    def("Specifier").bases("Node");

    // This supertype is shared/abused by both def/babel.js and
    // def/esprima.js. In the future, it will be possible to load only one set
    // of definitions appropriate for a given parser, but until then we must
    // rely on default functions to reconcile the conflicting AST formats.
    def("ModuleSpecifier")
      .bases("Specifier")
      // This local field is used by Babel/Acorn. It should not technically
      // be optional in the Babel/Acorn AST format, but it must be optional
      // in the Esprima AST format.
      .field("local", or(def("Identifier"), null), defaults["null"])
      // The id and name fields are used by Esprima. The id field should not
      // technically be optional in the Esprima AST format, but it must be
      // optional in the Babel/Acorn AST format.
      .field("id", or(def("Identifier"), null), defaults["null"])
      .field("name", or(def("Identifier"), null), defaults["null"]);

    def("TaggedTemplateExpression")
      .bases("Expression")
      .build("tag", "quasi")
      .field("tag", def("Expression"))
      .field("quasi", def("TemplateLiteral"));

    def("TemplateLiteral")
      .bases("Expression")
      .build("quasis", "expressions")
      .field("quasis", [def("TemplateElement")])
      .field("expressions", [def("Expression")]);

    def("TemplateElement")
      .bases("Node")
      .build("value", "tail")
      .field("value", {"cooked": String, "raw": String})
      .field("tail", Boolean);
};

var es7 = function (fork) {
    fork.use(es6);

    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var builtin = types.builtInTypes;
    var defaults = fork.use(shared).defaults;

    def("Function")
      .field("async", Boolean, defaults["false"]);

    def("SpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ObjectExpression")
      .field("properties", [or(def("Property"), def("SpreadProperty"))]);

    def("SpreadPropertyPattern")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern")
      )]);

    def("AwaitExpression")
      .bases("Expression")
      .build("argument", "all")
      .field("argument", or(def("Expression"), null))
      .field("all", Boolean, defaults["false"]);
};

var mozilla = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var shared$$1 = fork.use(shared);
    var geq = shared$$1.geq;
    var defaults = shared$$1.defaults;

    def("Function")
        // SpiderMonkey allows expression closures: function(x) x+1
        .field("body", or(def("BlockStatement"), def("Expression")));

    def("ForInStatement")
        .build("left", "right", "body", "each")
        .field("each", Boolean, defaults["false"]);

    def("ForOfStatement")
        .bases("Statement")
        .build("left", "right", "body")
        .field("left", or(
            def("VariableDeclaration"),
            def("Expression")))
        .field("right", def("Expression"))
        .field("body", def("Statement"));

    def("LetStatement")
        .bases("Statement")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Statement"));

    def("LetExpression")
        .bases("Expression")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Expression"));

    def("GraphExpression")
        .bases("Expression")
        .build("index", "expression")
        .field("index", geq(0))
        .field("expression", def("Literal"));

    def("GraphIndexExpression")
        .bases("Expression")
        .build("index")
        .field("index", geq(0));
};

var e4x = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;

    // Note that none of these types are buildable because the Mozilla Parser
    // API doesn't specify any builder functions, and nobody uses E4X anymore.

    def("XMLDefaultDeclaration")
        .bases("Declaration")
        .field("namespace", def("Expression"));

    def("XMLAnyName").bases("Expression");

    def("XMLQualifiedIdentifier")
        .bases("Expression")
        .field("left", or(def("Identifier"), def("XMLAnyName")))
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLFunctionQualifiedIdentifier")
        .bases("Expression")
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLAttributeSelector")
        .bases("Expression")
        .field("attribute", def("Expression"));

    def("XMLFilterExpression")
        .bases("Expression")
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("XMLElement")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XMLList")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XML").bases("Node");

    def("XMLEscape")
        .bases("XML")
        .field("expression", def("Expression"));

    def("XMLText")
        .bases("XML")
        .field("text", String);

    def("XMLStartTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLEndTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLPointTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLName")
        .bases("XML")
        .field("contents", or(String, [def("XML")]));

    def("XMLAttribute")
        .bases("XML")
        .field("value", String);

    def("XMLCdata")
        .bases("XML")
        .field("contents", String);

    def("XMLComment")
        .bases("XML")
        .field("contents", String);

    def("XMLProcessingInstruction")
        .bases("XML")
        .field("target", String)
        .field("contents", or(String, null));
};

var jsx = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(shared).defaults;

    def("JSXAttribute")
      .bases("Node")
      .build("name", "value")
      .field("name", or(def("JSXIdentifier"), def("JSXNamespacedName")))
      .field("value", or(
        def("Literal"), // attr="value"
        def("JSXExpressionContainer"), // attr={value}
        null // attr= or just attr
      ), defaults["null"]);

    def("JSXIdentifier")
      .bases("Identifier")
      .build("name")
      .field("name", String);

    def("JSXNamespacedName")
      .bases("Node")
      .build("namespace", "name")
      .field("namespace", def("JSXIdentifier"))
      .field("name", def("JSXIdentifier"));

    def("JSXMemberExpression")
      .bases("MemberExpression")
      .build("object", "property")
      .field("object", or(def("JSXIdentifier"), def("JSXMemberExpression")))
      .field("property", def("JSXIdentifier"))
      .field("computed", Boolean, defaults.false);

    var JSXElementName = or(
      def("JSXIdentifier"),
      def("JSXNamespacedName"),
      def("JSXMemberExpression")
    );

    def("JSXSpreadAttribute")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    var JSXAttributes = [or(
      def("JSXAttribute"),
      def("JSXSpreadAttribute")
    )];

    def("JSXExpressionContainer")
      .bases("Expression")
      .build("expression")
      .field("expression", def("Expression"));

    def("JSXElement")
      .bases("Expression")
      .build("openingElement", "closingElement", "children")
      .field("openingElement", def("JSXOpeningElement"))
      .field("closingElement", or(def("JSXClosingElement"), null), defaults["null"])
      .field("children", [or(
        def("JSXElement"),
        def("JSXExpressionContainer"),
        def("JSXText"),
        def("Literal") // TODO Esprima should return JSXText instead.
      )], defaults.emptyArray)
      .field("name", JSXElementName, function () {
          // Little-known fact: the `this` object inside a default function
          // is none other than the partially-built object itself, and any
          // fields initialized directly from builder function arguments
          // (like openingElement, closingElement, and children) are
          // guaranteed to be available.
          return this.openingElement.name;
      }, true) // hidden from traversal
      .field("selfClosing", Boolean, function () {
          return this.openingElement.selfClosing;
      }, true) // hidden from traversal
      .field("attributes", JSXAttributes, function () {
          return this.openingElement.attributes;
      }, true); // hidden from traversal

    def("JSXOpeningElement")
      .bases("Node") // TODO Does this make sense? Can't really be an JSXElement.
      .build("name", "attributes", "selfClosing")
      .field("name", JSXElementName)
      .field("attributes", JSXAttributes, defaults.emptyArray)
      .field("selfClosing", Boolean, defaults["false"]);

    def("JSXClosingElement")
      .bases("Node") // TODO Same concern.
      .build("name")
      .field("name", JSXElementName);

    def("JSXText")
      .bases("Literal")
      .build("value")
      .field("value", String);

    def("JSXEmptyExpression").bases("Expression").build();

};

var flow = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(shared).defaults;

    // Type Annotations
    def("Type").bases("Node");

    def("AnyTypeAnnotation")
      .bases("Type")
      .build();

    def("EmptyTypeAnnotation")
      .bases("Type")
      .build();

    def("MixedTypeAnnotation")
      .bases("Type")
      .build();

    def("VoidTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    def("StringTypeAnnotation")
      .bases("Type")
      .build();

    def("StringLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", String)
      .field("raw", String);

    def("BooleanTypeAnnotation")
      .bases("Type")
      .build();

    def("BooleanLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Boolean)
      .field("raw", String);

    def("TypeAnnotation")
      .bases("Node")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullableTypeAnnotation")
      .bases("Type")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullLiteralTypeAnnotation")
      .bases("Type")
      .build();

    def("NullTypeAnnotation")
      .bases("Type")
      .build();

    def("ThisTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistsTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistentialTypeParam")
      .bases("Type")
      .build();

    def("FunctionTypeAnnotation")
      .bases("Type")
      .build("params", "returnType", "rest", "typeParameters")
      .field("params", [def("FunctionTypeParam")])
      .field("returnType", def("Type"))
      .field("rest", or(def("FunctionTypeParam"), null))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null));

    def("FunctionTypeParam")
      .bases("Node")
      .build("name", "typeAnnotation", "optional")
      .field("name", def("Identifier"))
      .field("typeAnnotation", def("Type"))
      .field("optional", Boolean);

    def("ArrayTypeAnnotation")
      .bases("Type")
      .build("elementType")
      .field("elementType", def("Type"));

    def("ObjectTypeAnnotation")
      .bases("Type")
      .build("properties", "indexers", "callProperties")
      .field("properties", [def("ObjectTypeProperty")])
      .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
      .field("callProperties",
        [def("ObjectTypeCallProperty")],
        defaults.emptyArray)
      .field("exact", Boolean, defaults["false"]);

    def("ObjectTypeProperty")
      .bases("Node")
      .build("key", "value", "optional")
      .field("key", or(def("Literal"), def("Identifier")))
      .field("value", def("Type"))
      .field("optional", Boolean)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeIndexer")
      .bases("Node")
      .build("id", "key", "value")
      .field("id", def("Identifier"))
      .field("key", def("Type"))
      .field("value", def("Type"))
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeCallProperty")
      .bases("Node")
      .build("value")
      .field("value", def("FunctionTypeAnnotation"))
      .field("static", Boolean, defaults["false"]);

    def("QualifiedTypeIdentifier")
      .bases("Node")
      .build("qualification", "id")
      .field("qualification",
        or(def("Identifier"),
          def("QualifiedTypeIdentifier")))
      .field("id", def("Identifier"));

    def("GenericTypeAnnotation")
      .bases("Type")
      .build("id", "typeParameters")
      .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("MemberTypeAnnotation")
      .bases("Type")
      .build("object", "property")
      .field("object", def("Identifier"))
      .field("property",
        or(def("MemberTypeAnnotation"),
          def("GenericTypeAnnotation")));

    def("UnionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("IntersectionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("TypeofTypeAnnotation")
      .bases("Type")
      .build("argument")
      .field("argument", def("Type"));

    def("Identifier")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("TypeParameterDeclaration")
      .bases("Node")
      .build("params")
      .field("params", [def("TypeParameter")]);

    def("TypeParameterInstantiation")
      .bases("Node")
      .build("params")
      .field("params", [def("Type")]);

    def("TypeParameter")
      .bases("Type")
      .build("name", "variance", "bound")
      .field("name", String)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"])
      .field("bound",
        or(def("TypeAnnotation"), null),
        defaults["null"]);

    def("Function")
      .field("returnType",
        or(def("TypeAnnotation"), null),
        defaults["null"])
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"]);

    def("ClassProperty")
      .build("key", "value", "typeAnnotation", "static")
      .field("value", or(def("Expression"), null))
      .field("typeAnnotation", or(def("TypeAnnotation"), null))
      .field("static", Boolean, defaults["false"])
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ClassImplements")
      .field("typeParameters",
        or(def("TypeParameterInstantiation"), null),
        defaults["null"]);

    def("InterfaceDeclaration")
      .bases("Declaration")
      .build("id", "body", "extends")
      .field("id", def("Identifier"))
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"])
      .field("body", def("ObjectTypeAnnotation"))
      .field("extends", [def("InterfaceExtends")]);

    def("DeclareInterface")
      .bases("InterfaceDeclaration")
      .build("id", "body", "extends");

    def("InterfaceExtends")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("TypeAlias")
      .bases("Declaration")
      .build("id", "typeParameters", "right")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("right", def("Type"));

    def("DeclareTypeAlias")
      .bases("TypeAlias")
      .build("id", "typeParameters", "right");

    def("TypeCastExpression")
      .bases("Expression")
      .build("expression", "typeAnnotation")
      .field("expression", def("Expression"))
      .field("typeAnnotation", def("TypeAnnotation"));

    def("TupleTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("DeclareVariable")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareFunction")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareClass")
      .bases("InterfaceDeclaration")
      .build("id");

    def("DeclareModule")
      .bases("Statement")
      .build("id", "body")
      .field("id", or(def("Identifier"), def("Literal")))
      .field("body", def("BlockStatement"));

    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("DeclareExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("Type"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("DeclareExportAllDeclaration")
      .bases("Declaration")
      .build("source")
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);
};

var esprima = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var defaults = fork.use(shared).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("VariableDeclaration")
      .field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier") // Esprima deviation.
      )]);

    def("Property")
      .field("value", or(
        def("Expression"),
        def("Pattern") // Esprima deviation.
      ));

    def("ArrayPattern")
      .field("elements", [or(
        def("Pattern"),
        def("SpreadElement"),
        null
      )]);

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty") // Used by Esprima.
      )]);

// Like ModuleSpecifier, except type:"ExportSpecifier" and buildable.
// export {<id [as name]>} [from ...];
    def("ExportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// export <*> from ...;
    def("ExportBatchSpecifier")
      .bases("Specifier")
      .build();

// Like ModuleSpecifier, except type:"ImportSpecifier" and buildable.
// import {<id [as name]>} from ...;
    def("ImportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// import <* as id> from ...;
    def("ImportNamespaceSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

// import <id> from ...;
    def("ImportDefaultSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

    def("ExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("Declaration"),
        def("Expression"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("ImportDeclaration")
      .bases("Declaration")
      .build("specifiers", "source", "importKind")
      .field("specifiers", [or(
        def("ImportSpecifier"),
        def("ImportNamespaceSpecifier"),
        def("ImportDefaultSpecifier")
      )], defaults.emptyArray)
      .field("source", def("Literal"))
      .field("importKind", or(
        "value",
        "type"
      ), function() {
        return "value";
      });

    def("Block")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");

    def("Line")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");
};

var babel = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var defaults = fork.use(shared).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("Noop")
        .bases("Node")
        .build();

    def("DoExpression")
        .bases("Expression")
        .build("body")
        .field("body", [def("Statement")]);

    def("Super")
        .bases("Expression")
        .build();

    def("BindExpression")
        .bases("Expression")
        .build("object", "callee")
        .field("object", or(def("Expression"), null))
        .field("callee", def("Expression"));

    def("Decorator")
        .bases("Node")
        .build("expression")
        .field("expression", def("Expression"));

    def("Property")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MethodDefinition")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MetaProperty")
        .bases("Expression")
        .build("meta", "property")
        .field("meta", def("Identifier"))
        .field("property", def("Identifier"));

    def("ParenthesizedExpression")
        .bases("Expression")
        .build("expression")
        .field("expression", def("Expression"));

    def("ImportSpecifier")
        .bases("ModuleSpecifier")
        .build("imported", "local")
        .field("imported", def("Identifier"));

    def("ImportDefaultSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ImportNamespaceSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ExportDefaultDeclaration")
        .bases("Declaration")
        .build("declaration")
        .field("declaration", or(def("Declaration"), def("Expression")));

    def("ExportNamedDeclaration")
        .bases("Declaration")
        .build("declaration", "specifiers", "source")
        .field("declaration", or(def("Declaration"), null))
        .field("specifiers", [def("ExportSpecifier")], defaults.emptyArray)
        .field("source", or(def("Literal"), null), defaults["null"]);

    def("ExportSpecifier")
        .bases("ModuleSpecifier")
        .build("local", "exported")
        .field("exported", def("Identifier"));

    def("ExportNamespaceSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportDefaultSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportAllDeclaration")
        .bases("Declaration")
        .build("exported", "source")
        .field("exported", or(def("Identifier"), null))
        .field("source", def("Literal"));

    def("CommentBlock")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");

    def("CommentLine")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");
};

var babel6 = function (fork) {
    fork.use(babel);
    fork.use(flow);

    // var types = fork.types;
    var types = fork.use(types$1);
    // var defaults = fork.shared.defaults;
    var defaults = fork.use(shared).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("Directive")
        .bases("Node")
        .build("value")
        .field("value", def("DirectiveLiteral"));

    def("DirectiveLiteral")
        .bases("Node", "Expression")
        .build("value")
        .field("value", String, defaults["use strict"]);

    def("BlockStatement")
        .bases("Statement")
        .build("body")
        .field("body", [def("Statement")])
        .field("directives", [def("Directive")], defaults.emptyArray);

    def("Program")
        .bases("Node")
        .build("body")
        .field("body", [def("Statement")])
        .field("directives", [def("Directive")], defaults.emptyArray);

    // Split Literal
    def("StringLiteral")
        .bases("Literal")
        .build("value")
        .field("value", String);

    def("NumericLiteral")
        .bases("Literal")
        .build("value")
        .field("value", Number);

    def("NullLiteral")
        .bases("Literal")
        .build();

    def("BooleanLiteral")
        .bases("Literal")
        .build("value")
        .field("value", Boolean);

    def("RegExpLiteral")
        .bases("Literal")
        .build("pattern", "flags")
        .field("pattern", String)
        .field("flags", String);

    var ObjectExpressionProperty = or(
      def("Property"),
      def("ObjectMethod"),
      def("ObjectProperty"),
      def("SpreadProperty")
    );

    // Split Property -> ObjectProperty and ObjectMethod
    def("ObjectExpression")
        .bases("Expression")
        .build("properties")
        .field("properties", [ObjectExpressionProperty]);

    // ObjectMethod hoist .value properties to own properties
    def("ObjectMethod")
        .bases("Node", "Function")
        .build("kind", "key", "params", "body", "computed")
        .field("kind", or("method", "get", "set"))
        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
        .field("params", [def("Pattern")])
        .field("body", def("BlockStatement"))
        .field("computed", Boolean, defaults["false"])
        .field("generator", Boolean, defaults["false"])
        .field("async", Boolean, defaults["false"])
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("ObjectProperty")
        .bases("Node")
        .build("key", "value")
        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
        .field("value", or(def("Expression"), def("Pattern")))
        .field("computed", Boolean, defaults["false"]);

    var ClassBodyElement = or(
      def("MethodDefinition"),
      def("VariableDeclarator"),
      def("ClassPropertyDefinition"),
      def("ClassProperty"),
      def("ClassMethod")
    );

    // MethodDefinition -> ClassMethod
    def("ClassBody")
        .bases("Declaration")
        .build("body")
        .field("body", [ClassBodyElement]);

    def("ClassMethod")
        .bases("Declaration", "Function")
        .build("kind", "key", "params", "body", "computed", "static")
        .field("kind", or("get", "set", "method", "constructor"))
        .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
        .field("params", [def("Pattern")])
        .field("body", def("BlockStatement"))
        .field("computed", Boolean, defaults["false"])
        .field("static", Boolean, defaults["false"])
        .field("generator", Boolean, defaults["false"])
        .field("async", Boolean, defaults["false"])
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"), // Used by Esprima
        def("ObjectProperty"), // Babel 6
        def("RestProperty") // Babel 6
    );

    // Split into RestProperty and SpreadProperty
    def("ObjectPattern")
        .bases("Pattern")
        .build("properties")
        .field("properties", [ObjectPatternProperty])
        .field("decorators",
               or([def("Decorator")], null),
               defaults["null"]);

    def("SpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("RestProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ForAwaitStatement")
      .bases("Statement")
      .build("left", "right", "body")
      .field("left", or(
          def("VariableDeclaration"),
          def("Expression")))
      .field("right", def("Expression"))
      .field("body", def("Statement"));
};

var main = fork([
    // This core module of AST types captures ES5 as it is parsed today by
    // git://github.com/ariya/esprima.git#master.
    core,

    // Feel free to add to or remove from this list of extension modules to
    // configure the precise type hierarchy that you need.
    es6,
    es7,
    mozilla,
    e4x,
    jsx,
    flow,
    esprima,
    babel,
    babel6
]);

function traverseDoc(doc, onEnter, onExit) {
  var hasStopped = false;
  function traverseDocRec(doc) {
    if (onEnter) {
      hasStopped = hasStopped || onEnter(doc) === false;
    }
    if (hasStopped) {
      return;
    }

    if (doc.type === "concat") {
      for (var i = 0; i < doc.parts.length; i++) {
        traverseDocRec(doc.parts[i]);
      }
    } else if (doc.type === "if-break") {
      if (doc.breakContents) {
        traverseDocRec(doc.breakContents);
      }
      if (doc.flatContents) {
        traverseDocRec(doc.flatContents);
      }
    } else if (doc.contents) {
      traverseDocRec(doc.contents);
    }

    if (onExit) {
      onExit(doc);
    }
  }

  traverseDocRec(doc);
}

function findInDoc(doc, fn, defaultValue) {
  var result = defaultValue;
  traverseDoc(doc, function(doc) {
    var maybeResult = fn(doc);
    if (maybeResult !== undefined) {
      result = maybeResult;
      return false;
    }
  });
  return result;
}

function isEmpty(n) {
  return typeof n === "string" && n.length === 0;
}

function getFirstString(doc) {
  return findInDoc(
    doc,
    doc => {
      if (typeof doc === "string" && doc.trim().length !== 0) {
        return doc;
      }
    },
    null
  );
}

function isLineNext(doc) {
  return findInDoc(
    doc,
    doc => {
      if (typeof doc === "string") {
        return false;
      }
      if (doc.type === "line") {
        return true;
      }
    },
    false
  );
}

function willBreak$1(doc) {
  return findInDoc(
    doc,
    doc => {
      if (doc.type === "group" && doc.break) {
        return true;
      }
      if (doc.type === "line" && doc.hard) {
        return true;
      }
    },
    false
  );
}

function breakParentGroup(groupStack) {
  if (groupStack.length > 0) {
    const parentGroup = groupStack[groupStack.length - 1];
    // Breaks are not propagated through conditional groups because
    // the user is expected to manually handle what breaks.
    if (!parentGroup.expandedStates) {
      parentGroup.break = true;
    }
  }
  return null;
}

function propagateBreaks(doc) {
  const groupStack = [];
  traverseDoc(
    doc,
    doc => {
      if (doc.type === "break-parent") {
        breakParentGroup(groupStack);
      }
      if (doc.type === "group") {
        groupStack.push(doc);
      }
    },
    doc => {
      if (doc.type === "group") {
        const group = groupStack.pop();
        if (group.break) {
          breakParentGroup(groupStack);
        }
      }
    }
  );
}

var docUtils = {
  isEmpty,
  getFirstString,
  willBreak: willBreak$1,
  isLineNext,
  traverseDoc,
  propagateBreaks
};

function assertDoc(val) {
  if (
    !(typeof val === "string" || val != null && typeof val.type === "string")
  ) {
    throw new Error(
      "Value " + JSON.stringify(val) + " is not a valid document"
    );
  }
}

function concat$1(parts) {
  parts.forEach(assertDoc);

  // We cannot do this until we change `printJSXElement` to not
  // access the internals of a document directly.
  // if(parts.length === 1) {
  //   // If it's a single document, no need to concat it.
  //   return parts[0];
  // }
  return { type: "concat", parts };
}

function indent$1(n, contents) {
  assertDoc(contents);

  return { type: "indent", contents, n };
}

function group(contents, opts) {
  opts = opts || {};

  assertDoc(contents);

  return {
    type: "group",
    contents: contents,
    break: !!opts.shouldBreak,
    expandedStates: opts.expandedStates
  };
}

function conditionalGroup(states, opts) {
  return group(
    states[0],
    Object.assign(opts || {}, { expandedStates: states })
  );
}

function ifBreak(breakContents, flatContents) {
  if (breakContents) {
    assertDoc(breakContents);
  }
  if (flatContents) {
    assertDoc(flatContents);
  }

  return { type: "if-break", breakContents, flatContents };
}

function lineSuffix$1(contents) {
  assertDoc(contents);
  return { type: "line-suffix", contents };
}

const breakParent$1 = { type: "break-parent" };
const line = { type: "line" };
const softline = { type: "line", soft: true };
const hardline$1 = concat$1([{ type: "line", hard: true }, breakParent$1]);
const literalline = concat$1([
  { type: "line", hard: true, literal: true },
  breakParent$1
]);

function join$1(sep, arr) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    if (i !== 0) {
      res.push(sep);
    }

    res.push(arr[i]);
  }

  return concat$1(res);
}

var docBuilders$1 = {
  concat: concat$1,
  join: join$1,
  line,
  softline,
  hardline: hardline$1,
  literalline,
  group,
  conditionalGroup,
  lineSuffix: lineSuffix$1,
  breakParent: breakParent$1,
  ifBreak,
  indent: indent$1
};

var types$3 = main;
var n$1 = types$3.namedTypes;

function comparePos$1(pos1, pos2) {
  return pos1.line - pos2.line || pos1.column - pos2.column;
}

function expandLoc(parentNode, childNode) {
  if (locStart$1(childNode) - locStart$1(parentNode) < 0) {
    setLocStart(parentNode, locStart$1(childNode));
  }

  if (locEnd$1(parentNode) - locEnd$1(childNode) < 0) {
    setLocEnd(parentNode, locEnd$1(childNode));
  }
}

function fixFaultyLocations(node, text) {
  if (node.decorators) {
    // Expand the loc of the node responsible for printing the decorators
    // (here, the decorated node) so that it includes node.decorators.
    node.decorators.forEach(function(decorator) {
      expandLoc(node, decorator);
    });
  } else if (node.declaration && isExportDeclaration(node)) {
    // Expand the loc of the node responsible for printing the decorators
    // (here, the export declaration) so that it includes node.decorators.
    var decorators = node.declaration.decorators;
    if (decorators) {
      decorators.forEach(function(decorator) {
        expandLoc(node, decorator);
      });
    }
  } else if (
    n$1.MethodDefinition && n$1.MethodDefinition.check(node) ||
    n$1.Property.check(node) && (node.method || node.shorthand)
  ) {
    if (n$1.FunctionExpression.check(node.value)) {
      // FunctionExpression method values should be anonymous,
      // because their .id fields are ignored anyway.
      node.value.id = null;
    }
  } else if (node.type === "ObjectTypeProperty") {
    var end = skipSpaces(text, locEnd$1(node), true);
    if (end !== false && text.charAt(end) === ",") {
      // Some parsers accidentally include trailing commas in the
      // end information for ObjectTypeProperty nodes.
      if ((end = skipSpaces(text, end - 1, true)) !== false) {
        setLocEnd(node, end);
      }
    }
  }
}

function isExportDeclaration(node) {
  if (node)
    switch (node.type) {
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportDefaultSpecifier":
      case "DeclareExportDeclaration":
      case "ExportNamedDeclaration":
      case "ExportAllDeclaration":
        return true;
    }

  return false;
}

function getParentExportDeclaration(path) {
  var parentNode = path.getParentNode();
  if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
    return parentNode;
  }

  return null;
}

function getLast(arr) {
  if (arr.length > 0) {
    return arr[arr.length - 1];
  }
  return null;
}

function skip(chars) {
  return (text, index, opts) => {
    const backwards = opts && opts.backwards;

    // Allow `skip` functions to be threaded together without having
    // to check for failures (did someone say monads?).
    if (index === false) {
      return false;
    }

    const length = text.length;
    let cursor = index;
    while (cursor >= 0 && cursor < length) {
      const c = text.charAt(cursor);
      if (chars instanceof RegExp) {
        if (!chars.test(c)) {
          return cursor;
        }
      } else if (chars.indexOf(c) === -1) {
        return cursor;
      }

      backwards ? cursor-- : cursor++;
    }

    if (cursor === -1 || cursor === length) {
      // If we reached the beginning or end of the file, return the
      // out-of-bounds cursor. It's up to the caller to handle this
      // correctly. We don't want to indicate `false` though if it
      // actually skipped valid characters.
      return cursor;
    }
    return false;
  };
}

const skipWhitespace = skip(/\s/);
const skipSpaces = skip(" \t");
const skipToLineEnd = skip(",; \t");
const skipEverythingButNewLine = skip(/[^\r\n]/);

function skipInlineComment(text, index) {
  if (index === false) {
    return false;
  }

  if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {
    for (var i = index + 2; i < text.length; ++i) {
      if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
        return i + 2;
      }
    }
  }
  return index;
}

function skipTrailingComment(text, index) {
  if (index === false) {
    return false;
  }

  if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {
    return skipEverythingButNewLine(text, index);
  }
  return index;
}

// This one doesn't use the above helper function because it wants to
// test \r\n in order and `skip` doesn't support ordering and we only
// want to skip one newline. It's simple to implement.
function skipNewline(text, index, opts) {
  const backwards = opts && opts.backwards;
  if (index === false) {
    return false;
  } else if (backwards) {
    if (text.charAt(index) === "\n") {
      return index - 1;
    }
    if (text.charAt(index - 1) === "\r" && text.charAt(index) === "\n") {
      return index - 2;
    }
  } else {
    if (text.charAt(index) === "\n") {
      return index + 1;
    }
    if (text.charAt(index) === "\r" && text.charAt(index + 1) === "\n") {
      return index + 2;
    }
  }

  return index;
}

function hasNewline(text, index, opts) {
  opts = opts || {};
  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
  const idx2 = skipNewline(text, idx, opts);
  return idx !== idx2;
}

function hasNewlineInRange(text, start, end) {
  for (var i = start; i < end; ++i) {
    if (text.charAt(i) === "\n") {
      return true;
    }
  }
  return false;
}

// Note: this function doesn't ignore leading comments unlike isNextLineEmpty
function isPreviousLineEmpty(text, node) {
  let idx = locStart$1(node) - 1;
  idx = skipSpaces(text, idx, { backwards: true });
  idx = skipNewline(text, idx, { backwards: true });
  idx = skipSpaces(text, idx, { backwards: true });
  const idx2 = skipNewline(text, idx, { backwards: true });
  return idx !== idx2;
}

function isNextLineEmpty(text, node) {
  let oldIdx = null;
  let idx = locEnd$1(node);
  idx = skipToLineEnd(text, idx);
  while (idx !== oldIdx) {
    // We need to skip all the potential trailing inline comments
    oldIdx = idx;
    idx = skipInlineComment(text, idx);
    idx = skipSpaces(text, idx);
  }
  idx = skipTrailingComment(text, idx);
  idx = skipNewline(text, idx);
  return hasNewline(text, idx);
}

function hasSpaces(text, index, opts) {
  opts = opts || {};
  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
  return idx !== index;
}

function locStart$1(node) {
  if (node.range) {
    return node.range[0];
  }
  return node.start;
}

function locEnd$1(node) {
  if (node.range) {
    return node.range[1];
  }
  return node.end;
}

function setLocStart(node, index) {
  if (node.range) {
    node.range[0] = index;
  } else {
    node.start = index;
  }
}

function setLocEnd(node, index) {
  if (node.range) {
    node.range[1] = index;
  } else {
    node.end = index;
  }
}

// http://stackoverflow.com/a/7124052
function htmlEscapeInsideDoubleQuote(str) {
  return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;");
  // Intentionally disable the following since it is safe inside of a
  // double quote context
  //    .replace(/'/g, '&#39;')
  //    .replace(/</g, '&lt;')
  //    .replace(/>/g, '&gt;');
}

// http://stackoverflow.com/a/7124052
function htmlEscapeInsideAngleBracket(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  // Intentionally disable the following since it is safe inside of a
  // angle bracket context
  //    .replace(/&/g, '&amp;')
  //    .replace(/"/g, '&quot;')
  //    .replace(/'/g, '&#39;')
}

var PRECEDENCE = {};
[
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%", "**"]
].forEach(function(tier, i) {
  tier.forEach(function(op) {
    PRECEDENCE[op] = i;
  });
});

function getPrecedence(op) {
  return PRECEDENCE[op];
}

var util$4 = {
  comparePos: comparePos$1,
  getPrecedence,
  fixFaultyLocations,
  isExportDeclaration,
  getParentExportDeclaration,
  getLast,
  skipWhitespace,
  skipSpaces,
  skipNewline,
  isNextLineEmpty,
  isPreviousLineEmpty,
  hasNewline,
  hasNewlineInRange,
  hasSpaces,
  locStart: locStart$1,
  locEnd: locEnd$1,
  setLocStart,
  setLocEnd,
  htmlEscapeInsideDoubleQuote,
  htmlEscapeInsideAngleBracket
};

var assert$2 = require$$0$1;
var types = main;
var n = types.namedTypes;
var isArray$1 = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var docBuilders = docBuilders$1;
var concat = docBuilders.concat;
var hardline = docBuilders.hardline;
var breakParent = docBuilders.breakParent;
var indent = docBuilders.indent;
var lineSuffix = docBuilders.lineSuffix;
var join = docBuilders.join;
var util$3 = util$4;
var childNodesCacheKey = Symbol("child-nodes");
var locStart = util$3.locStart;
var locEnd = util$3.locEnd;

// TODO Move a non-caching implementation of this function into ast-types,
// and implement a caching wrapper function here.
function getSortedChildNodes(node, text, resultArray) {
  if (!node) {
    return;
  }

  // The loc checks below are sensitive to some of the problems that
  // are fixed by this utility function.
  util$3.fixFaultyLocations(node, text);

  if (resultArray) {
    if (n.Node.check(node) && node.type !== "EmptyStatement") {
      // This reverse insertion sort almost always takes constant
      // time because we almost always (maybe always?) append the
      // nodes in order anyway.
      for (var i = resultArray.length - 1; i >= 0; --i) {
        if (locEnd(resultArray[i]) - locStart(node) <= 0) {
          break;
        }
      }
      resultArray.splice(i + 1, 0, node);
      return;
    }
  } else if (node[childNodesCacheKey]) {
    return node[childNodesCacheKey];
  }

  var names;
  if (isArray$1.check(node)) {
    names = Object.keys(node);
  } else if (isObject.check(node)) {
    names = types.getFieldNames(node);
  } else {
    return;
  }

  if (!resultArray) {
    Object.defineProperty(node, childNodesCacheKey, {
      value: resultArray = [],
      enumerable: false
    });
  }

  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
    getSortedChildNodes(node[names[i]], text, resultArray);
  }

  return resultArray;
}

// As efficiently as possible, decorate the comment object with
// .precedingNode, .enclosingNode, and/or .followingNode properties, at
// least one of which is guaranteed to be defined.
function decorateComment(node, comment, text) {
  var childNodes = getSortedChildNodes(node, text);
  var precedingNode, followingNode;
  // Time to dust off the old binary search robes and wizard hat.
  var left = 0, right = childNodes.length;
  while (left < right) {
    var middle = left + right >> 1;
    var child = childNodes[middle];

    if (
      locStart(child) - locStart(comment) <= 0 &&
      locEnd(comment) - locEnd(child) <= 0
    ) {
      // The comment is completely contained by this child node.
      comment.enclosingNode = child;

      decorateComment(child, comment, text);
      return; // Abandon the binary search at this level.
    }

    if (locEnd(child) - locStart(comment) <= 0) {
      // This child node falls completely before the comment.
      // Because we will never consider this node or any nodes
      // before it again, this node must be the closest preceding
      // node we have encountered so far.
      precedingNode = child;
      left = middle + 1;
      continue;
    }

    if (locEnd(comment) - locStart(child) <= 0) {
      // This child node falls completely after the comment.
      // Because we will never consider this node or any nodes after
      // it again, this node must be the closest following node we
      // have encountered so far.
      followingNode = child;
      right = middle;
      continue;
    }

    throw new Error("Comment location overlaps with node location");
  }

  if (precedingNode) {
    comment.precedingNode = precedingNode;
  }

  if (followingNode) {
    comment.followingNode = followingNode;
  }
}

function attach(comments, ast, text) {
  if (!isArray$1.check(comments)) {
    return;
  }

  var tiesToBreak = [];

  comments.forEach(function(comment) {
    decorateComment(ast, comment, text);

    const precedingNode = comment.precedingNode;
    const enclosingNode = comment.enclosingNode;
    const followingNode = comment.followingNode;

    if (util$3.hasNewline(text, locStart(comment), { backwards: true })) {
      // If a comment exists on its own line, prefer a leading comment.
      // We also need to check if it's the first line of the file.
      if (
        handleMemberExpressionComment(enclosingNode, followingNode, comment) ||
        handleIfStatementComments(enclosingNode, followingNode, comment) ||
        handleTryStatementComments(enclosingNode, followingNode, comment)
      ) {
        // We're good
      } else if (followingNode) {
        // Always a leading comment.
        addLeadingComment(followingNode, comment);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    } else if (util$3.hasNewline(text, locEnd(comment))) {
      if (
        handleConditionalExpressionComments(
          enclosingNode,
          followingNode,
          comment
        )
      ) {
        // We're good
      } else if (precedingNode) {
        // There is content before this comment on the same line, but
        // none after it, so prefer a trailing comment of the previous node.
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    } else {
      if (handleIfStatementComments(enclosingNode, followingNode, comment)) {
        // We're good
      } else if (precedingNode && followingNode) {
        // Otherwise, text exists both before and after the comment on
        // the same line. If there is both a preceding and following
        // node, use a tie-breaking algorithm to determine if it should
        // be attached to the next or previous node. In the last case,
        // simply attach the right node;
        const tieCount = tiesToBreak.length;
        if (tieCount > 0) {
          var lastTie = tiesToBreak[tieCount - 1];
          if (lastTie.followingNode !== comment.followingNode) {
            breakTies(tiesToBreak, text);
          }
        }
        tiesToBreak.push(comment);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    }
  });

  breakTies(tiesToBreak, text);

  comments.forEach(function(comment) {
    // These node references were useful for breaking ties, but we
    // don't need them anymore, and they create cycles in the AST that
    // may lead to infinite recursion if we don't delete them here.
    delete comment.precedingNode;
    delete comment.enclosingNode;
    delete comment.followingNode;
  });
}

function breakTies(tiesToBreak, text) {
  var tieCount = tiesToBreak.length;
  if (tieCount === 0) {
    return;
  }

  var precedingNode = tiesToBreak[0].precedingNode;
  var followingNode = tiesToBreak[0].followingNode;
  var gapEndPos = locStart(followingNode);

  // Iterate backwards through tiesToBreak, examining the gaps
  // between the tied comments. In order to qualify as leading, a
  // comment must be separated from followingNode by an unbroken series of
  // whitespace-only gaps (or other comments).
  for (
    var indexOfFirstLeadingComment = tieCount;
    indexOfFirstLeadingComment > 0;
    --indexOfFirstLeadingComment
  ) {
    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
    assert$2.strictEqual(comment.precedingNode, precedingNode);
    assert$2.strictEqual(comment.followingNode, followingNode);

    var gap = text.slice(locEnd(comment), gapEndPos);
    if (/\S/.test(gap)) {
      // The gap string contained something other than whitespace.
      break;
    }

    gapEndPos = locStart(comment);
  }

  tiesToBreak.forEach(function(comment, i) {
    if (i < indexOfFirstLeadingComment) {
      addTrailingComment(precedingNode, comment);
    } else {
      addLeadingComment(followingNode, comment);
    }
  });

  tiesToBreak.length = 0;
}

function addCommentHelper(node, comment) {
  var comments = node.comments || (node.comments = []);
  comments.push(comment);
  comment.printed = false;
}

function addLeadingComment(node, comment) {
  comment.leading = true;
  comment.trailing = false;
  addCommentHelper(node, comment);
}

function addDanglingComment(node, comment) {
  comment.leading = false;
  comment.trailing = false;
  addCommentHelper(node, comment);
}

function addTrailingComment(node, comment) {
  comment.leading = false;
  comment.trailing = true;
  addCommentHelper(node, comment);
}

function addBlockStatementFirstComment(node, comment) {
  if (node.body.length === 0) {
    addDanglingComment(node, comment);
  } else {
    addLeadingComment(node.body[0], comment);
  }
}

function addBlockOrNotComment(node, comment) {
  if (node.type === "BlockStatement") {
    addBlockStatementFirstComment(node, comment);
  } else {
    addLeadingComment(node, comment);
  }
}

// There are often comments before the else clause of if statements like
//
//   if (1) { ... }
//   // comment
//   else { ... }
//
// They are being attached as leading comments of the BlockExpression which
// is not well printed. What we want is to instead move the comment inside
// of the block and make it leadingComment of the first element of the block
// or dangling comment of the block if there is nothing inside
//
//   if (1) { ... }
//   else {
//     // comment
//     ...
//   }
function handleIfStatementComments(enclosingNode, followingNode, comment) {
  if (
    !enclosingNode || enclosingNode.type !== "IfStatement" || !followingNode
  ) {
    return false;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "IfStatement") {
    addBlockOrNotComment(followingNode.consequent, comment);
    return true;
  }

  return false;
}

// Same as IfStatement but for TryStatement
function handleTryStatementComments(enclosingNode, followingNode, comment) {
  if (
    !enclosingNode || enclosingNode.type !== "TryStatement" || !followingNode
  ) {
    return false;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "TryStatement") {
    addBlockOrNotComment(followingNode.finalizer, comment);
    return true;
  }

  if (followingNode.type === "CatchClause") {
    addBlockOrNotComment(followingNode.body, comment);
    return true;
  }

  return false;
}

function handleMemberExpressionComment(enclosingNode, followingNode, comment) {
  if (
    enclosingNode &&
    enclosingNode.type === "MemberExpression" &&
    followingNode &&
    followingNode.type === "Identifier"
  ) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleConditionalExpressionComments(
  enclosingNode,
  followingNode,
  comment
) {
  if (
    enclosingNode &&
    enclosingNode.type === "ConditionalExpression" &&
    followingNode
  ) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}

function printComment(commentPath) {
  const comment = commentPath.getValue();
  comment.printed = true;

  switch (comment.type) {
    case "CommentBlock":
    case "Block":
      return "/*" + comment.value + "*/";
    case "CommentLine":
    case "Line":
      return "//" + comment.value;
    default:
      throw new Error("Not a comment: " + JSON.stringify(comment));
  }
}

function printLeadingComment(commentPath, print, options) {
  const comment = commentPath.getValue();
  const contents = printComment(commentPath);
  const text = options.originalText;
  const isBlock = comment.type === "Block" || comment.type === "CommentBlock";

  // Leading block comments should see if they need to stay on the
  // same line or not.
  if (isBlock) {
    return concat([
      contents,
      util$3.hasNewline(options.originalText, locEnd(comment)) ? hardline : " "
    ]);
  }

  return concat([contents, hardline]);
}

function printTrailingComment(commentPath, print, options, parentNode) {
  const comment = commentPath.getValue();
  const contents = printComment(commentPath);
  const isBlock = comment.type === "Block" || comment.type === "CommentBlock";

  if (
    util$3.hasNewline(options.originalText, locStart(comment), {
      backwards: true
    })
  ) {
    // This allows comments at the end of nested structures:
    // {
    //   x: 1,
    //   y: 2
    //   // A comment
    // }
    // Those kinds of comments are almost always leading comments, but
    // here it doesn't go "outside" the block and turns it into a
    // trailing comment for `2`. We can simulate the above by checking
    // if this a comment on its own line; normal trailing comments are
    // always at the end of another expression.

    const isLineBeforeEmpty = util$3.isPreviousLineEmpty(
      options.originalText,
      comment
    );

    return lineSuffix(
      concat([hardline, isLineBeforeEmpty ? hardline : "", contents])
    );
  } else if (isBlock) {
    // Trailing block comments never need a newline
    return concat([" ", contents]);
  }

  return concat([lineSuffix(" " + contents), !isBlock ? breakParent : ""]);
}

function printDanglingComments(path, options, sameIndent) {
  const text = options.originalText;
  const parts = [];
  const node = path.getValue();

  if (!node || !node.comments) {
    return "";
  }

  path.each(
    commentPath => {
      const comment = commentPath.getValue();
      if (!comment.leading && !comment.trailing) {
        parts.push(printComment(commentPath));
      }
    },
    "comments"
  );

  if (parts.length === 0) {
    return "";
  }

  if (sameIndent) {
    return join(hardline, parts);
  }
  return indent(options.tabWidth, concat([hardline, join(hardline, parts)]));
}

function printComments(path, print, options) {
  var value = path.getValue();
  var parent = path.getParentNode();
  var printed = print(path);
  var comments = n.Node.check(value) && types.getFieldValue(value, "comments");

  if (!comments || comments.length === 0) {
    return printed;
  }

  var leadingParts = [];
  var trailingParts = [printed];

  path.each(
    function(commentPath) {
      var comment = commentPath.getValue();
      var leading = types.getFieldValue(comment, "leading");
      var trailing = types.getFieldValue(comment, "trailing");

      if (leading) {
        leadingParts.push(printLeadingComment(commentPath, print, options));

        const text = options.originalText;
        if (
          util$3.hasNewline(text, util$3.skipNewline(text, util$3.locEnd(comment)))
        ) {
          leadingParts.push(hardline);
        }
      } else if (trailing) {
        trailingParts.push(
          printTrailingComment(commentPath, print, options, parent)
        );
      }
    },
    "comments"
  );

  return concat(leadingParts.concat(trailingParts));
}

var comments$1 = { attach, printComments, printDanglingComments };

var name = "prettier";
var version$2 = "0.18.0";
var description = "Prettier is an opinionated JavaScript formatter";
var bin = {"prettier":"./bin/prettier.js"};
var repository = {"type":"git","url":"git+https://github.com/jlongster/prettier.git"};
var author = "James Long";
var license = "MIT";
var bugs = {"url":"https://github.com/jlongster/prettier/issues"};
var main$2 = "./index.js";
var dependencies = {"ast-types":"0.9.4","babel-code-frame":"6.22.0","babylon":"6.15.0","chalk":"1.1.3","esutils":"2.0.2","flow-parser":"0.38.0","get-stdin":"5.0.1","glob":"7.1.1","jest-validate":"18.2.0","minimist":"1.2.0"};
var devDependencies = {"jest":"18.0.0","rollup":"0.41.1","rollup-plugin-commonjs":"7.0.0","rollup-plugin-json":"2.1.0","rollup-plugin-node-builtins":"2.0.0","rollup-plugin-node-globals":"1.1.0","rollup-plugin-node-resolve":"2.0.0","rollup-plugin-real-babili":"1.0.0-alpha3","diff":"3.2.0"};
var scripts = {"test":"jest","format":"./bin/prettier.js --write","format:single":"npm run format -- src/printer.js","format:all":"npm run format -- index.js src/*.js bin/*.js","build:docs":"rollup -c docs/rollup.config.js","build:dist":"rollup -c dist/rollup.config.js"};
var jest = {"setupFiles":["<rootDir>/tests_config/run_spec.js"],"testRegex":"jsfmt\\.spec\\.js$","testPathIgnorePatterns":["tests/new_react","tests/more_react"]};
var _package = {
	name: name,
	version: version$2,
	description: description,
	bin: bin,
	repository: repository,
	author: author,
	license: license,
	bugs: bugs,
	main: main$2,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts,
	jest: jest
};

var _package$1 = Object.freeze({
	name: name,
	version: version$2,
	description: description,
	bin: bin,
	repository: repository,
	author: author,
	license: license,
	bugs: bugs,
	main: main$2,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts,
	jest: jest,
	default: _package
});

var assert$5 = require$$0$1;
var types$5 = main;
var util$7 = util$4;
var n$2 = types$5.namedTypes;
var isArray$2 = types$5.builtInTypes.array;
var isNumber$1 = types$5.builtInTypes.number;

function FastPath$1(value) {
  assert$5.ok(this instanceof FastPath$1);
  this.stack = [value];
}

var FPp = FastPath$1.prototype;

// Static convenience function for coercing a value to a FastPath.
FastPath$1.from = function(obj) {
  if (obj instanceof FastPath$1) {
    // Return a defensive copy of any existing FastPath instances.
    return obj.copy();
  }

  if (obj instanceof types$5.NodePath) {
    // For backwards compatibility, unroll NodePath instances into
    // lightweight FastPath [..., name, value] stacks.
    var copy = Object.create(FastPath$1.prototype);
    var stack = [obj.value];
    for (var pp; pp = obj.parentPath; obj = pp)
      stack.push(obj.name, pp.value);
    copy.stack = stack.reverse();
    return copy;
  }

  // Otherwise use obj as the value of the new FastPath instance.
  return new FastPath$1(obj);
};

FPp.copy = function copy() {
  var copy = Object.create(FastPath$1.prototype);
  copy.stack = this.stack.slice(0);
  return copy;
};

// The name of the current property is always the penultimate element of
// this.stack, and always a String.
FPp.getName = function getName() {
  var s = this.stack;
  var len = s.length;
  if (len > 1) {
    return s[len - 2];
  }
  // Since the name is always a string, null is a safe sentinel value to
  // return if we do not know the name of the (root) value.
  return null;
};

// The value of the current property is always the final element of
// this.stack.
FPp.getValue = function getValue() {
  var s = this.stack;
  return s[s.length - 1];
};

function getNodeHelper(path, count) {
  var s = path.stack;

  for (var i = s.length - 1; i >= 0; i -= 2) {
    var value = s[i];
    if (n$2.Node.check(value) && --count < 0) {
      return value;
    }
  }

  return null;
}

FPp.getNode = function getNode(count) {
  return getNodeHelper(this, ~~count);
};

FPp.getParentNode = function getParentNode(count) {
  return getNodeHelper(this, ~~count + 1);
};

FPp.isLast = function isLast() {
  var s = this.stack;
  if (this.getParentNode()) {
    var idx = s[s.length - 2];
    // The name of this node should be an index
    assert$5.ok(typeof idx === "number");

    const arr = s[s.length - 3];
    // We should have an array as a parent node
    assert$5.ok(Array.isArray(arr));

    return idx === arr.length - 1;
  }
  return false;
};

// Temporarily push properties named by string arguments given after the
// callback function onto this.stack, then call the callback with a
// reference to this (modified) FastPath object. Note that the stack will
// be restored to its original state after the callback is finished, so it
// is probably a mistake to retain a reference to the path.
FPp.call = function call(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;
  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }
  var result = callback(this);
  s.length = origLen;
  return result;
};

// Similar to FastPath.prototype.call, except that the value obtained by
// accessing this.getValue()[name1][name2]... should be array-like. The
// callback will be called with a reference to this path object for each
// element of the array.
FPp.each = function each(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      // If the callback needs to know the value of i, call
      // path.getName(), assuming path is the parameter name.
      callback(this);
      s.length -= 2;
    }
  }

  s.length = origLen;
};

// Similar to FastPath.prototype.each, except that the results of the
// callback function invocations are stored in an array and returned at
// the end of the iteration.
FPp.map = function map(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  var result = new Array(value.length);

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      result[i] = callback(this, i);
      s.length -= 2;
    }
  }

  s.length = origLen;

  return result;
};

// Inspired by require("ast-types").NodePath.prototype.needsParens, but
// more efficient because we're iterating backwards through a stack.
FPp.needsParens = function(assumeExpressionContext) {
  var parent = this.getParentNode();
  if (!parent) {
    return false;
  }

  var name = this.getName();
  var node = this.getNode();

  // If the value of this path is some child of a Node and not a Node
  // itself, then it doesn't need parentheses. Only Node objects (in
  // fact, only Expression nodes) need parentheses.
  if (this.getValue() !== node) {
    return false;
  }

  // Only statements don't need parentheses.
  if (n$2.Statement.check(node)) {
    return false;
  }

  // Identifiers never need parentheses.
  if (node.type === "Identifier") {
    return false;
  }

  if (parent.type === "ParenthesizedExpression") {
    return false;
  }

  // Add parens around the extends clause of a class. It is needed for almost
  // all expressions.
  if (
    (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") &&
    parent.superClass === node &&
    (node.type === "ArrowFunctionExpression" ||
      node.type === "AssignmentExpression" ||
      node.type === "AwaitExpression" ||
      node.type === "BinaryExpression" ||
      node.type === "ConditionalExpression" ||
      node.type === "LogicalExpression" ||
      node.type === "NewExpression" ||
      node.type === "ObjectExpression" ||
      node.type === "ParenthesizedExpression" ||
      node.type === "SequenceExpression" ||
      node.type === "TaggedTemplateExpression" ||
      node.type === "UnaryExpression" ||
      node.type === "UpdateExpression" ||
      node.type === "YieldExpression")
  ) {
    return true;
  }

  // The left-hand side of the ** exponentiation operator must always
  // be parenthesized unless it's an ident or literal
  if (
    parent.type === "BinaryExpression" &&
    parent.operator === "**" &&
    parent.left === node &&
    node.type !== "Identifier" &&
    node.type !== "Literal" &&
    node.type !== "NumericLiteral"
  ) {
    return true;
  }

  switch (node.type) {
    case "SpreadElement":
    case "SpreadProperty":
      return parent.type === "MemberExpression" &&
        name === "object" &&
        parent.object === node;

    case "UpdateExpression":
      switch (parent.type) {
        case "MemberExpression":
          return name === "object" && parent.object === node;

        case "TaggedTemplateExpression":
        case "CallExpression":
        case "NewExpression":
          return true;

        case "UnaryExpression":
          if (
            node.prefix &&
            (node.operator === "++" && parent.operator === "+" ||
              node.operator === "--" && parent.operator === "-")
          ) {
            return true;
          }

          return false;
      }

    case "UnaryExpression":
      switch (parent.type) {
        case "UnaryExpression":
          return node.operator === parent.operator &&
            (node.operator === "+" || node.operator === "-");

        case "MemberExpression":
          return name === "object" && parent.object === node;
      }

    case "BinaryExpression":
      if (
        node.operator === "in" &&
        parent.type === "ForStatement" &&
        parent.init === node
      ) {
        return true;
      }

      if (node.operator === "in" && parent.type === "AssignmentExpression") {
        return true;
      }

    case "LogicalExpression":
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          return name === "callee" && parent.callee === node;

        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
          return true;

        case "MemberExpression":
          return name === "object" && parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
          var po = parent.operator;
          var pp = util$7.getPrecedence(po);
          var no = node.operator;
          var np = util$7.getPrecedence(no);

          if (pp > np) {
            return true;
          }

          if (pp === np && name === "right") {
            assert$5.strictEqual(parent.right, node);
            return true;
          }

        default:
          return false;
      }

    case "SequenceExpression":
      switch (parent.type) {
        case "ReturnStatement":
          return false;

        case "ForStatement":
          // Although parentheses wouldn't hurt around sequence
          // expressions in the head of for loops, traditional style
          // dictates that e.g. i++, j++ should not be wrapped with
          // parentheses.
          return false;

        case "ExpressionStatement":
          return name !== "expression";

        default:
          // Otherwise err on the side of overparenthesization, adding
          // explicit exceptions above if this proves overzealous.
          return true;
      }

    case "YieldExpression":
    case "AwaitExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "BinaryExpression":
        case "LogicalExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "NewExpression":
        case "MemberExpression":
          return true;

        case "CallExpression":
          return parent.callee === node;

        case "ConditionalExpression":
          return parent.test === node;

        default:
          return false;
      }

    case "ArrayTypeAnnotation":
      return parent.type === "NullableTypeAnnotation";

    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return parent.type === "NullableTypeAnnotation" ||
        parent.type === "IntersectionTypeAnnotation" ||
        parent.type === "UnionTypeAnnotation";

    case "NullableTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation";

    case "FunctionTypeAnnotation":
      return parent.type === "UnionTypeAnnotation" ||
        parent.type === "IntersectionTypeAnnotation";

    case "NumericLiteral":
    case "Literal":
      return parent.type === "MemberExpression" &&
        isNumber$1.check(node.value) &&
        name === "object" &&
        parent.object === node;

    case "AssignmentExpression":
      if (
        parent.type === "ArrowFunctionExpression" &&
        parent.body === node &&
        node.left.type === "ObjectPattern"
      ) {
        return true;
      }

    case "ConditionalExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
        case "LogicalExpression":
        case "NewExpression":
        case "ExportDefaultDeclaration":
          return true;

        case "CallExpression":
          return name === "callee" && parent.callee === node;

        case "ConditionalExpression":
          return name === "test" && parent.test === node;

        case "MemberExpression":
          return name === "object" && parent.object === node;

        default:
          return n$2.ObjectPattern.check(node.left) && this.firstInStatement();
      }

    case "FunctionExpression":
    case "ArrowFunctionExpression":
      if (parent.type === "CallExpression" && name === "callee") {
        return true;
      }

      switch (parent.type) {
        case "ConditionalExpression":
          if (parent.test === node) {
            return true;
          }

        case "ExportDefaultDeclaration":
          return node.type !== "ArrowFunctionExpression";

        case "ExpressionStatement":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
          return true;

        case "NewExpression":
          return name === "callee";

        case "LogicalExpression":
          return node.type === "ArrowFunctionExpression";

        default:
          return isBinary(parent);
      }

    case "ClassExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "BinaryExpression":
        case "ExportDefaultDeclaration":
        case "ExpressionStatement":
          return true;
        case "CallExpression":
          if (parent.callee === node) {
            return true;
          }
        case "MemberExpression":
          return name === "object" && parent.object === node;
        case "ConditionalExpression":
          if (parent.test === node) {
            return true;
          }
      }

      return false;

    case "ObjectExpression":
      if (parent.type === "ArrowFunctionExpression" && name === "body") {
        return true;
      }
      if (parent.type === "TaggedTemplateExpression") {
        return true;
      }
      if (parent.type === "MemberExpression") {
        return name === "object" && parent.object === node;
      }

    case "StringLiteral":
      if (parent.type === "ExpressionStatement") {
        return true;
      }

    default:
      if (
        parent.type === "NewExpression" &&
        name === "callee" &&
        parent.callee === node
      ) {
        return containsCallExpression(node);
      }
  }

  if (
    assumeExpressionContext !== true &&
    !this.canBeFirstInStatement() &&
    this.firstInStatement()
  )
    return true;

  return false;
};

function isBinary(node) {
  return n$2.BinaryExpression.check(node) || n$2.LogicalExpression.check(node);
}

function containsCallExpression(node) {
  if (n$2.CallExpression.check(node)) {
    return true;
  }

  if (isArray$2.check(node)) {
    return node.some(containsCallExpression);
  }

  if (n$2.Node.check(node)) {
    return types$5.someField(node, function(name, child) {
      return containsCallExpression(child);
    });
  }

  return false;
}

FPp.canBeFirstInStatement = function() {
  var node = this.getNode();
  return !n$2.FunctionExpression.check(node) &&
    !n$2.ObjectExpression.check(node) &&
    !n$2.ClassExpression.check(node) &&
    !(n$2.AssignmentExpression.check(node) && n$2.ObjectPattern.check(node.left));
};

FPp.firstInStatement = function() {
  var s = this.stack;
  var parentName, parent;
  var childName, child;

  for (var i = s.length - 1; i >= 0; i -= 2) {
    if (n$2.Node.check(s[i])) {
      childName = parentName;
      child = parent;
      parentName = s[i - 1];
      parent = s[i];
    }

    if (!parent || !child) {
      continue;
    }

    if (
      n$2.BlockStatement.check(parent) && parentName === "body" && childName === 0
    ) {
      assert$5.strictEqual(parent.body[0], child);
      return true;
    }

    if (n$2.ExpressionStatement.check(parent) && childName === "expression") {
      assert$5.strictEqual(parent.expression, child);
      return true;
    }

    if (
      n$2.SequenceExpression.check(parent) &&
      parentName === "expressions" &&
      childName === 0
    ) {
      assert$5.strictEqual(parent.expressions[0], child);
      continue;
    }

    if (n$2.CallExpression.check(parent) && childName === "callee") {
      assert$5.strictEqual(parent.callee, child);
      continue;
    }

    if (n$2.MemberExpression.check(parent) && childName === "object") {
      assert$5.strictEqual(parent.object, child);
      continue;
    }

    if (n$2.ConditionalExpression.check(parent) && childName === "test") {
      assert$5.strictEqual(parent.test, child);
      continue;
    }

    if (isBinary(parent) && childName === "left") {
      assert$5.strictEqual(parent.left, child);
      continue;
    }

    if (
      n$2.UnaryExpression.check(parent) &&
      !parent.prefix &&
      childName === "argument"
    ) {
      assert$5.strictEqual(parent.argument, child);
      continue;
    }

    return false;
  }

  return true;
};

var fastPath = FastPath$1;

var assert$4 = require$$0$1;
var comments$3 = comments$1;
var FastPath = fastPath;
var util$6 = util$4;
var isIdentifierName = utils.keyword.isIdentifierNameES6;

var docBuilders$3 = docBuilders$1;
var concat$2 = docBuilders$3.concat;
var join$2 = docBuilders$3.join;
var line$1 = docBuilders$3.line;
var hardline$2 = docBuilders$3.hardline;
var softline$1 = docBuilders$3.softline;
var literalline$1 = docBuilders$3.literalline;
var group$1 = docBuilders$3.group;
var indent$2 = docBuilders$3.indent;
var conditionalGroup$1 = docBuilders$3.conditionalGroup;
var ifBreak$1 = docBuilders$3.ifBreak;
var breakParent$2 = docBuilders$3.breakParent;

var docUtils$2 = docUtils;
var willBreak$2 = docUtils$2.willBreak;
var isLineNext$1 = docUtils$2.isLineNext;
var getFirstString$1 = docUtils$2.getFirstString;
var isEmpty$1 = docUtils$2.isEmpty;

var types$4 = main;
var namedTypes = types$4.namedTypes;
var isString = types$4.builtInTypes.string;
function genericPrint(path, options, printPath) {
  assert$4.ok(path instanceof FastPath);

  var node = path.getValue();
  var parts = [];
  var needsParens = false;
  var linesWithoutParens = genericPrintNoParens(path, options, printPath);

  if (!node || isEmpty$1(linesWithoutParens)) {
    return linesWithoutParens;
  }

  // Escape hatch
  if (
    node.comments &&
    node.comments.length > 0 &&
    node.comments[0].value.trim() === "prettier-ignore"
  ) {
    return options.originalText.slice(util$6.locStart(node), util$6.locEnd(node));
  }

  if (
    node.decorators &&
    node.decorators.length > 0 &&
    // If the parent node is an export declaration, it will be
    // responsible for printing node.decorators.
    !util$6.getParentExportDeclaration(path)
  ) {
    const separator = node.decorators.length === 1 &&
      node.decorators[0].expression.type === "Identifier"
      ? " "
      : hardline$2;
    path.each(
      function(decoratorPath) {
        parts.push(printPath(decoratorPath), separator);
      },
      "decorators"
    );
  } else if (
    util$6.isExportDeclaration(node) &&
    node.declaration &&
    node.declaration.decorators
  ) {
    // Export declarations are responsible for printing any decorators
    // that logically apply to node.declaration.
    path.each(
      function(decoratorPath) {
        parts.push(printPath(decoratorPath), line$1);
      },
      "declaration",
      "decorators"
    );
  } else {
    // Nodes with decorators can't have parentheses, so we can avoid
    // computing path.needsParens() except in this case.
    needsParens = path.needsParens();
  }

  if (needsParens) {
    parts.unshift("(");
  }

  parts.push(linesWithoutParens);

  if (needsParens) {
    parts.push(")");
  }

  return concat$2(parts);
}

function genericPrintNoParens(path, options, print) {
  var n = path.getValue();

  if (!n) {
    return "";
  }

  if (typeof n === "string") {
    return n;
  }

  // TODO: For some reason NumericLiteralTypeAnnotation is not
  // printable so this throws, but I think that's a bug in ast-types.
  // This assert isn't very useful though.
  // namedTypes.Printable.assert(n);
  var parts = [];
  switch (n.type) {
    case "File":
      return path.call(print, "program");
    case "Program":
      // Babel 6
      if (n.directives) {
        path.each(
          function(childPath) {
            parts.push(print(childPath), ";", hardline$2);
            if (
              util$6.isNextLineEmpty(options.originalText, childPath.getValue())
            ) {
              parts.push(hardline$2);
            }
          },
          "directives"
        );
      }

      parts.push(
        path.call(
          function(bodyPath) {
            return printStatementSequence(bodyPath, options, print);
          },
          "body"
        )
      );

      parts.push(
        comments$3.printDanglingComments(path, options, /* sameIndent */ true)
      );

      // Only force a trailing newline if there were any contents.
      if (n.body.length || n.comments) {
        parts.push(hardline$2);
      }

      return concat$2(parts);
    // Babel extension.
    case "Noop":
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return concat$2([path.call(print, "expression"), ";"]); // Babel extension.
    case "ParenthesizedExpression":
      return concat$2(["(", path.call(print, "expression"), ")"]);
    case "AssignmentExpression":
      return group$1(
        concat$2([
          path.call(print, "left"),
          " ",
          n.operator,
          " ",
          path.call(print, "right")
        ])
      );
    case "BinaryExpression":
    case "LogicalExpression": {
      const parts = [];
      printBinaryishExpressions(path, parts, print, options);
      const parent = path.getParentNode();

      // Avoid indenting sub-expressions in if/etc statements.
      if (
        shouldInlineLogicalExpression(n) ||
        n !== parent.body &&
        (parent.type === "IfStatement" ||
          parent.type === "WhileStatement" ||
          parent.type === "DoStatement" ||
          parent.type === "ForStatement") ||
        n === parent.body && parent.type === "ArrowFunctionExpression"
      ) {
        return group$1(concat$2(parts));
      }

      const rest = concat$2(parts.slice(1));

      return group$1(
        concat$2([
          // Don't include the initial expression in the indentation
          // level. The first item is guaranteed to be the first
          // left-most expression.
          parts.length > 0 ? parts[0] : "",
          indent$2(options.tabWidth, rest)
        ])
      );
    }
    case "AssignmentPattern":
      return concat$2([
        path.call(print, "left"),
        " = ",
        path.call(print, "right")
      ]);
    case "MemberExpression": {
      return concat$2([
        path.call(print, "object"),
        printMemberLookup(path, options, print)
      ]);
    }
    case "MetaProperty":
      return concat$2([
        path.call(print, "meta"),
        ".",
        path.call(print, "property")
      ]);
    case "BindExpression":
      if (n.object) {
        parts.push(path.call(print, "object"));
      }

      parts.push("::", path.call(print, "callee"));

      return concat$2(parts);
    case "Path":
      return join$2(".", n.body);
    case "Identifier":
      return concat$2([
        n.name,
        n.optional ? "?" : "",
        path.call(print, "typeAnnotation")
      ]);
    case "SpreadElement":
    case "SpreadElementPattern":
    // Babel 6 for ObjectPattern
    case "RestProperty":
    case "SpreadProperty":
    case "SpreadPropertyPattern":
    case "RestElement":
      return concat$2([
        "...",
        path.call(print, "argument"),
        path.call(print, "typeAnnotation")
      ]);
    case "FunctionDeclaration":
    case "FunctionExpression":
      if (n.async) parts.push("async ");

      parts.push("function");

      if (n.generator) parts.push("*");

      if (n.id) {
        parts.push(" ", path.call(print, "id"));
      }

      parts.push(
        path.call(print, "typeParameters"),
        group$1(
          concat$2([
            printFunctionParams(path, print, options),
            printReturnType(path, print)
          ])
        ),
        " ",
        path.call(print, "body")
      );

      return concat$2(parts);
    case "ArrowFunctionExpression":
      if (n.async) parts.push("async ");

      if (n.typeParameters) {
        parts.push(path.call(print, "typeParameters"));
      }

      if (
        n.params.length === 1 &&
        !n.rest &&
        n.params[0].type === "Identifier" &&
        !n.params[0].typeAnnotation &&
        !n.params[0].leadingComments &&
        !n.params[0].trailingComments &&
        !n.predicate &&
        !n.returnType
      ) {
        parts.push(path.call(print, "params", 0));
      } else {
        parts.push(
          group$1(
            concat$2([
              printFunctionParams(path, print, options),
              printReturnType(path, print)
            ])
          )
        );
      }

      parts.push(" =>");

      const body = path.call(print, "body");
      const collapsed = concat$2([concat$2(parts), " ", body]);

      // We want to always keep these types of nodes on the same line
      // as the arrow.
      if (
        n.body.type === "ArrayExpression" ||
        n.body.type === "ObjectExpression" ||
        n.body.type === "JSXElement" ||
        n.body.type === "BlockStatement"
      ) {
        return group$1(collapsed);
      }

      // These nested groups are a little wonky, but because
      // `conditionalGroup` suppresses break propagation, we want to
      // re-propagate it. We still want to allow the printer to choose
      // the more collapsed version, but still break parents if there
      // are any hard breaks in the content.
      return group$1(
        conditionalGroup$1([
          collapsed,
          concat$2([
            concat$2(parts),
            indent$2(options.tabWidth, concat$2([line$1, body]))
          ])
        ]),
        { shouldBreak: willBreak$2(body) }
      );
    case "MethodDefinition":
      if (n.static) {
        parts.push("static ");
      }

      parts.push(printMethod(path, options, print));

      return concat$2(parts);
    case "YieldExpression":
      parts.push("yield");

      if (n.delegate) parts.push("*");

      if (n.argument) parts.push(" ", path.call(print, "argument"));

      return concat$2(parts);
    case "AwaitExpression":
      parts.push("await");

      if (n.all) parts.push("*");

      if (n.argument) parts.push(" ", path.call(print, "argument"));

      return concat$2(parts);
    case "ModuleDeclaration":
      parts.push("module", path.call(print, "id"));

      if (n.source) {
        assert$4.ok(!n.body);

        parts.push("from", path.call(print, "source"));
      } else {
        parts.push(path.call(print, "body"));
      }

      return join$2(" ", parts);
    case "ImportSpecifier":
      if (n.imported) {
        if (n.importKind) {
          parts.push(path.call(print, "importKind"), " ");
        }

        parts.push(path.call(print, "imported"));

        if (n.local && n.local.name !== n.imported.name) {
          parts.push(" as ", path.call(print, "local"));
        }
      } else if (n.id) {
        parts.push(path.call(print, "id"));

        if (n.name) {
          parts.push(" as ", path.call(print, "name"));
        }
      }

      return concat$2(parts);
    case "ExportSpecifier":
      if (n.local) {
        parts.push(path.call(print, "local"));

        if (n.exported && n.exported.name !== n.local.name) {
          parts.push(" as ", path.call(print, "exported"));
        }
      } else if (n.id) {
        parts.push(path.call(print, "id"));

        if (n.name) {
          parts.push(" as ", path.call(print, "name"));
        }
      }

      return concat$2(parts);
    case "ExportBatchSpecifier":
      return "*";
    case "ImportNamespaceSpecifier":
      parts.push("* as ");

      if (n.local) {
        parts.push(path.call(print, "local"));
      } else if (n.id) {
        parts.push(path.call(print, "id"));
      }

      return concat$2(parts);
    case "ImportDefaultSpecifier":
      if (n.local) {
        return path.call(print, "local");
      }

      return path.call(print, "id");
    case "ExportDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      return printExportDeclaration(path, options, print);
    case "ExportAllDeclaration":
      parts.push("export *");

      if (n.exported) {
        parts.push(" as ", path.call(print, "exported"));
      }

      parts.push(" from ", path.call(print, "source"), ";");

      return concat$2(parts);
    case "ExportNamespaceSpecifier":
      return concat$2(["* as ", path.call(print, "exported")]);
    case "ExportDefaultSpecifier":
      return path.call(print, "exported");
    case "ImportDeclaration":
      parts.push("import ");

      const fromParts = [];

      if (n.importKind && n.importKind !== "value") {
        parts.push(n.importKind + " ");
      }

      var standalones = [];
      var grouped = [];
      if (n.specifiers && n.specifiers.length > 0) {
        path.each(
          function(specifierPath) {
            var value = specifierPath.getValue();
            if (
              namedTypes.ImportDefaultSpecifier.check(value) ||
              namedTypes.ImportNamespaceSpecifier.check(value)
            ) {
              standalones.push(print(specifierPath));
            } else {
              grouped.push(print(specifierPath));
            }
          },
          "specifiers"
        );

        if (standalones.length > 0) {
          parts.push(join$2(", ", standalones));
        }

        if (standalones.length > 0 && grouped.length > 0) {
          parts.push(", ");
        }

        if (grouped.length > 0) {
          parts.push(
            group$1(
              concat$2([
                "{",
                indent$2(
                  options.tabWidth,
                  concat$2([
                    options.bracketSpacing ? line$1 : softline$1,
                    join$2(concat$2([",", line$1]), grouped)
                  ])
                ),
                ifBreak$1(options.trailingComma ? "," : ""),
                options.bracketSpacing ? line$1 : softline$1,
                "}"
              ])
            )
          );
        }

        fromParts.push(grouped.length === 0 ? line$1 : " ", "from ");
      }

      fromParts.push(path.call(print, "source"), ";");

      // If there's a very long import, break the following way:
      //
      //   import veryLong
      //     from 'verylong'
      //
      // In case there are grouped elements, they will already break the way
      // we want and this break would take precedence instead.
      if (grouped.length === 0) {
        return group$1(
          concat$2([concat$2(parts), indent$2(options.tabWidth, concat$2(fromParts))])
        );
      }

      return concat$2([concat$2(parts), concat$2(fromParts)]);

    case "Import": {
      return "import";
    }
    case "BlockStatement": {
      var naked = path.call(
        function(bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        },
        "body"
      );

      const hasContent = getFirstString$1(naked);
      const hasDirectives = n.directives && n.directives.length > 0;

      var parent = path.getParentNode();
      if (
        !hasContent &&
        !hasDirectives &&
        !n.comments &&
        (parent.type === "ArrowFunctionExpression" ||
          parent.type === "FunctionExpression" ||
          parent.type === "FunctionDeclaration" ||
          parent.type === "ObjectMethod" ||
          parent.type === "ClassMethod")
      ) {
        return "{}";
      }

      parts.push("{");

      // Babel 6
      if (hasDirectives) {
        path.each(
          function(childPath) {
            parts.push(
              indent$2(
                options.tabWidth,
                concat$2([hardline$2, print(childPath), ";"])
              )
            );
          },
          "directives"
        );
      }

      if (hasContent) {
        parts.push(indent$2(options.tabWidth, concat$2([hardline$2, naked])));
      }

      parts.push(comments$3.printDanglingComments(path, options));
      parts.push(hardline$2, "}");

      return concat$2(parts);
    }
    case "ReturnStatement":
      parts.push("return");

      if (
        n.argument &&
        n.argument.comments &&
        n.argument.comments.some(comment => comment.leading)
      ) {
        parts.push(
          concat$2([
            " (",
            indent$2(
              options.tabWidth,
              concat$2([softline$1, path.call(print, "argument")])
            ),
            line$1,
            ")"
          ])
        );
      } else if (n.argument) {
        parts.push(" ", path.call(print, "argument"));
      }

      parts.push(";");

      return concat$2(parts);
    case "CallExpression": {
      const parent = path.getParentNode();
      // We detect calls on member lookups and possibly print them in a
      // special chain format. See `printMemberChain` for more info.
      if (n.callee.type === "MemberExpression") {
        return printMemberChain(path, options, print);
      }

      return concat$2([
        path.call(print, "callee"),
        printArgumentsList(path, options, print)
      ]);
    }

    case "ObjectExpression":
    case "ObjectPattern":
    case "ObjectTypeAnnotation":
      var allowBreak = false;
      var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
      // Leave this here because we *might* want to make this
      // configurable later -- flow accepts ";" for type separators
      var separator = isTypeAnnotation ? "," : ",";
      var fields = [];
      var leftBrace = n.exact ? "{|" : "{";
      var rightBrace = n.exact ? "|}" : "}";
      var parent = path.getParentNode(0);
      var parentIsUnionTypeAnnotation = parent.type === "UnionTypeAnnotation";

      if (isTypeAnnotation) {
        fields.push("indexers", "callProperties");
      }

      fields.push("properties");

      var props = [];
      let separatorParts = [];

      fields.forEach(function(field) {
        path.each(
          function(childPath) {
            props.push(concat$2(separatorParts));
            props.push(group$1(print(childPath)));

            separatorParts = [separator, line$1];
            if (
              util$6.isNextLineEmpty(options.originalText, childPath.getValue())
            ) {
              separatorParts.push(hardline$2);
            }
          },
          field
        );
      });

      const lastElem = util$6.getLast(n.properties);
      const canHaveTrailingComma = !(lastElem &&
        lastElem.type === "RestProperty");

      const shouldBreak = util$6.hasNewlineInRange(
        options.originalText,
        util$6.locStart(n),
        util$6.locEnd(n)
      );

      if (props.length === 0) {
        return group$1(
          concat$2([
            "{",
            comments$3.printDanglingComments(path, options),
            softline$1,
            "}"
          ])
        );
      } else {
        return group$1(
          concat$2([
            leftBrace,
            indent$2(
              options.tabWidth + (parentIsUnionTypeAnnotation ? 2 : 0),
              concat$2([options.bracketSpacing ? line$1 : softline$1, concat$2(props)])
            ),
            ifBreak$1(canHaveTrailingComma && options.trailingComma ? "," : ""),
            indent$2(
              parentIsUnionTypeAnnotation ? 2 : 0,
              concat$2([options.bracketSpacing ? line$1 : softline$1, rightBrace])
            ),
            path.call(print, "typeAnnotation")
          ]),
          { shouldBreak }
        );
      }

    case "PropertyPattern":
      return concat$2([
        path.call(print, "key"),
        ": ",
        path.call(print, "pattern")
      ]);
    // Babel 6
    case "ObjectProperty": // Non-standard AST node type.
    case "Property":
      if (n.method || n.kind === "get" || n.kind === "set") {
        return printMethod(path, options, print);
      }

      if (n.shorthand) {
        parts.push(path.call(print, "value"));
      } else {
        if (n.computed) {
          parts.push("[", path.call(print, "key"), "]");
        } else {
          parts.push(printPropertyKey(path, options, print));
        }
        parts.push(concat$2([": ", path.call(print, "value")]));
      }

      return concat$2(parts); // Babel 6
    case "ClassMethod":
      if (n.static) {
        parts.push("static ");
      }

      parts = parts.concat(printObjectMethod(path, options, print));

      return concat$2(parts); // Babel 6
    case "ObjectMethod":
      return printObjectMethod(path, options, print);
    case "Decorator":
      return concat$2(["@", path.call(print, "expression")]);
    case "ArrayExpression":
    case "ArrayPattern":
      if (n.elements.length === 0) {
        parts.push(
          group$1(
            concat$2([
              "[",
              comments$3.printDanglingComments(path, options),
              softline$1,
              "]"
            ])
          )
        );
      } else {
        const lastElem = util$6.getLast(n.elements);
        const canHaveTrailingComma = !(lastElem &&
          lastElem.type === "RestElement");

        // JavaScript allows you to have empty elements in an array which
        // changes its length based on the number of commas. The algorithm
        // is that if the last argument is null, we need to force insert
        // a comma to ensure JavaScript recognizes it.
        //   [,].length === 1
        //   [1,].length === 1
        //   [1,,].length === 2
        //
        // Note that util.getLast returns null if the array is empty, but
        // we already check for an empty array just above so we are safe
        const needsForcedTrailingComma = canHaveTrailingComma &&
          lastElem === null;

        var printedElements = [];
        let separatorParts = [];
        path.each(
          function(childPath) {
            printedElements.push(concat$2(separatorParts));
            printedElements.push(group$1(print(childPath)));

            separatorParts = [",", line$1];
            if (
              childPath.getValue() &&
              util$6.isNextLineEmpty(options.originalText, childPath.getValue())
            ) {
              separatorParts.push(softline$1);
            }
          },
          "elements"
        );

        parts.push(
          group$1(
            concat$2([
              "[",
              indent$2(
                options.tabWidth,
                concat$2([softline$1, concat$2(printedElements)])
              ),
              needsForcedTrailingComma ? "," : "",
              ifBreak$1(
                canHaveTrailingComma &&
                  !needsForcedTrailingComma &&
                  options.trailingComma
                  ? ","
                  : ""
              ),
              softline$1,
              "]"
            ])
          )
        );
      }

      if (n.typeAnnotation) parts.push(path.call(print, "typeAnnotation"));

      return concat$2(parts);
    case "SequenceExpression":
      return join$2(", ", path.map(print, "expressions"));
    case "ThisExpression":
      return "this";
    case "Super":
      return "super"; // Babel 6 Literal split
    case "NullLiteral":
      return "null"; // Babel 6 Literal split
    case "RegExpLiteral":
      return n.extra.raw;
    // Babel 6 Literal split
    case "NumericLiteral":
      return printNumber(n.extra.raw);
    // Babel 6 Literal split
    case "BooleanLiteral":
    // Babel 6 Literal split
    case "StringLiteral":
    case "Literal":
      if (typeof n.value === "number") return printNumber(n.raw);
      if (typeof n.value !== "string") return "" + n.value;

      return nodeStr(n, options); // Babel 6
    case "Directive":
      return path.call(print, "value"); // Babel 6
    case "DirectiveLiteral":
      return nodeStr(n, options);
    case "ModuleSpecifier":
      if (n.local) {
        throw new Error("The ESTree ModuleSpecifier type should be abstract");
      }

      // The Esprima ModuleSpecifier type is just a string-valued
      // Literal identifying the imported-from module.
      return nodeStr(n, options);
    case "UnaryExpression":
      parts.push(n.operator);

      if (/[a-z]$/.test(n.operator)) parts.push(" ");

      parts.push(path.call(print, "argument"));

      return concat$2(parts);
    case "UpdateExpression":
      parts.push(path.call(print, "argument"), n.operator);

      if (n.prefix) parts.reverse();

      return concat$2(parts);
    case "ConditionalExpression":
      return group$1(
        concat$2([
          path.call(print, "test"),
          indent$2(
            options.tabWidth,
            concat$2([
              line$1,
              "? ",
              indent$2(2, path.call(print, "consequent")),
              line$1,
              ": ",
              indent$2(2, path.call(print, "alternate"))
            ])
          )
        ])
      );
    case "NewExpression":
      parts.push("new ", path.call(print, "callee"));

      var args = n.arguments;

      if (args) {
        parts.push(printArgumentsList(path, options, print));
      }

      return concat$2(parts);
    case "VariableDeclaration":
      var printed = path.map(
        function(childPath) {
          return print(childPath);
        },
        "declarations"
      );

      parts = [
        n.kind,
        " ",
        printed[0],
        indent$2(
          options.tabWidth,
          concat$2(printed.slice(1).map(p => concat$2([",", line$1, p])))
        )
      ];

      // We generally want to terminate all variable declarations with a
      // semicolon, except when they in the () part of for loops.
      var parentNode = path.getParentNode();

      var isParentForLoop = namedTypes.ForStatement.check(parentNode) ||
        namedTypes.ForInStatement.check(parentNode) ||
        namedTypes.ForOfStatement &&
          namedTypes.ForOfStatement.check(parentNode) ||
        namedTypes.ForAwaitStatement &&
          namedTypes.ForAwaitStatement.check(parentNode);

      if (!(isParentForLoop && parentNode.body !== n)) {
        parts.push(";");
      }

      return group$1(concat$2(parts));
    case "VariableDeclarator":
      return n.init
        ? concat$2([path.call(print, "id"), " = ", path.call(print, "init")])
        : path.call(print, "id");
    case "WithStatement":
      return concat$2([
        "with (",
        path.call(print, "object"),
        ")",
        adjustClause(path.call(print, "body"), options)
      ]);
    case "IfStatement":
      const con = adjustClause(path.call(print, "consequent"), options);

      parts = [
        "if (",
        group$1(
          concat$2([
            indent$2(
              options.tabWidth,
              concat$2([softline$1, path.call(print, "test")])
            ),
            softline$1
          ])
        ),
        ")",
        con
      ];

      if (n.alternate) {
        const hasBraces = isCurlyBracket(con);
        const isEmpty = isEmptyBlock(con);

        if (hasBraces && !isEmpty) {
          parts.push(" else");
        } else {
          // We use `conditionalGroup` to suppress break propagation.
          // This allows us to provide a hardline without forcing the
          // entire `if` clause to break up.
          parts.push(conditionalGroup$1([concat$2([hardline$2, "else"])]));
        }

        parts.push(
          adjustClause(
            path.call(print, "alternate"),
            options,
            n.alternate.type === "IfStatement"
          )
        );
      }

      return group$1(concat$2(parts));
    case "ForStatement": {
      const body = adjustClause(path.call(print, "body"), options);

      if (!n.init && !n.test && !n.update) {
        return concat$2(["for (;;)", body]);
      }

      return concat$2([
        "for (",
        group$1(
          concat$2([
            indent$2(
              options.tabWidth,
              concat$2([
                softline$1,
                path.call(print, "init"),
                ";",
                line$1,
                path.call(print, "test"),
                ";",
                line$1,
                path.call(print, "update")
              ])
            ),
            softline$1
          ])
        ),
        ")",
        body
      ]);
    }
    case "WhileStatement":
      return concat$2([
        "while (",
        group$1(
          concat$2([
            indent$2(
              options.tabWidth,
              concat$2([softline$1, path.call(print, "test")])
            ),
            softline$1
          ])
        ),
        ")",
        adjustClause(path.call(print, "body"), options)
      ]);
    case "ForInStatement":
      // Note: esprima can't actually parse "for each (".
      return concat$2([
        n.each ? "for each (" : "for (",
        path.call(print, "left"),
        " in ",
        path.call(print, "right"),
        ")",
        adjustClause(path.call(print, "body"), options)
      ]);
    case "ForOfStatement":
      return concat$2([
        "for (",
        path.call(print, "left"),
        " of ",
        path.call(print, "right"),
        ")",
        adjustClause(path.call(print, "body"), options)
      ]);
    case "ForAwaitStatement":
      return concat$2([
        "for await (",
        path.call(print, "left"),
        " of ",
        path.call(print, "right"),
        ")",
        adjustClause(path.call(print, "body"), options)
      ]);
    case "DoWhileStatement":
      var clause = adjustClause(path.call(print, "body"), options);
      var doBody = concat$2(["do", clause]);
      var parts = [doBody];
      const hasBraces = isCurlyBracket(clause);

      if (hasBraces) parts.push(" while");
      else parts.push(concat$2([line$1, "while"]));

      parts.push(" (", path.call(print, "test"), ");");

      return concat$2(parts);
    case "DoExpression":
      var statements = path.call(
        function(bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        },
        "body"
      );
      return concat$2(["do {\n", statements.indent(options.tabWidth), "\n}"]);
    case "BreakStatement":
      parts.push("break");

      if (n.label) parts.push(" ", path.call(print, "label"));

      parts.push(";");

      return concat$2(parts);
    case "ContinueStatement":
      parts.push("continue");

      if (n.label) parts.push(" ", path.call(print, "label"));

      parts.push(";");

      return concat$2(parts);
    case "LabeledStatement":
      if (n.body.type === "EmptyStatement") {
        return concat$2([path.call(print, "label"), ":;"]);
      }

      return concat$2([
        path.call(print, "label"),
        ":",
        hardline$2,
        path.call(print, "body")
      ]);
    case "TryStatement":
      parts.push("try ", path.call(print, "block"));

      if (n.handler) {
        parts.push(" ", path.call(print, "handler"));
      } else if (n.handlers) {
        path.each(
          function(handlerPath) {
            parts.push(" ", print(handlerPath));
          },
          "handlers"
        );
      }

      if (n.finalizer) {
        parts.push(" finally ", path.call(print, "finalizer"));
      }

      return concat$2(parts);
    case "CatchClause":
      parts.push("catch (", path.call(print, "param"));

      if (n.guard)
        // Note: esprima does not recognize conditional catch clauses.
        parts.push(" if ", path.call(print, "guard"));

      parts.push(") ", path.call(print, "body"));

      return concat$2(parts);
    case "ThrowStatement":
      return concat$2(["throw ", path.call(print, "argument"), ";"]);
    // Note: ignoring n.lexical because it has no printing consequences.
    case "SwitchStatement":
      return concat$2([
        "switch (",
        path.call(print, "discriminant"),
        ") {",
        n.cases.length > 0
          ? indent$2(
              options.tabWidth,
              concat$2([hardline$2, join$2(hardline$2, path.map(print, "cases"))])
            )
          : "",
        hardline$2,
        "}"
      ]);
    case "SwitchCase":
      if (n.test) parts.push("case ", path.call(print, "test"), ":");
      else parts.push("default:");

      if (n.consequent.find(node => node.type !== "EmptyStatement")) {
        const cons = path.call(
          function(consequentPath) {
            return printStatementSequence(consequentPath, options, print);
          },
          "consequent"
        );

        parts.push(
          isCurlyBracket(cons)
            ? concat$2([" ", cons])
            : indent$2(options.tabWidth, concat$2([hardline$2, cons]))
        );
      }

      return concat$2(parts);
    // JSX extensions below.
    case "DebuggerStatement":
      return "debugger;";
    case "JSXAttribute":
      parts.push(path.call(print, "name"));

      if (n.value) {
        let res;
        if (
          (n.value.type === "StringLiteral" || n.value.type === "Literal") &&
          typeof n.value.value === "string"
        ) {
          res = '"' + util$6.htmlEscapeInsideDoubleQuote(n.value.value) + '"';
        } else {
          res = path.call(print, "value");
        }
        parts.push("=", res);
      }

      return concat$2(parts);
    case "JSXIdentifier":
      return "" + n.name;
    case "JSXNamespacedName":
      return join$2(":", [
        path.call(print, "namespace"),
        path.call(print, "name")
      ]);
    case "JSXMemberExpression":
      return join$2(".", [
        path.call(print, "object"),
        path.call(print, "property")
      ]);
    case "JSXSpreadAttribute":
      return concat$2(["{...", path.call(print, "argument"), "}"]);
    case "JSXExpressionContainer": {
      const parent = path.getParentNode(0);

      const shouldInline = n.expression.type === "ArrayExpression" ||
        n.expression.type === "ObjectExpression" ||
        n.expression.type === "ArrowFunctionExpression" ||
        n.expression.type === "CallExpression" ||
        n.expression.type === "FunctionExpression" ||
        n.expression.type === "JSXEmptyExpression" ||
        parent.type === "JSXElement" &&
          (n.expression.type === "ConditionalExpression" ||
            n.expression.type === "LogicalExpression");

      if (shouldInline) {
        return group$1(concat$2(["{", path.call(print, "expression"), "}"]));
      }

      return group$1(
        concat$2([
          "{",
          indent$2(
            options.tabWidth,
            concat$2([softline$1, path.call(print, "expression")])
          ),
          softline$1,
          "}"
        ])
      );
    }
    case "JSXElement": {
      const elem = printJSXElement(path, options, print);
      return maybeWrapJSXElementInParens(path, elem, options);
    }
    case "JSXOpeningElement": {
      const n = path.getValue();

      // don't break up opening elements with a single long text attribute
      if (
        n.attributes.length === 1 &&
        n.attributes[0].value &&
        n.attributes[0].value.type === "Literal" &&
        typeof n.attributes[0].value.value === "string"
      ) {
        return group$1(
          concat$2([
            "<",
            path.call(print, "name"),
            " ",
            concat$2(path.map(print, "attributes")),
            n.selfClosing ? " />" : ">"
          ])
        );
      }

      return group$1(
        concat$2([
          "<",
          path.call(print, "name"),
          concat$2([
            indent$2(
              options.tabWidth,
              concat$2(
                path.map(attr => concat$2([line$1, print(attr)]), "attributes")
              )
            ),
            n.selfClosing ? line$1 : options.jsxBracketSameLine ? ">" : softline$1
          ]),
          n.selfClosing ? "/>" : options.jsxBracketSameLine ? "" : ">"
        ])
      );
    }
    case "JSXClosingElement":
      return concat$2(["</", path.call(print, "name"), ">"]);
    case "JSXText":
      throw new Error("JSXTest should be handled by JSXElement");
    case "JSXEmptyExpression":
      return concat$2([
        comments$3.printDanglingComments(path, options, /* sameIndent */ true),
        softline$1
      ]);
    case "TypeAnnotatedIdentifier":
      return concat$2([
        path.call(print, "annotation"),
        " ",
        path.call(print, "identifier")
      ]);
    case "ClassBody":
      if (!n.comments && n.body.length === 0) {
        return "{}";
      }

      return concat$2([
        "{",
        n.body.length > 0
          ? indent$2(
              options.tabWidth,
              concat$2([
                hardline$2,
                path.call(
                  function(bodyPath) {
                    return printStatementSequence(bodyPath, options, print);
                  },
                  "body"
                )
              ])
            )
          : comments$3.printDanglingComments(path, options),
        hardline$2,
        "}"
      ]);
    case "ClassPropertyDefinition":
      parts.push("static ", path.call(print, "definition"));

      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(";");

      return concat$2(parts);
    case "ClassProperty":
      if (n.static) parts.push("static ");

      var key;

      if (n.computed) {
        key = concat$2(["[", path.call(print, "key"), "]"]);
      } else {
        key = printPropertyKey(path, options, print);
        if (n.variance === "plus") {
          key = concat$2(["+", key]);
        } else if (n.variance === "minus") {
          key = concat$2(["-", key]);
        }
      }

      parts.push(key);

      if (n.typeAnnotation) parts.push(path.call(print, "typeAnnotation"));

      if (n.value) parts.push(" = ", path.call(print, "value"));

      parts.push(";");

      return concat$2(parts);
    case "ClassDeclaration":
    case "ClassExpression":
      return concat$2(printClass(path, options, print));
    case "TemplateElement":
      return join$2(literalline$1, n.value.raw.split("\n"));
    case "TemplateLiteral":
      var expressions = path.map(print, "expressions");

      parts.push("`");

      path.each(
        function(childPath) {
          var i = childPath.getName();

          parts.push(print(childPath));

          if (i < expressions.length) {
            parts.push("${", expressions[i], "}");
          }
        },
        "quasis"
      );

      parts.push("`");

      return concat$2(parts);
    // These types are unprintable because they serve as abstract
    // supertypes for other (printable) types.
    case "TaggedTemplateExpression":
      return concat$2([path.call(print, "tag"), path.call(print, "quasi")]);
    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    // Supertype of Block and Line.
    case "Comment":
    // Flow
    case "MemberTypeAnnotation": // Flow
    case "Type":
      throw new Error("unprintable type: " + JSON.stringify(n.type));

    // Type Annotations for Facebook Flow, typically stripped out or
    // transformed away before printing.
    case "TypeAnnotation":
      if (n.typeAnnotation) {
        if (n.typeAnnotation.type !== "FunctionTypeAnnotation") {
          parts.push(": ");
        }

        parts.push(path.call(print, "typeAnnotation"));

        return concat$2(parts);
      }

      return "";
    case "TupleTypeAnnotation":
      return concat$2(["[", join$2(", ", path.map(print, "types")), "]"]);
    case "ExistentialTypeParam":
    case "ExistsTypeAnnotation":
      return "*";
    case "EmptyTypeAnnotation":
      return "empty";
    case "AnyTypeAnnotation":
      return "any";
    case "MixedTypeAnnotation":
      return "mixed";
    case "ArrayTypeAnnotation":
      return concat$2([path.call(print, "elementType"), "[]"]);
    case "BooleanTypeAnnotation":
      return "boolean";
    case "NumericLiteralTypeAnnotation":
    case "BooleanLiteralTypeAnnotation":
      return "" + n.value;
    case "DeclareClass":
      return printFlowDeclaration(path, printClass(path, options, print));
    case "DeclareFunction":
      return printFlowDeclaration(path, [
        "function ",
        path.call(print, "id"),
        n.predicate ? " " : "",
        path.call(print, "predicate"),
        ";"
      ]);
    case "DeclareModule":
      return printFlowDeclaration(path, [
        "module ",
        path.call(print, "id"),
        " ",
        path.call(print, "body")
      ]);
    case "DeclareModuleExports":
      return printFlowDeclaration(path, [
        "module.exports",
        path.call(print, "typeAnnotation"),
        ";"
      ]);
    case "DeclareVariable":
      return printFlowDeclaration(path, ["var ", path.call(print, "id"), ";"]);
    case "DeclareExportAllDeclaration":
      return concat$2(["declare export * from ", path.call(print, "source")]);
    case "DeclareExportDeclaration":
      return concat$2(["declare ", printExportDeclaration(path, options, print)]);
    case "FunctionTypeAnnotation":
      // FunctionTypeAnnotation is ambiguous:
      // declare function foo(a: B): void; OR
      // var A: (a: B) => void;
      var parent = path.getParentNode(0);
      var isArrowFunctionTypeAnnotation = !(!parent.variance &&
        !parent.optional &&
        namedTypes.ObjectTypeProperty.check(parent) ||
        namedTypes.ObjectTypeCallProperty.check(parent) ||
        namedTypes.DeclareFunction.check(path.getParentNode(2)));

      var needsColon = isArrowFunctionTypeAnnotation &&
        namedTypes.TypeAnnotation.check(parent);

      if (isObjectTypePropertyAFunction(parent)) {
        isArrowFunctionTypeAnnotation = true;
        needsColon = true;
      }

      if (needsColon) {
        parts.push(": ");
      }

      parts.push(path.call(print, "typeParameters"));

      parts.push(group$1(printFunctionParams(path, print, options)));

      // The returnType is not wrapped in a TypeAnnotation, so the colon
      // needs to be added separately.
      if (n.returnType || n.predicate) {
        parts.push(
          isArrowFunctionTypeAnnotation ? " => " : ": ",
          path.call(print, "returnType"),
          path.call(print, "predicate")
        );
      }

      return concat$2(parts);
    case "FunctionTypeParam":
      return concat$2([
        path.call(print, "name"),
        n.optional ? "?" : "",
        n.name ? ": " : "",
        path.call(print, "typeAnnotation")
      ]);
    case "GenericTypeAnnotation":
      return concat$2([
        path.call(print, "id"),
        path.call(print, "typeParameters")
      ]);
    case "DeclareInterface":
    case "InterfaceDeclaration": {
      if (
        n.type === "DeclareInterface" ||
        isFlowNodeStartingWithDeclare(n, options)
      ) {
        parts.push("declare ");
      }

      parts.push(
        "interface ",
        path.call(print, "id"),
        path.call(print, "typeParameters"),
        " "
      );

      if (n["extends"].length > 0) {
        parts.push("extends ", join$2(", ", path.map(print, "extends")), " ");
      }

      parts.push(path.call(print, "body"));

      return concat$2(parts);
    }
    case "ClassImplements":
    case "InterfaceExtends":
      return concat$2([
        path.call(print, "id"),
        path.call(print, "typeParameters")
      ]);
    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation": {
      const types = path.map(print, "types");
      const op = n.type === "IntersectionTypeAnnotation" ? "&" : "|";

      // single-line variation
      // A | B | C

      // multi-line variation
      // | A
      // | B
      // | C
      return group$1(
        indent$2(
          options.tabWidth,
          concat$2([
            ifBreak$1(concat$2([line$1, op, " "])),
            join$2(concat$2([line$1, op, " "]), types)
          ])
        )
      );
    }
    case "NullableTypeAnnotation":
      return concat$2(["?", path.call(print, "typeAnnotation")]);
    case "NullLiteralTypeAnnotation":
      return "null";
    case "ThisTypeAnnotation":
      return "this";
    case "NumberTypeAnnotation":
      return "number";
    case "ObjectTypeCallProperty":
      if (n.static) {
        parts.push("static ");
      }

      parts.push(path.call(print, "value"));

      return concat$2(parts);
    case "ObjectTypeIndexer":
      var variance = n.variance === "plus"
        ? "+"
        : n.variance === "minus" ? "-" : "";
      return concat$2([
        variance,
        "[",
        path.call(print, "id"),
        n.id ? ": " : "",
        path.call(print, "key"),
        "]: ",
        path.call(print, "value")
      ]);
    case "ObjectTypeProperty":
      var variance = n.variance === "plus"
        ? "+"
        : n.variance === "minus" ? "-" : "";
      // TODO: This is a bad hack and we need a better way to know
      // when to emit an arrow function or not.
      var isFunction = !n.variance &&
        !n.optional &&
        n.value.type === "FunctionTypeAnnotation";

      if (isObjectTypePropertyAFunction(n)) {
        isFunction = true;
      }

      return concat$2([
        n.static ? "static " : "",
        variance,
        path.call(print, "key"),
        n.optional ? "?" : "",
        isFunction ? "" : ": ",
        path.call(print, "value")
      ]);
    case "QualifiedTypeIdentifier":
      return concat$2([
        path.call(print, "qualification"),
        ".",
        path.call(print, "id")
      ]);
    case "StringLiteralTypeAnnotation":
      return nodeStr(n, options);
    case "NumberLiteralTypeAnnotation":
      assert$4.strictEqual(typeof n.value, "number");

      return "" + n.value;
    case "StringTypeAnnotation":
      return "string";
    case "DeclareTypeAlias":
    case "TypeAlias": {
      if (
        n.type === "DeclareTypeAlias" ||
        isFlowNodeStartingWithDeclare(n, options)
      ) {
        parts.push("declare ");
      }

      parts.push(
        "type ",
        path.call(print, "id"),
        path.call(print, "typeParameters"),
        " = ",
        path.call(print, "right"),
        ";"
      );

      return concat$2(parts);
    }
    case "TypeCastExpression":
      return concat$2([
        "(",
        path.call(print, "expression"),
        path.call(print, "typeAnnotation"),
        ")"
      ]);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation":
      return concat$2(["<", join$2(", ", path.map(print, "params")), ">"]);
    case "TypeParameter":
      switch (n.variance) {
        case "plus":
          parts.push("+");

          break;
        case "minus":
          parts.push("-");

          break;
        default:
      }

      parts.push(path.call(print, "name"));

      if (n.bound) {
        parts.push(path.call(print, "bound"));
      }

      if (n["default"]) {
        parts.push("=", path.call(print, "default"));
      }

      return concat$2(parts);
    case "TypeofTypeAnnotation":
      return concat$2(["typeof ", path.call(print, "argument")]);
    case "VoidTypeAnnotation":
      return "void";
    case "NullTypeAnnotation":
      return "null";
    case "InferredPredicate":
      return "%checks";
    // Unhandled types below. If encountered, nodes of these types should
    // be either left alone or desugared into AST types that are fully
    // supported by the pretty-printer.
    case "DeclaredPredicate":
      return concat$2(["%checks(", path.call(print, "value"), ")"]);
    // TODO
    case "ClassHeritage":
    // TODO
    case "ComprehensionBlock":
    // TODO
    case "ComprehensionExpression":
    // TODO
    case "Glob":
    // TODO
    case "GeneratorExpression":
    // TODO
    case "LetStatement":
    // TODO
    case "LetExpression":
    // TODO
    case "GraphExpression":
    // TODO
    // XML types that nobody cares about or needs to print.
    case "GraphIndexExpression":
    case "XMLDefaultDeclaration":
    case "XMLAnyName":
    case "XMLQualifiedIdentifier":
    case "XMLFunctionQualifiedIdentifier":
    case "XMLAttributeSelector":
    case "XMLFilterExpression":
    case "XML":
    case "XMLElement":
    case "XMLList":
    case "XMLEscape":
    case "XMLText":
    case "XMLStartTag":
    case "XMLEndTag":
    case "XMLPointTag":
    case "XMLName":
    case "XMLAttribute":
    case "XMLCdata":
    case "XMLComment":
    case "XMLProcessingInstruction":
    default:
      debugger;
      throw new Error("unknown type: " + JSON.stringify(n.type));
  }
  return p;
}

function printStatementSequence(path, options, print) {
  let printed = [];

  path.map(function(stmtPath, i) {
    var stmt = stmtPath.getValue();

    // Just in case the AST has been modified to contain falsy
    // "statements," it's safer simply to skip them.
    if (!stmt) {
      return;
    }

    // Skip printing EmptyStatement nodes to avoid leaving stray
    // semicolons lying around.
    if (stmt.type === "EmptyStatement") {
      return;
    }

    const stmtPrinted = print(stmtPath);
    const text = options.originalText;
    const parts = [];

    parts.push(stmtPrinted);

    if (util$6.isNextLineEmpty(text, stmt) && !isLastStatement(stmtPath)) {
      parts.push(hardline$2);
    }

    printed.push(concat$2(parts));
  });

  return join$2(hardline$2, printed);
}

function printPropertyKey(path, options, print) {
  const node = path.getNode();
  const key = node.key;

  if (
    (key.type === "StringLiteral" ||
      key.type === "Literal" && typeof key.value === "string") &&
    isIdentifierName(key.value) &&
    !node.computed &&
    // There's a bug in the flow parser where it throws if there are
    // unquoted unicode literals as keys. Let's quote them for now.
    (options.parser !== "flow" || key.value.match(/[a-zA-Z0-9$_]/))
  ) {
    // 'a' -> a
    return key.value;
  }
  return path.call(print, "key");
}

function printMethod(path, options, print) {
  var node = path.getNode();
  var kind = node.kind;
  var parts = [];

  if (node.type === "ObjectMethod" || node.type === "ClassMethod") {
    node.value = node;
  } else {
    namedTypes.FunctionExpression.assert(node.value);
  }

  if (node.value.async) {
    parts.push("async ");
  }

  if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
    if (node.value.generator) {
      parts.push("*");
    }
  } else {
    assert$4.ok(kind === "get" || kind === "set");

    parts.push(kind, " ");
  }

  var key = printPropertyKey(path, options, print);

  if (node.computed) {
    key = concat$2(["[", key, "]"]);
  }

  parts.push(
    key,
    path.call(print, "value", "typeParameters"),
    group$1(
      concat$2([
        path.call(
          function(valuePath) {
            return printFunctionParams(valuePath, print, options);
          },
          "value"
        ),
        path.call(p => printReturnType(p, print), "value")
      ])
    ),
    " ",
    path.call(print, "value", "body")
  );

  return concat$2(parts);
}

function printArgumentsList(path, options, print) {
  var printed = path.map(print, "arguments");
  var args;

  if (printed.length === 0) {
    return "()";
  }

  const lastArg = util$6.getLast(path.getValue().arguments);
  // This is just an optimization; I think we could return the
  // conditional group for all function calls, but it's more expensive
  // so only do it for specific forms.
  const groupLastArg = (!lastArg.comments || !lastArg.comments.length) &&
    (lastArg.type === "ObjectExpression" ||
      lastArg.type === "ArrayExpression" ||
      lastArg.type === "FunctionExpression" ||
      lastArg.type === "ArrowFunctionExpression" &&
        (lastArg.body.type === "BlockStatement" ||
          lastArg.body.type === "ArrowFunctionExpression" ||
          lastArg.body.type === "ObjectExpression" ||
          lastArg.body.type === "ArrayExpression" ||
          lastArg.body.type === "CallExpression" ||
          lastArg.body.type === "JSXElement"));

  if (groupLastArg) {
    const shouldBreak = printed.slice(0, -1).some(willBreak$2);
    return concat$2([
      printed.some(willBreak$2) ? breakParent$2 : "",
      conditionalGroup$1(
        [
          concat$2(["(", join$2(concat$2([", "]), printed), ")"]),
          concat$2([
            "(",
            join$2(concat$2([",", line$1]), printed.slice(0, -1)),
            printed.length > 1 ? ", " : "",
            group$1(util$6.getLast(printed), { shouldBreak: true }),
            ")"
          ]),
          group$1(
            concat$2([
              "(",
              indent$2(
                options.tabWidth,
                concat$2([line$1, join$2(concat$2([",", line$1]), printed)])
              ),
              options.trailingComma ? "," : "",
              line$1,
              ")"
            ]),
            { shouldBreak: true }
          )
        ],
        { shouldBreak }
      )
    ]);
  }

  return group$1(
    concat$2([
      "(",
      indent$2(
        options.tabWidth,
        concat$2([softline$1, join$2(concat$2([",", line$1]), printed)])
      ),
      ifBreak$1(options.trailingComma ? "," : ""),
      softline$1,
      ")"
    ]),
    { shouldBreak: printed.some(willBreak$2) }
  );
}

function printFunctionParams(path, print, options) {
  var fun = path.getValue();
  // namedTypes.Function.assert(fun);
  var printed = path.map(print, "params");

  if (fun.defaults) {
    path.each(
      function(defExprPath) {
        var i = defExprPath.getName();
        var p = printed[i];

        if (p && defExprPath.getValue()) {
          printed[i] = concat$2([p, " = ", print(defExprPath)]);
        }
      },
      "defaults"
    );
  }

  if (fun.rest) {
    printed.push(concat$2(["...", path.call(print, "rest")]));
  }

  if (printed.length === 0) {
    return "()";
  }

  const lastParam = util$6.getLast(path.getValue().params);
  const canHaveTrailingComma = !(lastParam &&
    lastParam.type === "RestElement") &&
    !fun.rest;

  return concat$2([
    "(",
    indent$2(
      options.tabWidth,
      concat$2([softline$1, join$2(concat$2([",", line$1]), printed)])
    ),
    ifBreak$1(canHaveTrailingComma && options.trailingComma ? "," : ""),
    softline$1,
    ")"
  ]);
}

function printObjectMethod(path, options, print) {
  var objMethod = path.getValue();
  var parts = [];

  if (objMethod.async) parts.push("async ");

  if (objMethod.generator) parts.push("*");

  if (
    objMethod.method || objMethod.kind === "get" || objMethod.kind === "set"
  ) {
    return printMethod(path, options, print);
  }

  var key = printPropertyKey(path, options, print);

  if (objMethod.computed) {
    parts.push("[", key, "]");
  } else {
    parts.push(key);
  }

  if (objMethod.typeParameters) {
    parts.push(path.call(print, "typeParameters"));
  }

  parts.push(
    group$1(
      concat$2([
        printFunctionParams(path, print, options),
        printReturnType(path, print)
      ])
    ),
    " ",
    path.call(print, "body")
  );

  return concat$2(parts);
}

function printReturnType(path, print) {
  const n = path.getValue();
  const parts = [path.call(print, "returnType")];

  if (n.predicate) {
    // The return type will already add the colon, but otherwise we
    // need to do it ourselves
    parts.push(n.returnType ? " " : ": ", path.call(print, "predicate"));
  }

  return concat$2(parts);
}

function printExportDeclaration(path, options, print) {
  var decl = path.getValue();
  var parts = ["export "];

  namedTypes.Declaration.assert(decl);

  if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
    parts.push("default ");
  }

  if (decl.declaration) {
    parts.push(path.call(print, "declaration"));

    if (
      decl.type === "ExportDefaultDeclaration" &&
      (decl.declaration.type !== "ClassDeclaration" &&
        decl.declaration.type !== "FunctionDeclaration")
    ) {
      parts.push(";");
    }
  } else {
    if (decl.specifiers && decl.specifiers.length > 0) {
      if (
        decl.specifiers.length === 1 &&
        decl.specifiers[0].type === "ExportBatchSpecifier"
      ) {
        parts.push("*");
      } else if (
        decl.specifiers.length === 1 &&
          decl.specifiers[0].type === "ExportDefaultSpecifier" ||
        decl.specifiers[0].type === "ExportNamespaceSpecifier"
      ) {
        parts.push(path.map(print, "specifiers")[0]);
      } else {
        parts.push(
          decl.exportKind === "type" ? "type " : "",
          group$1(
            concat$2([
              "{",
              indent$2(
                options.tabWidth,
                concat$2([
                  options.bracketSpacing ? line$1 : softline$1,
                  join$2(concat$2([",", line$1]), path.map(print, "specifiers"))
                ])
              ),
              ifBreak$1(options.trailingComma ? "," : ""),
              options.bracketSpacing ? line$1 : softline$1,
              "}"
            ])
          )
        );
      }
    } else {
      parts.push("{}");
    }

    if (decl.source) {
      parts.push(" from ", path.call(print, "source"));
    }

    parts.push(";");
  }

  return concat$2(parts);
}

function printFlowDeclaration(path, parts) {
  var parentExportDecl = util$6.getParentExportDeclaration(path);

  if (parentExportDecl) {
    assert$4.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
  } else {
    // If the parent node has type DeclareExportDeclaration, then it
    // will be responsible for printing the "declare" token. Otherwise
    // it needs to be printed with this non-exported declaration node.
    parts.unshift("declare ");
  }

  return concat$2(parts);
}

function printClass(path, options, print) {
  const n = path.getValue();
  const parts = ["class"];

  if (n.id) {
    parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
  }

  const partsGroup = [];
  if (n.superClass) {
    partsGroup.push(
      line$1,
      "extends ",
      path.call(print, "superClass"),
      path.call(print, "superTypeParameters")
    );
  } else if (n.extends && n.extends.length > 0) {
    partsGroup.push(line$1, "extends ", join$2(", ", path.map(print, "extends")));
  }

  if (n["implements"] && n["implements"].length > 0) {
    partsGroup.push(
      line$1,
      "implements ",
      join$2(", ", path.map(print, "implements"))
    );
  }

  if (partsGroup.length > 0) {
    parts.push(group$1(indent$2(options.tabWidth, concat$2(partsGroup))));
  }

  parts.push(" ", path.call(print, "body"));

  return parts;
}

function printMemberLookup(path, options, print) {
  const property = path.call(print, "property");
  const n = path.getValue();

  return concat$2(
    n.computed
      ? [
          "[",
          group$1(
            concat$2([
              indent$2(options.tabWidth, concat$2([softline$1, property])),
              softline$1
            ])
          ),
          "]"
        ]
      : [".", property]
  );
}

// We detect calls on member expressions specially to format a
// comman pattern better. The pattern we are looking for is this:
//
// arr
//   .map(x => x + 1)
//   .filter(x => x > 10)
//   .some(x => x % 2)
//
// The way it is structured in the AST is via a nested sequence of
// MemberExpression and CallExpression. We need to traverse the AST
// and make groups out of it to print it in the desired way.
function printMemberChain(path, options, print) {
  // The first phase is to linearize the AST by traversing it down.
  //
  //   a().b()
  // has the following AST structure:
  //   CallExpression(MemberExpression(CallExpression(Identifier)))
  // and we transform it into
  //   [Identifier, CallExpression, MemberExpression, CallExpression]
  const printedNodes = [];

  function rec(path) {
    const node = path.getValue();
    if (node.type === "CallExpression") {
      printedNodes.unshift({
        node: node,
        printed: comments$3.printComments(
          path,
          p => printArgumentsList(path, options, print),
          options
        )
      });
      path.call(callee => rec(callee), "callee");
    } else if (node.type === "MemberExpression") {
      printedNodes.unshift({
        node: node,
        printed: comments$3.printComments(
          path,
          p => printMemberLookup(path, options, print),
          options
        )
      });
      path.call(object => rec(object), "object");
    } else {
      printedNodes.unshift({
        node: node,
        printed: path.call(print)
      });
    }
  }
  // Note: the comments of the root node have already been printed, so we
  // need to extract this first call without printing them as they would
  // if handled inside of the recursive call.
  printedNodes.unshift({
    node: path.getValue(),
    printed: printArgumentsList(path, options, print)
  });
  path.call(callee => rec(callee), "callee");

  // Once we have a linear list of printed nodes, we want to create groups out
  // of it.
  //
  //   a().b.c().d().e
  // will be grouped as
  //   [
  //     [Identifier, CallExpression],
  //     [MemberExpression, MemberExpression, CallExpression],
  //     [MemberExpression, CallExpression],
  //     [MemberExpression],
  //   ]
  // so that we can print it as
  //   a()
  //     .b.c()
  //     .d()
  //     .e

  // The first group is the first node followed by
  //   - as many CallExpression as possible
  //       < fn()()() >.something()
  //   - then, as many MemberExpression as possible but the last one
  //       < this.items >.something()
  var groups = [];
  var currentGroup = [printedNodes[0]];
  var i = 1;
  for (; i < printedNodes.length; ++i) {
    if (printedNodes[i].node.type === "CallExpression") {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }
  for (; i + 1 < printedNodes.length; ++i) {
    if (
      printedNodes[i].node.type === "MemberExpression" &&
      printedNodes[i + 1].node.type === "MemberExpression"
    ) {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }
  groups.push(currentGroup);
  currentGroup = [];

  // Then, each following group is a sequence of MemberExpression followed by
  // a sequence of CallExpression. To compute it, we keep adding things to the
  // group until we has seen a CallExpression in the past and reach a
  // MemberExpression
  var hasSeenCallExpression = false;
  for (; i < printedNodes.length; ++i) {
    if (
      hasSeenCallExpression && printedNodes[i].node.type === "MemberExpression"
    ) {
      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }

    if (printedNodes[i].node.type === "CallExpression") {
      hasSeenCallExpression = true;
    }
    currentGroup.push(printedNodes[i]);
  }
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }

  // There are cases like Object.keys(), Observable.of(), _.values() where
  // they are the subject of all the chained calls and therefore should
  // be kept on the same line:
  //
  //   Object.keys(items)
  //     .filter(x => x)
  //     .map(x => x)
  //
  // In order to detect those cases, we use an heuristic: if the first
  // node is just an identifier with the name starting with a capital
  // letter or just a sequence of _$. The rationale is that they are
  // likely to be factories.
  const shouldMerge = groups[0].length === 1 &&
    groups[0][0].node.type === "Identifier" &&
    groups[0][0].node.name.match(/(^[A-Z])|^[_$]+$/) &&
    groups.length >= 2;

  function printGroup(printedGroup) {
    return concat$2(printedGroup.map(tuple => tuple.printed));
  }

  function printIndentedGroup(groups, lineType) {
    return indent$2(
      options.tabWidth,
      group$1(concat$2([lineType, join$2(lineType, groups.map(printGroup))]))
    );
  }

  const printedGroups = groups.map(printGroup);
  const oneLine = concat$2(printedGroups);
  const hasComment = groups.length >= 2 && groups[1][0].node.comments;

  // If we only have a single `.`, we shouldn't do anything fancy and just
  // render everything concatenated together.
  if (groups.length <= 2 && !hasComment) {
    return group$1(oneLine);
  }

  const expanded = concat$2([
    printGroup(groups[0]),
    shouldMerge ? printIndentedGroup(groups.slice(1, 2), softline$1) : "",
    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1), hardline$2)
  ]);

  // If there's a comment, we don't want to print in one line.
  if (hasComment) {
    return group$1(expanded);
  }

  // If any group but the last one has a hard line, we want to force expand
  // it. If the last group is a function it's okay to inline if it fits.
  if (printedGroups.slice(0, -1).some(willBreak$2)) {
    return group$1(expanded);
  }

  return conditionalGroup$1([oneLine, expanded]);
}

function isEmptyJSXElement(node) {
  if (node.children.length === 0) return true;
  if (node.children.length > 1) return false;

  // if there is one child but it's just a newline, treat as empty
  const value = node.children[0].value;
  if (!/\S/.test(value) && /\n/.test(value)) {
    return true;
  } else {
    return false;
  }
}

// JSX Children are strange, mostly for two reasons:
// 1. JSX reads newlines into string values, instead of skipping them like JS
// 2. up to one whitespace between elements within a line is significant,
//    but not between lines.
//
// So for one thing, '\n' needs to be parsed out of string literals
// and turned into hardlines (with string boundaries otherwise using softline)
//
// For another, leading, trailing, and lone whitespace all need to
// turn themselves into the rather ugly `{' '}` when breaking.
function printJSXChildren(path, options, print, jsxWhitespace) {
  const n = path.getValue();
  const children = [];

  // using `map` instead of `each` because it provides `i`
  path.map(
    function(childPath, i) {
      const child = childPath.getValue();
      const isLiteral = namedTypes.Literal.check(child);

      if (isLiteral && typeof child.value === "string") {
        // There's a bug in the flow parser where it doesn't unescape the
        // value field. To workaround this, we can use rawValue which is
        // correctly escaped (since it parsed).
        // We really want to use value and re-escape it ourself when possible
        // though.
        const partiallyEscapedValue = options.parser === "flow"
          ? child.raw
          : util$6.htmlEscapeInsideAngleBracket(child.value);
        const value = partiallyEscapedValue.replace(/\u00a0/g, "&nbsp;");

        if (/\S/.test(value)) {
          // treat each line of text as its own entity
          value.split(/(\n\s*)/).forEach(line => {
            const newlines = line.match(/\n/g);
            if (newlines) {
              children.push(hardline$2);

              // allow one extra newline
              if (newlines.length > 1) {
                children.push(hardline$2);
              }
              return;
            }

            const beginSpace = /^\s+/.test(line);
            if (beginSpace) {
              children.push(jsxWhitespace);
            }

            const stripped = line.replace(/^\s+|\s+$/g, "");
            if (stripped) {
              children.push(stripped);
            }

            const endSpace = /\s+$/.test(line);
            if (endSpace) {
              children.push(jsxWhitespace);
            }
          });

          if (!isLineNext$1(util$6.getLast(children))) {
            children.push(softline$1);
          }
        } else if (/\n/.test(value)) {
          children.push(hardline$2);

          // allow one extra newline
          if (value.match(/\n/g).length > 1) {
            children.push(hardline$2);
          }
        } else if (/\s/.test(value)) {
          // whitespace-only without newlines,
          // eg; a single space separating two elements
          children.push(jsxWhitespace);
          children.push(softline$1);
        }
      } else {
        children.push(print(childPath));

        // add a line unless it's followed by a JSX newline
        let next = n.children[i + 1];
        if (!(next && /^\s*\n/.test(next.value))) {
          children.push(softline$1);
        }
      }
    },
    "children"
  );

  return children;
}

// JSX expands children from the inside-out, instead of the outside-in.
// This is both to break children before attributes,
// and to ensure that when children break, their parents do as well.
//
// Any element that is written without any newlines and fits on a single line
// is left that way.
// Not only that, any user-written-line containing multiple JSX siblings
// should also be kept on one line if possible,
// so each user-written-line is wrapped in its own group.
//
// Elements that contain newlines or don't fit on a single line (recursively)
// are fully-split, using hardline and shouldBreak: true.
//
// To support that case properly, all leading and trailing spaces
// are stripped from the list of children, and replaced with a single hardline.
function printJSXElement(path, options, print) {
  const n = path.getValue();

  // Turn <div></div> into <div />
  if (isEmptyJSXElement(n)) {
    n.openingElement.selfClosing = true;
    delete n.closingElement;
  }

  // If no children, just print the opening element
  const openingLines = path.call(print, "openingElement");
  if (n.openingElement.selfClosing) {
    assert$4.ok(!n.closingElement);
    return openingLines;
  }

  const jsxWhitespace = options.singleQuote
    ? ifBreak$1("{' '}", " ")
    : ifBreak$1('{" "}', " ");
  const children = printJSXChildren(path, options, print, jsxWhitespace);
  let forcedBreak = false;

  // Trim trailing lines, recording if there was a hardline
  let numTrailingHard = 0;
  while (children.length && isLineNext$1(util$6.getLast(children))) {
    if (willBreak$2(util$6.getLast(children))) {
      ++numTrailingHard;
      forcedBreak = true;
    }
    children.pop();
  }
  // allow one extra newline
  if (numTrailingHard > 1) {
    children.push(hardline$2);
  }

  // Trim leading lines, recording if there was a hardline
  let numLeadingHard = 0;
  while (children.length && isLineNext$1(children[0])) {
    if (willBreak$2(children[0])) {
      ++numLeadingHard;
      forcedBreak = true;
    }
    children.shift();
  }
  // allow one extra newline
  if (numLeadingHard > 1) {
    children.unshift(hardline$2);
  }

  // Group by line, recording if there was a hardline.
  let groups = [[]]; // Initialize the first line's group
  children.forEach((child, i) => {
    // leading and trailing JSX whitespace don't go into a group
    if (child === jsxWhitespace) {
      if (i === 0) {
        groups.unshift(child);
        return;
      } else if (i === children.length - 1) {
        groups.push(child);
        return;
      }
    }

    let prev = children[i - 1];
    if (prev && willBreak$2(prev)) {
      forcedBreak = true;

      // On a new line, so create a new group and put this element in it.
      groups.push([child]);
    } else {
      // Not on a newline, so add this element to the current group.
      util$6.getLast(groups).push(child);
    }

    // Ensure we record hardline of last element.
    if (!forcedBreak && i === children.length - 1) {
      if (willBreak$2(child)) forcedBreak = true;
    }
  });

  const childrenGroupedByLine = [
    hardline$2,
    // Conditional groups suppress break propagation; we want to output
    // hard lines without breaking up the entire jsx element.
    // Note that leading and trailing JSX Whitespace don't go into a group.
    concat$2(
      groups.map(
        contents =>
          Array.isArray(contents)
            ? conditionalGroup$1([concat$2(contents)])
            : contents
      )
    )
  ];

  const closingLines = path.call(print, "closingElement");

  const multiLineElem = group$1(
    concat$2([
      openingLines,
      indent$2(
        options.tabWidth,
        group$1(concat$2(childrenGroupedByLine), { shouldBreak: true })
      ),
      hardline$2,
      closingLines
    ])
  );

  if (forcedBreak) {
    return multiLineElem;
  }

  return conditionalGroup$1([
    group$1(concat$2([openingLines, concat$2(children), closingLines])),
    multiLineElem
  ]);
}

function maybeWrapJSXElementInParens(path, elem, options) {
  const parent = path.getParentNode();
  if (!parent) return elem;

  const NO_WRAP_PARENTS = {
    JSXElement: true,
    ExpressionStatement: true,
    CallExpression: true,
    ConditionalExpression: true,
    LogicalExpression: true
  };
  if (NO_WRAP_PARENTS[parent.type]) {
    return elem;
  }

  return group$1(
    concat$2([
      ifBreak$1("("),
      indent$2(options.tabWidth, concat$2([softline$1, elem])),
      softline$1,
      ifBreak$1(")")
    ])
  );
}

function isBinaryish(node) {
  return node.type === "BinaryExpression" || node.type === "LogicalExpression";
}

function shouldInlineLogicalExpression(node) {
  return node.type === "LogicalExpression" &&
    (node.right.type === "ObjectExpression" ||
      node.right.type === "ArrayExpression");
}

// For binary expressions to be consistent, we need to group
// subsequent operators with the same precedence level under a single
// group. Otherwise they will be nested such that some of them break
// onto new lines but not all. Operators with the same precedence
// level should either all break or not. Because we group them by
// precedence level and the AST is structured based on precedence
// level, things are naturally broken up correctly, i.e. `&&` is
// broken before `+`.
function printBinaryishExpressions(path, parts, print, options, isNested) {
  let node = path.getValue();

  // We treat BinaryExpression and LogicalExpression nodes the same.
  if (isBinaryish(node)) {
    // Put all operators with the same precedence level in the same
    // group. The reason we only need to do this with the `left`
    // expression is because given an expression like `1 + 2 - 3`, it
    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
    // is where the rest of the expression will exist. Binary
    // expressions on the right side mean they have a difference
    // precedence level and should be treated as a separate group, so
    // print them normally.
    if (
      util$6.getPrecedence(node.left.operator) ===
      util$6.getPrecedence(node.operator)
    ) {
      // Flatten them out by recursively calling this function. The
      // printed values will all be appended to `parts`.
      path.call(
        left =>
          printBinaryishExpressions(
            left,
            parts,
            print,
            options,
            /* isNested */ true
          ),
        "left"
      );
    } else {
      parts.push(path.call(print, "left"));
    }

    const right = concat$2([
      node.operator,
      shouldInlineLogicalExpression(node) ? " " : line$1,
      path.call(print, "right")
    ]);

    // If there's only a single binary expression: everything except && and ||,
    // we want to create a group in order to avoid having a small right part
    // like -1 be on its own line.
    const parent = path.getParentNode();
    const shouldGroup = node.type === "BinaryExpression" &&
      parent.type !== "BinaryExpression" &&
      node.left.type !== "BinaryExpression" &&
      node.right.type !== "BinaryExpression";

    parts.push(" ", shouldGroup ? group$1(right) : right);

    // The root comments are already printed, but we need to manually print
    // the other ones since we don't call the normal print on BinaryExpression,
    // only for the left and right parts
    if (isNested && node.comments) {
      parts.push(comments$3.printComments(path, p => "", options));
    }
  } else {
    // Our stopping case. Simply print the node normally.
    parts.push(path.call(print));
  }

  return parts;
}

function adjustClause(clause, options, forceSpace) {
  if (clause === "") {
    return ";";
  }

  if (isCurlyBracket(clause) || forceSpace) {
    return concat$2([" ", clause]);
  }

  return indent$2(options.tabWidth, concat$2([line$1, clause]));
}

function isCurlyBracket(doc) {
  const str = getFirstString$1(doc);
  return str === "{" || str === "{}";
}

function isEmptyBlock(doc) {
  const str = getFirstString$1(doc);
  return str === "{}";
}

function nodeStr(node, options) {
  const str = node.value;
  isString.assert(str);

  // Workaround a bug in the Javascript version of the flow parser where
  // astral unicode characters like \uD801\uDC28 are incorrectly parsed as
  // a sequence of \uFFFD.
  if (options.parser === "flow" && str.indexOf("\ufffd") !== -1) {
    return node.raw;
  }

  const raw = node.extra ? node.extra.raw : node.raw;
  // `rawContent` is the string exactly like it appeared in the input source
  // code, with its enclosing quote.
  const rawContent = raw.slice(1, -1);

  const double = { quote: '"', regex: /"/g };
  const single = { quote: "'", regex: /'/g };

  const preferred = options.singleQuote ? single : double;
  const alternate = preferred === single ? double : single;

  let shouldUseAlternateQuote = false;

  // If `rawContent` contains at least one of the quote preferred for enclosing
  // the string, we might want to enclose with the alternate quote instead, to
  // minimize the number of escaped quotes.
  if (rawContent.includes(preferred.quote)) {
    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;

    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;
  }

  const enclosingQuote = shouldUseAlternateQuote
    ? alternate.quote
    : preferred.quote;

  // It might sound unnecessary to use `makeString` even if `node.raw` already
  // is enclosed with `enclosingQuote`, but it isn't. `node.raw` could contain
  // unnecessary escapes (such as in `"\'"`). Always using `makeString` makes
  // sure that we consistently output the minimum amount of escaped quotes.
  return makeString(rawContent, enclosingQuote);
}

function makeString(rawContent, enclosingQuote) {
  const otherQuote = enclosingQuote === '"' ? "'" : '"';

  // Matches _any_ escape and unescaped quotes (both single and double).
  const regex = /\\([\s\S])|(['"])/g;

  // Escape and unescape single and double quotes as needed to be able to
  // enclose `rawContent` with `enclosingQuote`.
  const newContent = rawContent.replace(regex, (match, escaped, quote) => {
    // If we matched an escape, and the escaped character is a quote of the
    // other type than we intend to enclose the string with, there's no need for
    // it to be escaped, so return it _without_ the backslash.
    if (escaped === otherQuote) {
      return escaped;
    }

    // If we matched an unescaped quote and it is of the _same_ type as we
    // intend to enclose the string with, it must be escaped, so return it with
    // a backslash.
    if (quote === enclosingQuote) {
      return "\\" + quote;
    }

    // Otherwise return the escape or unescaped quote as-is.
    return match;
  });

  return enclosingQuote + newContent + enclosingQuote;
}

function printNumber(rawNumber) {
  return rawNumber
    .toLowerCase()
    // Remove unnecessary plus and zeroes from scientific notation.
    .replace(/^([\d.]+e)(?:\+|(-))?0*/, "$1$2")
    // Make sure numbers always start with a digit.
    .replace(/^\./, "0.")
    // Remove trailing dot.
    .replace(/\.(?=e|$)/, "");
}

function isLastStatement(path) {
  const parent = path.getParentNode();
  const node = path.getValue();
  const body = parent.body;
  return body && body[body.length - 1] === node;
}

// Hack to differentiate between the following two which have the same ast
// type T = { method: () => void };
// type T = { method(): void };
function isObjectTypePropertyAFunction(node) {
  return node.type === "ObjectTypeProperty" &&
    node.value.type === "FunctionTypeAnnotation" &&
    !node.static &&
    util$6.locStart(node.key) !== util$6.locStart(node.value);
}

function isFlowNodeStartingWithDeclare(node, options) {
  if (options.parser !== "flow") {
    return false;
  }

  return options.originalText
    .slice(0, util$6.locStart(node))
    .match(/declare\s*$/);
}

function printAstToDoc$1(ast, options) {
  function printGenerically(path) {
    return comments$3.printComments(
      path,
      p => genericPrint(p, options, printGenerically),
      options
    );
  }

  const doc = printGenerically(FastPath.from(ast));
  docUtils$2.propagateBreaks(doc);
  return doc;
}

var printer = { printAstToDoc: printAstToDoc$1 };

const MODE_BREAK = 1;
const MODE_FLAT = 2;

function fits(next, restCommands, width) {
  let restIdx = restCommands.length;
  const cmds = [next];
  while (width >= 0) {
    if (cmds.length === 0) {
      if (restIdx === 0) {
        return true;
      } else {
        cmds.push(restCommands[restIdx - 1]);

        restIdx--;

        continue;
      }
    }

    const x = cmds.pop();
    const ind = x[0];
    const mode = x[1];
    const doc = x[2];

    if (typeof doc === "string") {
      width -= doc.length;
    } else {
      switch (doc.type) {
        case "concat":
          for (var i = doc.parts.length - 1; i >= 0; i--) {
            cmds.push([ind, mode, doc.parts[i]]);
          }

          break;
        case "indent":
          cmds.push([ind + doc.n, mode, doc.contents]);

          break;
        case "group":
          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);

          break;
        case "if-break":
          if (mode === MODE_BREAK) {
            if (doc.breakContents) {
              cmds.push([ind, mode, doc.breakContents]);
            }
          }
          if (mode === MODE_FLAT) {
            if (doc.flatContents) {
              cmds.push([ind, mode, doc.flatContents]);
            }
          }

          break;
        case "line":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!doc.hard) {
                if (!doc.soft) {
                  width -= 1;
                }

                break;
              }

            case MODE_BREAK:
              return true;
          }
          break;
      }
    }
  }
  return false;
}

function printDocToString$1(doc, width, newLine) {
  newLine = newLine || "\n";

  let pos = 0;
  // cmds is basically a stack. We've turned a recursive call into a
  // while loop which is much faster. The while loop below adds new
  // cmds to the array instead of recursively calling `print`.
  let cmds = [[0, MODE_BREAK, doc]];
  let out = [];
  let shouldRemeasure = false;
  let lineSuffix = [];

  while (cmds.length !== 0) {
    const x = cmds.pop();
    const ind = x[0];
    const mode = x[1];
    const doc = x[2];

    if (typeof doc === "string") {
      out.push(doc);

      pos += doc.length;
    } else {
      switch (doc.type) {
        case "concat":
          for (var i = doc.parts.length - 1; i >= 0; i--) {
            cmds.push([ind, mode, doc.parts[i]]);
          }

          break;
        case "indent":
          cmds.push([ind + doc.n, mode, doc.contents]);

          break;
        case "group":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!shouldRemeasure) {
                cmds.push([
                  ind,
                  doc.break ? MODE_BREAK : MODE_FLAT,
                  doc.contents
                ]);

                break;
              }

            case MODE_BREAK:
              shouldRemeasure = false;

              const next = [ind, MODE_FLAT, doc.contents];
              let rem = width - pos;

              if (!doc.break && fits(next, cmds, rem)) {
                cmds.push(next);
              } else {
                // Expanded states are a rare case where a document
                // can manually provide multiple representations of
                // itself. It provides an array of documents
                // going from the least expanded (most flattened)
                // representation first to the most expanded. If a
                // group has these, we need to manually go through
                // these states and find the first one that fits.
                if (doc.expandedStates) {
                  const mostExpanded = doc.expandedStates[
                    doc.expandedStates.length - 1
                  ];

                  if (doc.break) {
                    cmds.push([ind, MODE_BREAK, mostExpanded]);

                    break;
                  } else {
                    for (var i = 1; i < doc.expandedStates.length + 1; i++) {
                      if (i >= doc.expandedStates.length) {
                        cmds.push([ind, MODE_BREAK, mostExpanded]);

                        break;
                      } else {
                        const state = doc.expandedStates[i];
                        const cmd = [ind, MODE_FLAT, state];

                        if (fits(cmd, cmds, rem)) {
                          cmds.push(cmd);

                          break;
                        }
                      }
                    }
                  }
                } else {
                  cmds.push([ind, MODE_BREAK, doc.contents]);
                }
              }

              break;
          }
          break;
        case "if-break":
          if (mode === MODE_BREAK) {
            if (doc.breakContents) {
              cmds.push([ind, mode, doc.breakContents]);
            }
          }
          if (mode === MODE_FLAT) {
            if (doc.flatContents) {
              cmds.push([ind, mode, doc.flatContents]);
            }
          }

          break;
        case "line-suffix":
          lineSuffix.push([ind, mode, doc.contents]);
          break;
        case "line":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!doc.hard) {
                if (!doc.soft) {
                  out.push(" ");

                  pos += 1;
                }

                break;
              } else {
                // This line was forced into the output even if we
                // were in flattened mode, so we need to tell the next
                // group that no matter what, it needs to remeasure
                // because the previous measurement didn't accurately
                // capture the entire expression (this is necessary
                // for nested groups)
                shouldRemeasure = true;
              }

            case MODE_BREAK:
              if (lineSuffix.length) {
                cmds.push([ind, mode, doc]);
                [].push.apply(cmds, lineSuffix.reverse());
                lineSuffix = [];
                break;
              }

              if (doc.literal) {
                out.push(newLine);
                pos = 0;
              } else {
                if (out.length > 0) {
                  // Trim whitespace at the end of line
                  out[out.length - 1] = out[out.length - 1].replace(
                    /[^\S\n]*$/,
                    ""
                  );
                }

                out.push(newLine + " ".repeat(ind));
                pos = ind;
              }
              break;
          }
          break;
        default:
      }
    }
  }
  return out.join("");
}

var docPrinter = { printDocToString: printDocToString$1 };

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

const ESCAPED_CHARACTERS = /(\\|\"|\')/g;

var printString$1 = val => val.replace(ESCAPED_CHARACTERS, '\\$1');

const style = index$16;
const printString = printString$1;

const toString = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = Symbol.prototype.toString;

const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/ig;

const getSymbols = Object.getOwnPropertySymbols || (obj => []);

function isToStringedArrayType(toStringed) {
  return (
    toStringed === '[object Array]' ||
    toStringed === '[object ArrayBuffer]' ||
    toStringed === '[object DataView]' ||
    toStringed === '[object Float32Array]' ||
    toStringed === '[object Float64Array]' ||
    toStringed === '[object Int8Array]' ||
    toStringed === '[object Int16Array]' ||
    toStringed === '[object Int32Array]' ||
    toStringed === '[object Uint8Array]' ||
    toStringed === '[object Uint8ClampedArray]' ||
    toStringed === '[object Uint16Array]' ||
    toStringed === '[object Uint32Array]');

}

function printNumber$1(val) {
  if (val != +val) {
    return 'NaN';
  }
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}

function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return '[Function]';
  } else if (val.name === '') {
    return '[Function anonymous]';
  } else {
    return '[Function ' + val.name + ']';
  }
}

function printSymbol(val) {
  return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
}

function printError(val) {
  return '[' + errorToString.call(val) + ']';
}

function printBasicValue(val, printFunctionName, escapeRegex) {
  if (val === true || val === false) {
    return '' + val;
  }
  if (val === undefined) {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }

  const typeOf = typeof val;

  if (typeOf === 'number') {
    return printNumber$1(val);
  }
  if (typeOf === 'string') {
    return '"' + printString(val) + '"';
  }
  if (typeOf === 'function') {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === 'symbol') {
    return printSymbol(val);
  }

  const toStringed = toString.call(val);

  if (toStringed === '[object WeakMap]') {
    return 'WeakMap {}';
  }
  if (toStringed === '[object WeakSet]') {
    return 'WeakSet {}';
  }
  if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === '[object Symbol]') {
    return printSymbol(val);
  }
  if (toStringed === '[object Date]') {
    return toISOString.call(val);
  }
  if (toStringed === '[object Error]') {
    return printError(val);
  }
  if (toStringed === '[object RegExp]') {
    if (escapeRegex) {
      return printString(regExpToString.call(val));
    }
    return regExpToString.call(val);
  }
  if (toStringed === '[object Arguments]' && val.length === 0) {
    return 'Arguments []';
  }
  if (isToStringedArrayType(toStringed) && val.length === 0) {
    return val.constructor.name + ' []';
  }

  if (val instanceof Error) {
    return printError(val);
  }

  return false;
}

function printList(list, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let body = '';

  if (list.length) {
    body += edgeSpacing;

    const innerIndent = prevIndent + indent;

    for (let i = 0; i < list.length; i++) {
      body += innerIndent + print(list[i], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      if (i < list.length - 1) {
        body += ',' + spacing;
      }
    }

    body += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return '[' + body + ']';
}

function printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  return (min ? '' : 'Arguments ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  return (min ? '' : val.constructor.name + ' ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let result = 'Map {';
  const iterator = val.entries();
  let current = iterator.next();

  if (!current.done) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    while (!current.done) {
      const key = print(current.value[0], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
      const value = print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      result += innerIndent + key + ' => ' + value;

      current = iterator.next();

      if (!current.done) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  const constructor = min ? '' : val.constructor ? val.constructor.name + ' ' : 'Object ';
  let result = constructor + '{';
  let keys = Object.keys(val).sort();
  const symbols = getSymbols(val);

  if (symbols.length) {
    keys = keys.
    filter(key => !(typeof key === 'symbol' || toString.call(key) === '[object Symbol]')).
    concat(symbols);
  }

  if (keys.length) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const name = print(key, indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
      const value = print(val[key], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      result += innerIndent + name + ': ' + value;

      if (i < keys.length - 1) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let result = 'Set {';
  const iterator = val.entries();
  let current = iterator.next();

  if (!current.done) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    while (!current.done) {
      result += innerIndent + print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      current = iterator.next();

      if (!current.done) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  refs = refs.slice();
  if (refs.indexOf(val) > -1) {
    return '[Circular]';
  } else {
    refs.push(val);
  }

  currentDepth++;

  const hitMaxDepth = currentDepth > maxDepth;

  if (callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function') {
    return print(val.toJSON(), indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  const toStringed = toString.call(val);
  if (toStringed === '[object Arguments]') {
    return hitMaxDepth ? '[Arguments]' : printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? '[Array]' : printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (toStringed === '[object Map]') {
    return hitMaxDepth ? '[Map]' : printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (toStringed === '[object Set]') {
    return hitMaxDepth ? '[Set]' : printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  return hitMaxDepth ? '[Object]' : printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let match = false;
  let plugin;

  for (let p = 0; p < plugins.length; p++) {
    plugin = plugins[p];

    if (plugin.test(val)) {
      match = true;
      break;
    }
  }

  if (!match) {
    return false;
  }

  function boundPrint(val) {
    return print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  function boundIndent(str) {
    const indentation = prevIndent + indent;
    return indentation + str.replace(NEWLINE_REGEXP, '\n' + indentation);
  }

  const opts = {
    edgeSpacing,
    spacing };

  return plugin.print(val, boundPrint, boundIndent, opts, colors);
}

function print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  const basic = printBasicValue(val, printFunctionName, escapeRegex);
  if (basic) {
    return basic;
  }

  const plugin = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  if (plugin) {
    return plugin;
  }

  return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

const DEFAULTS = {
  callToJSON: true,
  escapeRegex: false,
  highlight: false,
  indent: 2,
  maxDepth: Infinity,
  min: false,
  plugins: [],
  printFunctionName: true,
  theme: {
    content: 'reset',
    prop: 'yellow',
    tag: 'cyan',
    value: 'green' } };



function validateOptions(opts) {
  Object.keys(opts).forEach(key => {
    if (!DEFAULTS.hasOwnProperty(key)) {
      throw new Error('prettyFormat: Invalid option: ' + key);
    }
  });

  if (opts.min && opts.indent !== undefined && opts.indent !== 0) {
    throw new Error('prettyFormat: Cannot run with min option and indent');
  }
}

function normalizeOptions$1(opts) {
  const result = {};

  Object.keys(DEFAULTS).forEach(key =>
  result[key] = opts.hasOwnProperty(key) ? opts[key] : DEFAULTS[key]);


  if (result.min) {
    result.indent = 0;
  }

  return result;
}

function createIndent(indent) {
  return new Array(indent + 1).join(' ');
}

function prettyFormat(val, opts) {
  if (!opts) {
    opts = DEFAULTS;
  } else {
    validateOptions(opts);
    opts = normalizeOptions$1(opts);
  }

  const colors = {};
  Object.keys(opts.theme).forEach(key => {
    if (opts.highlight) {
      colors[key] = style[opts.theme[key]];
    } else {
      colors[key] = { close: '', open: '' };
    }
  });

  let indent;
  let refs;
  const prevIndent = '';
  const currentDepth = 0;
  const spacing = opts.min ? ' ' : '\n';
  const edgeSpacing = opts.min ? '' : '\n';

  if (opts && opts.plugins.length) {
    indent = createIndent(opts.indent);
    refs = [];
    const pluginsResult = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex, colors);
    if (pluginsResult) {
      return pluginsResult;
    }
  }

  const basicResult = printBasicValue(val, opts.printFunctionName, opts.escapeRegex);
  if (basicResult) {
    return basicResult;
  }

  if (!indent) {
    indent = createIndent(opts.indent);
  }
  if (!refs) {
    refs = [];
  }
  return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex, colors);
}

var index$36 = prettyFormat;

/* eslint-disable no-nested-ternary */
var arr = [];
var charCodeCache = [];

var index$38 = function (a, b) {
	if (a === b) {
		return 0;
	}

	var aLen = a.length;
	var bLen = b.length;

	if (aLen === 0) {
		return bLen;
	}

	if (bLen === 0) {
		return aLen;
	}

	var bCharCode;
	var ret;
	var tmp;
	var tmp2;
	var i = 0;
	var j = 0;

	while (i < aLen) {
		charCodeCache[i] = a.charCodeAt(i);
		arr[i] = ++i;
	}

	while (j < bLen) {
		bCharCode = b.charCodeAt(j);
		tmp = j++;
		ret = j;

		for (i = 0; i < aLen; i++) {
			tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + 1;
			tmp = arr[i];
			ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
		}
	}

	return ret;
};

const chalk$2 = index$12;
const BULLET = chalk$2.bold('\u25cf');
const DEPRECATION = `${ BULLET } Deprecation Warning`;
const ERROR$1 = `${ BULLET } Validation Error`;
const WARNING = `${ BULLET } Validation Warning`;

const format$3 = value =>
typeof value === 'function' ?
value.toString() :
index$36(value, { min: true });

class ValidationError$1 extends Error {



  constructor(name, message, comment) {
    super();
    comment = comment ? '\n\n' + comment : '\n';
    this.name = '';
    this.message = chalk$2.red(chalk$2.bold(name) + ':\n\n' + message + comment);
    Error.captureStackTrace(this, () => {});
  }}


const logValidationWarning = (
name,
message,
comment) =>
{
  comment = comment ? '\n\n' + comment : '\n';
  console.warn(chalk$2.yellow(chalk$2.bold(name) + ':\n\n' + message + comment));
};

const createDidYouMeanMessage = (
unrecognized,
allowedOptions) =>
{
  const leven = index$38;
  const suggestion = allowedOptions.find(option => {
    const steps = leven(option, unrecognized);
    return steps < 3;
  });

  return suggestion ?
  `Did you mean ${ chalk$2.bold(format$3(suggestion)) }?` :
  '';
};

var utils$3 = {
  DEPRECATION,
  ERROR: ERROR$1,
  ValidationError: ValidationError$1,
  WARNING,
  createDidYouMeanMessage,
  format: format$3,
  logValidationWarning };

const chalk$3 = index$12;
const prettyFormat$1 = index$36;















const EXPECTED_COLOR = chalk$3.green;
const RECEIVED_COLOR = chalk$3.red;

const NUMBERS = [
'zero',
'one',
'two',
'three',
'four',
'five',
'six',
'seven',
'eight',
'nine',
'ten',
'eleven',
'twelve',
'thirteen'];


// get the type of a value with handling the edge cases like `typeof []`
// and `typeof null`
const getType$1 = value => {
  if (typeof value === 'undefined') {
    return 'undefined';
  } else if (value === null) {
    return 'null';
  } else if (Array.isArray(value)) {
    return 'array';
  } else if (typeof value === 'boolean') {
    return 'boolean';
  } else if (typeof value === 'function') {
    return 'function';
  } else if (typeof value === 'number') {
    return 'number';
  } else if (typeof value === 'string') {
    return 'string';
  } else if (typeof value === 'object') {
    if (value.constructor === RegExp) {
      return 'regexp';
    } else if (value.constructor === Map) {
      return 'map';
    } else if (value.constructor === Set) {
      return 'set';
    }
    return 'object';
    // $FlowFixMe https://github.com/facebook/flow/issues/1015
  } else if (typeof value === 'symbol') {
    return 'symbol';
  }

  throw new Error(`value of unknown type: ${ value }`);
};

const stringify = function (object) {let maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  const MAX_LENGTH = 10000;
  let result;

  try {
    result = prettyFormat$1(object, {
      maxDepth,
      min: true });

  } catch (e) {
    result = prettyFormat$1(object, {
      callToJSON: false,
      maxDepth,
      min: true });

  }

  return result.length >= MAX_LENGTH && maxDepth > 1 ?
  stringify(object, Math.floor(maxDepth / 2)) :
  result;
};

const printReceived = object => RECEIVED_COLOR(stringify(object));
const printExpected = value => EXPECTED_COLOR(stringify(value));

const printWithType = (
name,
received,
print) =>
{
  const type = getType$1(received);
  return (
    name + ':' + (
    type !== 'null' && type !== 'undefined' ?
    '\n  ' + type + ': ' :
    ' ') +
    print(received));

};

const ensureNoExpected = (expected, matcherName) => {
  matcherName || (matcherName = 'This');
  if (typeof expected !== 'undefined') {
    throw new Error(
    matcherHint('[.not]' + matcherName, undefined, '') + '\n\n' +
    'Matcher does not accept any arguments.\n' +
    printWithType('Got', expected, printExpected));

  }
};

const ensureActualIsNumber = (actual, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof actual !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
    `Actual value must be a number.\n` +
    printWithType('Received', actual, printReceived));

  }
};

const ensureExpectedIsNumber = (expected, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof expected !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
    `Expected value must be a number.\n` +
    printWithType('Got', expected, printExpected));

  }
};

const ensureNumbers = (actual, expected, matcherName) => {
  ensureActualIsNumber(actual, matcherName);
  ensureExpectedIsNumber(expected, matcherName);
};

const pluralize =
(word, count) =>
(NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');

const matcherHint = function (
matcherName)






{let received = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'received';let expected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'expected';let options = arguments[3];
  const secondArgument = options && options.secondArgument;
  const isDirectExpectCall = options && options.isDirectExpectCall;
  return (
    chalk$3.dim('expect' + (isDirectExpectCall ? '' : '(')) +
    RECEIVED_COLOR(received) +
    chalk$3.dim((isDirectExpectCall ? '' : ')') + matcherName + '(') +
    EXPECTED_COLOR(expected) + (
    secondArgument ? `, ${ EXPECTED_COLOR(secondArgument) }` : '') +
    chalk$3.dim(')'));

};

var index$40 = {
  EXPECTED_COLOR,
  RECEIVED_COLOR,
  ensureActualIsNumber,
  ensureExpectedIsNumber,
  ensureNoExpected,
  ensureNumbers,
  getType: getType$1,
  matcherHint,
  pluralize,
  printExpected,
  printReceived,
  printWithType,
  stringify };

const chalk$1 = index$12;var _require =
utils$3;const format$2 = _require.format; const ValidationError = _require.ValidationError; const ERROR = _require.ERROR;var _require2 =
index$40;const getType = _require2.getType;

const errorMessage = (
option,
received,
defaultValue,
options) =>
{
  const message =
  `  Option ${ chalk$1.bold(`"${ option }"`) } must be of type:
    ${ chalk$1.bold.green(getType(defaultValue)) }
  but instead received:
    ${ chalk$1.bold.red(getType(received)) }

  Example:
  {
    ${ chalk$1.bold(`"${ option }"`) }: ${ chalk$1.bold(format$2(defaultValue)) }
  }`;

  const comment = options.comment;
  const name = options.title && options.title.error || ERROR;

  throw new ValidationError(name, message, comment);
};

var errors = {
  ValidationError,
  errorMessage };

var _require$2 =



utils$3;const logValidationWarning$1 = _require$2.logValidationWarning; const DEPRECATION$2 = _require$2.DEPRECATION;

const deprecationMessage = (message, options) => {
  const comment = options.comment;
  const name = options.title && options.title.deprecation || DEPRECATION$2;

  logValidationWarning$1(name, message, comment);
};

const deprecationWarning$1 = (
config,
option,
deprecatedOptions,
options) =>
{
  if (option in deprecatedOptions) {
    deprecationMessage(deprecatedOptions[option](config), options);
  }
};

var deprecated = {
  deprecationWarning: deprecationWarning$1 };

const chalk$4 = index$12;var _require$3 =





utils$3;const format$4 = _require$3.format; const logValidationWarning$2 = _require$3.logValidationWarning; const createDidYouMeanMessage$1 = _require$3.createDidYouMeanMessage; const WARNING$2 = _require$3.WARNING;

const unknownOptionWarning$1 = (
config,
exampleConfig,
option,
options) =>
{
  const didYouMean =
  createDidYouMeanMessage$1(option, Object.keys(exampleConfig));
  /* eslint-disable max-len */
  const message =
  `  Unknown option ${ chalk$4.bold(`"${ option }"`) } with value ${ chalk$4.bold(format$4(config[option])) } was found.` + (
  didYouMean && ` ${ didYouMean }`) +
  `\n  This is probably a typing mistake. Fixing it will remove this message.`;
  /* eslint-enable max-len */

  const comment = options.comment;
  const name = options.title && options.title.warning || WARNING$2;

  logValidationWarning$2(name, message, comment);
};

var warnings = {
  unknownOptionWarning: unknownOptionWarning$1 };

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

const config = {
  comment: '  A comment',
  condition: (option, validOption) => true,
  deprecate: (config, option, deprecatedOptions, options) => {},
  deprecatedConfig: {
    key: config => {} },

  error: (option, received, defaultValue, options) => {},
  exampleConfig: { key: 'value', test: 'case' },
  title: {
    deprecation: 'Deprecation Warning',
    error: 'Validation Error',
    warning: 'Validation Warning' },

  unknown: (config, option, options) => {} };


var exampleConfig$2 = config;

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

const toString$1 = Object.prototype.toString;

const validationCondition$1 = (
option,
validOption) =>
{
  return (
    option === null ||
    option === undefined ||
    toString$1.call(option) === toString$1.call(validOption));

};

var condition = validationCondition$1;

var _require$1 =



deprecated;const deprecationWarning = _require$1.deprecationWarning;var _require2$1 =
warnings;const unknownOptionWarning = _require2$1.unknownOptionWarning;var _require3 =
errors;const errorMessage$1 = _require3.errorMessage;
const exampleConfig$1 = exampleConfig$2;
const validationCondition = condition;var _require4 =
utils$3;const ERROR$2 = _require4.ERROR; const DEPRECATION$1 = _require4.DEPRECATION; const WARNING$1 = _require4.WARNING;

var defaultConfig$1 = {
  comment: '',
  condition: validationCondition,
  deprecate: deprecationWarning,
  deprecatedConfig: {},
  error: errorMessage$1,
  exampleConfig: exampleConfig$1,
  title: {
    deprecation: DEPRECATION$1,
    error: ERROR$2,
    warning: WARNING$1 },

  unknown: unknownOptionWarning };

const defaultConfig = defaultConfig$1;

const _validate = (config, options) => {
  for (const key in config) {
    if (hasOwnProperty.call(options.exampleConfig, key)) {
      if (
      typeof options.condition === 'function' &&
      typeof options.error === 'function' &&
      !options.condition(config[key], options.exampleConfig[key]))
      {
        options.error(key, config[key], options.exampleConfig[key], options);
      }
    } else if (
    options.deprecatedConfig &&
    key in options.deprecatedConfig &&
    typeof options.deprecate === 'function')
    {
      options.deprecate(config, key, options.deprecatedConfig, options);
    } else {
      options.unknown &&
      options.unknown(config, options.exampleConfig, key, options);
    }
  }
};

const validate$1 = (config, options) => {
  _validate(options, defaultConfig); // validate against jest-validate config

  const defaultedOptions = Object.assign(
  {},
  defaultConfig,
  options,
  { title: Object.assign({}, defaultConfig.title, options.title) });


  _validate(config, defaultedOptions);

  return true;
};

var validate_1 = validate$1;

var index$34 = {
  ValidationError: errors.ValidationError,
  createDidYouMeanMessage: utils$3.createDidYouMeanMessage,
  logValidationWarning: utils$3.logValidationWarning,
  validate: validate_1 };

const deprecated$2 = {
  useFlowParser: config =>
    `  The ${'"useFlowParser"'} option is deprecated. Use ${'"parser"'} instead.

  Prettier now treats your configuration as:
  {
    ${'"parser"'}: ${config.useFlowParser ? '"flow"' : '"babylon"'}
  }`
};

var deprecated_1 = deprecated$2;

var validate = index$34.validate;
var deprecatedConfig = deprecated_1;

var defaults = {
  tabWidth: 2,
  printWidth: 80,
  singleQuote: false,
  trailingComma: false,
  bracketSpacing: true,
  jsxBracketSameLine: false,
  parser: "babylon"
};

var exampleConfig = Object.assign({}, defaults, {
  filename: "testFilename",
  printWidth: 80,
  originalText: "text"
});

// Copy options and fill in default values.
function normalize$1(options) {
  validate(options, { exampleConfig, deprecatedConfig });
  const normalized = Object.assign({}, options || {});

  // For backward compatibility. Deprecated in 0.0.10
  if ("useFlowParser" in normalized) {
    normalized.parser = normalized.useFlowParser ? "flow" : "babylon";
    delete normalized.useFlowParser;
  }

  Object.keys(defaults).forEach(k => {
    if (normalized[k] == null) {
      normalized[k] = defaults[k];
    }
  });

  return normalized;
}

var options$1 = { normalize: normalize$1 };

var flow_parser = createCommonjsModule(function (module, exports) {
// Generated by js_of_ocaml 2.7
(function(a8){"use strict";var
dR=104,g0="filter",ef=254,I=108,d1="i",fZ="expressions",gM="Invalid_argument",fY='"',bs="get",g_="Identifier",aX=16777215,gA="function",cQ="variance",gZ="exported",dQ=65599,fB="jsError",gY="o",gz=402,d0="consequent",gd=512,gL="&",gW="src/parser/expression_parser.ml",gX="(global)",gy="End_of_file",ec=120,gw="new",gx="Failure",d6="label",cW="local",fX="empty",bU="params",fO="shorthand",R=128,aW="0",P=248,gc=-43,dZ="constructor",aL="src/parser/spider_monkey_ast.ml",gb="yield",dY="%#",fN="Sys_blocked_io",f$=-53,ga="fd ",gK="superTypeParameters",g9=1023,f_="var",bO=107,ac="camlinternalFormat.ml",fW="Division_by_zero",f9="0o",gv="elements",gt="each",gu="Sys_error",gV=112,eb="x",ee="decorators",fM="protected",fK=-97,fL=1114111,dP=-69,cK=1073741823,gJ=780,fJ="%u",cY=105,d5="object",gU="%d",ed="method",ci=110,fV=57343,cO="'",fA="Unix",f8="Popping lex mode from empty stack",gs=218,cV="int_of_string",ce="operator",f7=-80,ck="from",a5="name",c0=789,c3="e",dX="d",cM="returnType",fI="X",bc="-",gr="callee",gI=-24,gT=-48,ch="async",dW="src/parser/statement_parser.ml",gq="*-/",cU="predicate",bP="set",dL="types",dO=" : file already exists",f6=109,cT=240,br="left",be="right",ea=2048,fz=216,fU=-66,b="body",dK="0x",cS="optional",f5="Out_of_memory",fy="\n",f4=101,f3="index out of bounds",gp=955,bN="typeof",g8="package",gS="Lookahead.peek failed",T=255,cX=224,fx=199,fH="public",go="loc",fT=65536,gH="enum",gG="in",d_="src/parser/lexer_flow.mll",d$="properties",bT="type",cn=250,cq=1024,bL="source",fG="interface",d9="arguments",g7="module",a6="static",d8="declaration",cZ=246,cg=102,gn="lexing: empty token",dJ="generator",fF=-10,cj="init",dV=113,g6="private",fE="% ",cL="default",u="",gR="Stack_overflow",dN="exportKind",d3=-79,gF="instanceof",g5="Property",c2="implements",gm=948,ah=100,av="argument",gQ="Not_found",bS="src/parser/type_parser.ml",c1=103,bu="raw",fD="Match_failure",fC=-40,f2="alternate",gl=189,gE=1e3,g4=223,cP=".",cf="+",cl=65535,cp=106,bR="kind",gk="prefix",gP="superClass",gO="const",aI="typeParameters",fS="delete",fR="blocks",gj=252,F=127,d7="false",bK="key",bM="test",gN=133,g3="mixins",bd=" ",d4="void",gh="RestElement",gi="Undefined_recursive_module",gD="let",bt=256,dT=":",gC="nan",cN=192,gg=116,bQ="expression",g2=65520,Z="value",aV="typeAnnotation",fQ="minus",f1=56320,fP=245,gB="%+",dI="specifiers",cR="Set.bal",bq="%",cm="/",g1="Assert_failure",dM="property",f0=114,co="computed",gf="%i",aU="as",ai="id",dS="true",d2="extends",ge="importKind",dU="null";function
hr(a,b){throw[0,a,b]}var
U=[0];function
Hz(c,b){function
f(a){hr(U.Undefined_recursive_module,c);}function
e(a,b,c){if(typeof
a==="number")switch(a){case
0:b[c]={fun:f};break;case
1:b[c]=[cZ,f];break;default:b[c]=[];}else
switch(a[0]){case
0:b[c]=[0];for(var
d=1;d<a[1].length;d++)e(a[1][d],b[c],d);break;default:b[c]=a[1];}}var
a=[];e(b,a,0);return a[0]}function
e(a,b){if(typeof
b===gA){a.fun=b;return 0}if(b.fun){a.fun=b.fun;return 0}var
c=b.length;while(c--)a[c]=b[c];return 0}function
g$(a,b,c){if(typeof
a==="number")switch(a){case
0:b.fun=c;break;case
1:default:e(b,c);}else
switch(a[0]){case
0:for(var
d=1;d<a[1].length;d++)g$(a[1][d],b[d],c[d]);break}return 0}function
HA(a,b){var
g=a.length,h=b.length,f=g+h-1,d=new
Array(f);d[0]=0;var
c=1,e=1;for(;c<g;c++)d[c]=a[c];for(;c<f;c++,e++)d[c]=b[e];return d}function
HB(a,b,c,d,e){if(d<=b)for(var
f=1;f<=e;f++)c[d+f]=a[b+f];else
for(var
f=e;f>=1;f--)c[d+f]=a[b+f];return 0}function
hb(a,b,c){var
d=new
Array(c+1);d[0]=0;for(var
e=1,f=b+1;e<=c;e++,f++)d[e]=a[f];return d}function
db(a,b,c){var
e=new
Array(c);for(var
d=0;d<c;d++)e[d]=a[b+d];return e}function
ek(a,b,c){var
d=String.fromCharCode;if(b==0&&c<=4096&&c==a.length)return d.apply(null,a);var
e=u;for(;0<c;b+=cq,c-=cq)e+=d.apply(null,db(a,b,Math.min(c,cq)));return e}function
c5(a){var
c=new
Array(a.l),e=a.c,d=e.length,b=0;for(;b<d;b++)c[b]=e.charCodeAt(b);for(d=a.l;b<d;b++)c[b]=0;a.c=c;a.t=4;return c}function
aM(a,b,c,d,e){if(e==0)return 0;if(d==0&&(e>=c.l||c.t==2&&e>=c.c.length)){c.c=a.t==4?ek(a.c,b,e):b==0&&a.c.length==e?a.c:a.c.substr(b,e);c.t=c.c.length==c.l?0:2;}else
if(c.t==2&&d==c.c.length){c.c+=a.t==4?ek(a.c,b,e):b==0&&a.c.length==e?a.c:a.c.substr(b,e);c.t=c.c.length==c.l?0:2;}else{if(c.t!=4)c5(c);var
g=a.c,h=c.c;if(a.t==4)for(var
f=0;f<e;f++)h[d+f]=g[b+f];else{var
i=Math.min(e,g.length-b);for(var
f=0;f<i;f++)h[d+f]=g.charCodeAt(b+f);for(;f<e;f++)h[d+f]=0;}}return 0}function
Iq(a,b){var
e=a.length,d=new
Array(e+1),c=0;for(;c<e;c++)d[c]=a[c];d[c]=b;return d}function
bg(c,b){if(c.fun)return bg(c.fun,b);var
a=c.length,d=b.length,e=a-d;if(e==0)return c.apply(null,b);else
if(e<0)return bg(c.apply(null,db(b,0,a)),db(b,a,d-a));else
return function(a){return bg(c,Iq(b,a))}}function
c$(a,b){if(b.repeat)return b.repeat(a);var
c=u,d=0;if(a==0)return c;for(;;){if(a&1)c+=b;a>>=1;if(a==0)return c;b+=b;d++;if(d==9)b.slice(0,1);}}function
a7(a){if(a.t==2)a.c+=c$(a.l-a.c.length,"\0");else
a.c=ek(a.c,0,a.c.length);a.t=0;}function
hg(a){if(a.length<24){for(var
b=0;b<a.length;b++)if(a.charCodeAt(b)>F)return false;return true}else
return!/[^\x00-\x7f]/.test(a)}function
Im(a){for(var
j=u,d=u,g,f,h,b,c=0,i=a.length;c<i;c++){f=a.charCodeAt(c);if(f<R){for(var
e=c+1;e<i&&(f=a.charCodeAt(e))<R;e++);if(e-c>gd){d.substr(0,1);j+=d;d=u;j+=a.slice(c,e);}else
d+=a.slice(c,e);if(e==i)break;c=e;}b=1;if(++c<i&&((h=a.charCodeAt(c))&-64)==R){g=h+(f<<6);if(f<cX){b=g-12416;if(b<R)b=1;}else{b=2;if(++c<i&&((h=a.charCodeAt(c))&-64)==R){g=h+(g<<6);if(f<cT){b=g-925824;if(b<ea||b>=55295&&b<57344)b=2;}else{b=3;if(++c<i&&((h=a.charCodeAt(c))&-64)==R&&f<fP){b=h-63447168+(g<<6);if(b<fT||b>fL)b=3;}}}}}if(b<4){c-=b;d+="\ufffd";}else
if(b>cl)d+=String.fromCharCode(55232+(b>>10),f1+(b&g9));else
d+=String.fromCharCode(b);if(d.length>cq){d.substr(0,1);j+=d;d=u;}}return j+d}function
Il(a){switch(a.t){case
9:return a.c;default:a7(a);case
0:if(hg(a.c)){a.t=9;return a.c}a.t=8;case
8:return Im(a.c)}}function
aw(a,b,c){this.t=a;this.c=b;this.l=c;}aw.prototype.toString=function(){return Il(this)};function
d(a){return new
aw(0,a,a.length)}function
ej(a,b){hr(a,d(b));}function
bX(a){ej(U.Invalid_argument,a);}function
HC(){bX(f3);}function
f(a,b){if(b>>>0>=a.length-1)HC();return a}function
HD(a){if(isFinite(a)){if(Math.abs(a)>=2.22507385850720138e-308)return 0;if(a!=0)return 1;return 2}return isNaN(a)?4:3}function
HM(a,b){var
c=a[3]<<16,d=b[3]<<16;if(c>d)return 1;if(c<d)return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
HX(a,b){if(a<b)return-1;if(a==b)return 0;return 1}function
A(a,b){a.t&6&&a7(a);b.t&6&&a7(b);return a.c<b.c?-1:a.c>b.c?1:0}function
c4(a,b,c){var
e=[];for(;;){if(!(c&&a===b))if(a
instanceof
aw)if(b
instanceof
aw){if(a!==b){var
d=A(a,b);if(d!=0)return d}}else
return 1;else
if(a
instanceof
Array&&a[0]===(a[0]|0)){var
f=a[0];if(f===ef)f=0;if(f===cn){a=a[1];continue}else
if(b
instanceof
Array&&b[0]===(b[0]|0)){var
g=b[0];if(g===ef)g=0;if(g===cn){b=b[1];continue}else
if(f!=g)return f<g?-1:1;else
switch(f){case
248:var
d=HX(a[2],b[2]);if(d!=0)return d;break;case
251:bX("equal: abstract value");case
255:var
d=HM(a,b);if(d!=0)return d;break;default:if(a.length!=b.length)return a.length<b.length?-1:1;if(a.length>1)e.push(a,b,1);}}else
return 1}else
if(b
instanceof
aw||b
instanceof
Array&&b[0]===(b[0]|0))return-1;else
if(typeof
a!="number"&&a&&a.compare)return a.compare(b,c);else{if(a<b)return-1;if(a>b)return 1;if(a!=b){if(!c)return NaN;if(a==a)return 1;if(b==b)return-1}}if(e.length==0)return 0;var
h=e.pop();b=e.pop();a=e.pop();if(h+1<a.length)e.push(a,b,h+1);a=a[h];b=b[h];}}function
bW(a,b){return c4(a,b,true)}function
ad(a){if(a<0)bX("String.create");return new
aw(a?2:9,u,a)}function
hc(a,b){return+(c4(a,b,false)==0)}function
HF(a,b,c,d){if(c>0)if(b==0&&(c>=a.l||a.t==2&&c>=a.c.length))if(d==0){a.c=u;a.t=2;}else{a.c=c$(c,String.fromCharCode(d));a.t=c==a.l?0:2;}else{if(a.t!=4)c5(a);for(c+=b;b<c;b++)a.c[b]=d;}return 0}function
bw(a){ej(U.Failure,a);}function
bV(a){if((a.t&6)!=0)a7(a);return a.c}function
HG(a){var
b;a=bV(a);b=+a;if(a.length>0&&b===b)return b;a=a.replace(/_/g,u);b=+a;if(a.length>0&&b===b||/^[+-]?nan$/i.test(a))return b;if(/^ *0x[0-9a-f_]+p[+-]?[0-9_]+/i.test(a)){var
c=a.indexOf("p");c=c==-1?a.indexOf("P"):c;var
d=+a.substring(c+1);b=+a.substring(0,c);return b*Math.pow(2,d)}if(/^\+?inf(inity)?$/i.test(a))return Infinity;if(/^-inf(inity)?$/i.test(a))return-Infinity;bw("float_of_string");}function
ei(a){a=bV(a);var
e=a.length;if(e>31)bX("format_int: format too long");var
b={justify:cf,signstyle:bc,filler:bd,alternate:false,base:0,signedconv:false,width:0,uppercase:false,sign:1,prec:-1,conv:"f"};for(var
d=0;d<e;d++){var
c=a.charAt(d);switch(c){case"-":b.justify=bc;break;case"+":case" ":b.signstyle=c;break;case"0":b.filler=aW;break;case"#":b.alternate=true;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":b.width=0;while(c=a.charCodeAt(d)-48,c>=0&&c<=9){b.width=b.width*10+c;d++;}d--;break;case".":b.prec=0;d++;while(c=a.charCodeAt(d)-48,c>=0&&c<=9){b.prec=b.prec*10+c;d++;}d--;case"d":case"i":b.signedconv=true;case"u":b.base=10;break;case"x":b.base=16;break;case"X":b.base=16;b.uppercase=true;break;case"o":b.base=8;break;case"e":case"f":case"g":b.signedconv=true;b.conv=c;break;case"E":case"F":case"G":b.signedconv=true;b.uppercase=true;b.conv=c.toLowerCase();break}}return b}function
eg(a,b){if(a.uppercase)b=b.toUpperCase();var
f=b.length;if(a.signedconv&&(a.sign<0||a.signstyle!=bc))f++;if(a.alternate){if(a.base==8)f+=1;if(a.base==16)f+=2;}var
c=u;if(a.justify==cf&&a.filler==bd)for(var
e=f;e<a.width;e++)c+=bd;if(a.signedconv)if(a.sign<0)c+=bc;else
if(a.signstyle!=bc)c+=a.signstyle;if(a.alternate&&a.base==8)c+=aW;if(a.alternate&&a.base==16)c+=dK;if(a.justify==cf&&a.filler==aW)for(var
e=f;e<a.width;e++)c+=aW;c+=b;if(a.justify==bc)for(var
e=f;e<a.width;e++)c+=bd;return d(c)}function
HH(a,b){var
c,f=ei(a),e=f.prec<0?6:f.prec;if(b<0){f.sign=-1;b=-b;}if(isNaN(b)){c=gC;f.filler=bd;}else
if(!isFinite(b)){c="inf";f.filler=bd;}else
switch(f.conv){case"e":var
c=b.toExponential(e),d=c.length;if(c.charAt(d-3)==c3)c=c.slice(0,d-1)+aW+c.slice(d-1);break;case"f":c=b.toFixed(e);break;case"g":e=e?e:1;c=b.toExponential(e-1);var
i=c.indexOf(c3),h=+c.slice(i+1);if(h<-4||b>=1e+21||b.toFixed(0).length>e){var
d=i-1;while(c.charAt(d)==aW)d--;if(c.charAt(d)==cP)d--;c=c.slice(0,d+1)+c.slice(i);d=c.length;if(c.charAt(d-3)==c3)c=c.slice(0,d-1)+aW+c.slice(d-1);break}else{var
g=e;if(h<0){g-=h+1;c=b.toFixed(g);}else
while(c=b.toFixed(g),c.length>e+1)g--;if(g){var
d=c.length-1;while(c.charAt(d)==aW)d--;if(c.charAt(d)==cP)d--;c=c.slice(0,d+1);}}break}return eg(f,c)}function
c6(a,b){if(bV(a)==gU)return d(u+b);var
c=ei(a);if(b<0)if(c.signedconv){c.sign=-1;b=-b;}else
b>>>=0;var
e=b.toString(c.base);if(c.prec>=0){c.filler=bd;var
f=c.prec-e.length;if(f>0)e=c$(f,aW)+e;}return eg(c,e)}function
HJ(a,b){return+(c4(a,b,false)>=0)}function
hd(a){if(!isFinite(a)){if(isNaN(a))return[T,1,0,g2];return a>0?[T,0,0,32752]:[T,0,0,g2]}var
f=a>=0?0:32768;if(f)a=-a;var
b=Math.floor(Math.LOG2E*Math.log(a))+g9;if(b<=0){b=0;a/=Math.pow(2,-1026);}else{a/=Math.pow(2,b-1027);if(a<16){a*=2;b-=1;}if(b==0)a/=2;}var
d=Math.pow(2,24),c=a|0;a=(a-c)*d;var
e=a|0;a=(a-e)*d;var
g=a|0;c=c&15|f|b<<4;return[T,g,e,c]}if(!Math.imul)Math.imul=function(a,b){b|=0;return((a>>16)*b<<16)+(a&cl)*b|0};var
bY=Math.imul,HK=function(){var
o=bt;function
c(a,b){return a<<b|a>>>32-b}function
g(a,b){b=bY(b,3432918353|0);b=c(b,15);b=bY(b,461845907);a^=b;a=c(a,13);return(a+(a<<2)|0)+(3864292196|0)|0}function
q(a){a^=a>>>16;a=bY(a,2246822507|0);a^=a>>>13;a=bY(a,3266489909|0);a^=a>>>16;return a}function
r(a,b){var
d=b[1]|b[2]<<24,c=b[2]>>>8|b[3]<<16;a=g(a,d);a=g(a,c);return a}function
s(a,b){var
d=b[1]|b[2]<<24,c=b[2]>>>8|b[3]<<16;a=g(a,c^d);return a}function
u(a,b){var
e=b.length,c,d;for(c=0;c+4<=e;c+=4){d=b.charCodeAt(c)|b.charCodeAt(c+1)<<8|b.charCodeAt(c+2)<<16|b.charCodeAt(c+3)<<24;a=g(a,d);}d=0;switch(e&3){case
3:d=b.charCodeAt(c+2)<<16;case
2:d|=b.charCodeAt(c+1)<<8;case
1:d|=b.charCodeAt(c);a=g(a,d);}a^=e;return a}function
t(a,b){var
e=b.length,c,d;for(c=0;c+4<=e;c+=4){d=b[c]|b[c+1]<<8|b[c+2]<<16|b[c+3]<<24;a=g(a,d);}d=0;switch(e&3){case
3:d=b[c+2]<<16;case
2:d|=b[c+1]<<8;case
1:d|=b[c];a=g(a,d);}a^=e;return a}return function(a,b,c,d){var
k,l,m,i,h,f,e,j,n;i=b;if(i<0||i>o)i=o;h=a;f=c;k=[d];l=0;m=1;while(l<m&&h>0){e=k[l++];if(e
instanceof
Array&&e[0]===(e[0]|0))switch(e[0]){case
248:f=g(f,e[2]);h--;break;case
250:k[--l]=e[1];break;case
255:f=s(f,e);h--;break;default:var
p=e.length-1<<10|e[0];f=g(f,p);for(j=1,n=e.length;j<n;j++){if(m>=i)break;k[m++]=e[j];}break}else
if(e
instanceof
aw){switch(e.t&6){default:a7(e);case
0:f=u(f,e.c);break;case
2:f=t(f,e.c);}h--;}else
if(e===(e|0)){f=g(f,e+e+1);h--;}else
if(e===+e){f=r(f,hd(e));h--;}}f=q(f);return f&cK}}();function
HU(a){return[a[3]>>8,a[3]&T,a[2]>>16,a[2]>>8&T,a[2]&T,a[1]>>16,a[1]>>8&T,a[1]&T]}function
HL(e,b,c){var
d=0;function
g(a){b--;if(e<0||b<0)return;if(a
instanceof
Array&&a[0]===(a[0]|0))switch(a[0]){case
248:e--;d=d*dQ+a[2]|0;break;case
250:b++;g(a);break;case
255:e--;d=d*dQ+a[1]+(a[2]<<24)|0;break;default:e--;d=d*19+a[0]|0;for(var
c=a.length-1;c>0;c--)g(a[c]);}else
if(a
instanceof
aw){e--;switch(a.t&6){default:a7(a);case
0:for(var
i=a.c,f=a.l,c=0;c<f;c++)d=d*19+i.charCodeAt(c)|0;break;case
2:for(var
h=a.c,f=a.l,c=0;c<f;c++)d=d*19+h[c]|0;}}else
if(a===(a|0)){e--;d=d*dQ+a|0;}else
if(a===+a){e--;var
j=HU(hd(a));for(var
c=7;c>=0;c--)d=d*19+j[c]|0;}}g(c);return d&cK}function
HP(a){return(a[3]|a[2]|a[1])==0}function
HS(a){return[T,a&aX,a>>24&aX,a>>31&cl]}function
hm(a){var
d=a.length,c=new
Array(d);for(var
b=0;b<d;b++)c[b]=a[b];return c}function
HT(a,b){var
c=a[1]-b[1],d=a[2]-b[2]+(c>>24),e=a[3]-b[3]+(d>>24);return[T,c&aX,d&aX,e&cl]}function
hf(a,b){if(a[3]>b[3])return 1;if(a[3]<b[3])return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
he(a){a[3]=a[3]<<1|a[2]>>23;a[2]=(a[2]<<1|a[1]>>23)&aX;a[1]=a[1]<<1&aX;}function
HQ(a){a[1]=(a[1]>>>1|a[2]<<23)&aX;a[2]=(a[2]>>>1|a[3]<<23)&aX;a[3]=a[3]>>>1;}function
HW(a,b){var
e=0,d=hm(a),c=hm(b),f=[T,0,0,0];while(hf(d,c)>0){e++;he(c);}while(e>=0){e--;he(f);if(hf(d,c)>=0){f[1]++;d=HT(d,c);}HQ(c);}return[0,f,d]}function
HV(a){return a[1]|a[2]<<24}function
HO(a){return a[3]<<16<0}function
HR(a){var
b=-a[1],c=-a[2]+(b>>24),d=-a[3]+(c>>24);return[T,b&aX,c&aX,d&cl]}function
HN(a,b){var
c=ei(a);if(c.signedconv&&HO(b)){c.sign=-1;b=HR(b);}var
d=u,h=HS(c.base),g="0123456789abcdef";do{var
f=HW(b,h);b=f[1];d=g.charAt(HV(f[2]))+d;}while(!HP(b));if(c.prec>=0){c.filler=bd;var
e=c.prec-d.length;if(e>0)d=c$(e,aW)+d;}return eg(c,d)}function
aN(a,b){switch(a.t&6){default:if(b>=a.c.length)return 0;case
0:return a.c.charCodeAt(b);case
4:return a.c[b]}}function
x(a){return a.l}function
Ia(a){var
b=0,d=x(a),c=10,e=d>0&&aN(a,0)==45?(b++,-1):1;if(b+1<d&&aN(a,b)==48)switch(aN(a,b+1)){case
120:case
88:c=16;b+=2;break;case
111:case
79:c=8;b+=2;break;case
98:case
66:c=2;b+=2;break}return[b,e,c]}function
ho(a){if(a>=48&&a<=57)return a-48;if(a>=65&&a<=90)return a-55;if(a>=97&&a<=122)return a-87;return-1}function
bh(a){var
h=Ia(a),d=h[0],i=h[1],e=h[2],g=x(a),j=-1>>>0,f=d<g?aN(a,d):0,c=ho(f);if(c<0||c>=e)bw(cV);var
b=c;for(d++;d<g;d++){f=aN(a,d);if(f==95)continue;c=ho(f);if(c<0||c>=e)break;b=e*b+c;if(b>j)bw(cV);}if(d!=g)bw(cV);b=i*b;if(e==10&&(b|0)!=b)bw(cV);return b|0}function
c7(a){return+(a>31&&a<F)}function
HY(a){return db(a,1,a.length-1)}function
HZ(a){return!!a}function
H0(a){return a.toString()}function
H1(a){var
c={};for(var
b=1;b<a.length;b++){var
d=a[b];c[d[1].toString()]=d[2];}return c}function
In(a){for(var
f=u,c=f,b,h,d=0,g=a.length;d<g;d++){b=a.charCodeAt(d);if(b<R){for(var
e=d+1;e<g&&(b=a.charCodeAt(e))<R;e++);if(e-d>gd){c.substr(0,1);f+=c;c=u;f+=a.slice(d,e);}else
c+=a.slice(d,e);if(e==g)break;d=e;}if(b<ea){c+=String.fromCharCode(cN|b>>6);c+=String.fromCharCode(R|b&63);}else
if(b<55296||b>=fV)c+=String.fromCharCode(cX|b>>12,R|b>>6&63,R|b&63);else
if(b>=56319||d+1==g||(h=a.charCodeAt(d+1))<f1||h>fV)c+="\xef\xbf\xbd";else{d++;b=(b<<10)+h-56613888;c+=String.fromCharCode(cT|b>>18,R|b>>12&63,R|b>>6&63,R|b&63);}if(c.length>cq){c.substr(0,1);f+=c;c=u;}}return f+c}function
cr(a){var
b=9;if(!hg(a))b=8,a=In(a);return new
aw(b,a,a.length)}function
aq(a){a=bV(a);var
d=a.length/2,c=new
Array(d);for(var
b=0;b<d;b++)c[b]=(a.charCodeAt(2*b)|a.charCodeAt(2*b+1)<<8)<<16>>16;return c}function
ha(a){if(a.t!=4)c5(a);return a.c}function
H2(a,b,c){var
o=2,p=3,s=5,e=6,i=7,h=8,k=9,n=1,m=2,r=3,t=4,q=5;if(!a.lex_default){a.lex_base=aq(a[n]);a.lex_backtrk=aq(a[m]);a.lex_check=aq(a[q]);a.lex_trans=aq(a[t]);a.lex_default=aq(a[r]);}var
f,d=b,l=ha(c[o]);if(d>=0){c[i]=c[s]=c[e];c[h]=-1;}else
d=-d-1;for(;;){var
g=a.lex_base[d];if(g<0)return-g-1;var
j=a.lex_backtrk[d];if(j>=0){c[i]=c[e];c[h]=j;}if(c[e]>=c[p])if(c[k]==0)return-d-1;else
f=bt;else{f=l[c[e]];c[e]++;}d=a.lex_check[g+f]==d?a.lex_trans[g+f]:a.lex_default[d];if(d<0){c[e]=c[i];if(c[h]==-1)bw(gn);else
return c[h]}else
if(f==bt)c[k]=0;}}function
hi(a){var
c=0;for(var
b=a.length-1;b>=0;b--){var
d=a[b];c=[0,d,c];}return c}function
bx(a,b){var
a=a+1|0,c=new
Array(a);c[0]=0;for(var
d=1;d<a;d++)c[d]=b;return c}function
hu(a){return new
aw(4,a,a.length)}var
H4=function(){function
m(a,b){return a+b|0}function
l(a,b,c,d,e,f){b=m(m(b,a),m(d,f));return m(b<<e|b>>>32-e,c)}function
h(a,b,c,d,e,f,g){return l(b&c|~b&d,a,b,e,f,g)}function
i(a,b,c,d,e,f,g){return l(b&d|c&~d,a,b,e,f,g)}function
j(a,b,c,d,e,f,g){return l(b^c^d,a,b,e,f,g)}function
k(a,b,c,d,e,f,g){return l(c^(b|~d),a,b,e,f,g)}function
n(a,b){var
g=b;a[g>>2]|=R<<8*(g&3);for(g=(g&~3)+8;(g&63)<60;g+=4)a[(g>>2)-1]=0;a[(g>>2)-1]=b<<3;a[g>>2]=b>>29&536870911;var
l=[1732584193,4023233417,2562383102,271733878];for(g=0;g<a.length;g+=16){var
c=l[0],d=l[1],e=l[2],f=l[3];c=h(c,d,e,f,a[g+0],7,3614090360);f=h(f,c,d,e,a[g+1],12,3905402710);e=h(e,f,c,d,a[g+2],17,606105819);d=h(d,e,f,c,a[g+3],22,3250441966);c=h(c,d,e,f,a[g+4],7,4118548399);f=h(f,c,d,e,a[g+5],12,1200080426);e=h(e,f,c,d,a[g+6],17,2821735955);d=h(d,e,f,c,a[g+7],22,4249261313);c=h(c,d,e,f,a[g+8],7,1770035416);f=h(f,c,d,e,a[g+9],12,2336552879);e=h(e,f,c,d,a[g+10],17,4294925233);d=h(d,e,f,c,a[g+11],22,2304563134);c=h(c,d,e,f,a[g+12],7,1804603682);f=h(f,c,d,e,a[g+13],12,4254626195);e=h(e,f,c,d,a[g+14],17,2792965006);d=h(d,e,f,c,a[g+15],22,1236535329);c=i(c,d,e,f,a[g+1],5,4129170786);f=i(f,c,d,e,a[g+6],9,3225465664);e=i(e,f,c,d,a[g+11],14,643717713);d=i(d,e,f,c,a[g+0],20,3921069994);c=i(c,d,e,f,a[g+5],5,3593408605);f=i(f,c,d,e,a[g+10],9,38016083);e=i(e,f,c,d,a[g+15],14,3634488961);d=i(d,e,f,c,a[g+4],20,3889429448);c=i(c,d,e,f,a[g+9],5,568446438);f=i(f,c,d,e,a[g+14],9,3275163606);e=i(e,f,c,d,a[g+3],14,4107603335);d=i(d,e,f,c,a[g+8],20,1163531501);c=i(c,d,e,f,a[g+13],5,2850285829);f=i(f,c,d,e,a[g+2],9,4243563512);e=i(e,f,c,d,a[g+7],14,1735328473);d=i(d,e,f,c,a[g+12],20,2368359562);c=j(c,d,e,f,a[g+5],4,4294588738);f=j(f,c,d,e,a[g+8],11,2272392833);e=j(e,f,c,d,a[g+11],16,1839030562);d=j(d,e,f,c,a[g+14],23,4259657740);c=j(c,d,e,f,a[g+1],4,2763975236);f=j(f,c,d,e,a[g+4],11,1272893353);e=j(e,f,c,d,a[g+7],16,4139469664);d=j(d,e,f,c,a[g+10],23,3200236656);c=j(c,d,e,f,a[g+13],4,681279174);f=j(f,c,d,e,a[g+0],11,3936430074);e=j(e,f,c,d,a[g+3],16,3572445317);d=j(d,e,f,c,a[g+6],23,76029189);c=j(c,d,e,f,a[g+9],4,3654602809);f=j(f,c,d,e,a[g+12],11,3873151461);e=j(e,f,c,d,a[g+15],16,530742520);d=j(d,e,f,c,a[g+2],23,3299628645);c=k(c,d,e,f,a[g+0],6,4096336452);f=k(f,c,d,e,a[g+7],10,1126891415);e=k(e,f,c,d,a[g+14],15,2878612391);d=k(d,e,f,c,a[g+5],21,4237533241);c=k(c,d,e,f,a[g+12],6,1700485571);f=k(f,c,d,e,a[g+3],10,2399980690);e=k(e,f,c,d,a[g+10],15,4293915773);d=k(d,e,f,c,a[g+1],21,2240044497);c=k(c,d,e,f,a[g+8],6,1873313359);f=k(f,c,d,e,a[g+15],10,4264355552);e=k(e,f,c,d,a[g+6],15,2734768916);d=k(d,e,f,c,a[g+13],21,1309151649);c=k(c,d,e,f,a[g+4],6,4149444226);f=k(f,c,d,e,a[g+11],10,3174756917);e=k(e,f,c,d,a[g+2],15,718787259);d=k(d,e,f,c,a[g+9],21,3951481745);l[0]=m(c,l[0]);l[1]=m(d,l[1]);l[2]=m(e,l[2]);l[3]=m(f,l[3]);}var
o=new
Array(16);for(var
g=0;g<4;g++)for(var
n=0;n<4;n++)o[g*4+n]=l[g]>>8*n&T;return o}return function(a,b,c){var
h=[];switch(a.t&6){default:a7(a);case
0:var
g=a.c;for(var
d=0;d<c;d+=4){var
e=d+b;h[d>>2]=g.charCodeAt(e)|g.charCodeAt(e+1)<<8|g.charCodeAt(e+2)<<16|g.charCodeAt(e+3)<<24;}for(;d<c;d++)h[d>>2]|=g.charCodeAt(d+b)<<8*(d&3);break;case
4:var
f=a.c;for(var
d=0;d<c;d+=4){var
e=d+b;h[d>>2]=f[e]|f[e+1]<<8|f[e+2]<<16|f[e+3]<<24;}for(;d<c;d++)h[d>>2]|=f[d+b]<<8*(d&3);}return hu(n(h,c))}}();function
aY(a){ej(U.Sys_error,a);}function
H5(a){if(!a.opened)aY("Cannot flush a closed channel");if(a.buffer==u)return 0;if(a.output)switch(a.output.length){case
2:a.output(a,a.buffer);break;default:a.output(a.buffer);}a.buffer=u;return 0}var
hv=0;function
Ir(){return new
Date().getTime()/gE}function
el(){return Math.floor(Ir())}function
bf(a){this.data=a;this.inode=hv++;var
b=el();this.atime=b;this.mtime=b;this.ctime=b;}bf.prototype={truncate:function(){this.data=ad(0);this.modified();},modified:function(){var
a=el();this.atime=a;this.mtime=a;}};var
HE=cm;function
bv(){this.content={};this.inode=hv++;var
a=el();this.atime=a;this.mtime=a;this.ctime=a;}bv.prototype={exists:function(a){return this.content[a]?1:0},mk:function(a,b){this.content[a]=b;},get:function(a){return this.content[a]},list:function(){var
a=[];for(var
b
in
this.content)a.push(b);return a},remove:function(a){delete
this.content[a];}};var
c_=new
bv();c_.mk(u,new
bv());function
ct(a,b,c){if(U.fds===undefined)U.fds=new
Array();c=c?c:{};var
d={};d.file=b;d.offset=c.append?x(b.data):0;d.flags=c;U.fds[a]=d;U.fd_last_idx=a;return a}ct(0,new
bf(ad(0)));ct(1,new
bf(ad(0)));ct(2,new
bf(ad(0)));function
H6(a){var
b=U.fds[a];if(b.flags.wronly)aY(ga+a+" is writeonly");return{file:b.file,offset:b.offset,fd:a,opened:true,refill:null}}function
Io(a){if(a.charCodeAt(a.length-1)==10)a=a.substr(0,a.length-1);var
b=a8.console;b&&b.error&&b.error(a);}function
Ip(a){if(a.charCodeAt(a.length-1)==10)a=a.substr(0,a.length-1);var
b=a8.console;b&&b.log&&b.log(a);}var
c9=new
Array();function
Ie(a,b){var
h=d(b),c=x(h),g=x(a.file.data),f=a.offset;if(f+c>=g){var
e=ad(f+c);aM(a.file.data,0,e,0,g);aM(h,0,e,f,c);a.file.data=e;}a.offset+=c;a.file.modified();return 0}function
hj(a){var
b;switch(a){case
1:b=Ip;break;case
2:b=Io;break;default:b=Ie;}var
d=U.fds[a];if(d.flags.rdonly)aY(ga+a+" is readonly");var
c={file:d.file,offset:d.offset,fd:a,opened:true,buffer:u,output:b};c9[c.fd]=c;return c}function
H7(){var
a=0;for(var
b
in
c9)if(c9[b].opened)a=[0,c9[b],a];return a}function
hp(a){throw a}function
Ic(){hp(U.Division_by_zero);}function
hk(a,b){if(b==0)Ic();return a%b}function
H3(a,b,c,d){for(;;){var
e=a.charCodeAt(b);b++;if(e==T)return;var
f=a.charCodeAt(b);b++;c[e+1]=f==T?d:c[f+1];}}function
hh(a,b,c){for(;;){var
d=a.charCodeAt(b);b++;if(d==T)return;var
e=a.charCodeAt(b);b++;c[d+1]=e==T?-1:c[e+1];}}function
H9(a,b,c){var
u=2,v=3,B=5,f=6,j=7,i=8,o=9,k=10,s=1,q=2,z=3,C=4,w=5,t=6,r=7,A=8,D=9,x=10,y=11;if(!a.lex_default){a.lex_base=aq(a[s]);a.lex_backtrk=aq(a[q]);a.lex_check=aq(a[w]);a.lex_trans=aq(a[C]);a.lex_default=aq(a[z]);}if(!a.lex_default_code){a.lex_base_code=aq(a[t]);a.lex_backtrk_code=aq(a[r]);a.lex_check_code=aq(a[x]);a.lex_trans_code=aq(a[D]);a.lex_default_code=aq(a[A]);}if(a.lex_code==null)a.lex_code=bV(a[y]);var
e,d=b,p=ha(c[u]);if(d>=0){c[j]=c[B]=c[f];c[i]=-1;}else
d=-d-1;for(;;){var
h=a.lex_base[d];if(h<0){var
g=a.lex_base_code[d];hh(a.lex_code,g,c[k]);return-h-1}var
m=a.lex_backtrk[d];if(m>=0){var
g=a.lex_backtrk_code[d];hh(a.lex_code,g,c[k]);c[j]=c[f];c[i]=m;}if(c[f]>=c[v])if(c[o]==0)return-d-1;else
e=bt;else{e=p[c[f]];c[f]++;}var
l=d;d=a.lex_check[h+e]==d?a.lex_trans[h+e]:a.lex_default[d];if(d<0){c[f]=c[j];if(c[i]==-1)bw(gn);else
return c[i]}else{var
n=a.lex_base_code[l],g;g=a.lex_check_code[n+e]==l?a.lex_trans_code[n+e]:a.lex_default_code[l];if(g>0)H3(a.lex_code,g,c[k],c[f]);if(e==bt)c[o]=0;}}}function
by(a,b){return+(c4(a,b,false)!=0)}function
H_(a,b){a[0]=b;return 0}function
hn(a){return a
instanceof
Array?a[0]:a
instanceof
aw?gj:gE}function
aJ(a,b,c){U[a+1]=b;if(c)U[c]=b;}var
hl={};function
Id(a,b){hl[bV(a)]=b;return 0}var
H$=0;function
aZ(a){a[2]=H$++;return a}function
ak(a,b){a.t&6&&a7(a);b.t&6&&a7(b);return a.c==b.c?1:0}function
ht(){bX(f3);}function
_(a,b){if(b>>>0>=a.l)ht();return aN(a,b)}function
j(a,b){return 1-ak(a,b)}function
S(a,b,c){c&=T;if(a.t!=4){if(b==a.c.length){a.c+=String.fromCharCode(c);if(b+1==a.l)a.t=0;return 0}c5(a);}a.c[b]=c;return 0}function
cs(a,b,c){if(b>>>0>=a.l)ht();return S(a,b,c)}function
If(){return 0}function
Ig(){return 32}function
Ii(){return[0,d(fA),32,0]}function
Ib(){hp(U.Not_found);}function
da(a){var
b=a8,c=a.toString();if(b.process&&b.process.env&&b.process.env[c]!=undefined)return cr(b.process.env[c]);Ib();}function
Ik(){var
a=new
Date()^4294967295*Math.random();return[0,a]}function
a(a){var
b=1;while(a&&a.joo_tramp){a=a.joo_tramp.apply(null,a.joo_args);b++;}return a}function
g(a,b){return{joo_tramp:a,joo_args:b}}function
hs(a){return a}function
H8(a){return hl[a]}function
al(a){if(a
instanceof
Array)return a;if(a8.RangeError&&a
instanceof
a8.RangeError&&a.message&&a.message.match(/maximum call stack/i))return hs(U.Stack_overflow);if(a8.InternalError&&a
instanceof
a8.InternalError&&a.message&&a.message.match(/too much recursion/i))return hs(U.Stack_overflow);if(a
instanceof
a8.Error)return[0,H8(fB),a];return[0,U.Failure,cr(String(a))]}function
i(a,b){return a.length==1?a(b):bg(a,[b])}function
m(a,b,c){return a.length==2?a(b,c):bg(a,[b,c])}function
w(a,b,c,d){return a.length==3?a(b,c,d):bg(a,[b,c,d])}function
bp(a,b,c,d,e){return a.length==4?a(b,c,d,e):bg(a,[b,c,d,e])}function
cd(a,b,c,d,e,f){return a.length==5?a(b,c,d,e,f):bg(a,[b,c,d,e,f])}var
dc=[P,d(gx),-3],em=[P,d(gM),-4],aj=[P,d(gQ),-7],v=[P,d(g1),-11],eu=[0,d(u),1,0,0],dp=[0,0,0],as=[0,d('\0\0\xb2\xff\xb3\xff\xb9\xffB\0C\0T\0W\0F\0I\0J\0K\0M\0e\0\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff\xe5\xff\xe6\xff\xe7\xff\xe8\xff\xc0\0L\0e\0\x17\x01n\x01\xf6\xff\xf7\xffl\0u\0v\0\0\0\x0e\0\x0f\0\x07\x003\x01\xfe\xff\xff\xff\x01\0\x12\0(\0\f\0\x15\0*\0\f\0=\0-\0\t\0\xb6\xff\xf9\xff\xe0\x01B\0u\0\x0f\x000\x004\0\x17\0\xe5\x01(\x008\0\x1a\0K\0:\0\x17\0\xfb\xffh\0a\0\xac\0q\0m\0y\0q\0i\0{\0{\0\xa8\0\xca\xff\xfa\xff\xc9\xff\xf8\xff\x0b\x02\xa5\x02\xfc\x02S\x03\xaa\x03\x01\x04X\x04\xaf\x04\x06\x05]\x05\xb4\x05\x0b\x06b\x06\xb9\x06\xc3\x01\x10\x07g\x07\xbe\x07\x15\bl\b\xc3\b\x1a\tq\t\xc8\t\xb8\0\xe2\xffE\x02\xc7\xff\xdc\xff\xc6\xff\xdb\xff\xb7\xff\xaa\0\xda\xff\xab\0\xd9\xff\xac\0\xd8\xff\xd2\xff\xad\0\xd7\xff\xb0\0\xd0\xff\xcf\xff\xcc\xff\xd4\xff\xcb\xff\xd3\xff\xc8\xff\xc5\xff:\n\xcc\xff\xcd\xff\xcf\xff\xd3\xff\xb0\0\xd9\xff\xda\xff\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff~\0\xe7\xff\x80\0\xe9\xff\xea\xff\x9a\0\x94\n\xfa\n\xd6\x01Q\x0b\xa8\x0b\x1a\f\xf9\xff\xcf\0\xf1\0D\0\x9c\0\x9d\0\xa3\0\xc4\x0b\xff\xff\x83\0\xc1\0\xd1\0\xf9\0\xb4\0\xc4\0\xa7\0\xcb\t\xd4\0\x96\0\xfa\xff\x1f\f\xea\0\x1d\x01\xb7\0\xf3\0\xf4\0\xfa\0$\f\xe9\0\x15\x01\xf7\0\xdf\x0b\x17\x01\xd9\0\xfc\xff,\x01&\x01{\x01@\x01<\x01H\x01@\x018\x01J\x01d\x01\xfb\xff\xf3\x01\x0f\x01K\x01j\x01c\x01K\f>\x01N\x01P\x01\xec\x0bp\x01?\x01x\f\xff\fV\r\xad\r\0\x02\x04\x0e[\x0e\xb2\x0e\t\x0f`\x0f\xb7\x0f\x0e\x10e\x10\xbc\x10\x13\x11j\x11\xc1\x11\x18\x12o\x12\xc6\x12\x1d\x13t\x13\xcb\x13"\x14\xd1\x01\xe2\xffy\x14\xd0\x14\'\x15~\x15\x99\x01\x9d\x01\xad\x01\xa6\x01\x9f\x01\xeb\xff\xe6\xff\xe5\xff\xd1\xff\x1b\f\xfc\xff\xfd\xff\xfe\xff\xff\xff\xcf\x15\xee\xff\x01\0\xef\xff\x18\x16\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xf9\xff\xf1\x02H\x03>\x16\xfe\xff\xff\xffU\x16\xfd\xff\x9f\x03\xfc\xff{\x16\x92\x16\xb8\x16\xcf\x16\xf2\xff\xf5\x16\xf1\xff\xd7\x02\xfb\xff\xea\x01\xfe\xff\xff\xff\xe4\x01\xfd\xff\xfc\xff;\x02\xfd\xff\xfe\xff\xff\xff\0\x17\xf9\xff\xee\x01`\x01\x9c\x01\xa0\x01*\x02)\fC\x15\xfe\xff\xff\xffc\x01\xad\x01\xc7\x01+\x02\xa0\x01\xba\x01\xaa\x01\x87\x15\xca\x01\xa7\x01\xfb\xff\xfc\xff\x0b\x16\xf8\xff\x04\0\xf9\xff\xfa\xff8\x17,\x03\xff\xff\xfd\xff\x05\0\xfe\xff\xc0\x17\x96\t\xfb\xff\xfc\xff\x0b\x02\xff\xff\xfd\xff\xfe\xff2\x18\xf1\xff\xf2\xff\x8a\x18\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xfa\xffv\x02\xb0\x01!\x02"\x023\x02\x88\x167\x18\xfe\xff\xff\xff\x05\x02L\x02_\x02\xf3\x02@\x02Q\x02C\x02\xbd\x16c\x02%\x02\xfb\xff\xfc\xff|\f\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x06\0\xff\xff\xfc\x18\xf9\xff\xf8\x18\x07\0\xfd\xff\xfe\xff\xff\xffO\x19\xdf\n_\f\x84\x17\x9c\x19\xfc\xff\xfb\xff\xd3\x19\xfa\xff*\x1a\x81\x1a\xd8\x1a/\x1b\x86\x1b\xaa\x02\xf8\x1b\xfa\xff\xfb\xff\xd6\x02G\x02\x83\x02\xa9\x02J\x03\x04\x19K\x1b\xff\xffp\x02\xb7\x02\xd7\x02\x8d\x03\xaa\x02\xba\x02\x9d\x02\xc9\x16\xd9\x02\x9b\x02\xfc\xff\xfd\xff\xc3\x16\xf9\xff\xfa\xff\b\0\xfc\xff\xe1\x02\xfe\xff\xff\xff\xfd\xff\xfb\xff'),d("\xff\xff\xff\xff\xff\xff\xff\xffD\0A\0>\0=\0<\0;\0E\0G\0B\0C\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\0K\0\x1e\0\x15\0\x15\0\xff\xff\xff\xffM\0?\0J\0M\0M\0M\0M\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x15\0\x14\0\x0f\0\x14\0\x14\0\x0b\0\n\0\r\0\f\0\x0e\0\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x13\0\x12\0\x11\0\x10\0\x15\0\x13\0\x12\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\0\xff\xff*\0\xff\xff.\0\xff\xff\xff\xff2\0\xff\xff1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff+\0\xff\xff\x17\0\xff\xff\xff\xff3\0\x13\0\x13\0\x1e\0\x12\0\x12\x001\0\xff\xff)\x003\x003\x003\x003\x003\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\0\x11\0\x11\0\x10\0\xff\xff\x10\0\x0f\0\x0f\0\x12\0\x11\0\f\0\x11\0\x11\0\b\0\x07\0\n\0\t\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0e\0\r\0\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\x05\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x06\0\x06\0\x06\0\x06\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\x04\0\x07\0\xff\xff\xff\xff\x01\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x0e\0\x0e\0\x0e\0\x0e\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x06\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff"),d("\x01\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\x01\x01\0\0\0\0\0\0\0\0\x06\x01\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0!\x01\0\0\xff\xff\0\0\0\0\xff\xff\0\0\0\0)\x01\0\0\0\0\0\0-\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0D\x01\0\0\xff\xff\0\0\0\0\xff\xffK\x01\0\0\0\0\xff\xff\0\0\xff\xffP\x01\0\0\0\0\xff\xff\0\0\0\0\0\0W\x01\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0v\x01\0\0\0\0\0\0\0\0\xff\xff\0\0}\x01\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x93\x01\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xaa\x01\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0"),d("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0(\0\b\x01&\0&\0F\x01M\x01{\x01\x80\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\n\0\x1e\0\x1f\0\x18\0\x05\0\r\0\x1e\0\x15\0\x14\0 \0\x07\0\x10\0\x06\0\x1a\0!\0\x1c\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x0f\0\x11\0\t\0\x0b\0\b\0\x0e\0\x19\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x13\0'\0\x12\0\x04\0\x18\0\x1d\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x17\0\f\0\x16\0\x03\0\x84\0\x83\0\x82\0\x80\0{\0z\0w\0x\0u\0s\0r\0p\0o\0m\0R\x001\x000\0/\0\x81\x001\0k\0\x7f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0N\x005\0.\0n\0&\0P\x004\0.\0-\x000\0/\0&\0&\0-\0&\0D\0C\0A\0>\0O\x003\0@\0?\0<\0=\0<\0<\0<\x002\x002\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0q\0B\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0E\0F\0G\0H\0I\0J\0K\0L\0M\0C\0%\0$\0#\0\x18\0Q\0l\0t\0v\0y\0}\0|\0&\0~\0\xff\0\"\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0<\0\xfe\0\xfd\0\xf7\0\xcc\0\xb1\0\x02\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xb3\0\xb0\0\xaf\0\xae\0\x18\0\xb2\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0S\0&\0\xad\0\xb1\0&\0&\0\xb0\0\xa6\0\xac\0\xa6\0U\0\xa6\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaf\0\xae\0&\0\xa6\0\xa6\0\xc2\0\xc1\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xc0\0\xbf\0\xbe\0\xbd\0S\0\xba\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xad\0\xbc\0\xba\0\xba\0\xba\0\xba\0\xac\0\xbb\0\xc3\0U\0\xc4\0W\0W\0W\0W\0W\0W\0W\0W\0\x1b\0\x1b\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\xcb\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0\xc1\0\xd8\0\xd7\0\xd2\0S\0\xd2\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0<\0\xd6\0\xd5\0<\0<\0<\0\xd2\0\xd2\0<\0<\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xd4\0\xd2\0\xf2\0<\0\xf8\0\xf9\0\xd3\0\xf1\0<\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xfa\0\xfb\0\xfc\0'\x01,\0+\0*\0%\x01A\x01&\x017\0@\x01?\x01B\x01@\x017\0>\x01=\x01)\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0?\x013\x01S\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\x003\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0*\x016\0>\x01=\x013\x013\x016\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\x003\x01U\x01T\x01\x18\0S\0r\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0s\x01q\x01p\x01o\x01\x18\0t\x01\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0r\x01;\0:\x009\0<\x01<\x01;\0:\x009\0S\0;\x01;\x01q\x01n\x01e\x018\0a\0e\x01a\0m\x018\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0p\x01o\x01#\x01e\x01e\x01e\x01\x8b\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa7\x01\"\x01\xa6\x01\xa5\x01S\0\xa8\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\xa4\x01\xa3\x01\xa6\x01h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0M\x01\xa5\x01\x9a\x01L\x01\x9a\x01+\x01\x9a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa4\x01\xa3\x01\x9a\x01\x9a\x01S\0\xb1\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0n\x01\0\0\0\0\0\0\0\0\0\0m\x01f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0_\0\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01$\x01U\0\0\0W\0W\0W\0W\0W\0W\0W\0W\0^\0^\0\xa2\x01\0\0\0\0\0\0\0\0\0\0\xa1\x01_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0S\0\0\0\xa2\x01\0\0\0\0\0\0\0\0\xff\xff\xa1\x01\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0a\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0R\x01Q\x01\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xa6\0\xa7\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xa6\0\0\0\x9f\0\0\0\x99\0\x98\0\x89\0\x9f\0\x92\0\x91\0\xa0\0\x88\0\x8f\0\x9e\0\x9b\0\xa1\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x8e\0\x90\0\x8c\0\x8a\0\x8b\0\x8d\0\xa6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x97\0S\x01\x96\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9a\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x95\0\x93\0\x94\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\0\0\xa5\0\xa4\0\xa3\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa2\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\x86\x01\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf3\0\x99\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xa6\0\0\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\x9c\0\x9c\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\xd2\0\0\0\x02\x01\xd2\0\xd2\0\xba\0\0\0\0\0\xba\0\xba\0\xba\0\0\0\0\0\xba\0\xba\x003\x01\0\0\0\x003\x013\x01\0\0\0\0\0\0\xd2\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\0\0\xcd\x003\x01\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xd2\0\0\0\0\0\xd2\0\xd2\0\xb5\0\0\0\0\0\0\0\0\0\xb5\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\0\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\x03\x01\0\0\xcd\0\0\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xb4\0{\x01\0\0\0\0z\x01\xb4\0\0\0\0\0\0\0\xba\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\x89\x01\xd2\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\xaa\0\xa9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\xa8\0\0\0\0\0\0\0\0\0x\x01\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0w\x01\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\xce\0:\x019\x018\x01\0\0\xb6\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\0\x007\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\xce\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0y\x01\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf4\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\xf5\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\x003\x015\x01\0\x003\x013\x01\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\x003\x01\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\b\x01\0\0\0\0\x07\x01\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x01\0\0\0\0\0\0F\x01\0\0\0\0E\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x019\x018\x01\0\0\0\0\0\0\0\0\x13\x01\0\0\0\0\0\0\0\0\0\0\x0f\x017\x01\0\0\0\0\x0e\x013\x01\0\0\0\0\0\0H\x01\0\0\0\0\r\x01\0\0\0\0\0\0\f\x01\0\0\x0b\x01\t\x01\n\x01\0\0\x12\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0G\x01I\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0e\x01\0\0\x19\x01e\x01e\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0e\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\xab\x01\0\0\x14\x01\xac\x01\0\0\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\0\0\0\0\0\0\0\0\xae\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x013\x015\x01J\x013\x014\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xad\x013\x01\0\0\0\0\xaf\x01\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01.\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01\0\0\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0l\x01k\x01j\x01e\x01\0\0\0\0\0\0\0\0\0\0\x1f\x01\0\0\0\0\0\0\0\0i\x01\x9a\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\xb0\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\x011\x010\x01N\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0/\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01e\x01g\x01\0\0e\x01f\x01e\x01g\x01\0\0e\x01e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\x01\0\0X\x01\0\0Y\x01e\x01\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0[\x01`\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\x01\0\0_\x01Z\x01^\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01]\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\x80\x01\0\0\0\0\x7f\x01\0\0\0\0\0\0\x9a\x01\0\0\0\0\x9a\x01\x9a\x01\0\0d\x01c\x01b\x01\0\0\0\0l\x01k\x01j\x01\x84\x01\x83\x01\0\0\x82\x01\0\0\0\0a\x01~\x01\x82\x01\x9a\x01\0\0i\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01h\x01\0\0\0\0\0\0\0\0\0\0\x82\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\0\0\0\0\0\0\0\0\x83\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x8a\x01\0\0\0\0\0\0\x82\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\x8a\x01\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x88\x01\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\x8c\x01\0\0\0\0\0\0\0\0\x81\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\0\0\0\0\0\0\x8c\x01\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\0\0\0\0\0\0\x8d\x01\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\0\0\0\0\0\0\x8e\x01\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\0\0\0\0\0\0\x8f\x01\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\x8b\x01\x9a\x01\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\0\0\0\0\0\0\x90\x01\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x91\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\0\0\0\0\0\0\x91\x01\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x01\0\0\0\0\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\x01\x98\x01\x97\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x96\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff"),d('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x07\x01\0\0\0\0E\x01L\x01z\x01\x7f\x01\xac\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x05\0\x06\0\x07\0\b\0\b\0\t\0\t\0\n\0\x0b\0\x0b\0\f\0\r\0\x19\0\x1f\0#\0$\0$\0\x06\0*\0\x1a\0\x07\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0 \0!\0%\0\r\0-\0 \0!\0,\0%\0+\0+\0.\0/\0,\x001\x006\x007\x009\0;\0 \0!\0:\0:\0=\0;\0>\0?\0A\0"\0)\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x002\0\f\x008\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0B\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0\0\0\0\0\0\0\x18\0N\0k\0s\0u\0w\0z\0z\x000\0|\0\x8a\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0@\0\x93\0\x95\0\x98\0\xa0\0\xa2\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xa1\0\xa3\0\xa4\0\xa4\0\x18\0\xa1\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x1b\0&\0\xa5\0\xa8\0&\0&\0\xa9\0\xac\0\xa5\0\xad\0\x1b\0\xae\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaa\0\xaa\0&\0\xb0\0\xb1\0\xb4\0\xb5\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xb6\0\xb7\0\xb8\0\xb8\0\x1b\0\xbb\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xab\0\xb9\0\xbc\0\xbd\0\xbf\0\xc0\0\xab\0\xb9\0\xc2\0\x1c\0\xc3\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xc4\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xcb\0\xce\0\xcf\0\xd3\0\x1c\0\xd4\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\x005\0\xd0\0\xd0\x005\x005\0<\0\xd5\0\xd7\0<\0<\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xd1\0\xd8\0\xf1\x005\0\xf7\0\xf8\0\xd1\0\x9b\0<\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\xf9\0\xfa\0\xfb\0%\x01&\0&\0&\0"\x01.\x01"\x015\0/\x010\x01.\x017\x01<\x001\x011\x01&\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\x008\x01;\x01S\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0<\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0(\x015\x009\x019\x01=\x01?\x01<\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0@\x01R\x01R\x01m\0S\0a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0`\x01b\x01c\x01c\x01m\0`\x01m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0i\x015\x005\x005\x002\x01:\x01<\0<\0<\0T\x002\x01:\x01j\x01d\x01m\x015\0T\0n\x01T\0d\x01<\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0k\x01k\x01 \x01o\x01q\x01r\x01\x91\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0\x95\x01 \x01\x96\x01\x97\x01T\0\x95\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x98\x01\x98\x01\x9d\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0I\x01\x9e\x01\xa1\x01I\x01\xa2\x01(\x01\xa3\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\x9f\x01\x9f\x01\xa5\x01\xa6\x01U\0\xae\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0V\0\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\xff\xff\xff\xff\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0l\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xff\xff\xff\xff\xff\xff\xff\xffV\0\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0W\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01 \x01W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\x99\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\x01W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xff\xff\xff\xff\xff\xff\xff\xffW\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0X\0\xff\xff\xa0\x01\xff\xff\xff\xff\xff\xff\xff\xffI\x01\xa0\x01\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xffX\0\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xffY\0\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xffZ\0\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff[\0\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\\\0\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff]\0\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xffb\0\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xffc\0\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xffd\0\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xfff\0\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xffg\0\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xffh\0\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xffi\0\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffO\x01O\x01\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\x85\0\x85\0\xff\xff\x85\0\x85\0\xff\xff\xff\xff\xff\xff\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\xaf\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0O\x01\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\xff\xff\xff\xff\x85\0\x85\0\x85\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\x84\x01\xff\xff\x9a\0\xff\xff\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xa6\0\xff\xff\xff\xff\xa6\0\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\0\x01\x9e\0\x9e\0\xb3\0\xff\xff\xff\xff\xb3\0\xb3\0\xba\0\xff\xff\xff\xff\xba\0\xba\x003\x01\xff\xff\xff\xff3\x013\x01\xff\xff\xff\xff\xff\xff\x9e\0\xff\xff\xff\xff\0\x01\xff\xff\xb3\0\xff\xff\xff\xff\0\x01\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\x9e\x003\x01\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\0\x01\xff\xff\xd2\0\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xb3\0u\x01\xff\xff\xff\xffu\x01\xba\0\xff\xff\xff\xff\xff\xff\xbe\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\xff\xff\x85\x01\xd6\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa6\0\xa6\0\xa6\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xd9\0\xff\xff\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xb3\0\xb3\0\xb3\0\xff\xff\xff\xff\xba\0\xba\0\xba\0\xff\xff\x9e\x003\x013\x013\x01\xff\xff\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\xff\xff3\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xd2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf5\x004\x014\x01\xff\xff4\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\x05\x01\xff\xff\xff\xff\x05\x01\xf6\0\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x014\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x014\x01\xff\xff\xff\xff\x05\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\x05\x01\x05\x01\x05\x01\xff\xff\x05\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffC\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xffe\x01\xff\xff\t\x01e\x01e\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\xff\xff\xff\xffe\x01\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xa9\x01\xff\xff\x05\x01\xa9\x01\xff\xff\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01,\x01,\x01C\x01,\x01,\x01\xff\xff\xff\xff\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xa9\x01,\x01\xff\xff\xff\xff\xa9\x01\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01,\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\xff\xffp\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01\xff\xff\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xff\xff\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01e\x01e\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\xff\xff\xff\xff\xff\xff\xff\xffe\x01\xa4\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffH\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01,\x01,\x01N\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff,\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffN\x01\xff\xffN\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01V\x01V\x01\xff\xffV\x01V\x01f\x01f\x01\xff\xfff\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01\xff\xffV\x01f\x01\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff|\x01\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xfff\x01f\x01f\x01~\x01~\x01\xff\xff|\x01\xff\xff\xff\xffV\x01|\x01|\x01\x9a\x01\xff\xfff\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff|\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\xff\xff\xff\xff\xff\xff\xff\xff~\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\x83\x01\xff\xff\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\x87\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\x9a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff|\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\x9b\x01\x9b\x01\xff\xff\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\x8f\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x92\x01\x92\x01\xff\xff\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01'),d('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\x16\0"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\x01\0\f\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x006\0_\0B\0v\0L\0N\0\0\0\x81\0\0\0\x98\0\0\0\xa2\0\xac\0\xb6\0\0\0\xc0\0\0\0\xca\0\0\0\xe1\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x1a\x01&\x01W\x01\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\x0b\0\r\0\x0f\0\xe5\0\x1a\0\b\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\x01\0\0\0\0\0\0\0\0y\x01\r\0\x1c\0\x10\0\x1a\x01\x1d\0E\0\x83\x01\0\0\x8d\x01\x9a\x01\xa4\x01\xae\x01\0\0\0\0\xb8\x01\xc2\x01\xdb\x01\xe5\x01\x89\0\x8b\0\0\0\xf9\x01\0\0\x03\x02\0\0\r\x02\x17\x02\0\0!\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'),d("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x0f\0\0\0\x0f\0\0\0\x0f\0\x0f\0\0\0#\0\0\0&\0)\0)\0)\0\0\0)\0)\0\0\0,\0\0\0/\0\0\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0k\0k\0s\0\0\0s\0v\0v\0W\0k\0~\0k\0k\0&\0\x8f\0/\0\x94\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9e\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),d("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),d("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\t\0\t\0\t\0\t\0e\0\0\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\0\0\0\0\0\0\0\0e\0\0\0e\0\t\0e\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x01\0\x01\0 \0 \0 \0 \0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0e\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0e\0e\x002\x002\x002\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0e\x002\0\t\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x8c\0\x8c\0\x8c\0\x8c\0\0\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0e\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0M\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0R\0R\x002\0\0\0\0\x002\x002\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\x002\0\0\0\0\x002\x002\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\0\0\0\0\0\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0\0\0\0\x002\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0R\0\0\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x86\0\x86\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0R\0\0\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),d("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\x005\x005\0<\0<\0\xb3\0\xff\xff\xba\0\xb3\0\xb3\0\xba\0\xba\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\0\xff\xff\xff\xff\xff\xff\xff\xff\xb3\0\xff\xff\xba\0!\0\xa1\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1b\0\xff\xff\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xff\xff\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0Y\0Y\0Z\0Z\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0A\0\xbc\0=\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xbb\0\xbf\0\xd3\0\xd4\0\xd7\0\xff\xff?\0V\0V\0V\0V\0V\0V\0X\0X\0X\0X\0X\0X\0X\0X\0\xbd\0\xd5\0@\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xe5\0\xe5\0\xe6\0\xe6\0\xff\xff\xff\xffB\0V\0V\0V\0V\0V\0V\0^\0\xc0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xd8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0\x85\0\xff\xff\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\xff\xff\x9e\0\x9e\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xff\xff\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xd6\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),d("\xff\x01\xff\xff\x03\xff\x01\xff\xff\x02\xff\xff\0\x02\xff\0\x01\xff\x06\xff\xff\x07\xff\xff\x01\xff\x03\xff\xff\x05\xff\xff\x04\xff\xff\0\x04\xff\0\x05\xff\0\x03\xff\0\x06\xff\0\x07\xff\x11\xff\x10\xff\x0e\xff\r\xff\f\xff\x0b\xff\n\xff\t\xff\b\xff\x07\xff\x06\xff\x05\xff\x04\xff\xff\x13\xff\x12\xff\xff\x12\xff\x13\xff\xff\x03\x11\x02\x12\x01\x0f\0\x10\xff\x16\xff\x13\xff\xff\x14\xff\xff\0\x14\xff\x01\x13\0\x0e\xff\x15\xff\xff\0\r\xff\x01\x15\0\f\xff\x19\xff\xff\0\t\xff\x13\xff\x16\xff\xff\x13\xff\xff\x18\xff\xff\x17\xff\xff\x01\x17\0\x04\xff\x01\x18\0\x06\xff\x01\x16\0\b\xff\0\x0b\xff\x01\x19\0\n\xff")],ds=[0,0,0,0,0,1,0],fm=[0,1];aJ(11,[P,d(gi),-12],gi);aJ(10,v,g1);aJ(9,[P,d(fN),fF],fN);aJ(8,[P,d(gR),-9],gR);aJ(7,[P,d(fD),-8],fD);aJ(6,aj,gQ);aJ(5,[P,d(fW),-6],fW);aJ(4,[P,d(gy),-5],gy);aJ(3,em,gM);aJ(2,dc,gx);aJ(1,[P,d(gu),-2],gu);aJ(0,[P,d(f5),-1],f5);var
hx=d(dS),hy=d(d7),hw=d("Pervasives.Exit"),hA=d("Array.blit"),hB=d("Array.Bottom"),hD=[0,d("list.ml"),g4,11],hC=d("hd"),hH=d("\\b"),hI=d("\\t"),hJ=d("\\n"),hK=d("\\r"),hG=d("\\\\"),hF=d("\\'"),hE=d("Char.chr"),hQ=d("String.contains_from / Bytes.contains_from"),hN=d("String.blit / Bytes.blit_string"),hM=d("Bytes.blit"),hL=d("String.sub / Bytes.sub"),hR=d(u),hT=d("Sys.Break"),hY=d("Set.remove_min_elt"),hZ=[0,0,0,0],h0=[0,0,0],h1=[0,d("set.ml"),372,18],hU=d(cR),hV=d(cR),hW=d(cR),hX=d(cR),h2=d("Queue.Empty"),h3=d("CamlinternalLazy.Undefined"),h7=d("Buffer.add: cannot grow buffer"),ie=d("%c"),ig=d("%s"),ih=d(gf),ii=d("%li"),ij=d("%ni"),ik=d("%Li"),il=d("%f"),im=d("%B"),io=d("%{"),ip=d("%}"),iq=d("%("),ir=d("%)"),is=d("%a"),it=d("%t"),iu=d("%r"),iv=d("%_r"),iw=[0,d(ac),793,23],iG=[0,d(ac),761,21],iz=[0,d(ac),762,21],iH=[0,d(ac),765,21],iA=[0,d(ac),766,21],iI=[0,d(ac),769,22],iB=[0,d(ac),770,22],iJ=[0,d(ac),774,30],iC=[0,d(ac),775,30],iE=[0,d(ac),779,26],ix=[0,d(ac),gJ,26],iF=[0,d(ac),c0,28],iy=[0,d(ac),790,28],iD=[0,d(ac),794,23],jh=d(fJ),jf=[0,d(ac),1415,4],jg=d("Printf: bad conversion %["),ji=[0,d(ac),1483,39],jj=[0,d(ac),1505,31],jk=[0,d(ac),1506,31],eE=d("Printf: bad conversion %_"),jl=d("@{"),jm=d("@["),je=[0,d(cO),[0,d(cO),0]],jc=d(gC),jd=d(cP),ja=d("neg_infinity"),jb=d("infinity"),iZ=[0,d(bq),[0,d(dX),0]],i0=[0,d(gB),[0,d(dX),0]],i1=[0,d(fE),[0,d(dX),0]],i2=[0,d(bq),[0,d(d1),0]],i3=[0,d(gB),[0,d(d1),0]],i4=[0,d(fE),[0,d(d1),0]],i5=[0,d(bq),[0,d(eb),0]],i6=[0,d(dY),[0,d(eb),0]],i7=[0,d(bq),[0,d(fI),0]],i8=[0,d(dY),[0,d(fI),0]],i9=[0,d(bq),[0,d(gY),0]],i_=[0,d(dY),[0,d(gY),0]],i$=[0,d(bq),[0,d("u"),0]],iM=d(gU),iN=d("%+d"),iO=d("% d"),iP=d(gf),iQ=d("%+i"),iR=d("% i"),iS=d("%x"),iT=d("%#x"),iU=d("%X"),iV=d("%#X"),iW=d("%o"),iX=d("%#o"),iY=d(fJ),iL=[0,d(fY),[0,d(fY),0]],h8=d("@]"),h9=d("@}"),h_=d("@?"),h$=d("@\n"),ia=d("@."),ib=d("@@"),ic=d("@%"),id=d("@"),iK=d("CamlinternalFormat.Type_mismatch"),jn=d(eb),Hw=d("OCAMLRUNPARAM"),Hu=d("CAMLRUNPARAM"),jo=d(u),Ht=d("TMPDIR"),Hs=d("TEMP"),jr=d("Cygwin"),js=d(fA),jt=d("Win32"),ju=[0,d("filename.ml"),gl,9],jx=d("Js.Error"),jy=d(fB),jz=d(gX),jB=d("Unexpected number"),jC=d("Unexpected string"),jD=d("Unexpected identifier"),jE=d("Unexpected reserved word"),jF=d("Unexpected end of input"),jG=d("Unexpected variance sigil"),jH=d("Type aliases are not allowed in untyped mode"),jI=d("Type annotations are not allowed in untyped mode"),jJ=d("Type declarations are not allowed in untyped mode"),jK=d("Type imports are not allowed in untyped mode"),jL=d("Type exports are not allowed in untyped mode"),jM=d("Interfaces are not allowed in untyped mode"),jN=d("Illegal newline after throw"),jO=d("Invalid regular expression"),jP=d("Invalid regular expression: missing /"),jQ=d("Invalid left-hand side in assignment"),jR=d("Invalid left-hand side in exponentiation expression"),jS=d("Invalid left-hand side in for-in"),jT=d("Invalid left-hand side in for-of"),jU=d("found an expression instead"),jV=d("Expected an object pattern, array pattern, or an identifier but "),jW=d("More than one default clause in switch statement"),jX=d("Missing catch or finally after try"),jY=d("Illegal continue statement"),jZ=d("Illegal break statement"),j0=d("Illegal return statement"),j1=d("Illegal yield expression"),j2=d("Strict mode code may not include a with statement"),j3=d("Catch variable may not be eval or arguments in strict mode"),j4=d("Variable name may not be eval or arguments in strict mode"),j5=d("Parameter name eval or arguments is not allowed in strict mode"),j6=d("Strict mode function may not have duplicate parameter names"),j7=d("Function name may not be eval or arguments in strict mode"),j8=d("Octal literals are not allowed in strict mode."),j9=d("Delete of an unqualified identifier in strict mode."),j_=d("Duplicate data property in object literal not allowed in strict mode"),j$=d("Object literal may not have data and accessor property with the same name"),ka=d("Object literal may not have multiple get/set accessors with the same name"),kb=d("Assignment to eval or arguments is not allowed in strict mode"),kc=d("Postfix increment/decrement may not have eval or arguments operand in strict mode"),kd=d("Prefix increment/decrement may not have eval or arguments operand in strict mode"),ke=d("Use of future reserved word in strict mode"),kf=d("JSX attributes must only be assigned a non-empty expression"),kg=d("JSX value should be either an expression or a quoted JSX text"),kh=d("Const must be initialized"),ki=d("Destructuring assignment must be initialized"),kj=d("Illegal newline before arrow"),kk=d(" declared at top level or immediately within another function."),kl=d("In strict mode code, functions can only be"),km=d("elements must be wrapped in an enclosing parent tag"),kn=d("Unexpected token <. Remember, adjacent JSX "),ko=d("Rest parameter must be final parameter of an argument list"),kp=d("async is an implementation detail and isn't necessary for your declare function statement. It is sufficient for your declare function to just have a Promise return type."),kq=d("`declare export let` is not supported. Use `declare export var` instead."),kr=d("`declare export const` is not supported. Use `declare export var` instead."),ks=d("`declare export type` is not supported. Use `export type` instead."),kt=d("`declare export interface` is not supported. Use `export interface` instead."),ku=d("`export * as` is an early-stage proposal and is not enabled by default. To enable support in the parser, use the `esproposal_export_star_as` option"),kv=d("When exporting a class as a named export, you must specify a class name. Did you mean `export default class ...`?"),kw=d("When exporting a function as a named export, you must specify a function name. Did you mean `export default function ...`?"),kx=d("Found a decorator in an unsupported position."),ky=d("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),kz=d("The Windows version of OCaml has a bug in how it parses hexidecimal numbers. It is fixed in OCaml 4.03.0. Until we can switch to 4.03.0, please avoid either hexidecimal notation or Windows."),kA=d("Duplicate `declare module.exports` statement!"),kB=d("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module xor they are a CommonJS module."),kC=d("Getter should have zero parameters"),kD=d("Setter should have exactly one parameter"),kE=d("`import type` or `import typeof`!"),kF=d("Imports within a `declare module` body must always be "),kG=d("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements"),kH=d("Missing comma between import specifiers"),kI=d("Unexpected parser state: "),kJ=d("Unexpected token "),kK=[0,[11,d("Unexpected token `"),[2,0,[11,d("`. Did you mean `"),[2,0,[11,d("`?"),0]]]]],d("Unexpected token `%s`. Did you mean `%s`?")],kL=d(cO),kM=d("Invalid flags supplied to RegExp constructor '"),kN=d(cO),kO=d("Undefined label '"),kP=d("' has already been declared"),kQ=d(" '"),kR=d("Expected corresponding JSX closing tag for "),kS=[0,[11,d("Duplicate export for `"),[2,0,[12,96,0]]],d("Duplicate export for `%s`")],jA=d("Parse_error.Error"),kT=[0,[0]],kU=[0,d(aL),18,6],kV=[0,[0,[0,[0]]]],kW=[0,d(aL),39,6],kX=[0,[0]],kY=[0,d(aL),44,6],kZ=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],k0=[0,d(aL),gs,6],k1=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],k2=[0,d(aL),515,6],k3=[0,[0,[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0,[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]]]],k4=[0,d(aL),gJ,6],k5=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],k6=[0,d(aL),883,6],k7=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],k8=[0,d(aL),gm,6],k9=[0,[0]],k_=[0,d(aL),gp,6],k$=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],la=[0,d(aL),1008,6],lb=[0,[0,[0,[0]]]],lc=[0,d(aL),1031,6],ld=[0,[0]],le=[0,[0,[0,[0]]]],lf=[0,[0]],lg=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],lh=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],li=[0,[0,[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0,[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]]]],lj=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],lk=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],ll=[0,[0]],lm=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],ln=[0,[0,[0,[0]]]],lA=d("comments"),lB=d(b),lC=d("Program"),lD=d("EmptyStatement"),lE=d("DebuggerStatement"),lF=d(bQ),lG=d("ExpressionStatement"),lH=d(f2),lI=d(d0),lJ=d(bM),lK=d("IfStatement"),lL=d(b),lM=d(d6),lN=d("LabeledStatement"),lO=d(d6),lP=d("BreakStatement"),lQ=d(d6),lR=d("ContinueStatement"),lS=d(b),lT=d(d5),lU=d("WithStatement"),lV=d("cases"),lW=d("discriminant"),lX=d("SwitchStatement"),lY=d(av),lZ=d("ReturnStatement"),l0=d(av),l1=d("ThrowStatement"),l2=d("finalizer"),l3=d("handler"),l4=d("block"),l5=d("TryStatement"),l6=d(b),l7=d(bM),l8=d("WhileStatement"),l9=d(bM),l_=d(b),l$=d("DoWhileStatement"),ma=d(b),mb=d("update"),mc=d(bM),md=d(cj),me=d("ForStatement"),mf=d(gt),mg=d(b),mh=d(be),mi=d(br),mj=d("ForInStatement"),mk=d("ForAwaitStatement"),mo=d("ForOfStatement"),ml=d(b),mm=d(be),mn=d(br),mp=d("CommonJS"),mu=d("ES"),mq=d(bR),mr=d(b),ms=d(ai),mt=d("DeclareModule"),mv=d(aV),mw=d("DeclareModuleExports"),mC=d(bL),mD=d("DeclareExportAllDeclaration"),mx=d(bL),my=d(dI),mz=d(d8),mA=d(cL),mB=d("DeclareExportDeclaration"),mJ=d(dN),mK=d(bL),mL=d("ExportAllDeclaration"),mE=d(dN),mF=d(bL),mG=d(dI),mH=d(d8),mI=d("ExportNamedDeclaration"),mM=d(dN),mN=d(d8),mO=d("ExportDefaultDeclaration"),mP=d(bT),mU=d(bN),mV=d(Z),mQ=d(ge),mR=d(bL),mS=d(dI),mT=d("ImportDeclaration"),mW=d("ThisExpression"),mX=d("Super"),mY=d(gv),mZ=d("ArrayExpression"),m0=d(d$),m1=d("ObjectExpression"),m2=d(aI),m3=d(cM),m4=d(bQ),m5=d(cU),m6=d(dJ),m7=d(ch),m8=d(b),m9=d(bU),m_=d(ai),m$=d("ArrowFunctionExpression"),na=d(fZ),nb=d("SequenceExpression"),nc=d(av),nd=d("AwaitExpression"),ne=d(bc),nj=d(cf),nk=d("!"),nl=d("~"),nm=d(bN),nn=d(d4),no=d(fS),np=d("matched above"),nf=d(av),ng=d(gk),nh=d(ce),ni=d("UnaryExpression"),nq=d("=="),nv=d("!="),nw=d("==="),nx=d("!=="),ny=d("<"),nz=d("<="),nA=d(">"),nB=d(">="),nC=d("<<"),nD=d(">>"),nE=d(">>>"),nF=d(cf),nG=d(bc),nH=d("*"),nI=d("**"),nJ=d(cm),nK=d(bq),nL=d("|"),nM=d("^"),nN=d(gL),nO=d(gG),nP=d(gF),nr=d(be),ns=d(br),nt=d(ce),nu=d("BinaryExpression"),nQ=d("="),nV=d("+="),nW=d("-="),nX=d("*="),nY=d("**="),nZ=d("/="),n0=d("%="),n1=d("<<="),n2=d(">>="),n3=d(">>>="),n4=d("|="),n5=d("^="),n6=d("&="),nR=d(be),nS=d(br),nT=d(ce),nU=d("AssignmentExpression"),oa=d("--"),n7=d("++"),n8=d(gk),n9=d(av),n_=d(ce),n$=d("UpdateExpression"),og=d("&&"),ob=d("||"),oc=d(be),od=d(br),oe=d(ce),of=d("LogicalExpression"),oh=d(f2),oi=d(d0),oj=d(bM),ok=d("ConditionalExpression"),ol=d(d9),om=d(gr),on=d("NewExpression"),oo=d(d9),op=d(gr),oq=d("CallExpression"),or=d(co),os=d(dM),ot=d(d5),ou=d("MemberExpression"),ov=d("delegate"),ow=d(av),ox=d("YieldExpression"),oy=d(g0),oz=d(fR),oA=d("ComprehensionExpression"),oB=d(g0),oC=d(fR),oD=d("GeneratorExpression"),oE=d(aV),oF=d(bQ),oG=d("TypeCastExpression"),oH=d(dM),oI=d("meta"),oJ=d("MetaProperty"),oK=d(aI),oL=d(cM),oM=d(bQ),oN=d(cU),oO=d(dJ),oP=d(ch),oQ=d(b),oR=d(bU),oS=d(ai),oT=d("FunctionDeclaration"),oU=d(aI),oV=d(cM),oW=d(bQ),oX=d(cU),oY=d(dJ),oZ=d(ch),o0=d(b),o1=d(bU),o2=d(ai),o3=d("FunctionExpression"),o4=d(cS),o5=d(aV),o6=d(a5),o7=d(g_),o8=d(cS),o9=d(aV),o_=d(a5),o$=d(g_),pa=d(d0),pb=d(bM),pc=d("SwitchCase"),pd=d(b),pe=d("param"),pf=d("CatchClause"),pg=d(b),ph=d("BlockStatement"),pi=d(ai),pj=d("DeclareVariable"),pk=d(cU),pl=d(ai),pm=d("DeclareFunction"),pn=d(d2),po=d(b),pp=d(aI),pq=d(ai),pr=d("DeclareClass"),pt=d(Z),ps=d(bT),pu=d(gZ),pv=d("ExportNamespaceSpecifier"),pw=d(be),px=d(aI),py=d(ai),pz=d("TypeAlias"),pA=d(ee),pB=d(c2),pC=d(gK),pD=d(aI),pE=d(gP),pF=d(b),pG=d(ai),pH=d("ClassDeclaration"),pI=d(ee),pJ=d(c2),pK=d(gK),pL=d(aI),pM=d(gP),pN=d(b),pO=d(ai),pP=d("ClassExpression"),pQ=d(aI),pR=d(ai),pS=d("ClassImplements"),pT=d(b),pU=d("ClassBody"),pV=d(dZ),p3=d(ed),p4=d(bs),p5=d(bP),pW=d(ee),pX=d(co),pY=d(a6),pZ=d(bR),p0=d(Z),p1=d(bK),p2=d("MethodDefinition"),p6=d(cQ),p7=d(a6),p8=d(co),p9=d(aV),p_=d(Z),p$=d(bK),qa=d("ClassProperty"),qb=d(d2),qc=d(b),qd=d(aI),qe=d(ai),qf=d("InterfaceDeclaration"),qg=d(aI),qh=d(ai),qi=d("InterfaceExtends"),qj=d(aV),qk=d(d$),ql=d("ObjectPattern"),qm=d(aV),qn=d(gv),qo=d("ArrayPattern"),qp=d(be),qq=d(br),qr=d("AssignmentPattern"),qs=d(av),qt=d(gh),qu=d(av),qv=d(gh),qw=d(cj),qE=d(bs),qF=d(bP),qx=d(co),qy=d(fO),qz=d(ed),qA=d(bR),qB=d(Z),qC=d(bK),qD=d(g5),qG=d(av),qH=d("SpreadProperty"),qI=d(co),qJ=d(fO),qK=d(ed),qL=d(cj),qM=d(bR),qN=d(Z),qO=d(bK),qP=d(g5),qQ=d(av),qR=d("RestProperty"),qS=d(av),qT=d("SpreadElement"),qU=d(gt),qV=d(be),qW=d(br),qX=d("ComprehensionBlock"),q1=d("flags"),q2=d("pattern"),q3=d("regex"),q4=d(bu),q5=d(Z),qY=d(bu),qZ=d(Z),q0=d("Literal"),q6=d(fZ),q7=d("quasis"),q8=d("TemplateLiteral"),q9=d("cooked"),q_=d(bu),q$=d("tail"),ra=d(Z),rb=d("TemplateElement"),rc=d("quasi"),rd=d("tag"),re=d("TaggedTemplateExpression"),rf=d(f_),rj=d(gD),rk=d(gO),rg=d(bR),rh=d("declarations"),ri=d("VariableDeclaration"),rl=d(cj),rm=d(ai),rn=d("VariableDeclarator"),rp=d(fQ),ro=d("plus"),rq=d("AnyTypeAnnotation"),rr=d("MixedTypeAnnotation"),rs=d("EmptyTypeAnnotation"),rt=d("VoidTypeAnnotation"),ru=d("NullLiteralTypeAnnotation"),rv=d("NumberTypeAnnotation"),rw=d("StringTypeAnnotation"),rx=d("BooleanTypeAnnotation"),ry=d(aV),rz=d("NullableTypeAnnotation"),rA=d(aI),rB=d("rest"),rC=d(cM),rD=d(bU),rE=d("FunctionTypeAnnotation"),rF=d(cS),rG=d(aV),rH=d(a5),rI=d("FunctionTypeParam"),rJ=[0,0,0,0],rK=d("callProperties"),rL=d("indexers"),rM=d(d$),rN=d("exact"),rO=d("ObjectTypeAnnotation"),rZ=d("There should not be computed object type property keys"),rP=d(cj),rX=d(bs),rY=d(bP),rQ=d(bR),rR=d(cQ),rS=d(a6),rT=d(cS),rU=d(Z),rV=d(bK),rW=d("ObjectTypeProperty"),r0=d(av),r1=d("ObjectTypeSpreadProperty"),r2=d(cQ),r3=d(a6),r4=d(Z),r5=d(bK),r6=d(ai),r7=d("ObjectTypeIndexer"),r8=d(a6),r9=d(Z),r_=d("ObjectTypeCallProperty"),r$=d("elementType"),sa=d("ArrayTypeAnnotation"),sb=d(ai),sc=d("qualification"),sd=d("QualifiedTypeIdentifier"),se=d(aI),sf=d(ai),sg=d("GenericTypeAnnotation"),sh=d(dL),si=d("UnionTypeAnnotation"),sj=d(dL),sk=d("IntersectionTypeAnnotation"),sl=d(av),sm=d("TypeofTypeAnnotation"),sn=d(dL),so=d("TupleTypeAnnotation"),sp=d(bu),sq=d(Z),sr=d("StringLiteralTypeAnnotation"),ss=d(bu),st=d(Z),su=d("NumberLiteralTypeAnnotation"),sv=d(bu),sw=d(Z),sx=d("BooleanLiteralTypeAnnotation"),sy=d("ExistsTypeAnnotation"),sz=d(aV),sA=d("TypeAnnotation"),sB=d(bU),sC=d("TypeParameterDeclaration"),sD=d(cL),sE=d(cQ),sF=d("bound"),sG=d(a5),sH=d("TypeParameter"),sI=d(bU),sJ=d("TypeParameterInstantiation"),sK=d("children"),sL=d("closingElement"),sM=d("openingElement"),sN=d("JSXElement"),sO=d("selfClosing"),sP=d("attributes"),sQ=d(a5),sR=d("JSXOpeningElement"),sS=d(a5),sT=d("JSXClosingElement"),sU=d(Z),sV=d(a5),sW=d("JSXAttribute"),sX=d(av),sY=d("JSXSpreadAttribute"),s1=d("JSXEmptyExpression"),sZ=d(bQ),s0=d("JSXExpressionContainer"),s2=d(bu),s3=d(Z),s4=d("JSXText"),s5=d(dM),s6=d(d5),s7=d("JSXMemberExpression"),s8=d(a5),s9=d("namespace"),s_=d("JSXNamespacedName"),s$=d(a5),ta=d("JSXIdentifier"),tb=d(gZ),tc=d(cW),td=d("ExportSpecifier"),te=d(cW),tf=d("ImportDefaultSpecifier"),tg=d(cW),th=d("ImportNamespaceSpecifier"),ti=d(bT),tn=d(bN),tj=d(ge),tk=d(cW),tl=d("imported"),tm=d("ImportSpecifier"),to=d("Block"),tq=d("Line"),tp=d(Z),tr=d(Z),ts=d("DeclaredPredicate"),tt=d("InferredPredicate"),ly=d("message"),lz=d(go),lv=d("range"),lw=d(go),lx=d(bT),lr=d(gX),ls=d("end"),lt=d("start"),lu=d(bL),lp=d("column"),lq=d("line"),vK=d(dT),vL=[0,0],vM=[0,0],vN=[0,2],vO=[0,2],vP=[0,1],vQ=[0,1],vR=[0,3],vS=[0,3],vT=d(dT),vU=[5,3,c0],vV=[5,3,c0],vW=d("\\"),vX=d(dK),vY=d(gq),vZ=d("*/"),v0=d(gq),v1=d(u),v2=d(u),v3=d(u),v4=d(u),v5=d(dK),v6=d("iexcl"),z6=d("aelig"),B4=d("Nu"),C4=d("Eacute"),Dy=d("Atilde"),DO=d("'int'"),DP=d("AElig"),DQ=d("Aacute"),DR=d("Acirc"),DS=d("Agrave"),DT=d("Alpha"),DU=d("Aring"),DV=[0,197],DW=[0,913],DX=[0,cN],DY=[0,194],DZ=[0,193],D0=[0,198],D1=[0,8747],Dz=d("Auml"),DA=d("Beta"),DB=d("Ccedil"),DC=d("Chi"),DD=d("Dagger"),DE=d("Delta"),DF=d("ETH"),DG=[0,208],DH=[0,916],DI=[0,8225],DJ=[0,935],DK=[0,fx],DL=[0,914],DM=[0,196],DN=[0,195],C5=d("Icirc"),Dj=d("Ecirc"),Dk=d("Egrave"),Dl=d("Epsilon"),Dm=d("Eta"),Dn=d("Euml"),Do=d("Gamma"),Dp=d("Iacute"),Dq=[0,205],Dr=[0,915],Ds=[0,203],Dt=[0,919],Du=[0,917],Dv=[0,200],Dw=[0,202],C6=d("Igrave"),C7=d("Iota"),C8=d("Iuml"),C9=d("Kappa"),C_=d("Lambda"),C$=d("Mu"),Da=d("Ntilde"),Db=[0,209],Dc=[0,924],Dd=[0,923],De=[0,922],Df=[0,207],Dg=[0,921],Dh=[0,204],Di=[0,206],Dx=[0,201],B5=d("Sigma"),Cz=d("Otilde"),CP=d("OElig"),CQ=d("Oacute"),CR=d("Ocirc"),CS=d("Ograve"),CT=d("Omega"),CU=d("Omicron"),CV=d("Oslash"),CW=[0,fz],CX=[0,927],CY=[0,937],CZ=[0,210],C0=[0,212],C1=[0,211],C2=[0,338],CA=d("Ouml"),CB=d("Phi"),CC=d("Pi"),CD=d("Prime"),CE=d("Psi"),CF=d("Rho"),CG=d("Scaron"),CH=[0,352],CI=[0,929],CJ=[0,936],CK=[0,8243],CL=[0,928],CM=[0,934],CN=[0,214],CO=[0,213],B6=d("Uuml"),Ck=d("THORN"),Cl=d("Tau"),Cm=d("Theta"),Cn=d("Uacute"),Co=d("Ucirc"),Cp=d("Ugrave"),Cq=d("Upsilon"),Cr=[0,933],Cs=[0,217],Ct=[0,219],Cu=[0,gs],Cv=[0,920],Cw=[0,932],Cx=[0,222],B7=d("Xi"),B8=d("Yacute"),B9=d("Yuml"),B_=d("Zeta"),B$=d("aacute"),Ca=d("acirc"),Cb=d("acute"),Cc=[0,180],Cd=[0,226],Ce=[0,225],Cf=[0,918],Cg=[0,376],Ch=[0,221],Ci=[0,926],Cj=[0,220],Cy=[0,931],C3=[0,925],z7=d("delta"),A5=d("cap"),Bz=d("aring"),BP=d("agrave"),BQ=d("alefsym"),BR=d("alpha"),BS=d("amp"),BT=d("and"),BU=d("ang"),BV=d("apos"),BW=[0,39],BX=[0,8736],BY=[0,8743],BZ=[0,38],B0=[0,945],B1=[0,8501],B2=[0,cX],BA=d("asymp"),BB=d("atilde"),BC=d("auml"),BD=d("bdquo"),BE=d("beta"),BF=d("brvbar"),BG=d("bull"),BH=[0,8226],BI=[0,166],BJ=[0,946],BK=[0,8222],BL=[0,228],BM=[0,227],BN=[0,8776],BO=[0,229],A6=d("copy"),Bk=d("ccedil"),Bl=d("cedil"),Bm=d("cent"),Bn=d("chi"),Bo=d("circ"),Bp=d("clubs"),Bq=d("cong"),Br=[0,8773],Bs=[0,9827],Bt=[0,710],Bu=[0,967],Bv=[0,162],Bw=[0,184],Bx=[0,231],A7=d("crarr"),A8=d("cup"),A9=d("curren"),A_=d("dArr"),A$=d("dagger"),Ba=d("darr"),Bb=d("deg"),Bc=[0,176],Bd=[0,8595],Be=[0,8224],Bf=[0,8659],Bg=[0,164],Bh=[0,8746],Bi=[0,8629],Bj=[0,169],By=[0,8745],z8=d("fnof"),AA=d("ensp"),AQ=d("diams"),AR=d("divide"),AS=d("eacute"),AT=d("ecirc"),AU=d("egrave"),AV=d(fX),AW=d("emsp"),AX=[0,8195],AY=[0,8709],AZ=[0,232],A0=[0,234],A1=[0,233],A2=[0,247],A3=[0,9830],AB=d("epsilon"),AC=d("equiv"),AD=d("eta"),AE=d("eth"),AF=d("euml"),AG=d("euro"),AH=d("exist"),AI=[0,8707],AJ=[0,8364],AK=[0,235],AL=[0,cT],AM=[0,951],AN=[0,8801],AO=[0,949],AP=[0,8194],z9=d("gt"),Al=d("forall"),Am=d("frac12"),An=d("frac14"),Ao=d("frac34"),Ap=d("frasl"),Aq=d("gamma"),Ar=d("ge"),As=[0,8805],At=[0,947],Au=[0,8260],Av=[0,190],Aw=[0,188],Ax=[0,gl],Ay=[0,8704],z_=d("hArr"),z$=d("harr"),Aa=d("hearts"),Ab=d("hellip"),Ac=d("iacute"),Ad=d("icirc"),Ae=[0,238],Af=[0,237],Ag=[0,8230],Ah=[0,9829],Ai=[0,8596],Aj=[0,8660],Ak=[0,62],Az=[0,gz],A4=[0,gm],B3=[0,230],v7=d("prime"),x7=d("ndash"),y7=d("le"),zB=d("kappa"),zR=d("igrave"),zS=d("image"),zT=d("infin"),zU=d("iota"),zV=d("iquest"),zW=d("isin"),zX=d("iuml"),zY=[0,239],zZ=[0,8712],z0=[0,191],z1=[0,953],z2=[0,8734],z3=[0,8465],z4=[0,236],zC=d("lArr"),zD=d("lambda"),zE=d("lang"),zF=d("laquo"),zG=d("larr"),zH=d("lceil"),zI=d("ldquo"),zJ=[0,8220],zK=[0,8968],zL=[0,8592],zM=[0,171],zN=[0,10216],zO=[0,gp],zP=[0,8656],zQ=[0,954],y8=d("macr"),zm=d("lfloor"),zn=d("lowast"),zo=d("loz"),zp=d("lrm"),zq=d("lsaquo"),zr=d("lsquo"),zs=d("lt"),zt=[0,60],zu=[0,8216],zv=[0,8249],zw=[0,8206],zx=[0,9674],zy=[0,8727],zz=[0,8970],y9=d("mdash"),y_=d("micro"),y$=d("middot"),za=d(fQ),zb=d("mu"),zc=d("nabla"),zd=d("nbsp"),ze=[0,160],zf=[0,8711],zg=[0,956],zh=[0,8722],zi=[0,183],zj=[0,181],zk=[0,8212],zl=[0,175],zA=[0,8804],x8=d("or"),yC=d("oacute"),yS=d("ne"),yT=d("ni"),yU=d("not"),yV=d("notin"),yW=d("nsub"),yX=d("ntilde"),yY=d("nu"),yZ=[0,957],y0=[0,241],y1=[0,8836],y2=[0,8713],y3=[0,172],y4=[0,8715],y5=[0,8800],yD=d("ocirc"),yE=d("oelig"),yF=d("ograve"),yG=d("oline"),yH=d("omega"),yI=d("omicron"),yJ=d("oplus"),yK=[0,8853],yL=[0,959],yM=[0,969],yN=[0,8254],yO=[0,242],yP=[0,339],yQ=[0,244],yR=[0,243],x9=d("part"),yn=d("ordf"),yo=d("ordm"),yp=d("oslash"),yq=d("otilde"),yr=d("otimes"),ys=d("ouml"),yt=d("para"),yu=[0,182],yv=[0,cZ],yw=[0,8855],yx=[0,fP],yy=[0,P],yz=[0,186],yA=[0,170],x_=d("permil"),x$=d("perp"),ya=d("phi"),yb=d("pi"),yc=d("piv"),yd=d("plusmn"),ye=d("pound"),yf=[0,163],yg=[0,177],yh=[0,982],yi=[0,960],yj=[0,966],yk=[0,8869],yl=[0,8240],ym=[0,8706],yB=[0,8744],y6=[0,8211],v8=d("sup1"),w8=d("rlm"),xC=d("raquo"),xS=d("prod"),xT=d("prop"),xU=d("psi"),xV=d("quot"),xW=d("rArr"),xX=d("radic"),xY=d("rang"),xZ=[0,10217],x0=[0,8730],x1=[0,8658],x2=[0,34],x3=[0,968],x4=[0,8733],x5=[0,8719],xD=d("rarr"),xE=d("rceil"),xF=d("rdquo"),xG=d("real"),xH=d("reg"),xI=d("rfloor"),xJ=d("rho"),xK=[0,961],xL=[0,8971],xM=[0,174],xN=[0,8476],xO=[0,8221],xP=[0,8969],xQ=[0,8594],xR=[0,187],w9=d("sigma"),xn=d("rsaquo"),xo=d("rsquo"),xp=d("sbquo"),xq=d("scaron"),xr=d("sdot"),xs=d("sect"),xt=d("shy"),xu=[0,173],xv=[0,167],xw=[0,8901],xx=[0,353],xy=[0,8218],xz=[0,8217],xA=[0,8250],w_=d("sigmaf"),w$=d("sim"),xa=d("spades"),xb=d("sub"),xc=d("sube"),xd=d("sum"),xe=d("sup"),xf=[0,8835],xg=[0,8721],xh=[0,8838],xi=[0,8834],xj=[0,9824],xk=[0,8764],xl=[0,962],xm=[0,963],xB=[0,8207],v9=d("uarr"),wD=d("thetasym"),wT=d("sup2"),wU=d("sup3"),wV=d("supe"),wW=d("szlig"),wX=d("tau"),wY=d("there4"),wZ=d("theta"),w0=[0,952],w1=[0,8756],w2=[0,964],w3=[0,g4],w4=[0,8839],w5=[0,179],w6=[0,178],wE=d("thinsp"),wF=d("thorn"),wG=d("tilde"),wH=d("times"),wI=d("trade"),wJ=d("uArr"),wK=d("uacute"),wL=[0,cn],wM=[0,8657],wN=[0,8482],wO=[0,215],wP=[0,732],wQ=[0,ef],wR=[0,8201],wS=[0,977],v_=d("xi"),wo=d("ucirc"),wp=d("ugrave"),wq=d("uml"),wr=d("upsih"),ws=d("upsilon"),wt=d("uuml"),wu=d("weierp"),wv=[0,8472],ww=[0,gj],wx=[0,965],wy=[0,978],wz=[0,168],wA=[0,249],wB=[0,251],v$=d("yacute"),wa=d("yen"),wb=d("yuml"),wc=d("zeta"),wd=d("zwj"),we=d("zwnj"),wh=[0,8204],wi=[0,8205],wj=[0,950],wk=[0,T],wl=[0,165],wm=[0,253],wn=[0,958],wC=[0,8593],w7=[0,185],x6=[0,8242],z5=[0,161],wf=d(";"),wg=d(gL),D2=d("}"),D3=[0,d(u),d(u),d(u)],D4=d("${"),D5=d(fy),vF=d(f9),vE=d(u),vD=[0,d(d_),620,11],vC=[0,d(d_),614,11],vz=[0,0],vB=[0,d(d_),556,4],vx=d(u),vr=[1,d("ILLEGAL")],vp=d(cm),vq=d(cm),tu=d("T_IDENTIFIER"),tv=d("T_LCURLY"),tw=d("T_RCURLY"),tx=d("T_LCURLYBAR"),ty=d("T_RCURLYBAR"),tz=d("T_LPAREN"),tA=d("T_RPAREN"),tB=d("T_LBRACKET"),tC=d("T_RBRACKET"),tD=d("T_SEMICOLON"),tE=d("T_COMMA"),tF=d("T_PERIOD"),tG=d("T_ARROW"),tH=d("T_ELLIPSIS"),tI=d("T_AT"),tJ=d("T_FUNCTION"),tK=d("T_IF"),tL=d("T_IN"),tM=d("T_INSTANCEOF"),tN=d("T_RETURN"),tO=d("T_SWITCH"),tP=d("T_THIS"),tQ=d("T_THROW"),tR=d("T_TRY"),tS=d("T_VAR"),tT=d("T_WHILE"),tU=d("T_WITH"),tV=d("T_CONST"),tW=d("T_LET"),tX=d("T_NULL"),tY=d("T_FALSE"),tZ=d("T_TRUE"),t0=d("T_BREAK"),t1=d("T_CASE"),t2=d("T_CATCH"),t3=d("T_CONTINUE"),t4=d("T_DEFAULT"),t5=d("T_DO"),t6=d("T_FINALLY"),t7=d("T_FOR"),t8=d("T_CLASS"),t9=d("T_EXTENDS"),t_=d("T_STATIC"),t$=d("T_ELSE"),ua=d("T_NEW"),ub=d("T_DELETE"),uc=d("T_TYPEOF"),ud=d("T_VOID"),ue=d("T_ENUM"),uf=d("T_EXPORT"),ug=d("T_IMPORT"),uh=d("T_SUPER"),ui=d("T_IMPLEMENTS"),uj=d("T_INTERFACE"),uk=d("T_PACKAGE"),ul=d("T_PRIVATE"),um=d("T_PROTECTED"),un=d("T_PUBLIC"),uo=d("T_YIELD"),up=d("T_DEBUGGER"),uq=d("T_DECLARE"),ur=d("T_TYPE"),us=d("T_OF"),ut=d("T_ASYNC"),uu=d("T_AWAIT"),uv=d("T_CHECKS"),uw=d("T_RSHIFT3_ASSIGN"),ux=d("T_RSHIFT_ASSIGN"),uy=d("T_LSHIFT_ASSIGN"),uz=d("T_BIT_XOR_ASSIGN"),uA=d("T_BIT_OR_ASSIGN"),uB=d("T_BIT_AND_ASSIGN"),uC=d("T_MOD_ASSIGN"),uD=d("T_DIV_ASSIGN"),uE=d("T_MULT_ASSIGN"),uF=d("T_EXP_ASSIGN"),uG=d("T_MINUS_ASSIGN"),uH=d("T_PLUS_ASSIGN"),uI=d("T_ASSIGN"),uJ=d("T_PLING"),uK=d("T_COLON"),uL=d("T_OR"),uM=d("T_AND"),uN=d("T_BIT_OR"),uO=d("T_BIT_XOR"),uP=d("T_BIT_AND"),uQ=d("T_EQUAL"),uR=d("T_NOT_EQUAL"),uS=d("T_STRICT_EQUAL"),uT=d("T_STRICT_NOT_EQUAL"),uU=d("T_LESS_THAN_EQUAL"),uV=d("T_GREATER_THAN_EQUAL"),uW=d("T_LESS_THAN"),uX=d("T_GREATER_THAN"),uY=d("T_LSHIFT"),uZ=d("T_RSHIFT"),u0=d("T_RSHIFT3"),u1=d("T_PLUS"),u2=d("T_MINUS"),u3=d("T_DIV"),u4=d("T_MULT"),u5=d("T_EXP"),u6=d("T_MOD"),u7=d("T_NOT"),u8=d("T_BIT_NOT"),u9=d("T_INCR"),u_=d("T_DECR"),u$=d("T_ERROR"),va=d("T_EOF"),vb=d("T_JSX_IDENTIFIER"),vc=d("T_ANY_TYPE"),vd=d("T_MIXED_TYPE"),ve=d("T_EMPTY_TYPE"),vf=d("T_BOOLEAN_TYPE"),vg=d("T_NUMBER_TYPE"),vh=d("T_STRING_TYPE"),vi=d("T_VOID_TYPE"),vj=d("T_NUMBER"),vk=d("T_STRING"),vl=d("T_TEMPLATE_PART"),vm=d("T_REGEXP"),vn=d("T_JSX_TEXT"),vo=d("T_NUMBER_SINGLETON_TYPE"),vs=d("Lexer_flow.FloatOfString.No_good"),vG=hi([[0,d(gA),15],[0,d("if"),16],[0,d(gG),17],[0,d(gF),18],[0,d("return"),19],[0,d("switch"),20],[0,d("this"),21],[0,d("throw"),22],[0,d("try"),23],[0,d(f_),24],[0,d("while"),25],[0,d("with"),26],[0,d(gO),27],[0,d(gD),28],[0,d(dU),29],[0,d(d7),30],[0,d(dS),31],[0,d("break"),32],[0,d("case"),33],[0,d("catch"),34],[0,d("continue"),35],[0,d(cL),36],[0,d("do"),37],[0,d("finally"),38],[0,d("for"),39],[0,d("class"),40],[0,d(d2),41],[0,d(a6),42],[0,d("else"),43],[0,d(gw),44],[0,d(fS),45],[0,d(bN),46],[0,d(d4),47],[0,d(gH),48],[0,d("export"),49],[0,d("import"),50],[0,d("super"),51],[0,d(c2),52],[0,d(fG),53],[0,d(g8),54],[0,d(g6),55],[0,d(fM),56],[0,d(fH),57],[0,d(gb),58],[0,d("debugger"),59],[0,d("declare"),60],[0,d(bT),61],[0,d("of"),62],[0,d(ch),63],[0,d("await"),64]]),vH=hi([[0,d(a6),42],[0,d(bN),46],[0,d("any"),ci],[0,d("mixed"),111],[0,d(fX),gV],[0,d("bool"),dV],[0,d("boolean"),dV],[0,d(dS),31],[0,d(d7),30],[0,d("number"),f0],[0,d("string"),115],[0,d(d4),gg],[0,d(dU),29]]),Ek=d(f8),Ej=d(f8),Eh=d(d9),Ei=d("eval"),D$=d(c2),Ea=d(fG),Eb=d(g8),Ec=d(g6),Ed=d(fM),Ee=d(fH),Ef=d(a6),Eg=d(gb),D_=d(gH),D9=[0,d("src/parser/parser_env.ml"),291,2],D8=[0,0,0],D7=d(gS),D6=d(gS),El=d("Parser_env.Try.Rollback"),Ep=[0,d("did not consume any tokens")],EP=[0,1],EQ=[0,0,0],EO=[0,0,0],EJ=[0,d(bS),496,6],EN=d(a6),EK=d(bs),EL=d(bP),EM=d(bs),EI=[0,1],EH=[0,[0,0,0]],EG=[0,1],EF=[0,1],EE=[0,1],Ex=[0,0],Ey=[0,1],Ez=[0,2],EA=[0,7],EB=[0,5],EC=[0,6],ED=[0,3],Ew=[0,4],Ev=[0,d(bS),I,17],Eu=[0,d(bS),87,17],Et=[0,d(bS),65,11],Es=[0,d(bS),69,11],Er=[0,d(bS),47,14],EV=[0,0,0],EU=[0,31],ET=[0,0,0],ES=[0,31],FQ=[0,1],FR=[0,29],FP=[0,d(gW),810,13],FN=[0,d(gW),712,17],FO=[0,[0,d(u),d(u)],1],FM=d(dU),FL=d(f9),FJ=[0,0,0],FK=[0,31],FH=d(gw),FI=d("target"),FG=[0,1],FF=[0,0],FE=[0,1],FD=[0,0],Fv=[0,1],Fw=[0,0],Fx=[0,2],Fy=[0,3],Fz=[0,7],FA=[0,6],FB=[0,4],FC=[0,5],E$=[0,[0,17,[0,2]]],Fa=[0,[0,18,[0,3]]],Fb=[0,[0,19,[0,4]]],Fc=[0,[0,0,[0,5]]],Fd=[0,[0,1,[0,5]]],Fe=[0,[0,2,[0,5]]],Ff=[0,[0,3,[0,5]]],Fg=[0,[0,5,[0,6]]],Fh=[0,[0,7,[0,6]]],Fi=[0,[0,4,[0,6]]],Fj=[0,[0,6,[0,6]]],Fk=[0,[0,8,[0,7]]],Fl=[0,[0,9,[0,7]]],Fm=[0,[0,10,[0,7]]],Fn=[0,[0,11,[0,8]]],Fo=[0,[0,12,[0,8]]],Fp=[0,[0,15,[0,9]]],Fq=[0,[0,13,[0,9]]],Fr=[0,[0,14,[1,10]]],Fs=[0,[0,16,[0,9]]],Fu=[0,[0,21,[0,6]]],Ft=[0,[0,20,[0,6]]],EY=[0,9],EZ=[0,8],E0=[0,7],E1=[0,11],E2=[0,10],E3=[0,12],E4=[0,6],E5=[0,5],E6=[0,3],E7=[0,4],E8=[0,2],E9=[0,1],E_=[0,0],EX=d(ch),FV=d(dT),FW=d(cP),FX=[0,0,0],FT=d(u),FU=[0,d(u)],F_=[0,0,0],F2=d(dZ),F3=d(dZ),F4=[0,1],F5=[0,1],F6=[0,1],F7=[0,1],F8=d(bs),F9=d(bP),F1=[0,0,0],FZ=d(bs),F0=d(bP),GL=d(bT),GM=[0,1,[0,0]],GQ=d(bN),GR=[0,1,[0,1]],GS=[0,0,0],GN=d(aU),GO=d(aU),GP=d(aU),GU=[0,1,0],GW=[0,2,0],GV=d(ck),GT=d(aU),GK=d(ck),GH=d(aU),GI=d(aU),GG=d(ck),GJ=[0,d(dW),1109,15],Gz=d("other than an interface declaration!"),GA=d("Internal Flow Error! Parsed `export interface` into something "),GB=[0,1],GC=d("other than a type alias!"),GD=d("Internal Flow Error! Parsed `export type` into something "),Gw=d(aU),Gx=d(aU),GF=d(cL),Gy=d(ck),GE=d("Internal Flow Error! Unexpected export statement declaration!"),Gu=d(aU),Gv=d(aU),Gt=d(ck),Gp=[0,1],Gq=d(g7),Gr=[0,1],Gs=d(g7),Go=d("exports"),Gn=[0,1],Gm=[0,1],Gk=d(g3),Gl=d(g3),Gj=[0,1],Gi=[0,1],Gh=d("Label"),Gg=[0,27],Gf=[0,0,0],Ge=[0,0,0],Gc=[0,d(dW),fx,20],Gd=[0,d(dW),fz,20],Gb=d("Parser error: No such thing as an expression pattern!"),He=[0,1],Hc=d("use strict"),Hd=[0,0,0],Ha=d(fy),Hb=d("Nooo: "),GX=[0,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],GY=[0,d("src/parser/parser_flow.ml"),39,28],Hf=[0,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],Hr=[0,0],Hq=d(" errors");function
Q(a){if(typeof
a==="number")return 0;else
switch(a[0]){case
0:return[0,Q(a[1])];case
1:return[1,Q(a[1])];case
2:return[2,Q(a[1])];case
3:return[3,Q(a[1])];case
4:return[4,Q(a[1])];case
5:return[5,Q(a[1])];case
6:return[6,Q(a[1])];case
7:return[7,Q(a[1])];case
8:var
c=a[1];return[8,c,Q(a[2])];case
9:var
b=a[1];return[9,b,b,Q(a[3])];case
10:return[10,Q(a[1])];case
11:return[11,Q(a[1])];case
12:return[12,Q(a[1])];default:return[13,Q(a[1])]}}function
am(a,b){if(typeof
a==="number")return b;else
switch(a[0]){case
0:return[0,am(a[1],b)];case
1:return[1,am(a[1],b)];case
2:return[2,am(a[1],b)];case
3:return[3,am(a[1],b)];case
4:return[4,am(a[1],b)];case
5:return[5,am(a[1],b)];case
6:return[6,am(a[1],b)];case
7:return[7,am(a[1],b)];case
8:var
c=a[1];return[8,c,am(a[2],b)];case
9:var
d=a[2],e=a[1];return[9,e,d,am(a[3],b)];case
10:return[10,am(a[1],b)];case
11:return[11,am(a[1],b)];case
12:return[12,am(a[1],b)];default:return[13,am(a[1],b)]}}function
L(a,b){if(typeof
a==="number")return b;else
switch(a[0]){case
0:return[0,L(a[1],b)];case
1:return[1,L(a[1],b)];case
2:var
c=a[1];return[2,c,L(a[2],b)];case
3:var
d=a[1];return[3,d,L(a[2],b)];case
4:var
e=a[3],f=a[2],g=a[1];return[4,g,f,e,L(a[4],b)];case
5:var
h=a[3],i=a[2],j=a[1];return[5,j,i,h,L(a[4],b)];case
6:var
k=a[3],l=a[2],m=a[1];return[6,m,l,k,L(a[4],b)];case
7:var
n=a[3],o=a[2],p=a[1];return[7,p,o,n,L(a[4],b)];case
8:var
q=a[3],r=a[2],s=a[1];return[8,s,r,q,L(a[4],b)];case
9:return[9,L(a[1],b)];case
10:return[10,L(a[1],b)];case
11:var
t=a[1];return[11,t,L(a[2],b)];case
12:var
u=a[1];return[12,u,L(a[2],b)];case
13:var
v=a[2],w=a[1];return[13,w,v,L(a[3],b)];case
14:var
x=a[2],y=a[1];return[14,y,x,L(a[3],b)];case
15:return[15,L(a[1],b)];case
16:return[16,L(a[1],b)];case
17:var
z=a[1];return[17,z,L(a[2],b)];case
18:var
A=a[1];return[18,A,L(a[2],b)];case
19:return[19,L(a[1],b)];case
20:var
B=a[2],C=a[1];return[20,C,B,L(a[3],b)];case
21:var
D=a[1];return[21,D,L(a[2],b)];case
22:return[22,L(a[1],b)];default:var
E=a[1];return[23,E,L(a[2],b)]}}function
ax(a){throw[0,dc,a]}function
ay(a){throw[0,em,a]}aZ([P,hw,0]);function
dd(a,b){return HJ(a,b)?a:b}function
cu(a){return 0<=a?a:-a|0}function
y(a,b){var
c=x(a),e=x(b),d=ad(c+e|0);aM(a,0,d,0,c);aM(b,0,d,c,e);return d}function
cv(a,b){if(a){var
c=a[1];return[0,c,cv(a[2],b)]}return b}H6(0);hj(1);hj(2);function
hz(a){function
b(a){var
b=a;for(;;){if(b){var
c=b[2],d=b[1];try{H5(d);}catch(f){}var
b=c;continue}return 0}}return b(H7(0))}function
bz(a){if(a){var
d=0,c=a,g=a[2],h=a[1];for(;;){if(c){var
d=d+1|0,c=c[2];continue}var
f=bx(d,h),e=1,b=g;for(;;){if(b){var
i=b[2];f[e+1]=b[1];var
e=e+1|0,b=i;continue}return f}}}return[0]}aZ([P,hB,0]);function
de(a){var
c=0,b=a;for(;;){if(b){var
c=c+1|0,b=b[2];continue}return c}}function
bi(a){return a?a[1]:ax(hC)}function
bZ(a,b){var
c=a,d=b;for(;;){if(c){var
e=[0,c[1],d],c=c[2],d=e;continue}return d}}function
q(a){return bZ(a,0)}function
bj(a,b){if(b){var
c=b[2],d=i(a,b[1]);return[0,d,bj(a,c)]}return 0}function
M(a,b){var
c=b;for(;;){if(c){var
d=c[2];i(a,c[1]);var
c=d;continue}return 0}}function
az(a,b,c){var
e=b,d=c;for(;;){if(d){var
f=d[2],e=m(a,e,d[1]),d=f;continue}return e}}function
en(a,b){var
d=a,c=b;for(;;){if(0===d)return c;if(c){var
d=d-1|0,c=c[2];continue}throw[0,v,hD]}}function
ae(a){if(0<=a)if(!(T<a))return a;return ay(hE)}function
eo(a){if(39===a)return hF;if(92===a)return hG;if(!(14<=a))switch(a){case
8:return hH;case
9:return hI;case
10:return hJ;case
13:return hK}if(c7(a)){var
c=ad(1);S(c,0,a);return c}var
b=ad(4);S(b,0,92);S(b,1,48+(a/ah|0)|0);S(b,2,48+((a/10|0)%10|0)|0);S(b,3,48+(a%10|0)|0);return b}function
b0(a,b){var
c=ad(a);HF(c,0,a,b);return c}function
ep(a){var
b=x(a),c=ad(b);aM(a,0,c,0,b);return c}function
cw(a,b,c){if(0<=b)if(0<=c)if(!((x(a)-c|0)<b)){var
d=ad(c);aM(a,b,d,0,c);return d}return ay(hL)}function
eq(a,b,c,d,e){if(0<=e)if(0<=b)if(!((x(a)-e|0)<b))if(0<=d)if(!((x(c)-e|0)<d))return aM(a,b,c,d,e);return ay(hM)}function
aO(a,b,c,d,e){if(0<=e)if(0<=b)if(!((x(a)-e|0)<b))if(0<=d)if(!((x(c)-e|0)<d))return aM(a,b,c,d,e);return ay(hN)}function
hO(a,b,c,d){var
e=c;for(;;){if(b<=e)throw aj;if(aN(a,e)===d)return e;var
e=e+1|0;continue}}function
hP(a,b,c){var
d=x(a);if(0<=b)if(!(d<b))try{hO(a,d,b,c);var
e=1;return e}catch(f){f=al(f);if(f===aj)return 0;throw f}return ay(hQ)}function
er(a,b){return b0(a,b)}function
cx(d,b){if(b){var
a=b[1],g=[0,0],f=[0,0],h=b[2];M(function(a){g[1]++;f[1]=f[1]+x(a)|0;return 0},b);var
e=ad(f[1]+bY(x(d),g[1]-1|0)|0);aM(a,0,e,0,x(a));var
c=[0,x(a)];M(function(a){aM(d,0,e,c[1],x(d));c[1]=c[1]+x(d)|0;aM(a,0,e,c[1],x(a));c[1]=c[1]+x(a)|0;return 0},h);return e}return hR}function
es(a,b){var
d=x(b)-1|0,e=0;if(!(d<0)){var
c=e;for(;;){i(a,aN(b,c));var
f=c+1|0;if(d!==c){var
c=f;continue}break}}return 0}function
hS(a,b){return hP(a,0,b)}var
df=A,dg=Ii(0)[1],dh=Ig(0),cy=If(0),di=(1<<(dh+fF|0))-1|0,b1=bY(dh/8|0,di)-1|0;aZ([P,hT,0]);function
aA(a,b,c){var
e=H2(a,b,c);if(0<=e){c[11]=c[12];var
d=c[12];c[12]=[0,d[1],d[2],d[3],c[4]+c[6]|0];}return e}function
et(a,b,c){var
e=H9(a,b,c);if(0<=e){c[11]=c[12];var
d=c[12];c[12]=[0,d[1],d[2],d[3],c[4]+c[6]|0];}return e}function
cz(a){return cw(a[2],a[5],a[6]-a[5]|0)}function
h(a,b,c){return cw(a[2],b,c-b|0)}function
C(a,b){return _(a[2],b)}function
aB(a){var
b=a[12];a[12]=[0,b[1],b[2]+1|0,b[4],b[4]];return 0}function
cA(h){function
p(a){return a?a[4]:0}function
e(a,b,c){var
d=a?a[4]:0,e=c?c[4]:0,f=e<=d?d+1|0:e+1|0;return[0,a,b,c,f]}function
f(a,b,c){var
g=a?a[4]:0,h=c?c[4]:0;if((h+2|0)<g){if(a){var
d=a[3],k=a[2],i=a[1],m=p(d);if(m<=p(i))return e(i,k,e(d,b,c));if(d){var
n=d[2],o=d[1],q=e(d[3],b,c);return e(e(i,k,o),n,q)}return ay(hU)}return ay(hV)}if((g+2|0)<h){if(c){var
j=c[3],l=c[2],f=c[1],r=p(f);if(r<=p(j))return e(e(a,b,f),l,j);if(f){var
s=f[2],t=f[1],u=e(f[3],l,j);return e(e(a,b,t),s,u)}return ay(hW)}return ay(hX)}var
v=h<=g?g+1|0:h+1|0;return[0,a,b,c,v]}function
c(a,b){if(b){var
e=b[3],d=b[2],g=b[1],i=m(h[1],a,d);return 0===i?b:0<=i?f(g,d,c(a,e)):f(c(a,g),d,e)}return[0,0,a,0,1]}function
g(a){return[0,0,a,0,1]}function
y(a,b){if(b){var
c=b[3],d=b[2];return f(y(a,b[1]),d,c)}return g(a)}function
z(a,b){if(b){var
c=b[2],d=b[1];return f(d,c,z(a,b[3]))}return g(a)}function
d(a,b,c){if(a){if(c){var
g=c[4],h=a[4],i=c[3],j=c[2],k=c[1],l=a[3],m=a[2],n=a[1];return(g+2|0)<h?f(n,m,d(l,b,c)):(h+2|0)<g?f(d(a,b,k),j,i):e(a,b,c)}return z(b,a)}return y(b,c)}function
q(a){var
b=a;for(;;){if(b){var
c=b[1];if(c){var
b=c;continue}return b[2]}throw aj}}function
a(a){var
b=a;for(;;){if(b){var
c=b[3],d=b[2];if(c){var
b=c;continue}return d}throw aj}}function
t(a){if(a){var
b=a[1];if(b){var
c=a[3],d=a[2];return f(t(b),d,c)}return a[3]}return ay(hY)}function
k(a,b){if(a){if(b){var
c=t(b);return d(a,q(b),c)}return a}return b}function
j(a,b){if(b){var
c=b[3],e=b[2],f=b[1],k=m(h[1],a,e);if(0===k)return[0,f,1,c];if(0<=k){var
g=j(a,c),l=g[3],n=g[2];return[0,d(f,e,g[1]),n,l]}var
i=j(a,f),o=i[2],p=i[1];return[0,p,o,d(i[3],e,c)]}return hZ}var
A=0;function
H(a){return a?0:1}function
I(a,b){var
c=b;for(;;){if(c){var
f=c[3],g=c[1],d=m(h[1],a,c[2]),e=0===d?1:0;if(e)return e;var
i=0<=d?f:g,c=i;continue}return 0}}function
u(a,b){if(b){var
c=b[3],e=b[2],d=b[1],g=m(h[1],a,e);if(0===g){if(d){if(c){var
i=t(c);return f(d,q(c),i)}return d}return c}return 0<=g?f(d,e,u(a,c)):f(u(a,d),e,c)}return 0}function
l(a,b){if(a){if(b){var
g=b[4],e=b[2],h=a[4],f=a[2],m=b[3],n=b[1],o=a[3],p=a[1];if(g<=h){if(1===g)return c(e,a);var
i=j(f,b),q=i[1],r=l(o,i[3]);return d(l(p,q),f,r)}if(1===h)return c(f,b);var
k=j(e,a),s=k[1],t=l(k[3],m);return d(l(s,n),e,t)}return a}return b}function
n(a,b){if(a){if(b){var
e=a[3],f=a[2],g=a[1],c=j(f,b),h=c[1];if(0===c[2]){var
i=n(e,c[3]);return k(n(g,h),i)}var
l=n(e,c[3]);return d(n(g,h),f,l)}return 0}return 0}function
o(a,b){if(a){if(b){var
e=a[3],f=a[2],g=a[1],c=j(f,b),h=c[1];if(0===c[2]){var
i=o(e,c[3]);return d(o(g,h),f,i)}var
l=o(e,c[3]);return k(o(g,h),l)}return a}return 0}function
r(a,b){var
c=a,d=b;for(;;){if(c){var
e=[0,c[2],c[3],d],c=c[1],d=e;continue}return d}}function
B(a,b){var
l=r(b,0),d=r(a,0),c=l;for(;;){if(d){if(c){var
f=c[3],g=c[2],i=d[3],j=d[2],e=m(h[1],d[1],c[1]);if(0===e){var
k=r(g,f),d=r(j,i),c=k;continue}return e}return 1}return c?-1:0}}function
J(a,b){return 0===B(a,b)?1:0}function
s(a,b){var
c=a,d=b;for(;;){if(c){if(d){var
i=d[3],j=d[1],e=c[3],f=c[2],g=c[1],k=m(h[1],f,d[2]);if(0===k){var
l=s(g,j);if(l){var
c=e,d=i;continue}return l}if(0<=k){var
n=s([0,0,f,e,0],i);if(n){var
c=g;continue}return n}var
o=s([0,g,f,0,0],j);if(o){var
c=e;continue}return o}return 0}return 1}}function
C(a,b){var
c=b;for(;;){if(c){var
d=c[3],e=c[2];C(a,c[1]);i(a,e);var
c=d;continue}return 0}}function
D(a,b,c){var
d=b,e=c;for(;;){if(d){var
f=d[3],g=d[2],h=m(a,g,D(a,d[1],e)),d=f,e=h;continue}return e}}function
E(a,b){var
c=b;for(;;){if(c){var
g=c[3],h=c[1],d=i(a,c[2]);if(d){var
e=E(a,h);if(e){var
c=g;continue}var
f=e;}else
var
f=d;return f}return 1}}function
F(a,b){var
c=b;for(;;){if(c){var
g=c[3],h=c[1],d=i(a,c[2]);if(d)var
e=d;else{var
f=F(a,h);if(!f){var
c=g;continue}var
e=f;}return e}return 0}}function
w(a,b){if(b){var
c=b[2],g=b[3],e=w(a,b[1]),h=i(a,c),f=w(a,g);return h?d(e,c,f):k(e,f)}return 0}function
x(a,b){if(b){var
c=b[2],m=b[3],e=x(a,b[1]),f=e[2],g=e[1],n=i(a,c),h=x(a,m),j=h[2],l=h[1];if(n){var
o=k(f,j);return[0,d(g,c,l),o]}var
p=d(f,c,j);return[0,k(g,l),p]}return h0}function
b(a){if(a){var
c=a[1],d=b(a[3]);return(b(c)+1|0)+d|0}return 0}function
G(a,b){var
d=a,c=b;for(;;){if(c){var
e=c[2],f=c[1],d=[0,e,G(d,c[3])],c=f;continue}return d}}function
K(a){return G(0,a)}function
L(a,b){var
c=b;for(;;){if(c){var
d=c[2],f=c[3],g=c[1],e=m(h[1],a,d);if(0===e)return d;var
i=0<=e?f:g,c=i;continue}throw aj}}return[0,A,H,I,c,g,u,l,n,o,B,J,s,C,D,E,F,w,x,b,K,q,a,q,j,L,function(a){if(a){var
j=a[2],b=a[1];if(j){var
k=j[2],f=j[1];if(k){var
n=k[2],o=k[1];if(n){var
p=n[2],r=n[1];if(p){if(p[2]){var
d=h[1],l=function(a,b){if(2===a){if(b){var
u=b[2];if(u){var
l=u[1],j=b[1],v=m(d,j,l);return 0===v?[0,j,0]:0<=v?[0,l,[0,j,0]]:[0,j,[0,l,0]]}}}else
if(3===a)if(b){var
o=b[2];if(o){var
w=o[2];if(w){var
e=w[1],c=o[1],f=b[1],x=m(d,f,c);if(0===x){var
y=m(d,c,e);return 0===y?[0,c,0]:0<=y?[0,e,[0,c,0]]:[0,c,[0,e,0]]}if(0<=x){var
z=m(d,f,e);if(0===z)return[0,c,[0,f,0]];if(0<=z){var
A=m(d,c,e);return 0===A?[0,c,[0,f,0]]:0<=A?[0,e,[0,c,[0,f,0]]]:[0,c,[0,e,[0,f,0]]]}return[0,c,[0,f,[0,e,0]]]}var
B=m(d,c,e);if(0===B)return[0,f,[0,c,0]];if(0<=B){var
C=m(d,f,e);return 0===C?[0,f,[0,c,0]]:0<=C?[0,e,[0,f,[0,c,0]]]:[0,f,[0,e,[0,c,0]]]}return[0,f,[0,c,[0,e,0]]]}}}var
n=a>>1,D=en(n,b),E=t(n,b),i=E,h=t(a-n|0,D),g=0;for(;;){if(i){if(h){var
p=h[2],q=h[1],r=i[2],k=i[1],s=m(d,k,q);if(0===s){var
i=r,h=p,g=[0,k,g];continue}if(0<s){var
i=r,g=[0,k,g];continue}var
h=p,g=[0,q,g];continue}return bZ(i,g)}return bZ(h,g)}},t=function(a,b){if(2===a){if(b){var
u=b[2];if(u){var
n=u[1],j=b[1],v=m(d,j,n);return 0===v?[0,j,0]:0<v?[0,j,[0,n,0]]:[0,n,[0,j,0]]}}}else
if(3===a)if(b){var
p=b[2];if(p){var
w=p[2];if(w){var
e=w[1],c=p[1],f=b[1],x=m(d,f,c);if(0===x){var
y=m(d,c,e);return 0===y?[0,c,0]:0<y?[0,c,[0,e,0]]:[0,e,[0,c,0]]}if(0<x){var
z=m(d,c,e);if(0===z)return[0,f,[0,c,0]];if(0<z)return[0,f,[0,c,[0,e,0]]];var
A=m(d,f,e);return 0===A?[0,f,[0,c,0]]:0<A?[0,f,[0,e,[0,c,0]]]:[0,e,[0,f,[0,c,0]]]}var
B=m(d,f,e);if(0===B)return[0,c,[0,f,0]];if(0<B)return[0,c,[0,f,[0,e,0]]];var
C=m(d,c,e);return 0===C?[0,c,[0,f,0]]:0<C?[0,c,[0,e,[0,f,0]]]:[0,e,[0,c,[0,f,0]]]}}}var
o=a>>1,D=en(o,b),E=l(o,b),i=E,h=l(a-o|0,D),g=0;for(;;){if(i){if(h){var
q=h[2],r=h[1],s=i[2],k=i[1],t=m(d,k,r);if(0===t){var
i=s,h=q,g=[0,k,g];continue}if(0<=t){var
h=q,g=[0,r,g];continue}var
i=s,g=[0,k,g];continue}return bZ(i,g)}return bZ(h,g)}},q=de(a),s=2<=q?l(q,a):a,i=function(a,b){if(!(3<a>>>0))switch(a){case
0:return[0,0,b];case
1:if(b)return[0,[0,0,b[1],0,1],b[2]];break;case
2:if(b){var
d=b[2];if(d)return[0,[0,[0,0,b[1],0,1],d[1],0,2],d[2]]}break;default:if(b){var
f=b[2];if(f){var
g=f[2];if(g)return[0,[0,[0,0,b[1],0,1],f[1],[0,0,g[1],0,1],2],g[2]]}}}var
h=a/2|0,j=i(h,b),c=j[2],l=j[1];if(c){var
m=c[1],k=i((a-h|0)-1|0,c[2]),n=k[2];return[0,e(l,m,k[1]),n]}throw[0,v,h1]};return i(de(s),s)[1]}var
u=p[1];return c(u,c(r,c(o,c(f,g(b)))))}return c(r,c(o,c(f,g(b))))}return c(o,c(f,g(b)))}return c(f,g(b))}return g(b)}return A}]}aZ([P,h2,0]);var
h4=aZ([P,h3,0]);function
h5(a){throw h4}function
h6(a){var
c=a[1];a[1]=h5;try{var
b=i(c,0);a[1]=b;H_(a,cn);return b}catch(f){f=al(f);a[1]=function(a){throw f};throw f}}function
D(a){var
b=1<=a?a:1,c=b1<b?b1:b,d=ad(c);return[0,d,0,c,d]}function
V(a){return cw(a[1],0,a[2])}function
ev(a,b){var
c=[0,a[3]];for(;;){if(c[1]<(a[2]+b|0)){c[1]=2*c[1]|0;continue}if(b1<c[1])if((a[2]+b|0)<=b1)c[1]=b1;else
ax(h7);var
d=ad(c[1]);eq(a[1],0,d,0,a[2]);a[1]=d;a[3]=c[1];return 0}}function
r(a,b){var
c=a[2];if(a[3]<=c)ev(a,1);S(a[1],c,b);a[2]=c+1|0;return 0}function
B(a,b){var
c=x(b),d=a[2]+c|0;if(a[3]<d)ev(a,c);aO(b,0,a[1],a[2],c);a[2]=d;return 0}var
dj=6;function
ew(a){return[0,0,ad(a)]}function
ex(a,b){var
c=x(a[2]),d=a[1]+b|0,e=c<d?1:0;if(e){var
f=ad(dd(c*2|0,d));eq(a[2],0,f,0,c);a[2]=f;var
g=0;}else
var
g=e;return g}function
b2(a,b){ex(a,1);cs(a[2],a[1],b);a[1]=a[1]+1|0;return 0}function
af(a,b){var
c=x(b);ex(a,c);aO(b,0,a[2],a[1],c);a[1]=a[1]+c|0;return 0}function
ey(a){return cw(a[2],0,a[1])}function
dk(a,b){var
c=b;for(;;)if(typeof
c==="number")return 0;else
switch(c[0]){case
0:var
d=c[1];af(a,ie);var
c=d;continue;case
1:var
e=c[1];af(a,ig);var
c=e;continue;case
2:var
f=c[1];af(a,ih);var
c=f;continue;case
3:var
g=c[1];af(a,ii);var
c=g;continue;case
4:var
h=c[1];af(a,ij);var
c=h;continue;case
5:var
i=c[1];af(a,ik);var
c=i;continue;case
6:var
j=c[1];af(a,il);var
c=j;continue;case
7:var
k=c[1];af(a,im);var
c=k;continue;case
8:var
l=c[2],m=c[1];af(a,io);dk(a,m);af(a,ip);var
c=l;continue;case
9:var
n=c[3],o=c[1];af(a,iq);dk(a,o);af(a,ir);var
c=n;continue;case
10:var
p=c[1];af(a,is);var
c=p;continue;case
11:var
q=c[1];af(a,it);var
c=q;continue;case
12:var
r=c[1];af(a,iu);var
c=r;continue;default:var
s=c[1];af(a,iv);var
c=s;continue}}function
W(a){if(typeof
a==="number")return 0;else
switch(a[0]){case
0:return[0,W(a[1])];case
1:return[1,W(a[1])];case
2:return[2,W(a[1])];case
3:return[3,W(a[1])];case
4:return[4,W(a[1])];case
5:return[5,W(a[1])];case
6:return[6,W(a[1])];case
7:return[7,W(a[1])];case
8:var
b=a[1];return[8,b,W(a[2])];case
9:var
c=a[2],d=a[1];return[9,c,d,W(a[3])];case
10:return[10,W(a[1])];case
11:return[11,W(a[1])];case
12:return[12,W(a[1])];default:return[13,W(a[1])]}}function
ag(a){if(typeof
a==="number"){var
r=function(a){return 0},s=function(a){return 0},t=function(a){return 0};return[0,function(a){return 0},t,s,r]}else
switch(a[0]){case
0:var
b=ag(a[1]),u=b[4],v=b[3],w=b[2],x=b[1],y=function(a){i(w,0);return 0};return[0,function(a){i(x,0);return 0},y,v,u];case
1:var
c=ag(a[1]),z=c[4],A=c[3],B=c[2],C=c[1],D=function(a){i(B,0);return 0};return[0,function(a){i(C,0);return 0},D,A,z];case
2:var
d=ag(a[1]),E=d[4],F=d[3],G=d[2],H=d[1],I=function(a){i(G,0);return 0};return[0,function(a){i(H,0);return 0},I,F,E];case
3:var
e=ag(a[1]),J=e[4],K=e[3],L=e[2],M=e[1],N=function(a){i(L,0);return 0};return[0,function(a){i(M,0);return 0},N,K,J];case
4:var
f=ag(a[1]),O=f[4],P=f[3],Q=f[2],R=f[1],S=function(a){i(Q,0);return 0};return[0,function(a){i(R,0);return 0},S,P,O];case
5:var
g=ag(a[1]),T=g[4],U=g[3],V=g[2],Y=g[1],Z=function(a){i(V,0);return 0};return[0,function(a){i(Y,0);return 0},Z,U,T];case
6:var
h=ag(a[1]),_=h[4],$=h[3],aa=h[2],ab=h[1],ac=function(a){i(aa,0);return 0};return[0,function(a){i(ab,0);return 0},ac,$,_];case
7:var
j=ag(a[1]),ad=j[4],ae=j[3],af=j[2],ah=j[1],ai=function(a){i(af,0);return 0};return[0,function(a){i(ah,0);return 0},ai,ae,ad];case
8:var
k=ag(a[2]),aj=k[4],ak=k[3],al=k[2],am=k[1],an=function(a){i(al,0);return 0};return[0,function(a){i(am,0);return 0},an,ak,aj];case
9:var
ao=a[2],ap=a[1],l=ag(a[3]),aq=l[4],ar=l[3],as=l[2],at=l[1],m=ag(X(W(ap),ao)),au=m[4],av=m[3],aw=m[2],ax=m[1],ay=function(a){i(au,0);i(aq,0);return 0},az=function(a){i(ar,0);i(av,0);return 0},aA=function(a){i(aw,0);i(as,0);return 0};return[0,function(a){i(at,0);i(ax,0);return 0},aA,az,ay];case
10:var
n=ag(a[1]),aB=n[4],aC=n[3],aD=n[2],aE=n[1],aF=function(a){i(aD,0);return 0};return[0,function(a){i(aE,0);return 0},aF,aC,aB];case
11:var
o=ag(a[1]),aG=o[4],aH=o[3],aI=o[2],aJ=o[1],aK=function(a){i(aI,0);return 0};return[0,function(a){i(aJ,0);return 0},aK,aH,aG];case
12:var
p=ag(a[1]),aL=p[4],aM=p[3],aN=p[2],aO=p[1],aP=function(a){i(aL,0);return 0},aQ=function(a){i(aM,0);return 0},aR=function(a){i(aN,0);return 0};return[0,function(a){i(aO,0);return 0},aR,aQ,aP];default:var
q=ag(a[1]),aS=q[4],aT=q[3],aU=q[2],aV=q[1],aW=function(a){i(aS,0);return 0},aX=function(a){i(aT,0);return 0},aY=function(a){i(aU,0);return 0};return[0,function(a){i(aV,0);return 0},aY,aX,aW]}}function
X(a,b){if(typeof
a==="number")if(typeof
b==="number")return 0;else
switch(b[0]){case
10:var
c=0;break;case
11:var
c=1;break;case
12:var
c=2;break;case
13:var
c=3;break;case
8:var
c=4;break;case
9:var
c=5;break;default:throw[0,v,iw]}else
switch(a[0]){case
0:var
s=a[1];if(typeof
b==="number")var
d=1;else
switch(b[0]){case
0:return[0,X(s,b[1])];case
8:var
c=4,d=0;break;case
9:var
c=5,d=0;break;case
10:var
c=0,d=0;break;case
11:var
c=1,d=0;break;case
12:var
c=2,d=0;break;case
13:var
c=3,d=0;break;default:var
d=1;}if(d)var
c=6;break;case
1:var
t=a[1];if(typeof
b==="number")var
e=1;else
switch(b[0]){case
1:return[1,X(t,b[1])];case
8:var
c=4,e=0;break;case
9:var
c=5,e=0;break;case
10:var
c=0,e=0;break;case
11:var
c=1,e=0;break;case
12:var
c=2,e=0;break;case
13:var
c=3,e=0;break;default:var
e=1;}if(e)var
c=6;break;case
2:var
u=a[1];if(typeof
b==="number")var
f=1;else
switch(b[0]){case
2:return[2,X(u,b[1])];case
8:var
c=4,f=0;break;case
9:var
c=5,f=0;break;case
10:var
c=0,f=0;break;case
11:var
c=1,f=0;break;case
12:var
c=2,f=0;break;case
13:var
c=3,f=0;break;default:var
f=1;}if(f)var
c=6;break;case
3:var
w=a[1];if(typeof
b==="number")var
g=1;else
switch(b[0]){case
3:return[3,X(w,b[1])];case
8:var
c=4,g=0;break;case
9:var
c=5,g=0;break;case
10:var
c=0,g=0;break;case
11:var
c=1,g=0;break;case
12:var
c=2,g=0;break;case
13:var
c=3,g=0;break;default:var
g=1;}if(g)var
c=6;break;case
4:var
x=a[1];if(typeof
b==="number")var
h=1;else
switch(b[0]){case
4:return[4,X(x,b[1])];case
8:var
c=4,h=0;break;case
9:var
c=5,h=0;break;case
10:var
c=0,h=0;break;case
11:var
c=1,h=0;break;case
12:var
c=2,h=0;break;case
13:var
c=3,h=0;break;default:var
h=1;}if(h)var
c=6;break;case
5:var
y=a[1];if(typeof
b==="number")var
j=1;else
switch(b[0]){case
5:return[5,X(y,b[1])];case
8:var
c=4,j=0;break;case
9:var
c=5,j=0;break;case
10:var
c=0,j=0;break;case
11:var
c=1,j=0;break;case
12:var
c=2,j=0;break;case
13:var
c=3,j=0;break;default:var
j=1;}if(j)var
c=6;break;case
6:var
z=a[1];if(typeof
b==="number")var
k=1;else
switch(b[0]){case
6:return[6,X(z,b[1])];case
8:var
c=4,k=0;break;case
9:var
c=5,k=0;break;case
10:var
c=0,k=0;break;case
11:var
c=1,k=0;break;case
12:var
c=2,k=0;break;case
13:var
c=3,k=0;break;default:var
k=1;}if(k)var
c=6;break;case
7:var
A=a[1];if(typeof
b==="number")var
l=1;else
switch(b[0]){case
7:return[7,X(A,b[1])];case
8:var
c=4,l=0;break;case
9:var
c=5,l=0;break;case
10:var
c=0,l=0;break;case
11:var
c=1,l=0;break;case
12:var
c=2,l=0;break;case
13:var
c=3,l=0;break;default:var
l=1;}if(l)var
c=6;break;case
8:var
B=a[2],C=a[1];if(typeof
b==="number")var
n=1;else
switch(b[0]){case
8:var
D=b[1],E=X(B,b[2]);return[8,X(C,D),E];case
10:var
c=0,n=0;break;case
11:var
c=1,n=0;break;case
12:var
c=2,n=0;break;case
13:var
c=3,n=0;break;default:var
n=1;}if(n)throw[0,v,iE];break;case
9:var
F=a[3],G=a[2],H=a[1];if(typeof
b==="number")var
m=1;else
switch(b[0]){case
8:var
c=4,m=0;break;case
9:var
I=b[3],J=b[2],K=b[1],r=ag(X(W(G),K)),L=r[4];i(r[2],0);i(L,0);return[9,H,J,X(F,I)];case
10:var
c=0,m=0;break;case
11:var
c=1,m=0;break;case
12:var
c=2,m=0;break;case
13:var
c=3,m=0;break;default:var
m=1;}if(m)throw[0,v,iF];break;case
10:var
M=a[1];if(typeof
b!=="number"&&10===b[0])return[10,X(M,b[1])];throw[0,v,iG];case
11:var
N=a[1];if(typeof
b==="number")var
q=1;else
switch(b[0]){case
10:var
c=0,q=0;break;case
11:return[11,X(N,b[1])];default:var
q=1;}if(q)throw[0,v,iH];break;case
12:var
O=a[1];if(typeof
b==="number")var
p=1;else
switch(b[0]){case
10:var
c=0,p=0;break;case
11:var
c=1,p=0;break;case
12:return[12,X(O,b[1])];default:var
p=1;}if(p)throw[0,v,iI];break;default:var
P=a[1];if(typeof
b==="number")var
o=1;else
switch(b[0]){case
10:var
c=0,o=0;break;case
11:var
c=1,o=0;break;case
12:var
c=2,o=0;break;case
13:return[13,X(P,b[1])];default:var
o=1;}if(o)throw[0,v,iJ]}switch(c){case
0:throw[0,v,iz];case
1:throw[0,v,iA];case
2:throw[0,v,iB];case
3:throw[0,v,iC];case
4:throw[0,v,ix];case
5:throw[0,v,iy];default:throw[0,v,iD]}}var
$=aZ([P,iK,0]);function
dl(a,b){if(typeof
a==="number")return[0,0,b];else{if(0===a[0])return[0,[0,a[1],a[2]],b];if(typeof
b!=="number"&&2===b[0])return[0,[1,a[1]],b[1]];throw $}}function
b3(a,b,c){var
d=dl(a,c);if(typeof
b==="number"){if(0===b)return[0,d[1],0,d[2]];var
e=d[2];if(typeof
e!=="number"&&2===e[0])return[0,d[1],1,e[1]];throw $}return[0,d[1],[0,b[1]],d[2]]}function
Hy(a,b,c){if(typeof
b==="number")return[0,0,c];else
switch(b[0]){case
0:if(typeof
c!=="number"&&0===c[0]){var
t=G(b[1],c[1]);return[0,[0,t[1]],t[2]]}break;case
1:if(typeof
c!=="number"&&0===c[0]){var
u=G(b[1],c[1]);return[0,[1,u[1]],u[2]]}break;case
2:var
ae=b[2],v=dl(b[1],c),f=v[2],af=v[1];if(typeof
f!=="number"&&1===f[0]){var
w=G(ae,f[1]);return[0,[2,af,w[1]],w[2]]}throw $;case
3:var
ag=b[2],x=dl(b[1],c),h=x[2],ah=x[1];if(typeof
h!=="number"&&1===h[0]){var
y=G(ag,h[1]);return[0,[3,ah,y[1]],y[2]]}throw $;case
4:var
ai=b[4],aj=b[1],i=b3(b[2],b[3],c),j=i[3],ak=i[2],al=i[1];if(typeof
j!=="number"&&2===j[0]){var
z=G(ai,j[1]);return[0,[4,aj,al,ak,z[1]],z[2]]}throw $;case
5:var
am=b[4],ao=b[1],k=b3(b[2],b[3],c),l=k[3],ap=k[2],aq=k[1];if(typeof
l!=="number"&&3===l[0]){var
A=G(am,l[1]);return[0,[5,ao,aq,ap,A[1]],A[2]]}throw $;case
6:var
ar=b[4],as=b[1],m=b3(b[2],b[3],c),n=m[3],at=m[2],au=m[1];if(typeof
n!=="number"&&4===n[0]){var
B=G(ar,n[1]);return[0,[6,as,au,at,B[1]],B[2]]}throw $;case
7:var
av=b[4],aw=b[1],o=b3(b[2],b[3],c),p=o[3],ax=o[2],ay=o[1];if(typeof
p!=="number"&&5===p[0]){var
C=G(av,p[1]);return[0,[7,aw,ay,ax,C[1]],C[2]]}throw $;case
8:var
az=b[4],aA=b[1],q=b3(b[2],b[3],c),r=q[3],aB=q[2],aC=q[1];if(typeof
r!=="number"&&6===r[0]){var
D=G(az,r[1]);return[0,[8,aA,aC,aB,D[1]],D[2]]}throw $;case
9:if(typeof
c!=="number"&&7===c[0]){var
E=G(b[1],c[1]);return[0,[9,E[1]],E[2]]}break;case
10:var
F=G(b[1],c);return[0,[10,F[1]],F[2]];case
11:var
aD=b[1],I=G(b[2],c);return[0,[11,aD,I[1]],I[2]];case
12:var
aE=b[1],J=G(b[2],c);return[0,[12,aE,J[1]],J[2]];case
13:if(typeof
c!=="number"&&8===c[0]){var
K=c[1],aF=c[2],aG=b[3],aH=b[1];if(by([0,b[2]],[0,K]))throw $;var
L=G(aG,aF);return[0,[13,aH,K,L[1]],L[2]]}break;case
14:if(typeof
c!=="number"&&9===c[0]){var
M=c[1],aI=c[3],aJ=b[3],aK=b[2],aL=b[1],aM=[0,Q(M)];if(by([0,Q(aK)],aM))throw $;var
N=G(aJ,Q(aI));return[0,[14,aL,M,N[1]],N[2]]}break;case
15:if(typeof
c!=="number"&&10===c[0]){var
O=G(b[1],c[1]);return[0,[15,O[1]],O[2]]}break;case
16:if(typeof
c!=="number"&&11===c[0]){var
P=G(b[1],c[1]);return[0,[16,P[1]],P[2]]}break;case
17:var
aN=b[1],R=G(b[2],c);return[0,[17,aN,R[1]],R[2]];case
18:var
S=b[2],s=b[1];if(0===s[0]){var
W=s[1],aR=W[2],X=G(W[1],c),aS=X[1],Y=G(S,X[2]);return[0,[18,[0,[0,aS,aR]],Y[1]],Y[2]]}var
Z=s[1],aT=Z[2],_=G(Z[1],c),aU=_[1],aa=G(S,_[2]);return[0,[18,[1,[0,aU,aT]],aa[1]],aa[2]];case
19:if(typeof
c!=="number"&&12===c[0]){var
T=G(b[1],c[1]);return[0,[19,T[1]],T[2]]}break;case
20:if(typeof
c!=="number"&&1===c[0]){var
aO=b[2],aP=b[1],U=G(b[3],c[1]);return[0,[20,aP,aO,U[1]],U[2]]}break;case
21:if(typeof
c!=="number"&&2===c[0]){var
aQ=b[1],V=G(b[2],c[1]);return[0,[21,aQ,V[1]],V[2]]}break;case
23:var
e=b[2],d=b[1];if(typeof
d==="number")switch(d){case
0:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
1:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
2:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
3:if(typeof
c!=="number"&&13===c[0]){var
ab=G(e,c[1]);return[0,[23,3,ab[1]],ab[2]]}throw $;default:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c])}else
switch(d[0]){case
0:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
1:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
2:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
3:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
4:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
5:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
6:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);case
7:return a<50?H(1+a,[7,d[1],d[2]],e,c):g(H,[0,[7,d[1],d[2]],e,c]);case
8:var
aV=d[1],ac=an(d[2],e,c),ad=ac[2];return[0,[23,[8,aV,ac[1]],ad[1]],ad[2]];case
9:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c]);default:return a<50?H(1+a,d,e,c):g(H,[0,d,e,c])}}throw $}function
H(a,b,c,d){var
e=G(c,d);return[0,[23,b,e[1]],e[2]]}function
G(b,c){return a(Hy(0,b,c))}function
an(a,b,c){if(typeof
a==="number")return[0,0,G(b,c)];else
switch(a[0]){case
0:if(typeof
c!=="number"&&0===c[0]){var
f=an(a[1],b,c[1]);return[0,[0,f[1]],f[2]]}break;case
1:if(typeof
c!=="number"&&1===c[0]){var
g=an(a[1],b,c[1]);return[0,[1,g[1]],g[2]]}break;case
2:if(typeof
c!=="number"&&2===c[0]){var
h=an(a[1],b,c[1]);return[0,[2,h[1]],h[2]]}break;case
3:if(typeof
c!=="number"&&3===c[0]){var
j=an(a[1],b,c[1]);return[0,[3,j[1]],j[2]]}break;case
4:if(typeof
c!=="number"&&4===c[0]){var
k=an(a[1],b,c[1]);return[0,[4,k[1]],k[2]]}break;case
5:if(typeof
c!=="number"&&5===c[0]){var
l=an(a[1],b,c[1]);return[0,[5,l[1]],l[2]]}break;case
6:if(typeof
c!=="number"&&6===c[0]){var
m=an(a[1],b,c[1]);return[0,[6,m[1]],m[2]]}break;case
7:if(typeof
c!=="number"&&7===c[0]){var
n=an(a[1],b,c[1]);return[0,[7,n[1]],n[2]]}break;case
8:if(typeof
c!=="number"&&8===c[0]){var
o=c[1],w=c[2],x=a[2];if(by([0,a[1]],[0,o]))throw $;var
p=an(x,b,w);return[0,[8,o,p[1]],p[2]]}break;case
9:if(typeof
c!=="number"&&9===c[0]){var
d=c[2],e=c[1],y=c[3],z=a[3],A=a[2],B=a[1],C=[0,Q(e)];if(by([0,Q(B)],C))throw $;var
D=[0,Q(d)];if(by([0,Q(A)],D))throw $;var
q=ag(X(W(e),d)),E=q[4];i(q[2],0);i(E,0);var
r=an(Q(z),b,y),F=r[2];return[0,[9,e,d,W(r[1])],F]}break;case
10:if(typeof
c!=="number"&&10===c[0]){var
s=an(a[1],b,c[1]);return[0,[10,s[1]],s[2]]}break;case
11:if(typeof
c!=="number"&&11===c[0]){var
t=an(a[1],b,c[1]);return[0,[11,t[1]],t[2]]}break;case
12:if(typeof
c!=="number"&&12===c[0]){var
u=an(a[1],b,c[1]);return[0,[12,u[1]],u[2]]}break;default:if(typeof
c!=="number"&&13===c[0]){var
v=an(a[1],b,c[1]);return[0,[13,v[1]],v[2]]}}throw $}function
ar(a,b,c){var
d=x(c),k=0<=b?a:0,f=cu(b);if(f<=d)return c;var
l=2===k?48:32,e=b0(f,l);switch(k){case
0:aO(c,0,e,0,d);break;case
1:aO(c,0,e,f-d|0,d);break;default:if(0<d){if(43===_(c,0))var
g=1;else
if(45===_(c,0))var
g=1;else
if(32===_(c,0))var
g=1;else
var
i=0,g=0;if(g){cs(e,0,_(c,0));aO(c,1,e,(f-d|0)+1|0,d-1|0);var
i=1;}}else
var
i=0;if(!i){if(1<d)if(48===_(c,0)){if(ec===_(c,1))var
j=1;else
if(88===_(c,1))var
j=1;else
var
h=0,j=0;if(j){cs(e,1,_(c,1));aO(c,2,e,(f-d|0)+2|0,d-2|0);var
h=1;}}else
var
h=0;else
var
h=0;if(!h)aO(c,0,e,f-d|0,d);}}return e}function
bA(a,b){var
d=cu(a),c=x(b),e=_(b,0);if(58<=e)var
f=71<=e?5<(e+fK|0)>>>0?1:0:65<=e?0:1;else{if(32===e)var
g=1;else
if(43<=e)switch(e+gc|0){case
5:if(c<(d+2|0))if(1<c){var
k=ec===_(b,1)?0:88===_(b,1)?0:1;if(!k){var
i=b0(d+2|0,48);cs(i,1,_(b,1));aO(b,2,i,(d-c|0)+4|0,c-2|0);return i}}var
f=0,g=0;break;case
0:case
2:var
g=1;break;case
1:case
3:case
4:var
f=1,g=0;break;default:var
f=0,g=0;}else
var
f=1,g=0;if(g){if(c<(d+1|0)){var
h=b0(d+1|0,48);cs(h,0,e);aO(b,1,h,(d-c|0)+2|0,c-1|0);return h}var
f=1;}}if(!f)if(c<d){var
j=b0(d,48);aO(b,0,j,d-c|0,c);return j}return b}function
ez(a){var
k=0;for(;;){if(x(a)<=k)var
m=0;else{var
f=aN(a,k),v=14<=f?34===f?1:92===f?1:0:11<=f?13<=f?1:0:8<=f?1:0;if(v)var
m=1;else{if(c7(f)){var
k=k+1|0;continue}var
m=1;}}if(m){var
b=[0,0],o=x(a)-1|0,q=0;if(!(o<0)){var
j=q;for(;;){var
e=aN(a,j),w=14<=e?34===e?1:92===e?1:0:11<=e?13<=e?1:0:8<=e?1:0,t=w?2:c7(e)?1:4;b[1]=b[1]+t|0;var
u=j+1|0;if(o!==j){var
j=u;continue}break}}if(b[1]===x(a))var
n=ep(a);else{var
c=ad(b[1]);b[1]=0;var
p=x(a)-1|0,r=0;if(!(p<0)){var
h=r;for(;;){var
d=aN(a,h),i=d-34|0;if(58<i>>>0)if(-20<=i)var
l=1;else{switch(i+34|0){case
8:S(c,b[1],92);b[1]++;S(c,b[1],98);var
g=1;break;case
9:S(c,b[1],92);b[1]++;S(c,b[1],gg);var
g=1;break;case
10:S(c,b[1],92);b[1]++;S(c,b[1],ci);var
g=1;break;case
13:S(c,b[1],92);b[1]++;S(c,b[1],f0);var
g=1;break;default:var
l=1,g=0;}if(g)var
l=0;}else
var
l=56<(i-1|0)>>>0?(S(c,b[1],92),b[1]++,S(c,b[1],d),0):1;if(l)if(c7(d))S(c,b[1],d);else{S(c,b[1],92);b[1]++;S(c,b[1],48+(d/ah|0)|0);b[1]++;S(c,b[1],48+((d/10|0)%10|0)|0);b[1]++;S(c,b[1],48+(d%10|0)|0);}b[1]++;var
s=h+1|0;if(p!==h){var
h=s;continue}break}}var
n=c;}}else
var
n=a;return cx(n,iL)}}function
dm(a,b){switch(a){case
0:var
c=iZ;break;case
1:var
c=i0;break;case
2:var
c=i1;break;case
3:var
c=i2;break;case
4:var
c=i3;break;case
5:var
c=i4;break;case
6:var
c=i5;break;case
7:var
c=i6;break;case
8:var
c=i7;break;case
9:var
c=i8;break;case
10:var
c=i9;break;case
11:var
c=i_;break;default:var
c=i$;}return cx(er(1,b),c)}function
eA(a,b){switch(a){case
0:var
c=iM;break;case
1:var
c=iN;break;case
2:var
c=iO;break;case
3:var
c=iP;break;case
4:var
c=iQ;break;case
5:var
c=iR;break;case
6:var
c=iS;break;case
7:var
c=iT;break;case
8:var
c=iU;break;case
9:var
c=iV;break;case
10:var
c=iW;break;case
11:var
c=iX;break;default:var
c=iY;}return c6(c,b)}function
eB(a,b){return c6(dm(a,I),b)}function
eC(a,b){return c6(dm(a,ci),b)}function
eD(a,b){return HN(dm(a,76),b)}function
a0(a,b,c){var
m=cu(cu(b));if(15===a)var
j=c1;else{switch(a){case
15:var
f=70;break;case
0:case
1:case
2:var
f=cg;break;case
3:case
4:case
5:var
f=f4;break;case
6:case
7:case
8:var
f=69;break;case
9:case
10:case
11:var
f=c1;break;default:var
f=71;}var
j=f;}var
e=ew(16);b2(e,37);switch(a){case
1:case
4:case
7:case
10:case
13:b2(e,43);break;case
2:case
5:case
8:case
11:case
14:b2(e,32);break}b2(e,46);af(e,d(u+m));b2(e,j);var
g=HH(ey(e),c);if(15===a){var
k=HD(c),n=x(g);if(3===k)return c<0?ja:jb;if(4<=k)return jc;var
h=0;for(;;){if(h===n)var
l=0;else{var
i=_(g,h)-46|0,o=23<i>>>0?55===i?1:0:21<(i-1|0)>>>0?1:0;if(!o){var
h=h+1|0;continue}var
l=1;}return l?g:y(g,jd)}}return g}function
dF(a,b,j,d,e){var
i=b,f=d,h=e;for(;;)if(typeof
h==="number")return m(i,j,f);else
switch(h[0]){case
0:var
C=h[1];return function(a){return z(i,j,[5,f,a],C)};case
1:var
D=h[1];return function(a){return z(i,j,[4,f,cx(eo(a),je)],D)};case
2:var
y=h[2],A=h[1];return a<50?cc(1+a,i,j,f,y,A,function(a){return a}):g(cc,[0,i,j,f,y,A,function(a){return a}]);case
3:return a<50?cc(1+a,i,j,f,h[2],h[1],ez):g(cc,[0,i,j,f,h[2],h[1],ez]);case
4:return a<50?a4(1+a,i,j,f,h[4],h[2],h[3],eA,h[1]):g(a4,[0,i,j,f,h[4],h[2],h[3],eA,h[1]]);case
5:return a<50?a4(1+a,i,j,f,h[4],h[2],h[3],eB,h[1]):g(a4,[0,i,j,f,h[4],h[2],h[3],eB,h[1]]);case
6:return a<50?a4(1+a,i,j,f,h[4],h[2],h[3],eC,h[1]):g(a4,[0,i,j,f,h[4],h[2],h[3],eC,h[1]]);case
7:return a<50?a4(1+a,i,j,f,h[4],h[2],h[3],eD,h[1]):g(a4,[0,i,j,f,h[4],h[2],h[3],eD,h[1]]);case
8:var
l=h[4],n=h[3],p=h[2],o=h[1];if(typeof
p==="number"){if(typeof
n==="number")return 0===n?function(a){return z(i,j,[4,f,a0(o,dj,a)],l)}:function(a,b){return z(i,j,[4,f,a0(o,a,b)],l)};var
Y=n[1];return function(a){return z(i,j,[4,f,a0(o,Y,a)],l)}}else{if(0===p[0]){var
t=p[2],u=p[1];if(typeof
n==="number")return 0===n?function(a){return z(i,j,[4,f,ar(u,t,a0(o,dj,a))],l)}:function(a,b){return z(i,j,[4,f,ar(u,t,a0(o,a,b))],l)};var
Z=n[1];return function(a){return z(i,j,[4,f,ar(u,t,a0(o,Z,a))],l)}}var
w=p[1];if(typeof
n==="number")return 0===n?function(a,b){return z(i,j,[4,f,ar(w,a,a0(o,dj,b))],l)}:function(a,b,c){return z(i,j,[4,f,ar(w,a,a0(o,b,c))],l)};var
_=n[1];return function(a,b){return z(i,j,[4,f,ar(w,a,a0(o,_,b))],l)}}case
9:var
F=h[1];return function(a){var
b=a?hx:hy;return z(i,j,[4,f,b],F)};case
10:var
f=[7,f],h=h[1];continue;case
11:var
f=[2,f,h[1]],h=h[2];continue;case
12:var
f=[3,f,h[1]],h=h[2];continue;case
13:var
H=h[3],I=h[2],x=ew(16);dk(x,I);var
B=ey(x);return function(a){return z(i,j,[4,f,B],H)};case
14:var
J=h[3],K=h[2];return function(a){var
c=a[1],b=G(c,Q(W(K)));if(typeof
b[2]==="number")return z(i,j,f,L(b[1],J));throw $};case
15:var
M=h[1];return function(c,b){return z(i,j,[6,f,function(a){return m(c,a,b)}],M)};case
16:var
N=h[1];return function(a){return z(i,j,[6,f,a],N)};case
17:var
f=[0,f,h[1]],h=h[2];continue;case
18:var
r=h[1];if(0===r[0]){var
c=h[2],O=r[1][1],P=0,i=function(f,i,c){return function(a,b){return z(i,a,[1,f,[0,b]],c)}}(f,i,c),f=P,h=O;continue}var
s=h[2],R=r[1][1],S=0,i=function(f,i,s){return function(a,b){return z(i,a,[1,f,[1,b]],s)}}(f,i,s),f=S,h=R;continue;case
19:throw[0,v,jf];case
20:var
T=h[3],U=[8,f,jg];return function(a){return z(i,j,U,T)};case
21:var
V=h[2];return function(a){return z(i,j,[4,f,c6(jh,a)],V)};case
22:var
X=h[1];return function(a){return z(i,j,[5,f,a],X)};default:var
k=h[2],q=h[1];if(typeof
q==="number")switch(q){case
0:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
1:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
2:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
3:throw[0,v,ji];default:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k])}else
switch(q[0]){case
0:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
1:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
2:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
3:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
4:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
5:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
6:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
7:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);case
8:return a<50?dE(1+a,i,j,f,q[2],k):g(dE,[0,i,j,f,q[2],k]);case
9:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k]);default:return a<50?E(1+a,i,j,f,k):g(E,[0,i,j,f,k])}}}function
dE(a,h,c,d,e,f){if(typeof
e==="number")return a<50?E(1+a,h,c,d,f):g(E,[0,h,c,d,f]);else
switch(e[0]){case
0:var
b=e[1];return function(a){return aC(h,c,d,b,f)};case
1:var
i=e[1];return function(a){return aC(h,c,d,i,f)};case
2:var
j=e[1];return function(a){return aC(h,c,d,j,f)};case
3:var
k=e[1];return function(a){return aC(h,c,d,k,f)};case
4:var
l=e[1];return function(a){return aC(h,c,d,l,f)};case
5:var
m=e[1];return function(a){return aC(h,c,d,m,f)};case
6:var
n=e[1];return function(a){return aC(h,c,d,n,f)};case
7:var
o=e[1];return function(a){return aC(h,c,d,o,f)};case
8:var
p=e[2];return function(a){return aC(h,c,d,p,f)};case
9:var
q=e[3],r=e[2],s=X(W(e[1]),r);return function(a){return aC(h,c,d,am(s,q),f)};case
10:var
t=e[1];return function(a,b){return aC(h,c,d,t,f)};case
11:var
u=e[1];return function(a){return aC(h,c,d,u,f)};case
12:throw[0,v,jj];default:throw[0,v,jk]}}function
E(a,b,c,d,e){return a<50?dF(1+a,b,c,[8,d,eE],e):g(dF,[0,b,c,[8,d,eE],e])}function
cc(a,h,c,d,e,f,g){if(typeof
f==="number")return function(a){return z(h,c,[4,d,i(g,a)],e)};else{if(0===f[0]){var
b=f[2],j=f[1];return function(a){return z(h,c,[4,d,ar(j,b,i(g,a))],e)}}var
k=f[1];return function(a,b){return z(h,c,[4,d,ar(k,a,i(g,b))],e)}}}function
a4(a,k,j,d,e,f,g,h,i){if(typeof
f==="number"){if(typeof
g==="number")return 0===g?function(a){return z(k,j,[4,d,m(h,i,a)],e)}:function(a,b){return z(k,j,[4,d,bA(a,m(h,i,b))],e)};var
b=g[1];return function(a){return z(k,j,[4,d,bA(b,m(h,i,a))],e)}}else{if(0===f[0]){var
c=f[2],l=f[1];if(typeof
g==="number")return 0===g?function(a){return z(k,j,[4,d,ar(l,c,m(h,i,a))],e)}:function(a,b){return z(k,j,[4,d,ar(l,c,bA(a,m(h,i,b)))],e)};var
o=g[1];return function(a){return z(k,j,[4,d,ar(l,c,bA(o,m(h,i,a)))],e)}}var
n=f[1];if(typeof
g==="number")return 0===g?function(a,b){return z(k,j,[4,d,ar(n,a,m(h,i,b))],e)}:function(a,b,c){return z(k,j,[4,d,ar(n,a,bA(b,m(h,i,c)))],e)};var
p=g[1];return function(a,b){return z(k,j,[4,d,ar(n,a,bA(p,m(h,i,b)))],e)}}}function
z(b,j,d,e){return a(dF(0,b,j,d,e))}function
aC(h,c,d,e,f){return a(dE(0,h,c,d,e,f))}function
a9(a,b){var
c=b;for(;;)if(typeof
c==="number")return 0;else
switch(c[0]){case
0:var
e=c[2],h=c[1];if(typeof
e==="number")switch(e){case
0:var
d=h8;break;case
1:var
d=h9;break;case
2:var
d=h_;break;case
3:var
d=h$;break;case
4:var
d=ia;break;case
5:var
d=ib;break;default:var
d=ic;}else
switch(e[0]){case
0:var
d=e[1];break;case
1:var
d=e[1];break;default:var
d=y(id,er(1,e[1]));}a9(a,h);return B(a,d);case
1:var
f=c[2],g=c[1];if(0===f[0]){var
j=f[1];a9(a,g);B(a,jl);var
c=j;continue}var
k=f[1];a9(a,g);B(a,jm);var
c=k;continue;case
6:var
n=c[2];a9(a,c[1]);return B(a,i(n,0));case
7:var
c=c[1];continue;case
8:var
o=c[2];a9(a,c[1]);return ay(o);case
2:case
4:var
l=c[2];a9(a,c[1]);return B(a,l);default:var
m=c[2];a9(a,c[1]);return r(a,m)}}function
eF(a){var
b=a[1];return z(function(a,b){var
c=D(64);a9(c,b);return V(c)},0,0,b)}var
eG=[0,0];function
eH(a){eG[1]=[0,a,eG[1]];return 0}32===dh;try{var
Hx=da(Hw),eJ=Hx;}catch(f){f=al(f);if(f!==aj)throw f;try{var
Hv=da(Hu),eI=Hv;}catch(f){f=al(f);if(f!==aj)throw f;var
eI=jo;}var
eJ=eI;}var
jp=hS(eJ,82),cB=[cZ,function(a){var
o=Ik(0),c=[0,bx(55,0),0],k=0===o.length-1?[0,0]:o,l=k.length-1,b=0;for(;;){f(c[1],b)[b+1]=b;var
v=b+1|0;if(54!==b){var
b=v;continue}var
i=[0,jn],m=54+dd(55,l)|0,q=0;if(!(m<0)){var
e=q;for(;;){var
g=e%55|0,n=hk(e,l),r=f(k,n)[n+1],j=y(i[1],d(u+r));i[1]=H4(j,0,x(j));var
h=i[1],p=((_(h,0)+(_(h,1)<<8)|0)+(_(h,2)<<16)|0)+(_(h,3)<<24)|0,s=(f(c[1],g)[g+1]^p)&cK;f(c[1],g)[g+1]=s;var
t=e+1|0;if(m!==e){var
e=t;continue}break}}c[2]=0;return c}}];function
eK(a,b){var
m=a?a[1]:jp,d=16;for(;;){if(!(b<=d))if(!(di<(d*2|0))){var
d=d*2|0;continue}if(m){var
k=hn(cB),c=cn===k?cB[1]:cZ===k?h6(cB):cB;c[2]=(c[2]+1|0)%55|0;var
e=c[2],g=f(c[1],e)[e+1],h=(c[2]+24|0)%55|0,i=(f(c[1],h)[h+1]+(g^(g>>>25|0)&31)|0)&cK,j=c[2];f(c[1],j)[j+1]=i;var
l=i;}else
var
l=0;return[0,0,bx(d,0),l,d]}}function
dn(a,b){return 3<=a.length-1?HK(10,ah,a[3],b)&(a[2].length-1-1|0):hk(HL(10,ah,b),a[2].length-1)}function
eL(d,b,c){var
e=dn(d,b),r=[0,b,c,f(d[2],e)[e+1]];f(d[2],e)[e+1]=r;d[1]=d[1]+1|0;var
o=d[2].length-1<<1<d[1]?1:0;if(o){var
h=d[2],i=h.length-1,j=i*2|0,k=j<di?1:0;if(k){var
g=bx(j,0);d[2]=g;var
l=function(a){if(a){var
c=a[1],e=a[2];l(a[3]);var
b=dn(d,c);return g[b+1]=[0,c,e,f(g,b)[b+1]]}return 0},m=i-1|0,p=0;if(!(m<0)){var
a=p;for(;;){l(f(h,a)[a+1]);var
q=a+1|0;if(m!==a){var
a=q;continue}break}}var
n=0;}else
var
n=k;return n}return o}function
eM(a,b){var
h=dn(a,b),d=f(a[2],h)[h+1];if(d){var
e=d[3],k=d[2];if(0===bW(b,d[1]))return k;if(e){var
g=e[3],l=e[2];if(0===bW(b,e[1]))return l;if(g){var
m=g[3],n=g[2];if(0===bW(b,g[1]))return n;var
c=m;for(;;){if(c){var
i=c[3],j=c[2];if(0===bW(b,c[1]))return j;var
c=i;continue}throw aj}}throw aj}throw aj}throw aj}var
aE=g$,aD=Hz;function
jq(a,b){var
c=hn(b)===P?b:b[1];return Id(a,c)}try{da(Ht);}catch(f){f=al(f);if(f!==aj)throw f}try{da(Hs);}catch(f){f=al(f);if(f!==aj)throw f}if(j(dg,jr))if(j(dg,js))if(j(dg,jt))throw[0,v,ju];var
eN=a8,eO=undefined,jv=null;function
b4(a){return a!==eO?1:0}var
jw=eN.Array,eP=aZ([P,jx,0]);jq(jy,[0,eP,{}]);eH(function(a){return a[1]===eP?[0,cr(a[2].toString())]:0});eH(function(a){return a
instanceof
jw?0:[0,cr(a.toString())]});function
eQ(a,b,c){var
d=c[4],e=dd(0,c[4]-c[3]|0);return[0,a,[0,b[2],b[4]-b[3]|0,b[4]],[0,c[2],e,d]]}function
n(a,b){return[0,a[1],a[2],b[3]]}function
eR(a){return typeof
a==="number"?jz:a[1]}function
eS(a){if(typeof
a==="number")return 1;else
switch(a[0]){case
0:return 2;case
3:return 4;default:return 3}}function
eT(a,b){return bW([0,a[1],a[2]],[0,b[1],b[2]])}var
eU=aZ([P,jA,0]),eV=m(aD,kU,kT),eW=m(aD,kW,kV),eX=m(aD,kY,kX),eY=m(aD,k0,kZ),eZ=m(aD,k2,k1),e0=m(aD,k4,k3),e1=m(aD,k6,k5),e2=m(aD,k8,k7),e3=m(aD,k_,k9),e4=m(aD,la,k$),e5=m(aD,lc,lb);w(aE,ld,eV,eV);w(aE,le,eW,eW);w(aE,lf,eX,eX);w(aE,lg,eY,eY);w(aE,lh,eZ,eZ);w(aE,li,e0,e0);w(aE,lj,e1,e1);w(aE,lk,e2,e2);w(aE,ll,e3,e3);w(aE,lm,e4,e4);w(aE,ln,e5,e5);function
lo(e){function
k(a,b){var
c=bz(bj(a,b));return i(e[4],c)}function
A(a){return i(e[5],a)}function
f(a,b){return b?i(a,b[1]):e[6]}function
b(a){var
b=[0,lp,A(a[2])],c=[0,[0,lq,A(a[1])],b];return i(e[3],c)}function
ad(a){var
c=a[1];if(c)var
d=c[1],g=typeof
d==="number"?i(e[1],lr):i(e[1],d[1]),f=g;else
var
f=e[6];var
h=[0,ls,b(a[3])],j=[0,[0,lu,f],[0,lt,b(a[2])],h];return i(e[3],j)}function
d(a,b,c){var
j=A(b[3][3]),k=[0,A(b[2][3]),j],l=[0,lv,i(e[4],k)],m=[0,lw,ad(b)],d=[0,[0,lx,i(e[1],a)],m,l],g=d.length-1;if(0===g)var
f=c.length-1,h=0===f?[0]:hb(c,0,f);else
var
h=0===c.length-1?hb(d,0,g):HA(d,c);return i(e[3],h)}function
an(a){return k(function(a){var
c=a[2];if(typeof
c==="number"){var
d=c;if(34<=d)switch(d){case
34:var
b=j_;break;case
35:var
b=j$;break;case
36:var
b=ka;break;case
37:var
b=kb;break;case
38:var
b=kc;break;case
39:var
b=kd;break;case
40:var
b=ke;break;case
41:var
b=kf;break;case
42:var
b=kg;break;case
43:var
b=kh;break;case
44:var
b=ki;break;case
45:var
b=kj;break;case
46:var
b=y(kl,kk);break;case
47:var
b=y(kn,km);break;case
48:var
b=ko;break;case
49:var
b=kp;break;case
50:var
b=kq;break;case
51:var
b=kr;break;case
52:var
b=ks;break;case
53:var
b=kt;break;case
54:var
b=ku;break;case
55:var
b=kv;break;case
56:var
b=kw;break;case
57:var
b=kx;break;case
58:var
b=ky;break;case
59:var
b=kz;break;case
60:var
b=kA;break;case
61:var
b=kB;break;case
62:var
b=kC;break;case
63:var
b=kD;break;case
64:var
b=y(kF,kE);break;case
65:var
b=kG;break;default:var
b=kH;}else
switch(d){case
0:var
b=jB;break;case
1:var
b=jC;break;case
2:var
b=jD;break;case
3:var
b=jE;break;case
4:var
b=jF;break;case
5:var
b=jG;break;case
6:var
b=jH;break;case
7:var
b=jI;break;case
8:var
b=jJ;break;case
9:var
b=jK;break;case
10:var
b=jL;break;case
11:var
b=jM;break;case
12:var
b=jN;break;case
13:var
b=jO;break;case
14:var
b=jP;break;case
15:var
b=jQ;break;case
16:var
b=jR;break;case
17:var
b=jS;break;case
18:var
b=jT;break;case
19:var
b=y(jV,jU);break;case
20:var
b=jW;break;case
21:var
b=jX;break;case
22:var
b=jY;break;case
23:var
b=jZ;break;case
24:var
b=j0;break;case
25:var
b=j1;break;case
26:var
b=j2;break;case
27:var
b=j3;break;case
28:var
b=j4;break;case
29:var
b=j5;break;case
30:var
b=j6;break;case
31:var
b=j7;break;case
32:var
b=j8;break;default:var
b=j9;}}else
switch(c[0]){case
0:var
b=y(kI,c[1]);break;case
1:var
b=y(kJ,c[1]);break;case
2:var
f=c[2],g=c[1],b=m(eF(kK),g,f);break;case
3:var
b=y(kM,y(c[1],kL));break;case
4:var
b=y(kO,y(c[1],kN));break;case
5:var
h=y(kQ,y(c[2],kP)),b=y(c[1],h);break;case
6:var
b=y(kR,c[1]);break;default:var
j=c[1],b=i(eF(kS),j);}var
k=[0,ly,i(e[1],b)],l=[0,[0,lz,ad(a[1])],k];return i(e[3],l)},a)}function
ao(a){var
b=[0,lA,k(aR,a[3])],c=[0,[0,lB,ae(a[2])],b];return d(lC,a[1],c)}function
ae(a){return k(p,a)}function
be(a,b){var
j=b[2],h=b[1];if(typeof
j==="number")return 0===j?d(lD,h,[0]):d(lE,h,[0]);else
switch(j[0]){case
0:return a<50?Y(1+a,[0,h,j[1]]):g(Y,[0,[0,h,j[1]]]);case
1:return d(lG,h,[0,[0,lF,c(j[1][1])]]);case
2:var
G=j[1],al=[0,lH,f(p,G[3])],am=[0,lI,p(G[2])];return d(lK,h,[0,[0,lJ,c(G[1])],am,al]);case
3:var
S=j[1],an=[0,lL,p(S[2])];return d(lN,h,[0,[0,lM,l(S[1])],an]);case
4:return d(lP,h,[0,[0,lO,f(l,j[1][1])]]);case
5:return d(lR,h,[0,[0,lQ,f(l,j[1][1])]]);case
6:var
Z=j[1],ao=[0,lS,p(Z[2])];return d(lU,h,[0,[0,lT,c(Z[1])],ao]);case
7:return a<50?U(1+a,[0,h,j[1]]):g(U,[0,[0,h,j[1]]]);case
8:var
_=j[1],av=[0,lV,k(ap,_[2])];return d(lX,h,[0,[0,lW,c(_[1])],av]);case
9:return d(lZ,h,[0,[0,lY,f(c,j[1][1])]]);case
10:return d(l1,h,[0,[0,l0,c(j[1][1])]]);case
11:var
I=j[1],ax=[0,l2,f(v,I[3])],ay=[0,l3,f(aq,I[2])];return d(l5,h,[0,[0,l4,v(I[1])],ay,ax]);case
12:var
$=j[1],az=[0,l6,p($[2])];return d(l8,h,[0,[0,l7,c($[1])],az]);case
13:var
aa=j[1],aA=[0,l9,c(aa[2])];return d(l$,h,[0,[0,l_,p(aa[1])],aA]);case
14:var
A=j[1],aB=function(a){return 0===a[0]?H(a[1]):c(a[1])},aC=[0,ma,p(A[4])],aD=[0,mb,f(c,A[3])],aE=[0,mc,f(c,A[2])];return d(me,h,[0,[0,md,f(aB,A[1])],aE,aD,aC]);case
15:var
B=j[1],J=B[1],aF=0===J[0]?H(J[1]):c(J[1]),aG=[0,mf,i(e[2],B[4])],aH=[0,mg,p(B[3])];return d(mj,h,[0,[0,mi,aF],[0,mh,c(B[2])],aH,aG]);case
16:var
D=j[1],aI=D[4]?mk:mo,K=D[1],aJ=0===K[0]?H(K[1]):c(K[1]),aK=[0,ml,p(D[3])];return d(aI,h,[0,[0,mn,aJ],[0,mm,c(D[2])],aK]);case
17:var
m=j[1],Q=m[3],a2=0===Q[0]?v(Q[1]):c(Q[1]),a3=[0,oK,f(u,m[9])],a4=[0,oL,f(t,m[8])],a5=[0,oM,i(e[2],m[7])],a6=[0,oN,f(C,m[6])],a7=[0,oO,i(e[2],m[5])],a8=[0,oP,i(e[2],m[4])],a9=[0,oR,F(m[2])];return d(oT,h,[0,[0,oS,f(l,m[1])],a9,[0,oQ,a2],a8,a7,a6,a5,a4,a3]);case
18:return a<50?R(1+a,[0,h,j[1]]):g(R,[0,[0,h,j[1]]]);case
19:var
q=j[1],a_=[0,pA,k(c,q[7])],a$=[0,pB,k(ah,q[6])],ba=[0,pC,f(z,q[5])],bb=[0,pD,f(u,q[4])],bc=[0,pE,f(c,q[3])],bd=[0,pF,ai(q[2])];return d(pH,h,[0,[0,pG,f(l,q[1])],bd,bc,bb,ba,a$,a_]);case
20:return a<50?T(1+a,[0,h,j[1]]):g(T,[0,[0,h,j[1]]]);case
21:return a<50?X(1+a,[0,h,j[1]]):g(X,[0,[0,h,j[1]]]);case
22:return a<50?W(1+a,[0,h,j[1]]):g(W,[0,[0,h,j[1]]]);case
23:return a<50?V(1+a,[0,h,j[1]]):g(V,[0,[0,h,j[1]]]);case
24:var
L=j[1],M=L[1],aL=0===M[0]?l(M[1]):r(M[1]),aM=0===L[3][0]?i(e[1],mp):i(e[1],mu);return d(mt,h,[0,[0,ms,aL],[0,mr,v(L[2])],[0,mq,aM]]);case
25:return d(mw,h,[0,[0,mv,t(j[1])]]);case
26:var
x=j[1],ab=x[3];if(ab){var
ac=ab[1];if(0!==ac[0])if(!ac[2])return d(mD,h,[0,[0,mC,f(r,x[4])]])}var
ad=x[2];if(ad){var
s=ad[1];switch(s[0]){case
0:var
y=ar(s[1]);break;case
1:var
y=as(s[1]);break;case
2:var
y=at(s[1]);break;case
3:var
y=o(s[1]);break;case
4:var
y=au(s[1]);break;default:var
y=aw(s[1]);}var
ae=y;}else
var
ae=e[6];var
aN=[0,mx,f(r,x[4])],aO=[0,my,ag(x[3])];return d(mB,h,[0,[0,mA,i(e[2],x[1])],[0,mz,ae],aO,aN]);case
27:var
w=j[1],af=w[2];if(af){var
aj=af[1];if(0!==aj[0])if(!aj[2]){var
aT=E(w[4]),aU=[0,mJ,i(e[1],aT)];return d(mL,h,[0,[0,mK,f(r,w[3])],aU])}}var
aP=E(w[4]),aQ=[0,mE,i(e[1],aP)],aR=[0,mF,f(r,w[3])],aS=[0,mG,ag(w[2])];return d(mI,h,[0,[0,mH,f(p,w[1])],aS,aR,aQ]);case
28:var
ak=j[1],N=ak[1],aV=0===N[0]?p(N[1]):c(N[1]),aW=E(ak[2]);return d(mO,h,[0,[0,mN,aV],[0,mM,i(e[1],aW)]]);default:var
O=j[1],aX=O[3],aY=bj(function(a){switch(a[0]){case
0:var
g=a[1],j=g[1],b=g[3],c=g[2],q=c?n(b[1],c[1][1]):b[1],r=c?c[1]:b;if(j)switch(j[1]){case
0:var
h=i(e[1],ti),f=1;break;case
1:var
h=i(e[1],tn),f=1;break;default:var
f=0;}else
var
f=0;if(!f)var
h=e[6];var
s=[0,tk,l(r)];return d(tm,q,[0,[0,tl,l(b)],s,[0,tj,h]]);case
1:var
k=a[1],o=[0,[0,te,l(k)]];return d(tf,k[1],o);default:var
m=a[1],p=[0,[0,tg,l(m[2])]];return d(th,m[1],p)}},aX);switch(O[1]){case
0:var
P=mP;break;case
1:var
P=mU;break;default:var
P=mV;}var
aZ=[0,mQ,i(e[1],P)],a0=[0,mR,r(O[2])],a1=bz(aY);return d(mT,h,[0,[0,mS,i(e[4],a1)],a0,aZ])}}function
j(a,b){var
h=b[2],j=b[1];if(typeof
h==="number")return 0===h?d(mW,j,[0]):d(mX,j,[0]);else
switch(h[0]){case
0:var
T=h[1][1];return d(mZ,j,[0,[0,mY,k(function(a){return f(G,a)},T)]]);case
1:return d(m1,j,[0,[0,m0,k(aA,h[1][1])]]);case
2:return a<50?$(1+a,[0,j,h[1]]):g($,[0,[0,j,h[1]]]);case
3:var
o=h[1],w=o[3],U=0===w[0]?v(w[1]):c(w[1]),V=[0,m2,f(u,o[9])],W=[0,m3,f(t,o[8])],X=[0,m4,i(e[2],o[7])],Y=[0,m5,f(C,o[6])],Z=[0,m6,i(e[2],o[5])],aa=[0,m7,i(e[2],o[4])],ab=[0,m9,F(o[2])];return d(m$,j,[0,[0,m_,f(l,o[1])],ab,[0,m8,U],aa,Z,Y,X,W,V]);case
4:return d(nb,j,[0,[0,na,k(c,h[1][1])]]);case
5:var
r=h[1];if(7<=r[1])return d(nd,j,[0,[0,nc,c(r[3])]]);switch(r[1]){case
0:var
p=ne;break;case
1:var
p=nj;break;case
2:var
p=nk;break;case
3:var
p=nl;break;case
4:var
p=nm;break;case
5:var
p=nn;break;case
6:var
p=no;break;default:var
p=ax(np);}var
ac=[0,nf,c(r[3])],ad=[0,ng,i(e[2],r[2])];return d(ni,j,[0,[0,nh,i(e[1],p)],ad,ac]);case
6:var
x=h[1];switch(x[1]){case
0:var
m=nq;break;case
1:var
m=nv;break;case
2:var
m=nw;break;case
3:var
m=nx;break;case
4:var
m=ny;break;case
5:var
m=nz;break;case
6:var
m=nA;break;case
7:var
m=nB;break;case
8:var
m=nC;break;case
9:var
m=nD;break;case
10:var
m=nE;break;case
11:var
m=nF;break;case
12:var
m=nG;break;case
13:var
m=nH;break;case
14:var
m=nI;break;case
15:var
m=nJ;break;case
16:var
m=nK;break;case
17:var
m=nL;break;case
18:var
m=nM;break;case
19:var
m=nN;break;case
20:var
m=nO;break;default:var
m=nP;}var
ae=[0,nr,c(x[3])],af=[0,ns,c(x[2])];return d(nu,j,[0,[0,nt,i(e[1],m)],af,ae]);case
7:var
y=h[1];switch(y[1]){case
0:var
n=nQ;break;case
1:var
n=nV;break;case
2:var
n=nW;break;case
3:var
n=nX;break;case
4:var
n=nY;break;case
5:var
n=nZ;break;case
6:var
n=n0;break;case
7:var
n=n1;break;case
8:var
n=n2;break;case
9:var
n=n3;break;case
10:var
n=n4;break;case
11:var
n=n5;break;default:var
n=n6;}var
ag=[0,nR,c(y[3])],aj=[0,nS,s(y[2])];return d(nU,j,[0,[0,nT,i(e[1],n)],aj,ag]);case
8:var
A=h[1],al=0===A[1]?n7:oa,am=[0,n8,i(e[2],A[3])],an=[0,n9,c(A[2])];return d(n$,j,[0,[0,n_,i(e[1],al)],an,am]);case
9:var
B=h[1],ao=0===B[1]?ob:og,ap=[0,oc,c(B[3])],aq=[0,od,c(B[2])];return d(of,j,[0,[0,oe,i(e[1],ao)],aq,ap]);case
10:var
D=h[1],ar=[0,oh,c(D[3])],as=[0,oi,c(D[2])];return d(ok,j,[0,[0,oj,c(D[1])],as,ar]);case
11:var
I=h[1],at=[0,ol,k(G,I[2])];return d(on,j,[0,[0,om,c(I[1])],at]);case
12:var
J=h[1],au=[0,oo,k(G,J[2])];return d(oq,j,[0,[0,op,c(J[1])],au]);case
13:var
E=h[1],H=E[2],av=0===H[0]?l(H[1]):c(H[1]),aw=[0,or,i(e[2],E[3])];return d(ou,j,[0,[0,ot,c(E[1])],[0,os,av],aw]);case
14:var
L=h[1],ay=[0,ov,i(e[2],L[2])];return d(ox,j,[0,[0,ow,f(c,L[1])],ay]);case
15:var
M=h[1],az=[0,oy,f(c,M[2])];return d(oA,j,[0,[0,oz,k(ak,M[1])],az]);case
16:var
N=h[1],aB=[0,oB,f(c,N[2])];return d(oD,j,[0,[0,oC,k(ak,N[1])],aB]);case
17:return a<50?_(1+a,h[1]):g(_,[0,h[1]]);case
18:return a<50?Q(1+a,[0,j,h[1]]):g(Q,[0,[0,j,h[1]]]);case
19:return a<50?P(1+a,[0,j,h[1]]):g(P,[0,[0,j,h[1]]]);case
20:var
O=h[1],aL=[0,rc,aC(O[2])];return d(re,j,[0,[0,rd,c(O[1])],aL]);case
21:return a<50?K(1+a,[0,j,h[1]]):g(K,[0,[0,j,h[1]]]);case
22:var
q=h[1],aF=[0,pI,k(c,q[7])],aG=[0,pJ,k(ah,q[6])],aH=[0,pK,f(z,q[5])],aI=[0,pL,f(u,q[4])],aJ=[0,pM,f(c,q[3])],aK=[0,pN,ai(q[2])];return d(pP,j,[0,[0,pO,f(l,q[1])],aK,aJ,aI,aH,aG,aF]);case
23:var
R=h[1],aD=[0,oE,t(R[2])];return d(oG,j,[0,[0,oF,c(R[1])],aD]);default:var
S=h[1],aE=[0,oH,l(S[2])];return d(oJ,j,[0,[0,oI,l(S[1])],aE])}}function
$(a,b){var
g=b[2],h=g[3],j=0===h[0]?v(h[1]):c(h[1]),k=[0,oU,f(u,g[9])],m=[0,oV,f(t,g[8])],n=[0,oW,i(e[2],g[7])],o=[0,oX,f(C,g[6])],p=[0,oY,i(e[2],g[5])],q=[0,oZ,i(e[2],g[4])],r=[0,o1,F(g[2])],s=[0,[0,o2,f(l,g[1])],r,[0,o0,j],q,p,o,n,m,k];return d(o3,b[1],s)}function
_(a,b){var
c=[0,o4,i(e[2],0)],f=[0,o5,e[6]],g=[0,[0,o6,i(e[1],b[2])],f,c];return d(o7,b[1],g)}function
Z(a,b,c){var
g=[0,o8,i(e[2],c[3])],h=[0,o9,f(t,c[2])];return d(o$,b,[0,[0,o_,i(e[1],c[1][2])],h,g])}function
bd(a,b){var
e=b[2],g=[0,pa,k(p,e[2])],h=[0,[0,pb,f(c,e[1])],g];return d(pc,b[1],h)}function
bc(a,b){var
c=b[2],e=[0,pd,v(c[2])],f=[0,[0,pe,s(c[1])],e];return d(pf,b[1],f)}function
Y(a,b){var
c=[0,[0,pg,ae(b[2][1])]];return d(ph,b[1],c)}function
X(a,b){var
c=b[2],e=c[2],f=e?e[1][1]:c[1][1],g=n(c[1][1],f),h=[0,[0,pi,af(g,[0,c[1],c[2],0])]];return d(pj,b[1],h)}function
W(a,b){var
c=b[2],e=n(c[1][1],c[2][1]),g=[0,pk,f(C,c[3])],h=[0,[0,pl,af(e,[0,c[1],[0,c[2]],0])],g];return d(pm,b[1],h)}function
V(a,b){var
c=b[2],e=[0,pn,k(aj,c[4])],g=[0,po,al(c[3])],h=[0,pp,f(u,c[2])],i=[0,[0,pq,l(c[1])],h,g,e];return d(pr,b[1],i)}function
bb(a,b){return 0===b?ps:pt}function
ba(a,b){if(b){var
c=b[1];if(0===c[0])return k(aQ,c[1]);var
f=c[2];if(f){var
g=[0,[0,pu,l(f[1])]],h=[0,d(pv,c[1],g)];return i(e[4],h)}return i(e[4],[0])}return i(e[4],[0])}function
U(a,b){var
c=b[2],e=[0,pw,o(c[3])],g=[0,px,f(u,c[2])],h=[0,[0,py,l(c[1])],g,e];return d(pz,b[1],h)}function
a$(a,b){var
c=b[2],e=[0,pQ,f(z,c[2])],g=[0,[0,pR,l(c[1])],e];return d(pS,b[1],g)}function
a_(a,b){var
c=[0,[0,pT,k(av,b[2][1])]];return d(pU,b[1],c)}function
a9(a,b){if(0===b[0]){var
q=b[1],g=q[2],j=g[2];switch(j[0]){case
0:var
m=[0,r(j[1]),0];break;case
1:var
m=[0,l(j[1]),0];break;default:var
m=[0,c(j[1]),1];}switch(g[1]){case
0:var
n=pV;break;case
1:var
n=p3;break;case
2:var
n=p4;break;default:var
n=p5;}var
u=[0,pW,k(c,g[5])],v=[0,pX,i(e[2],m[2])],w=[0,pY,i(e[2],g[4])],x=[0,pZ,i(e[1],n)],y=[0,p0,D(g[3])];return d(p2,q[1],[0,[0,p1,m[1]],y,x,w,v,u])}var
s=b[1],h=s[2],o=h[1];switch(o[0]){case
0:var
p=[0,r(o[1]),0];break;case
1:var
p=[0,l(o[1]),0];break;default:var
p=[0,c(o[1]),1];}var
z=[0,p6,f(B,h[5])],A=[0,p7,i(e[2],h[4])],C=[0,p8,i(e[2],p[2])],E=[0,p9,f(t,h[3])],F=[0,p_,f(c,h[2])];return d(qa,s[1],[0,[0,p$,p[1]],F,E,C,A,z])}function
T(a,b){var
c=b[2],e=[0,qb,k(aj,c[4])],g=[0,qc,al(c[3])],h=[0,qd,f(u,c[2])],i=[0,[0,qe,l(c[1])],h,g,e];return d(qf,b[1],i)}function
a8(a,b){var
e=b[2],c=e[1],g=0===c[0]?l(c[1]):J(c[1]),h=[0,[0,qh,g],[0,qg,f(z,e[2])]];return d(qi,b[1],h)}function
S(a,b){var
e=b[2],h=b[1];switch(e[0]){case
0:var
i=e[1],n=[0,qj,f(t,i[2])];return d(ql,h,[0,[0,qk,k(aB,i[1])],n]);case
1:var
l=e[1],o=[0,qm,f(t,l[2])],p=l[1];return d(qo,h,[0,[0,qn,k(function(a){return f(ay,a)},p)],o]);case
2:var
m=e[1],q=[0,qp,c(m[2])];return d(qr,h,[0,[0,qq,s(m[1])],q]);case
3:return a<50?Z(1+a,h,e[1]):g(Z,[0,h,e[1]]);default:return a<50?j(1+a,e[1]):g(j,[0,e[1]])}}function
a7(a,b){var
c=b[2],f=b[1];if(c){var
g=c[1],h=[0,[0,qs,s(g[2][1])]],j=d(qt,g[1],h),l=bz(q([0,j,q(bj(s,f))]));return i(e[4],l)}return k(s,f)}function
a6(a,b){if(0===b[0])return a<50?S(1+a,b[1]):g(S,[0,b[1]]);var
c=b[1],e=[0,[0,qu,s(c[2][1])]];return d(qv,c[1],e)}function
a5(a,b){if(0===b[0]){var
m=b[1],f=m[2],g=f[1];switch(g[0]){case
0:var
h=[0,r(g[1]),0];break;case
1:var
h=[0,l(g[1]),0];break;default:var
h=[0,c(g[1]),1];}var
j=f[2];switch(j[0]){case
0:var
k=[0,c(j[1]),qw];break;case
1:var
k=[0,D(j[1]),qE];break;default:var
k=[0,D(j[1]),qF];}var
o=[0,qx,i(e[2],h[2])],p=[0,qy,i(e[2],f[4])],q=[0,qz,i(e[2],f[3])],s=[0,qA,i(e[1],k[2])];return d(qD,m[1],[0,[0,qC,h[1]],[0,qB,k[1]],s,q,p,o])}var
n=b[1],t=[0,[0,qG,c(n[2][1])]];return d(qH,n[1],t)}function
a4(a,b){if(0===b[0]){var
j=b[1],h=j[2],f=h[1];switch(f[0]){case
0:var
g=[0,r(f[1]),0];break;case
1:var
g=[0,l(f[1]),0];break;default:var
g=[0,c(f[1]),1];}var
m=[0,qI,i(e[2],g[2])],n=[0,qJ,i(e[2],h[3])],o=[0,qK,i(e[2],0)],p=[0,qM,i(e[1],qL)],q=[0,qN,s(h[2])];return d(qP,j[1],[0,[0,qO,g[1]],q,p,o,n,m])}var
k=b[1],t=[0,[0,qQ,s(k[2][1])]];return d(qR,k[1],t)}function
a3(a,b){if(0===b[0])return a<50?j(1+a,b[1]):g(j,[0,b[1]]);var
e=b[1],f=[0,[0,qS,c(e[2][1])]];return d(qT,e[1],f)}function
a2(a,b){var
f=b[2],g=[0,qU,i(e[2],f[3])],h=[0,qV,c(f[2])],j=[0,[0,qW,s(f[1])],h,g];return d(qX,b[1],j)}function
Q(a,b){var
h=b[2],j=h[2],c=h[1],k=b[1];if(typeof
c==="number")var
f=e[6];else
switch(c[0]){case
0:var
f=i(e[1],c[1]);break;case
1:var
f=i(e[2],c[1]);break;case
2:var
f=i(e[5],c[1]);break;default:var
n=c[1],f=w(e[7],k,n[1],n[2]);}if(typeof
c==="number")var
g=0;else
if(3===c[0])var
m=c[1],o=[0,q1,i(e[1],m[2])],p=[0,[0,q2,i(e[1],m[1])],o],q=[0,q3,i(e[3],p)],l=[0,[0,q5,f],[0,q4,i(e[1],j)],q],g=1;else
var
g=0;if(!g)var
l=[0,[0,qZ,f],[0,qY,i(e[1],j)]];return d(q0,k,l)}function
P(a,b){var
e=b[2],f=[0,q6,k(c,e[2])],g=[0,[0,q7,k(aD,e[1])],f];return d(q8,b[1],g)}function
a1(a,b){var
c=b[2],f=[0,q9,i(e[1],c[1][2])],g=[0,[0,q_,i(e[1],c[1][1])],f],h=i(e[3],g),j=[0,[0,ra,h],[0,q$,i(e[2],c[2])]];return d(rb,b[1],j)}function
R(a,b){var
f=b[2];switch(f[2]){case
0:var
c=rf;break;case
1:var
c=rj;break;default:var
c=rk;}var
g=[0,rg,i(e[1],c)],h=[0,[0,rh,k(aE,f[1])],g];return d(ri,b[1],h)}function
a0(a,b){var
e=b[2],g=[0,rl,f(c,e[2])],h=[0,[0,rm,s(e[1])],g];return d(rn,b[1],h)}function
aZ(a,b){return 0===b[2]?i(e[1],ro):i(e[1],rp)}function
aY(a,b){var
f=b[2],c=b[1];if(typeof
f==="number")switch(f){case
0:return d(rq,c,[0]);case
1:return d(rr,c,[0]);case
2:return d(rs,c,[0]);case
3:return d(rt,c,[0]);case
4:return d(ru,c,[0]);case
5:return d(rv,c,[0]);case
6:return d(rw,c,[0]);case
7:return d(rx,c,[0]);default:return d(sy,c,[0])}else
switch(f[0]){case
0:return d(rz,c,[0,[0,ry,o(f[1])]]);case
1:return a<50?O(1+a,[0,c,f[1]]):g(O,[0,[0,c,f[1]]]);case
2:return a<50?M(1+a,[0,c,f[1]]):g(M,[0,[0,c,f[1]]]);case
3:return d(sa,c,[0,[0,r$,o(f[1])]]);case
4:return a<50?L(1+a,[0,c,f[1]]):g(L,[0,[0,c,f[1]]]);case
5:return d(si,c,[0,[0,sh,k(o,[0,f[1],[0,f[2],f[3]]])]]);case
6:return d(sk,c,[0,[0,sj,k(o,[0,f[1],[0,f[2],f[3]]])]]);case
7:return d(sm,c,[0,[0,sl,o(f[1])]]);case
8:return d(so,c,[0,[0,sn,k(o,f[1])]]);case
9:var
h=f[1],m=[0,sp,i(e[1],h[2])];return d(sr,c,[0,[0,sq,i(e[1],h[1])],m]);case
10:var
j=f[1],n=[0,ss,i(e[1],j[2])];return d(su,c,[0,[0,st,i(e[5],j[1])],n]);default:var
l=f[1],p=[0,sv,i(e[1],l[2])];return d(sx,c,[0,[0,sw,i(e[2],l[1])],p])}}function
O(a,b){var
c=b[2],e=c[1],g=[0,rA,f(u,c[3])],h=[0,rB,f(aG,e[2])],i=[0,rC,o(c[2])],j=[0,[0,rD,k(aF,e[1])],i,h,g];return d(rE,b[1],j)}function
N(a,b){var
c=b[2],g=[0,rF,i(e[2],c[3])],h=[0,rG,o(c[2])],j=[0,[0,rH,f(l,c[1])],h,g];return d(rI,b[1],j)}function
aX(a,b){return a<50?N(1+a,b[2][1]):g(N,[0,b[2][1]])}function
M(a,b){var
g=b[2],h=g[2],c=az(function(a,b){var
h=a[3],j=a[2],k=a[1];switch(b[0]){case
0:var
s=b[1],c=s[2],p=c[1];switch(p[0]){case
0:var
q=r(p[1]);break;case
1:var
q=l(p[1]);break;default:var
q=ax(rZ);}var
m=c[2];switch(m[0]){case
0:var
n=[0,o(m[1]),rP];break;case
1:var
w=m[1],n=[0,I([0,w[1],w[2]]),rX];break;default:var
x=m[1],n=[0,I([0,x[1],x[2]]),rY];}var
z=[0,rQ,i(e[1],n[2])],A=[0,rR,f(B,c[6])],C=[0,rS,i(e[2],c[4])],D=[0,rT,i(e[2],c[3])];return[0,[0,d(rW,s[1],[0,[0,rV,q],[0,rU,n[1]],D,C,A,z]),k],j,h];case
1:var
t=b[1],E=[0,[0,r0,aH(t[2][1])]];return[0,[0,d(r1,t[1],E),k],j,h];case
2:var
u=b[1],g=u[2],F=[0,r2,f(B,g[5])],G=[0,r3,i(e[2],g[4])],H=[0,r4,o(g[3])],J=[0,r5,o(g[2])],K=[0,[0,r6,f(l,g[1])],J,H,G,F];return[0,k,[0,d(r7,u[1],K),j],h];default:var
v=b[1],y=v[2],L=[0,r8,i(e[2],y[2])],M=[0,[0,r9,I(y[1])],L];return[0,k,j,[0,d(r_,v[1],M),h]]}},rJ,h),j=bz(q(c[3])),k=[0,rK,i(e[4],j)],m=bz(q(c[2])),n=[0,rL,i(e[4],m)],p=bz(q(c[1])),s=[0,rM,i(e[4],p)],t=[0,[0,rN,i(e[2],g[1])],s,n,k];return d(rO,b[1],t)}function
aW(a,b){var
e=b[2],c=e[1],f=0===c[0]?l(c[1]):J(c[1]),g=[0,[0,sc,f],[0,sb,l(e[2])]];return d(sd,b[1],g)}function
L(a,b){var
e=b[2],c=e[1],g=0===c[0]?l(c[1]):J(c[1]),h=[0,[0,sf,g],[0,se,f(z,e[2])]];return d(sg,b[1],h)}function
aV(a,b){var
c=[0,[0,sz,o(b[2])]];return d(sA,b[1],c)}function
aU(a,b){var
c=[0,[0,sB,k(aI,b[2][1])]];return d(sC,b[1],c)}function
aT(a,b){var
c=b[2],g=[0,sD,f(o,c[4])],h=[0,sE,f(B,c[3])],j=[0,sF,f(t,c[2])],k=[0,[0,sG,i(e[1],c[1])],j,h,g];return d(sH,b[1],k)}function
aS(a,b){var
c=[0,[0,sI,k(o,b[2][1])]];return d(sJ,b[1],c)}function
K(a,b){var
c=b[2],j=[0,sK,k(aM,c[3])],l=[0,sL,f(aL,c[2])],h=c[1],g=h[2],n=[0,sO,i(e[2],g[2])],o=[0,sP,k(aK,g[3])],p=[0,[0,sQ,am(g[1])],o,n],m=[0,[0,sM,d(sR,h[1],p)],l,j];return d(sN,b[1],m)}function
p(b){return a(be(0,b))}function
c(b){return a(j(0,b))}function
D(b){return a($(0,b))}function
l(b){return a(_(0,b))}function
af(b,c){return a(Z(0,b,c))}function
ap(b){return a(bd(0,b))}function
aq(b){return a(bc(0,b))}function
v(b){return a(Y(0,b))}function
ar(b){return a(X(0,b))}function
as(b){return a(W(0,b))}function
at(b){return a(V(0,b))}function
E(b){return a(bb(0,b))}function
ag(b){return a(ba(0,b))}function
au(b){return a(U(0,b))}function
ah(b){return a(a$(0,b))}function
ai(b){return a(a_(0,b))}function
av(b){return a(a9(0,b))}function
aw(b){return a(T(0,b))}function
aj(b){return a(a8(0,b))}function
s(b){return a(S(0,b))}function
F(b){return a(a7(0,b))}function
ay(b){return a(a6(0,b))}function
aA(b){return a(a5(0,b))}function
aB(b){return a(a4(0,b))}function
G(b){return a(a3(0,b))}function
ak(b){return a(a2(0,b))}function
r(b){return a(Q(0,b))}function
aC(b){return a(P(0,b))}function
aD(b){return a(a1(0,b))}function
H(b){return a(R(0,b))}function
aE(b){return a(a0(0,b))}function
B(b){return a(aZ(0,b))}function
o(b){return a(aY(0,b))}function
I(b){return a(O(0,b))}function
aF(b){return a(N(0,b))}function
aG(b){return a(aX(0,b))}function
al(b){return a(M(0,b))}function
J(b){return a(aW(0,b))}function
aH(b){return a(L(0,b))}function
t(b){return a(aV(0,b))}function
u(b){return a(aU(0,b))}function
aI(b){return a(aT(0,b))}function
z(b){return a(aS(0,b))}function
aJ(b){return a(K(0,b))}function
aK(a){if(0===a[0]){var
e=a[1],i=e[2],b=i[1],j=0===b[0]?h(b[1]):aP(b[1]),k=[0,[0,sV,j],[0,sU,f(aN,i[2])]];return d(sW,e[1],k)}var
g=a[1],l=[0,[0,sX,c(g[2][1])]];return d(sY,g[1],l)}function
aL(a){var
b=[0,[0,sS,am(a[2][1])]];return d(sT,a[1],b)}function
bh(a,b){var
c=b[2],f=b[1];switch(c[0]){case
0:return aJ([0,f,c[1]]);case
1:return a<50?x(1+a,[0,f,c[1]]):g(x,[0,[0,f,c[1]]]);default:var
h=c[1],j=[0,s2,i(e[1],h[2])];return d(s4,f,[0,[0,s3,i(e[1],h[1])],j])}}function
bg(a,b){switch(b[0]){case
0:return a<50?aa(1+a,b[1]):g(aa,[0,b[1]]);case
1:return a<50?ab(1+a,b[1]):g(ab,[0,b[1]]);default:return a<50?ac(1+a,b[1]):g(ac,[0,b[1]])}}function
bf(a,b){return 0===b[0]?r([0,b[1],b[2]]):a<50?x(1+a,[0,b[1],b[2]]):g(x,[0,[0,b[1],b[2]]])}function
x(a,b){var
e=b[2][1],f=0===e[0]?c(e[1]):d(s1,e[1],[0]);return d(s0,b[1],[0,[0,sZ,f]])}function
ac(a,b){var
e=b[2],c=e[1],f=0===c[0]?h(c[1]):aO(c[1]),g=[0,[0,s6,f],[0,s5,h(e[2])]];return d(s7,b[1],g)}function
ab(a,b){var
c=b[2],e=[0,s8,h(c[2])],f=[0,[0,s9,h(c[1])],e];return d(s_,b[1],f)}function
aa(a,b){var
c=[0,[0,s$,i(e[1],b[2][1])]];return d(ta,b[1],c)}function
aM(b){return a(bh(0,b))}function
am(b){return a(bg(0,b))}function
aN(b){return a(bf(0,b))}function
aO(b){return a(ac(0,b))}function
aP(b){return a(ab(0,b))}function
h(b){return a(aa(0,b))}function
aQ(a){var
b=a[2],c=b[2],e=c?l(c[1]):l(b[1]),f=[0,[0,tc,l(b[1])],[0,tb,e]];return d(td,a[1],f)}function
aR(a){var
b=a[2],c=0===b[0]?[0,to,b[1]]:[0,tq,b[1]],f=[0,[0,tp,i(e[1],c[2])]];return d(c[1],a[1],f)}function
C(a){var
b=a[2],e=b?[0,ts,[0,[0,tr,c(b[1])]]]:[0,tt,[0]];return d(e[1],a[1],e[2])}return[0,ao,c,an]}function
cC(a,b){b[6]=b[6]-a|0;var
c=b[12];b[12]=[0,c[1],c[2],c[3],c[4]-a|0];return 0}function
e6(a,b){return[0,b[1],a,b[3],b[4],b[5]]}function
bB(a,b){return by(a,b[3])?[0,b[1],b[2],a,b[4],b[5]]:b}function
p(a,b){return eQ(a[1],b[11],b[12])}function
bC(a){var
b=a[2],c=a[1],g=c[5],f=g!==dp?[0,c[1],c[2],c[3],c[4],dp]:c;if(typeof
b==="number")var
e=0;else
switch(b[0]){case
2:var
j=b[1],d=[0,j[1],j[2][3]],e=1;break;case
3:var
h=b[1],n=y(vp,h[3]),o=y(vq,y(h[2],n)),d=[0,h[1],o],e=1;break;case
1:case
4:var
i=b[1],d=[0,i[1],i[3]],e=1;break;default:var
e=0;}if(!e)var
k=cz(f[2]),d=[0,p(f,f[2]),k];var
l=q(g[2]),m=q(g[1]);return[0,f,[0,b,d[1],d[2],m,l]]}function
aP(a,b,c){return[0,a[1],a[2],a[3],a[4],[0,[0,[0,b,c],a[5][1]],a[5][2]]]}function
e7(a,b,c){return aP(a,b,[1,c])}function
aF(a,b){return aP(a,b,vr)}function
aQ(a,b,c,d){var
e=p(a,b);cC(x(c),b);return[0,aF(a,e),d]}var
bD=aZ([P,vs,0]);function
a_(a){var
b=a[5];if(b)return[0,a[1],a[2],a[3],a[4],b[2]];throw bD}function
vt(a){var
b=[0,0];es(function(a){b[1]=[0,a,b[1]];return 0},a);return[0,0,0,0,0,q(b[1])]}function
vu(a){var
c=a[5];if(c){var
d=c[1]+gc|0;if(!(2<d>>>0))switch(d){case
0:return a_(a);case
1:break;default:var
b=a_(a);return[0,1,b[2],b[3],b[4],b[5]]}}return a}function
vv(a){var
b=a[5];if(b)if(48===b[1]){var
c=b[2];if(c){var
d=c[1],e=88===d?0:ec===d?0:1;if(!e)return a_(a_(a))}}throw bD}function
vw(a){var
b=cx(vx,bj(eo,a[5]));try{var
c=bh(b);}catch(f){f=al(f);if(f[1]===dc)throw bD;throw f}return[0,a[1],a[2],c,a[4],0]}function
vy(a){var
b=a;for(;;){var
k=b[5];if(k){var
c=k[1];if(81<=c){if(95===c){var
b=a_(b);continue}var
l=gV===c?1:0;}else{if(46===c){if(0===b[4]){var
d=a_(b),b=[0,d[1],d[2],d[3],vz,d[5]];continue}throw bD}var
l=80<=c?1:0;}if(l)return vw(a_(b));if(48<=c)if(57<c)var
h=0;else
var
e=48,h=1;else
var
h=0;if(!h){if(65<=c)if(70<c)var
i=0;else
var
e=55,i=1;else
var
i=0;if(!i){if(97<=c)if(cg<c)var
j=0;else
var
e=87,j=1;else
var
j=0;if(!j)throw bD}}var
f=b[4],m=c-e|0,n=f?[0,f[1]-4|0]:f,o=(b[2]<<4)+m|0,g=a_(b),b=[0,g[1],o,g[3],n,g[5]];continue}return b}}function
vA(a){if(0===a[5]){var
b=a[2],c=a[4],d=c?a[3]+c[1]|0:a[3],e=0===d?b:Math.pow(b,d);return a[1]?-e:e}throw[0,v,vB]}function
e8(a){try{var
b=HG(a);return b}catch(b){b=al(b);if(cy)try{var
c=vA(vy(vv(vu(vt(a)))));return c}catch(f){f=al(f);if(f===bD)throw b;throw f}throw b}}function
aa(a,b,c,d,e){var
g=n(b,c),f=V(d),h=e?[0,f]:[1,f];return[0,a[1],a[2],a[3],a[4],[0,a[5][1],[0,[0,g,h],a[5][2]]]]}function
a$(a){var
c=a[5],b=0,f=a[6];for(;;){if(c===f){var
d=a[12];a[12]=[0,d[1],d[2],a[12][3]+b|0,d[4]];return 0}var
e=R===(_(a[2],c)&cN)?b+1|0:b,c=c+1|0,b=e;continue}}function
ba(a){if(7<(a+gT|0)>>>0)throw[0,v,vC];return a-48|0}function
bE(a){if(65<=a){if(97<=a){if(!(c1<=a))return(a-97|0)+10|0}else
if(!(71<=a))return(a-65|0)+10|0}else
if(!(9<(a+gT|0)>>>0))return a-48|0;throw[0,v,vD]}function
aR(a){if(fT<=a){var
b=[0,ae(R|a&63),0],c=[0,ae(R|(a>>>6|0)&63),b],d=[0,ae(R|(a>>>12|0)&63),c];return[0,ae(cT|a>>>18|0),d]}if(ea<=a){var
e=[0,ae(R|a&63),0],f=[0,ae(R|(a>>>6|0)&63),e];return[0,ae(cX|a>>>12|0),f]}if(R<=a){var
g=[0,ae(R|a&63),0];return[0,ae(cN|a>>>6|0),g]}return[0,ae(a),0]}function
aG(a,b,c){if(0===a)var
e=0;else
switch(a-1|0){case
0:var
d=bh(y(vF,b)),e=1;break;case
2:var
d=e8(b),e=1;break;default:var
e=0;}if(!e)var
d=bh(b);var
f=ak(c,vE)?d:-d;return[5,a,f]}var
e9=eK(0,53),e_=eK(0,53);M(function(a){return eL(e9,a[1],a[2])},vG);M(function(a){return eL(e_,a[1],a[2])},vH);function
Y(a,b,c){c[10]=bx(8,-1);return a<50?dG(1+a,b,c,0):g(dG,[0,b,c,0])}function
dG(a,b,c,d){var
z=d;for(;;){var
o=et(as,z,c);if(77<o>>>0){i(c[1],c);var
z=o;continue}var
y=o;if(39<=y)switch(y){case
39:return[0,b,90];case
40:return[0,b,91];case
41:return[0,b,86];case
42:return[0,b,87];case
43:return[0,b,cY];case
44:return[0,b,cp];case
45:return[0,b,68];case
46:return[0,b,94];case
47:return[0,b,67];case
48:return[0,b,66];case
49:return[0,b,96];case
50:return[0,b,95];case
51:return[0,b,77];case
52:return[0,b,76];case
53:return[0,b,74];case
54:return[0,b,75];case
55:return[0,b,72];case
56:return[0,b,71];case
57:return[0,b,70];case
58:return[0,b,69];case
59:return[0,b,92];case
60:return[0,b,93];case
61:return[0,b,97];case
62:return[0,b,98];case
63:return[0,b,ah];case
64:return[0,b,f4];case
65:return[0,b,cg];case
66:return[0,b,83];case
67:return[0,b,85];case
68:return[0,b,84];case
69:return[0,b,c1];case
70:return[0,b,dR];case
71:return[0,b,78];case
72:return[0,b,12];case
73:return[0,b,73];case
74:return[0,b,99];case
75:return[0,b,14];case
76:var
ak=b[3]?aP(b,p(b,c),4):b;return[0,ak,I];default:return[0,aF(b,p(b,c)),bO]}switch(y){case
0:aB(c);return a<50?Y(1+a,b,c):g(Y,[0,b,c]);case
1:return a<50?Y(1+a,aF(b,p(b,c)),c):g(Y,[0,aF(b,p(b,c)),c]);case
2:a$(c);return a<50?Y(1+a,b,c):g(Y,[0,b,c]);case
3:var
A=p(b,c),q=D(F),k=bk(b,q,c);return a<50?Y(1+a,aa(k[1],A,k[2],q,1),c):g(Y,[0,aa(k[1],A,k[2],q,1),c]);case
4:var
N=f(c[10],0)[1],O=h(c,c[5]+2|0,N),P=c[6],E=h(c,f(c[10],0)[1],P),Q=h(c,c[5],c[6]);if(b[4]){var
R=b[3]?e7(b,p(b,c),Q):b,s=bB(1,R);return j(E,vK)?a<50?Y(1+a,s,c):g(Y,[0,s,c]):[0,s,80]}var
G=p(b,c),e=D(F);B(e,O);B(e,E);var
l=bk(b,e,c);return a<50?Y(1+a,aa(l[1],G,l[2],e,1),c):g(Y,[0,aa(l[1],G,l[2],e,1),c]);case
5:return b[3]?a<50?Y(1+a,bB(0,b),c):g(Y,[0,bB(0,b),c]):(cC(1,c),[0,b,ah]);case
6:var
H=p(b,c),t=D(F),m=bl(b,t,c);return a<50?Y(1+a,aa(m[1],H,m[2],t,0),c):g(Y,[0,aa(m[1],H,m[2],t,0),c]);case
7:return 0===c[5]?a<50?Y(1+a,bl(b,D(F),c)[1],c):g(Y,[0,bl(b,D(F),c)[1],c]):[0,b,bO];case
8:var
J=C(c,c[5]),S=p(b,c),K=D(F),u=D(F);r(u,J);var
v=e$(b,J,K,u,0,c),T=v[3],U=V(u),W=V(K),X=[1,[0,n(S,v[2]),W,U,T]];return[0,v[1],X];case
9:var
L=D(F),M=D(F),w=D(F);B(w,cz(c));var
x=fb(b,p(b,c),L,M,w,c),Z=x[3],_=V(w),$=V(M),ab=[0,V(L),$,_];return[0,x[1],[2,[0,x[2],ab,Z]]];case
10:var
ac=c[6];return aQ(b,c,h(c,f(c[10],0)[1],ac),vL);case
11:return[0,b,vM];case
12:var
ad=c[6];return aQ(b,c,h(c,f(c[10],0)[1],ad),vN);case
13:return[0,b,vO];case
14:var
ae=c[6];return aQ(b,c,h(c,f(c[10],0)[1],ae),vP);case
15:return[0,b,vQ];case
22:var
ag=h(c,c[5],c[6]);a$(c);try{var
ai=[0,b,eM(e9,ag)];return ai}catch(f){f=al(f);if(f===aj)return[0,b,0];throw f}case
23:return[0,b,1];case
24:return[0,b,2];case
25:return[0,b,5];case
26:return[0,b,6];case
27:return[0,b,7];case
28:return[0,b,8];case
29:return[0,b,13];case
30:return[0,b,11];case
31:return[0,b,9];case
32:return[0,b,10];case
33:return[0,b,80];case
34:return[0,b,79];case
35:return[0,b,82];case
36:return[0,b,81];case
37:return[0,b,88];case
38:return[0,b,89];case
16:case
18:case
20:var
af=c[6];return aQ(b,c,h(c,f(c[10],0)[1],af),vR);default:return[0,b,vS]}}}function
vI(b,c){return a(Y(0,b,c))}function
ap(a,b,c){c[10]=bx(26,-1);var
d=c[6];f(c[10],17)[18]=d;var
e=c[6];f(c[10],16)[17]=e;var
h=c[6];f(c[10],15)[16]=h;var
i=c[6];f(c[10],14)[15]=i;var
j=c[6];f(c[10],13)[14]=j;var
k=c[6];f(c[10],12)[13]=k;var
l=c[6];f(c[10],11)[12]=l;var
m=c[6];f(c[10],10)[11]=m;var
n=c[6];f(c[10],9)[10]=n;var
o=c[6];f(c[10],8)[9]=o;var
p=c[6];f(c[10],7)[8]=p;var
q=c[6];f(c[10],6)[7]=q;var
r=c[6];f(c[10],5)[6]=r;var
s=c[6];f(c[10],4)[5]=s;return a<50?dH(1+a,b,c,gN):g(dH,[0,b,c,gN])}function
dH(a,b,c,d){var
x=d;for(;;){var
o=et(as,x,c);if(51<o>>>0){i(c[1],c);var
x=o;continue}switch(o){case
0:aB(c);return a<50?ap(1+a,b,c):g(ap,[0,b,c]);case
1:a$(c);return a<50?ap(1+a,b,c):g(ap,[0,b,c]);case
2:var
y=p(b,c),q=D(F),k=bk(b,q,c);return a<50?ap(1+a,aa(k[1],y,k[2],q,1),c):g(ap,[0,aa(k[1],y,k[2],q,1),c]);case
3:var
J=f(c[10],0)[1],K=h(c,c[5]+2|0,J),L=c[6],z=h(c,f(c[10],0)[1],L),M=h(c,c[5],c[6]);if(b[4]){var
N=b[3]?e7(b,p(b,c),M):b,s=bB(1,N);return j(z,vT)?a<50?ap(1+a,s,c):g(ap,[0,s,c]):[0,s,80]}var
A=p(b,c),e=D(F);B(e,K);B(e,z);var
l=bk(b,e,c);return a<50?ap(1+a,aa(l[1],A,l[2],e,1),c):g(ap,[0,aa(l[1],A,l[2],e,1),c]);case
4:return b[3]?a<50?ap(1+a,bB(0,b),c):g(ap,[0,bB(0,b),c]):(cC(1,c),[0,b,ah]);case
5:var
E=p(b,c),t=D(F),m=bl(b,t,c);return a<50?ap(1+a,aa(m[1],E,m[2],t,1),c):g(ap,[0,aa(m[1],E,m[2],t,1),c]);case
6:var
G=C(c,c[5]),O=p(b,c),H=D(F),u=D(F);r(u,G);var
v=e$(b,G,H,u,0,c),P=v[3],Q=V(u),R=V(H),S=[1,[0,n(O,v[2]),R,Q,P]];return[0,v[1],S];case
7:var
T=f(c[10],0)[1],U=h(c,c[5],T),W=f(c[10],1)[2],X=h(c,f(c[10],0)[1],W),Y=c[6],Z=h(c,f(c[10],1)[2],Y);return aQ(b,c,Z,aG(0,X,U));case
8:var
_=f(c[10],0)[1],$=h(c,c[5],_),ab=c[6];return[0,b,aG(0,h(c,f(c[10],0)[1],ab),$)];case
9:var
ac=f(c[10],0)[1],ad=h(c,c[5],ac),ae=f(c[10],1)[2],af=h(c,f(c[10],0)[1],ae),ag=c[6],ai=h(c,f(c[10],1)[2],ag);return aQ(b,c,ai,aG(2,af,ad));case
10:var
ak=f(c[10],0)[1],am=h(c,c[5],ak),an=c[6];return[0,b,aG(2,h(c,f(c[10],0)[1],an),am)];case
11:var
ao=f(c[10],0)[1],aq=h(c,c[5],ao),ar=f(c[10],1)[2],at=h(c,f(c[10],0)[1],ar),au=c[6],av=h(c,f(c[10],1)[2],au);return aQ(b,c,av,aG(1,at,aq));case
12:var
aw=f(c[10],0)[1],ax=h(c,c[5],aw),ay=c[6];return[0,b,aG(1,h(c,f(c[10],0)[1],ay),ax)];case
13:var
az=f(c[10],0)[1],aA=h(c,c[5],az),aC=f(c[10],1)[2],aD=h(c,f(c[10],0)[1],aC),aE=c[6],aF=h(c,f(c[10],1)[2],aE);try{var
aH=[0,b,aG(3,aD,aA)],w=aH;}catch(f){f=al(f);if(!cy)throw f;var
w=[0,aP(b,p(b,c),59),vU];}return aQ(w[1],c,aF,w[2]);case
14:var
aI=f(c[10],0)[1],aJ=h(c,c[5],aI),aK=c[6],aL=h(c,f(c[10],0)[1],aK);try{var
aM=[0,b,aG(3,aL,aJ)];return aM}catch(f){f=al(f);if(cy)return[0,aP(b,p(b,c),59),vV];throw f}case
15:var
aN=f(c[10],0)[1],aO=h(c,c[5],aN),aR=f(c[10],1)[2],aS=h(c,f(c[10],0)[1],aR),aT=c[6],aU=h(c,f(c[10],1)[2],aT);return aQ(b,c,aU,aG(3,aS,aO));case
16:var
aV=f(c[10],0)[1],aW=h(c,c[5],aV),aX=c[6];return[0,b,aG(3,h(c,f(c[10],0)[1],aX),aW)];case
17:var
aY=f(c[10],0)[1],aZ=h(c,c[5],aY),a0=f(c[10],1)[2],a1=h(c,f(c[10],0)[1],a0),a2=c[6],a3=h(c,f(c[10],1)[2],a2);return aQ(b,c,a3,aG(3,a1,aZ));case
18:var
a4=f(c[10],0)[1],a5=h(c,f(c[10],1)[2],a4),a6=f(c[10],2)[3];return[0,b,aG(3,h(c,f(c[10],3)[4],a6),a5)];case
19:var
a7=h(c,c[5],c[6]);a$(c);try{var
a8=[0,b,eM(e_,a7)];return a8}catch(f){f=al(f);if(f===aj)return[0,b,0];throw f}case
20:return[0,b,65];case
23:return[0,b,1];case
24:return[0,b,2];case
25:return[0,b,3];case
26:return[0,b,4];case
27:return[0,b,5];case
28:return[0,b,6];case
29:return[0,b,13];case
30:return[0,b,11];case
31:return[0,b,9];case
32:return[0,b,10];case
37:return[0,b,92];case
38:return[0,b,93];case
41:return[0,b,ah];case
43:return[0,b,83];case
44:return[0,b,85];case
45:return[0,b,46];case
46:return[0,b,12];case
48:return[0,b,97];case
49:return[0,b,98];case
50:var
a9=b[3]?aP(b,p(b,c),4):b;return[0,a9,I];case
51:return[0,b,bO];case
21:case
35:return[0,b,7];case
22:case
36:return[0,b,8];case
33:case
42:return[0,b,80];case
34:case
40:return[0,b,79];default:return[0,b,78]}}}function
vJ(b,c){return a(ap(0,b,c))}function
e$(a,b,c,d,e,f){var
g=a,j=e;a:for(;;){var
m=bt;for(;;){var
k=aA(as,m,f);if(3<k>>>0){i(f[1],f);var
m=k;continue}switch(k){case
0:var
l=C(f,f[5]);r(d,l);if(b===l)return[0,g,p(g,f),j];r(c,l);continue a;case
1:r(d,C(f,f[5]));var
n=fa(g,c,f),t=n[2],u=t||j;B(d,cz(f));var
g=n[1],j=u;continue a;case
2:var
o=h(f,f[5],f[6]);B(d,o);var
q=aF(g,p(g,f));B(c,o);return[0,q,p(q,f),j];default:var
s=C(f,f[5]);r(d,s);r(c,s);continue a}}}}function
fa(a,b,c){var
e=261;for(;;){var
d=aA(as,e,c);if(17<d>>>0){i(c[1],c);var
e=d;continue}switch(d){case
0:return[0,a,0];case
1:B(b,vW);return[0,a,0];case
2:var
m=C(c,c[5]+1|0),n=bE(C(c,c[5]+2|0)),o=aR((bE(m)*16|0)+n|0);M(function(a){return r(b,a)},o);return[0,a,0];case
3:var
f=C(c,c[5]),g=C(c,c[5]+1|0),j=C(c,c[5]+2|0),q=ba(j),s=ba(g)<<3,k=((ba(f)<<6)+s|0)+q|0;if(bt<=k){var
t=ba(g),u=aR((ba(f)<<3)+t|0);M(function(a){return r(b,a)},u);r(b,j);}else{var
v=aR(k);M(function(a){return r(b,a)},v);}return[0,a,1];case
4:var
w=C(c,c[5]),x=ba(C(c,c[5]+1|0)),z=aR((ba(w)<<3)+x|0);M(function(a){return r(b,a)},z);return[0,a,1];case
5:r(b,ae(0));return[0,a,0];case
6:r(b,ae(8));return[0,a,0];case
7:r(b,ae(12));return[0,a,0];case
8:r(b,ae(10));return[0,a,0];case
9:r(b,ae(13));return[0,a,0];case
10:r(b,ae(9));return[0,a,0];case
11:r(b,ae(11));return[0,a,0];case
12:var
A=aR(ba(C(c,c[5])));M(function(a){return r(b,a)},A);return[0,a,1];case
13:var
D=C(c,c[5]+1|0),E=C(c,c[5]+2|0),F=C(c,c[5]+3|0),G=bE(C(c,c[5]+4|0)),H=bE(F)<<4,I=bE(E)<<8,J=aR((((bE(D)<<12)+I|0)+H|0)+G|0);M(function(a){return r(b,a)},J);return[0,a,0];case
14:var
l=bh(y(vX,h(c,c[5]+2|0,c[6]-1|0))),K=fL<l?aF(a,p(a,c)):a,L=aR(l);M(function(a){return r(b,a)},L);return[0,K,0];case
15:var
N=C(c,c[5]),O=aF(a,p(a,c));r(b,N);return[0,O,0];case
16:aB(c);return[0,a,0];default:r(b,C(c,c[5]));return[0,a,0]}}}function
bk(a,b,c){a:for(;;){var
e=288;for(;;){var
d=aA(as,e,c);if(4<d>>>0){i(c[1],c);var
e=d;continue}switch(d){case
0:var
f=aF(a,p(a,c));return[0,f,p(f,c)];case
1:aB(c);r(b,10);continue a;case
2:var
g=p(a,c),h=a[3]?aP(a,g,[2,vZ,vY]):a;return[0,h,g];case
3:if(a[3])return[0,a,p(a,c)];B(b,v0);continue a;default:r(b,C(c,c[5]));continue a}}}}function
bl(a,b,c){a:for(;;){var
g=296;for(;;){var
d=aA(as,g,c);if(2<d>>>0){i(c[1],c);var
g=d;continue}switch(d){case
0:return[0,a,p(a,c)];case
1:var
e=p(a,c),f=e[3];aB(c);return[0,a,[0,e[1],e[2],[0,f[1],f[2]-1|0,f[3]-1|0]]];default:r(b,C(c,c[5]));continue a}}}}function
dq(a,b,c,d,e){a:for(;;){var
aG=380;for(;;){var
ak=aA(as,aG,e);if(6<ak>>>0){i(e[1],e);var
aG=ak;continue}switch(ak){case
0:var
aj=C(e,e[5]);switch(b){case
0:var
aD=39===aj?1:0;break;case
1:var
aD=34===aj?1:0;break;default:if(60===aj)var
aE=1;else
if(123===aj)var
aE=1;else
var
aD=0,aE=0;if(aE){cC(e[12][4]-e[11][4]|0,e);return[0,a,p(a,e)]}}if(aD)return[0,a,p(a,e)];r(d,aj);r(c,aj);continue a;case
1:var
aH=aF(a,p(a,e));return[0,aH,p(aH,e)];case
2:var
aI=h(e,e[5],e[6]);B(d,aI);B(c,aI);aB(e);continue a;case
3:var
bf=h(e,e[5]+3|0,e[6]-1|0);B(d,h(e,e[5],e[6]));var
bg=aR(bh(y(v5,bf)));M(function(a){return r(c,a)},bg);continue a;case
4:var
bi=h(e,e[5]+2|0,e[6]-1|0);B(d,h(e,e[5],e[6]));var
bj=aR(bh(bi));M(function(a){return r(c,a)},bj);continue a;case
5:var
f=h(e,e[5]+1|0,e[6]-1|0);B(d,h(e,e[5],e[6]));var
aJ=A(f,v6);if(0<=aJ)if(0<aJ){var
aK=A(f,v7);if(0<=aK)if(0<aK){var
aL=A(f,v8);if(0<=aL)if(0<aL){var
aM=A(f,v9);if(0<=aM)if(0<aM){var
aN=A(f,v_);if(0<=aN)if(0<aN)if(j(f,v$))if(j(f,wa))if(j(f,wb))if(j(f,wc))if(j(f,wd))if(j(f,we))var
g=1,k=0,Z=0,ab=0,G=0;else
var
X=wh,G=1;else
var
X=wi,G=1;else
var
X=wj,G=1;else
var
X=wk,G=1;else
var
X=wl,G=1;else
var
X=wm,G=1;else
var
X=wn,G=1;else
if(j(f,wo))if(j(f,wp))if(j(f,wq))if(j(f,wr))if(j(f,ws))if(j(f,wt))if(j(f,wu))var
g=1,k=0,Z=0,ab=0,G=0;else
var
X=wv,G=1;else
var
X=ww,G=1;else
var
X=wx,G=1;else
var
X=wy,G=1;else
var
X=wz,G=1;else
var
X=wA,G=1;else
var
X=wB,G=1;if(G)var
al=X,ab=1;}else
var
al=wC,ab=1;else{var
aP=A(f,wD);if(0<=aP)if(0<aP)if(j(f,wE))if(j(f,wF))if(j(f,wG))if(j(f,wH))if(j(f,wI))if(j(f,wJ))if(j(f,wK))var
g=1,k=0,Z=0,ab=0,m=0;else
var
I=wL,m=1;else
var
I=wM,m=1;else
var
I=wN,m=1;else
var
I=wO,m=1;else
var
I=wP,m=1;else
var
I=wQ,m=1;else
var
I=wR,m=1;else
var
I=wS,m=1;else
if(j(f,wT))if(j(f,wU))if(j(f,wV))if(j(f,wW))if(j(f,wX))if(j(f,wY))if(j(f,wZ))var
g=1,k=0,Z=0,ab=0,m=0;else
var
I=w0,m=1;else
var
I=w1,m=1;else
var
I=w2,m=1;else
var
I=w3,m=1;else
var
I=w4,m=1;else
var
I=w5,m=1;else
var
I=w6,m=1;if(m)var
al=I,ab=1;}if(ab)var
am=al,Z=1;}else
var
am=w7,Z=1;else{var
aQ=A(f,w8);if(0<=aQ)if(0<aQ){var
aS=A(f,w9);if(0<=aS)if(0<aS)if(j(f,w_))if(j(f,w$))if(j(f,xa))if(j(f,xb))if(j(f,xc))if(j(f,xd))if(j(f,xe))var
g=1,k=0,Z=0,ac=0,n=0;else
var
J=xf,n=1;else
var
J=xg,n=1;else
var
J=xh,n=1;else
var
J=xi,n=1;else
var
J=xj,n=1;else
var
J=xk,n=1;else
var
J=xl,n=1;else
var
J=xm,n=1;else
if(j(f,xn))if(j(f,xo))if(j(f,xp))if(j(f,xq))if(j(f,xr))if(j(f,xs))if(j(f,xt))var
g=1,k=0,Z=0,ac=0,n=0;else
var
J=xu,n=1;else
var
J=xv,n=1;else
var
J=xw,n=1;else
var
J=xx,n=1;else
var
J=xy,n=1;else
var
J=xz,n=1;else
var
J=xA,n=1;if(n)var
ap=J,ac=1;}else
var
ap=xB,ac=1;else{var
aT=A(f,xC);if(0<=aT)if(0<aT)if(j(f,xD))if(j(f,xE))if(j(f,xF))if(j(f,xG))if(j(f,xH))if(j(f,xI))if(j(f,xJ))var
g=1,k=0,Z=0,ac=0,o=0;else
var
K=xK,o=1;else
var
K=xL,o=1;else
var
K=xM,o=1;else
var
K=xN,o=1;else
var
K=xO,o=1;else
var
K=xP,o=1;else
var
K=xQ,o=1;else
var
K=xR,o=1;else
if(j(f,xS))if(j(f,xT))if(j(f,xU))if(j(f,xV))if(j(f,xW))if(j(f,xX))if(j(f,xY))var
g=1,k=0,Z=0,ac=0,o=0;else
var
K=xZ,o=1;else
var
K=x0,o=1;else
var
K=x1,o=1;else
var
K=x2,o=1;else
var
K=x3,o=1;else
var
K=x4,o=1;else
var
K=x5,o=1;if(o)var
ap=K,ac=1;}if(ac)var
am=ap,Z=1;}if(Z)var
an=am,k=1;}else
var
an=x6,k=1;else{var
aU=A(f,x7);if(0<=aU)if(0<aU){var
aV=A(f,x8);if(0<=aV)if(0<aV){var
aW=A(f,x9);if(0<=aW)if(0<aW)if(j(f,x_))if(j(f,x$))if(j(f,ya))if(j(f,yb))if(j(f,yc))if(j(f,yd))if(j(f,ye))var
g=1,k=0,_=0,ad=0,q=0;else
var
L=yf,q=1;else
var
L=yg,q=1;else
var
L=yh,q=1;else
var
L=yi,q=1;else
var
L=yj,q=1;else
var
L=yk,q=1;else
var
L=yl,q=1;else
var
L=ym,q=1;else
if(j(f,yn))if(j(f,yo))if(j(f,yp))if(j(f,yq))if(j(f,yr))if(j(f,ys))if(j(f,yt))var
g=1,k=0,_=0,ad=0,q=0;else
var
L=yu,q=1;else
var
L=yv,q=1;else
var
L=yw,q=1;else
var
L=yx,q=1;else
var
L=yy,q=1;else
var
L=yz,q=1;else
var
L=yA,q=1;if(q)var
aq=L,ad=1;}else
var
aq=yB,ad=1;else{var
aX=A(f,yC);if(0<=aX)if(0<aX)if(j(f,yD))if(j(f,yE))if(j(f,yF))if(j(f,yG))if(j(f,yH))if(j(f,yI))if(j(f,yJ))var
g=1,k=0,_=0,ad=0,s=0;else
var
N=yK,s=1;else
var
N=yL,s=1;else
var
N=yM,s=1;else
var
N=yN,s=1;else
var
N=yO,s=1;else
var
N=yP,s=1;else
var
N=yQ,s=1;else
var
N=yR,s=1;else
if(j(f,yS))if(j(f,yT))if(j(f,yU))if(j(f,yV))if(j(f,yW))if(j(f,yX))if(j(f,yY))var
g=1,k=0,_=0,ad=0,s=0;else
var
N=yZ,s=1;else
var
N=y0,s=1;else
var
N=y1,s=1;else
var
N=y2,s=1;else
var
N=y3,s=1;else
var
N=y4,s=1;else
var
N=y5,s=1;if(s)var
aq=N,ad=1;}if(ad)var
ar=aq,_=1;}else
var
ar=y6,_=1;else{var
aY=A(f,y7);if(0<=aY)if(0<aY){var
aZ=A(f,y8);if(0<=aZ)if(0<aZ)if(j(f,y9))if(j(f,y_))if(j(f,y$))if(j(f,za))if(j(f,zb))if(j(f,zc))if(j(f,zd))var
g=1,k=0,_=0,ae=0,t=0;else
var
O=ze,t=1;else
var
O=zf,t=1;else
var
O=zg,t=1;else
var
O=zh,t=1;else
var
O=zi,t=1;else
var
O=zj,t=1;else
var
O=zk,t=1;else
var
O=zl,t=1;else
if(j(f,zm))if(j(f,zn))if(j(f,zo))if(j(f,zp))if(j(f,zq))if(j(f,zr))if(j(f,zs))var
g=1,k=0,_=0,ae=0,t=0;else
var
O=zt,t=1;else
var
O=zu,t=1;else
var
O=zv,t=1;else
var
O=zw,t=1;else
var
O=zx,t=1;else
var
O=zy,t=1;else
var
O=zz,t=1;if(t)var
at=O,ae=1;}else
var
at=zA,ae=1;else{var
a0=A(f,zB);if(0<=a0)if(0<a0)if(j(f,zC))if(j(f,zD))if(j(f,zE))if(j(f,zF))if(j(f,zG))if(j(f,zH))if(j(f,zI))var
g=1,k=0,_=0,ae=0,u=0;else
var
P=zJ,u=1;else
var
P=zK,u=1;else
var
P=zL,u=1;else
var
P=zM,u=1;else
var
P=zN,u=1;else
var
P=zO,u=1;else
var
P=zP,u=1;else
var
P=zQ,u=1;else
if(j(f,zR))if(j(f,zS))if(j(f,zT))if(j(f,zU))if(j(f,zV))if(j(f,zW))if(j(f,zX))var
g=1,k=0,_=0,ae=0,u=0;else
var
P=zY,u=1;else
var
P=zZ,u=1;else
var
P=z0,u=1;else
var
P=z1,u=1;else
var
P=z2,u=1;else
var
P=z3,u=1;else
var
P=z4,u=1;if(u)var
at=P,ae=1;}if(ae)var
ar=at,_=1;}if(_)var
an=ar,k=1;}if(k)var
ao=an,g=0;}else
var
ao=z5,g=0;else{var
a1=A(f,z6);if(0<=a1)if(0<a1){var
a2=A(f,z7);if(0<=a2)if(0<a2){var
a3=A(f,z8);if(0<=a3)if(0<a3){var
a4=A(f,z9);if(0<=a4)if(0<a4)if(j(f,z_))if(j(f,z$))if(j(f,Aa))if(j(f,Ab))if(j(f,Ac))if(j(f,Ad))var
g=1,l=0,$=0,af=0,H=0;else
var
Y=Ae,H=1;else
var
Y=Af,H=1;else
var
Y=Ag,H=1;else
var
Y=Ah,H=1;else
var
Y=Ai,H=1;else
var
Y=Aj,H=1;else
var
Y=Ak,H=1;else
if(j(f,Al))if(j(f,Am))if(j(f,An))if(j(f,Ao))if(j(f,Ap))if(j(f,Aq))if(j(f,Ar))var
g=1,l=0,$=0,af=0,H=0;else
var
Y=As,H=1;else
var
Y=At,H=1;else
var
Y=Au,H=1;else
var
Y=Av,H=1;else
var
Y=Aw,H=1;else
var
Y=Ax,H=1;else
var
Y=Ay,H=1;if(H)var
au=Y,af=1;}else
var
au=Az,af=1;else{var
a5=A(f,AA);if(0<=a5)if(0<a5)if(j(f,AB))if(j(f,AC))if(j(f,AD))if(j(f,AE))if(j(f,AF))if(j(f,AG))if(j(f,AH))var
g=1,l=0,$=0,af=0,v=0;else
var
Q=AI,v=1;else
var
Q=AJ,v=1;else
var
Q=AK,v=1;else
var
Q=AL,v=1;else
var
Q=AM,v=1;else
var
Q=AN,v=1;else
var
Q=AO,v=1;else
var
Q=AP,v=1;else
if(j(f,AQ))if(j(f,AR))if(j(f,AS))if(j(f,AT))if(j(f,AU))if(j(f,AV))if(j(f,AW))var
g=1,l=0,$=0,af=0,v=0;else
var
Q=AX,v=1;else
var
Q=AY,v=1;else
var
Q=AZ,v=1;else
var
Q=A0,v=1;else
var
Q=A1,v=1;else
var
Q=A2,v=1;else
var
Q=A3,v=1;if(v)var
au=Q,af=1;}if(af)var
av=au,$=1;}else
var
av=A4,$=1;else{var
a6=A(f,A5);if(0<=a6)if(0<a6){var
a7=A(f,A6);if(0<=a7)if(0<a7)if(j(f,A7))if(j(f,A8))if(j(f,A9))if(j(f,A_))if(j(f,A$))if(j(f,Ba))if(j(f,Bb))var
g=1,l=0,$=0,ag=0,w=0;else
var
R=Bc,w=1;else
var
R=Bd,w=1;else
var
R=Be,w=1;else
var
R=Bf,w=1;else
var
R=Bg,w=1;else
var
R=Bh,w=1;else
var
R=Bi,w=1;else
var
R=Bj,w=1;else
if(j(f,Bk))if(j(f,Bl))if(j(f,Bm))if(j(f,Bn))if(j(f,Bo))if(j(f,Bp))if(j(f,Bq))var
g=1,l=0,$=0,ag=0,w=0;else
var
R=Br,w=1;else
var
R=Bs,w=1;else
var
R=Bt,w=1;else
var
R=Bu,w=1;else
var
R=Bv,w=1;else
var
R=Bw,w=1;else
var
R=Bx,w=1;if(w)var
ax=R,ag=1;}else
var
ax=By,ag=1;else{var
a8=A(f,Bz);if(0<=a8)if(0<a8)if(j(f,BA))if(j(f,BB))if(j(f,BC))if(j(f,BD))if(j(f,BE))if(j(f,BF))if(j(f,BG))var
g=1,l=0,$=0,ag=0,x=0;else
var
S=BH,x=1;else
var
S=BI,x=1;else
var
S=BJ,x=1;else
var
S=BK,x=1;else
var
S=BL,x=1;else
var
S=BM,x=1;else
var
S=BN,x=1;else
var
S=BO,x=1;else
if(j(f,BP))if(j(f,BQ))if(j(f,BR))if(j(f,BS))if(j(f,BT))if(j(f,BU))if(j(f,BV))var
g=1,l=0,$=0,ag=0,x=0;else
var
S=BW,x=1;else
var
S=BX,x=1;else
var
S=BY,x=1;else
var
S=BZ,x=1;else
var
S=B0,x=1;else
var
S=B1,x=1;else
var
S=B2,x=1;if(x)var
ax=S,ag=1;}if(ag)var
av=ax,$=1;}if($)var
aw=av,l=1;}else
var
aw=B3,l=1;else{var
a9=A(f,B4);if(0<=a9)if(0<a9){var
a_=A(f,B5);if(0<=a_)if(0<a_){var
a$=A(f,B6);if(0<=a$)if(0<a$)if(j(f,B7))if(j(f,B8))if(j(f,B9))if(j(f,B_))if(j(f,B$))if(j(f,Ca))if(j(f,Cb))var
g=1,l=0,aa=0,ah=0,z=0;else
var
T=Cc,z=1;else
var
T=Cd,z=1;else
var
T=Ce,z=1;else
var
T=Cf,z=1;else
var
T=Cg,z=1;else
var
T=Ch,z=1;else
var
T=Ci,z=1;else
var
T=Cj,z=1;else
if(j(f,Ck))if(j(f,Cl))if(j(f,Cm))if(j(f,Cn))if(j(f,Co))if(j(f,Cp))if(j(f,Cq))var
g=1,l=0,aa=0,ah=0,z=0;else
var
T=Cr,z=1;else
var
T=Cs,z=1;else
var
T=Ct,z=1;else
var
T=Cu,z=1;else
var
T=Cv,z=1;else
var
T=Cw,z=1;else
var
T=Cx,z=1;if(z)var
ay=T,ah=1;}else
var
ay=Cy,ah=1;else{var
ba=A(f,Cz);if(0<=ba)if(0<ba)if(j(f,CA))if(j(f,CB))if(j(f,CC))if(j(f,CD))if(j(f,CE))if(j(f,CF))if(j(f,CG))var
g=1,l=0,aa=0,ah=0,D=0;else
var
U=CH,D=1;else
var
U=CI,D=1;else
var
U=CJ,D=1;else
var
U=CK,D=1;else
var
U=CL,D=1;else
var
U=CM,D=1;else
var
U=CN,D=1;else
var
U=CO,D=1;else
if(j(f,CP))if(j(f,CQ))if(j(f,CR))if(j(f,CS))if(j(f,CT))if(j(f,CU))if(j(f,CV))var
g=1,l=0,aa=0,ah=0,D=0;else
var
U=CW,D=1;else
var
U=CX,D=1;else
var
U=CY,D=1;else
var
U=CZ,D=1;else
var
U=C0,D=1;else
var
U=C1,D=1;else
var
U=C2,D=1;if(D)var
ay=U,ah=1;}if(ah)var
az=ay,aa=1;}else
var
az=C3,aa=1;else{var
bb=A(f,C4);if(0<=bb)if(0<bb){var
bc=A(f,C5);if(0<=bc)if(0<bc)if(j(f,C6))if(j(f,C7))if(j(f,C8))if(j(f,C9))if(j(f,C_))if(j(f,C$))if(j(f,Da))var
g=1,l=0,aa=0,ai=0,E=0;else
var
V=Db,E=1;else
var
V=Dc,E=1;else
var
V=Dd,E=1;else
var
V=De,E=1;else
var
V=Df,E=1;else
var
V=Dg,E=1;else
var
V=Dh,E=1;else
var
V=Di,E=1;else
if(j(f,Dj))if(j(f,Dk))if(j(f,Dl))if(j(f,Dm))if(j(f,Dn))if(j(f,Do))if(j(f,Dp))var
g=1,l=0,aa=0,ai=0,E=0;else
var
V=Dq,E=1;else
var
V=Dr,E=1;else
var
V=Ds,E=1;else
var
V=Dt,E=1;else
var
V=Du,E=1;else
var
V=Dv,E=1;else
var
V=Dw,E=1;if(E)var
aC=V,ai=1;}else
var
aC=Dx,ai=1;else{var
bd=A(f,Dy);if(0<=bd)if(0<bd)if(j(f,Dz))if(j(f,DA))if(j(f,DB))if(j(f,DC))if(j(f,DD))if(j(f,DE))if(j(f,DF))var
g=1,l=0,aa=0,ai=0,F=0;else
var
W=DG,F=1;else
var
W=DH,F=1;else
var
W=DI,F=1;else
var
W=DJ,F=1;else
var
W=DK,F=1;else
var
W=DL,F=1;else
var
W=DM,F=1;else
var
W=DN,F=1;else
if(j(f,DO))if(j(f,DP))if(j(f,DQ))if(j(f,DR))if(j(f,DS))if(j(f,DT))if(j(f,DU))var
g=1,l=0,aa=0,ai=0,F=0;else
var
W=DV,F=1;else
var
W=DW,F=1;else
var
W=DX,F=1;else
var
W=DY,F=1;else
var
W=DZ,F=1;else
var
W=D0,F=1;else
var
W=D1,F=1;if(F)var
aC=W,ai=1;}if(ai)var
az=aC,aa=1;}if(aa)var
aw=az,l=1;}if(l)var
ao=aw,g=0;}var
aO=g?0:ao;if(aO){var
bk=aR(aO[1]);M(function(a){return r(c,a)},bk);}else
B(c,y(wg,y(f,wf)));continue a;default:var
be=C(e,e[5]);r(d,be);r(c,be);continue a}}}}function
fb(a,b,c,d,e,f){var
g=a;a:for(;;){var
l=425;for(;;){var
j=aA(as,l,f);if(6<j>>>0){i(f[1],f);var
l=j;continue}switch(j){case
0:var
m=aF(g,p(g,f));return[0,m,n(b,p(m,f)),1];case
1:r(e,96);return[0,g,n(b,p(g,f)),1];case
2:B(e,D4);return[0,g,n(b,p(g,f)),0];case
3:r(d,92);r(e,92);var
t=fa(g,c,f),o=cz(f);B(d,o);B(e,o);var
g=t[1];continue a;case
4:var
q=h(f,f[5],f[5]+2|0);B(d,q);B(e,q);B(c,D5);aB(f);continue a;case
5:var
s=C(f,f[5]);r(d,s);r(e,s);r(c,10);aB(f);continue a;default:var
k=C(f,f[5]);r(d,k);r(e,k);r(c,k);continue a}}}}var
bF=cA([0,df]);function
b5(a,b){var
c=a[2],d=c.slice();d[2]=c[2];return[0,[0],0,b,e6(d,a)]}function
dr(k,b){var
aG=b+1|0;if(k[1].length-1<aG){var
x=1;for(;;){if(!(aG<=x)){var
x=x*2|0;continue}var
ay=function(a){var
b=a<k[1].length-1?1:0,c=b?f(k[1],a)[a+1]:b;return c};if(0===x)var
az=[0];else{var
Q=bx(x,ay(0)),R=x-1|0,aH=1;if(!(R<1)){var
y=aH;for(;;){Q[y+1]=ay(y);var
aI=y+1|0;if(R!==y){var
y=aI;continue}break}}var
az=Q;}k[1]=az;break}}for(;;){if(k[2]<=b){var
e=k[4];switch(k[3]){case
0:var
s=bC(vI(e,e[2]));break;case
1:var
s=bC(vJ(e,e[2]));break;case
2:var
g=e[2],d=e;b:for(;;){var
ac=342;for(;;){var
H=aA(as,ac,g);if(14<H>>>0){i(g[1],g);var
ac=H;continue}switch(H){case
0:var
m=[0,d,I];break;case
1:aB(g);continue b;case
2:a$(g);continue b;case
3:var
aO=p(d,g),ad=D(F),ae=bl(d,ad,g),d=aa(ae[1],aO,ae[2],ad,1);continue b;case
4:var
aQ=p(d,g),af=D(F),ag=bk(d,af,g),d=aa(ag[1],aQ,ag[2],af,1);continue b;case
5:var
m=[0,d,92];break;case
6:var
m=[0,d,99];break;case
7:var
m=[0,d,93];break;case
8:var
m=[0,d,1];break;case
9:var
m=[0,d,80];break;case
10:var
m=[0,d,11];break;case
11:var
m=[0,d,78];break;case
12:a$(g);var
m=[0,d,f6];break;case
13:var
J=C(g,g[5]),aR=p(d,g),ah=D(F),z=D(F);r(z,J);var
aS=39===J?0:1,ai=dq(d,aS,ah,z,g);r(z,J);var
aT=V(ah),aU=V(z),aV=[4,[0,n(aR,ai[2]),aT,aU]],m=[0,ai[1],aV];break;default:var
m=[0,d,bO];}var
s=bC(m);break}break}break;case
3:var
S=e[2][12],T=eQ(e[1],S,S),u=D(F),v=D(F),l=e[2],aj=373;for(;;){var
K=aA(as,aj,l);if(4<K>>>0){i(l[1],l);var
aj=K;continue}switch(K){case
0:var
ak=h(l,l[5],l[6]);B(v,ak);B(u,ak);aB(l);var
al=dq(e,2,u,v,l),aW=V(u),aX=V(v),aY=[4,[0,n(T,al[2]),aW,aX]],w=[0,al[1],aY];break;case
1:var
w=[0,e,I];break;case
2:var
w=[0,e,92];break;case
3:var
w=[0,e,1];break;default:var
am=C(l,l[5]);r(v,am);r(u,am);var
an=dq(e,2,u,v,l),aZ=V(u),a0=V(v),a1=[4,[0,n(T,an[2]),aZ,a0]],w=[0,an[1],a1];}var
s=bC([0,w[1],w[2]]);break}break;case
4:var
j=e[2],o=e;b:for(;;){var
ao=gz;for(;;){var
L=aA(as,ao,j);if(5<L>>>0){i(j[1],j);var
ao=L;continue}switch(L){case
0:aB(j);continue b;case
1:a$(j);continue b;case
2:var
a2=p(o,j),ap=D(F),aq=bl(o,ap,j),o=aa(aq[1],a2,aq[2],ap,1);continue b;case
3:var
a3=p(o,j),ar=D(F),at=bk(o,ar,j),o=aa(at[1],a3,at[2],ar,1);continue b;case
4:var
a4=p(o,j),au=D(F),av=D(F),M=D(F);B(M,D2);var
N=fb(o,a4,au,av,M,j),a5=N[3],a6=V(M),a7=V(av),a8=[0,V(au),a7,a6],ax=[0,N[1],[2,[0,N[2],a8,a5]]];break;default:var
aw=aF(o,p(o,j)),ax=[0,aw,[2,[0,p(aw,j),D3,1]]];}var
s=bC(ax);break}break}break;default:var
a=e[2],c=e;b:for(;;){var
U=300;for(;;){var
A=aA(as,U,a);if(6<A>>>0){i(a[1],a);var
U=A;continue}switch(A){case
0:var
O=[0,c,I];break;case
1:aB(a);continue b;case
2:a$(a);continue b;case
3:var
aJ=p(c,a),W=D(F),X=bl(c,W,a),c=aa(X[1],aJ,X[2],W,1);continue b;case
4:var
aK=p(c,a),Y=D(F),Z=bk(c,Y,a),c=aa(Z[1],aK,Z[2],Y,1);continue b;case
5:var
aL=p(c,a),q=D(F);c:for(;;){var
$=323;for(;;){var
E=aA(as,$,a);if(7<E>>>0){i(a[1],a);var
$=E;continue}switch(E){case
0:var
t=[0,aP(c,p(c,a),14),v1];break;case
1:var
t=[0,aP(c,p(c,a),14),v2];break;case
2:B(q,h(a,a[5],a[5]+2|0));continue c;case
3:var
t=[0,c,h(a,a[5]+1|0,a[6])];break;case
4:var
t=[0,c,v3];break;case
5:r(q,C(a,a[5]));d:for(;;){var
ab=335;for(;;){var
G=aA(as,ab,a);if(4<G>>>0){i(a[1],a);var
ab=G;continue}switch(G){case
0:break;case
3:r(q,C(a,a[5]));break;case
4:r(q,C(a,a[5]));continue d;default:B(q,h(a,a[5],a[5]+2|0));continue d}continue c}}case
6:var
t=[0,aP(c,p(c,a),14),v4];break;default:r(q,C(a,a[5]));continue c}var
_=t[1],aM=n(aL,p(_,a)),aN=t[2],O=[0,_,[3,[0,aM,V(q),aN]]];break}break}break;default:var
O=[0,aF(c,p(c,a)),bO];}var
s=bC(O);break}break}}var
P=s[1],aC=P[2],aD=aC.slice();aD[2]=aC[2];var
a9=e6(aD,P);k[4]=P;var
aE=k[2],a_=[0,[0,a9,s[2]]];f(k[1],aE)[aE+1]=a_;k[2]=k[2]+1|0;continue}return 0}}function
b6(a){return bi(a[19][1])}function
at(a){return a[23][5]}function
s(a,b){var
d=b[2];a[1][1]=[0,[0,b[1],d],a[1][1]];var
c=a[18];return c?m(c[1],a,d):c}function
bG(a,b){var
c=b[2];if(m(bF[3],c,a[4][1]))return s(a,[0,b[1],[7,c]]);var
d=m(bF[4],c,a[4][1]);a[4][1]=d;return 0}function
b7(a,b){var
c=a?a[1]:0;if(c<2){var
e=b[21][1];dr(e,c);var
d=f(e[1],c)[c+1];return d?d[1][2]:ax(D6)}throw[0,v,D9]}function
bb(a,b){var
c=b.slice();c[6]=a;return c}function
b8(a,b){var
c=b.slice();c[13]=a;return c}function
b9(a,b){var
c=b.slice();c[8]=a;return c}function
bm(a,b){var
c=b.slice();c[11]=a;return c}function
dt(a,b){var
c=b.slice();c[14]=a;return c}function
fc(a,b){var
c=b.slice();c[7]=a;return c}function
fd(a,b){var
c=b.slice();c[12]=a;return c}function
fe(a,b){var
c=b.slice();c[18]=[0,a];return c}function
ff(b){function
c(a){return s(b,a)}return function(a){return M(c,a)}}function
cD(a){return a[5][1]}function
fg(a){var
b=a.slice();b[18]=0;return b}function
fh(a,b,c){var
d=a.slice();d[3]=bF[1];d[8]=0;d[9]=0;d[10]=1;d[16]=c;d[17]=b;return d}function
cE(a){return j(a,D_)?0:1}function
b_(a){if(j(a,D$))if(j(a,Ea))if(j(a,Eb))if(j(a,Ec))if(j(a,Ed))if(j(a,Ee))if(j(a,Ef))if(j(a,Eg))return 0;return 1}function
bn(a){if(j(a,Eh))if(j(a,Ei))return 0;return 1}function
l(a,b){var
c=a?a[1]:0;return b7([0,c],b)[1]}function
J(a,b){var
c=a?a[1]:0;return b7([0,c],b)[3]}function
o(a,b){var
c=a?a[1]:0;return b7([0,c],b)[2]}function
fi(a,b){var
c=a?a[1]:0;return b7([0,c],b)[4]}function
bH(a){var
b=cD(a);if(b)var
d=b[1][2][1],c=d<o(0,a)[2][1]?1:0;else
var
c=b;return c}function
b$(a){var
c=l(0,a);if(typeof
c==="number"){var
b=c-3|0;if(dR<b>>>0){if(!(cp<(b+1|0)>>>0))return 1}else{var
d=6!==b?1:0;if(!d)return d}}return bH(a)}function
N(a,b){var
c=a?a[1]:0,d=9===l([0,c],b)?1:0,e=d?[0,o([0,c],b)]:d;return e}function
aH(a,b){var
e=a?a[1]:0,c=J([0,e],b),f=l([0,e],b);if(!b_(c))if(!bn(c))if(!cE(c)){if(typeof
f==="number"){var
d=f-1|0,g=58<d>>>0?64<=d?0:1:27===d?1:0;if(g)return 1}return 0}return 1}function
cF(a,b){var
c=a?a[1]:0,d=15===l([0,c],b)?1:0;if(d)var
e=d;else
var
f=63===l([0,c],b)?1:0,e=f?15===l([0,c+1|0],b)?1:0:f;return e}function
du(a,b){var
d=a?a[1]:0,c=l([0,d],b);if(typeof
c==="number"){var
e=14===c?1:40===c?1:0;if(e)return 1}return 0}function
t(a,b){return s(a,[0,o(0,a),b])}function
fj(a){var
b=a[1];if(typeof
b==="number")switch(b){case
0:return 2;case
108:return 4}else
switch(b[0]){case
0:return 0;case
1:case
4:return 1}var
c=a[2];return cE(c)?3:b_(c)?40:[1,c]}function
ab(a){var
b=fi(0,a);i(ff(a),b);var
c=J(0,a);return t(a,fj([0,l(0,a),c]))}function
dv(b){function
c(a){return s(b,[0,a[1],57])}return function(a){return M(c,a)}}function
au(a,b){var
c=a[6];return c?t(a,b):c}function
aS(a,b){var
c=a[6];return c?s(a,[0,b[1],b[2]]):c}function
K(b){var
k=b[22][1];if(k){var
n=o(0,b),p=l(0,b),q=J(0,b),r=[0,n,p,b6(b),q];i(k[1],r);}var
j=b[21][1];dr(j,0);var
d=f(j[1],0)[1],s=d?d[1][1]:ax(D7);b[20][1]=s;var
t=fi(0,b);i(ff(b),t);var
m=b7([0,0],b)[5];M(function(a){b[2][1]=[0,a,b[2][1]];return 0},m);var
u=[0,o(0,b)];b[5][1]=u;var
a=b[21][1];dr(a,0);if(1<a[2]){var
c=a[2]-1|0,e=a[1],g=a[1],v=0<=c?(g.length-1-c|0)<1?0:(e.length-1-c|0)<0?0:(HB(g,1,e,0,c),1):0;if(!v)ay(hA);}var
h=a[2]-1|0;f(a[1],h)[h+1]=0;a[2]=a[2]-1|0;return 0}function
aK(a,b){a[19][1]=[0,b,a[19][1]];var
c=b6(a),d=b5(a[20][1],c);a[21][1]=d;return 0}function
a1(a){var
b=a[19][1],c=b?b[2]:ax(Ej);a[19][1]=c;var
d=b6(a),e=b5(a[20][1],d);a[21][1]=e;return 0}function
O(a){var
b=1-b$(a);return b?9===l(0,a)?K(a):ab(a):b}function
k(a,b){if(by(l(0,a),b))ab(a);return K(a)}function
ao(a,b){var
c=hc(l(0,a),b),d=c?(K(a),1):c;return d}function
aT(a,b){if(j(J(0,a),b))ab(a);return K(a)}var
ca=aZ([P,El,0]);function
Em(a){var
c=a[22][1];if(c){var
b=[0,0,0],f=[0,function(a){if(0===b[1]){var
c=[];e(c,[0,a,c]);b[1]=1;b[2]=c;return 0}var
d=b[2],f=[0,a,d[2]];b[1]=b[1]+1|0;d[2]=f;b[2]=f;return 0}];a[22][1]=f;var
d=[0,[0,c[1],b]];}else
var
d=c;return[0,a[1][1],a[2][1],a[5][1],a[19][1],a[20][1],d]}function
fk(a,b,c){if(c){var
h=c[1],j=h[1];b[22][1]=[0,j];if(a){var
k=h[2],e=0<k[1]?1:0;if(e){var
f=k[2],d=f[2];for(;;){i(j,d[1]);var
g=d!==f?1:0;if(g){var
d=d[2];continue}return g}}return e}var
l=a;}else
var
l=c;return l}function
En(a,b){fk(0,a,b[6]);a[1][1]=b[1];a[2][1]=b[2];a[5][1]=b[3];a[19][1]=b[4];a[20][1]=b[5];var
c=b6(a),d=b5(a[20][1],c);a[21][1]=d;return 0}function
Eo(a,b,c){fk(1,a,b[6]);return[0,c]}function
fl(a,b){var
c=Em(a);try{var
d=Eo(a,c,i(b,a));return d}catch(f){f=al(f);if(f===ca)return En(a,c);throw f}}function
bo(a,b){var
d=o(0,b),e=i(a,b),c=cD(b),f=c?c[1]:(t(b,Ep),o(0,b));return[0,n(d,f),e]}function
Eq(u){var
f=[],b=[],L=[],x=[],X=[],z=[],A=[],C=[],D=[],G=[],H=[],Y=[],g=[],M=[],N=[],Z=[],h=[],O=[],d=[],p=[],_=[],$=[],aa=[],ac=[],r=[],P=[],y=[],Q=[],B=[],R=[],ad=[],S=[];e(f,function(a){return i(X,a)});e(b,function(a){if(1-at(a))t(a,7);var
c=o(0,a);k(a,80);var
d=i(f,a),b=cD(a);if(b)return[0,n(c,b[1]),d];throw[0,v,Er]});e(L,function(a){var
c=o(0,a),b=l(0,a);if(typeof
b==="number"){if(97===b){K(a);return[0,[0,c,0]]}if(98===b){K(a);return[0,[0,c,1]]}}return 0});e(x,function(a){if(a){var
c=a[1][1],b=q(a);if(b)return[0,n(b[1][1],c),b];throw[0,v,Es]}throw[0,v,Et]});e(X,function(a){ao(a,83);return m(z,a,i(A,a))});e(z,function(a,b){if(83===l(0,a)){var
c=[0,b,0];for(;;){var
f=l(0,a);if(typeof
f==="number")if(83===f){k(a,83);var
c=[0,i(A,a),c];continue}var
g=i(x,c),d=g[2];if(d){var
e=d[2];if(e)return[0,g[1],[5,d[1],e[1],e[2]]]}throw[0,v,Eu]}}return b});e(A,function(a){ao(a,85);return m(C,a,i(D,a))});e(C,function(a,b){if(85===l(0,a)){var
c=[0,b,0];for(;;){var
f=l(0,a);if(typeof
f==="number")if(85===f){k(a,85);var
c=[0,i(D,a),c];continue}var
g=i(x,c),d=g[2];if(d){var
e=d[2];if(e)return[0,g[1],[6,d[1],e[1],e[2]]]}throw[0,v,Ev]}}return b});e(D,function(a){return m(G,a,i(H,a))});e(G,function(a,b){var
c=l(0,a);if(typeof
c==="number")if(12===c)if(!a[14]){var
d=m(h,a,b);return bp(r,a,d[1],0,[0,[0,d,0],0])}return b});e(H,function(a){var
b=l(0,a);if(typeof
b==="number")if(79===b){var
d=o(0,a);k(a,79);var
c=i(H,a);return[0,n(d,c[1]),[0,c]]}return i(Y,a)});e(Y,function(a){return m(g,a,i(M,a))});e(g,function(a,b){if(!bH(a))if(ao(a,7)){var
c=o(0,a);k(a,8);return m(g,a,[0,n(b[1],c),[3,b]])}return b});e(M,function(a){var
c=o(0,a),b=l(0,a);if(typeof
b==="number")switch(b){case
0:var
e=i(B,a);return[0,e[1],[4,e[2]]];case
5:return i(aa,a);case
7:return i(Z,a);case
46:var
u=o(0,a);k(a,46);var
h=i(M,a);return[0,n(u,h[1]),[7,h]];case
92:return i(ac,a);case
100:k(a,ah);return[0,c,8];case
1:case
3:var
f=bp(P,0,1,1,a);return[0,f[1],[2,f[2]]];case
30:case
31:var
t=J(0,a);k(a,b);return[0,c,[11,[0,31===b?1:0,t]]]}else
switch(b[0]){case
1:var
d=b[1],j=d[4],m=d[3],p=d[2],q=d[1];if(j)au(a,32);k(a,[1,[0,q,p,m,j]]);return[0,q,[9,[0,p,m]]];case
5:var
r=b[2],s=b[1],v=J(0,a);k(a,[5,s,r]);if(1===s)au(a,32);return[0,c,[10,[0,r,v]]]}var
g=i(N,b);return g?(k(a,b),[0,c,g[1]]):(ab(a),[0,c,0])});e(N,function(a){if(typeof
a==="number"){if(29===a)return Ew;if(ci<=a)switch(a-110|0){case
0:return Ex;case
1:return Ey;case
2:return Ez;case
3:return EA;case
4:return EB;case
5:return EC;default:return ED}}return 0});e(Z,function(a){var
g=o(0,a);k(a,7);var
b=0;for(;;){var
c=l(0,a);if(typeof
c==="number"){var
j=8===c?1:I===c?1:0;if(j){var
d=q(b),h=o(0,a);k(a,8);return[0,n(g,h),[8,d]]}}var
e=[0,i(f,a),b];if(8!==l(0,a))k(a,10);var
b=e;continue}});e(h,function(a,b){return[0,b[1],[0,0,b,0]]});e(O,function(a,b){if(1-at(a))t(a,7);var
d=ao(a,79);k(a,80);var
c=i(f,a);return[0,n(b[1],c[1]),[0,[0,b],c,d]]});function
ae(a){var
b=l(EE,a);if(typeof
b==="number")if(!(1<(b+d3|0)>>>0))return m(O,a,i(u[14],a)[1]);return m(h,a,i(f,a))}e(d,function(b){return function(a){var
c=a;for(;;){var
d=l(0,b);if(typeof
d==="number"){var
e=d-6|0,m=7<e>>>0?cg===e?1:0:5<(e-1|0)>>>0?1:0;if(m){var
f=13===d?1:0;if(f){var
i=o(0,b);k(b,13);var
g=ae(b),h=[0,[0,n(i,g[1]),[0,g]]];}else
var
h=f;return[0,q(c),h]}}var
j=[0,ae(b),c];if(6!==l(0,b))k(b,10);var
c=j;continue}}});e(p,function(a){k(a,5);var
b=m(d,a,0);k(a,6);return b});e(_,function(a){k(a,5);var
c=dt(0,a),e=l(0,c);if(typeof
e==="number")if(13<=e){if(I===e)var
q=1;else
if(14<=e)var
g=0,q=0;else
var
q=1;if(q)var
b=[0,m(d,c,0)],g=1;}else
if(6===e)var
b=EH,g=1;else
if(0===e)var
b=i($,c),g=1;else
var
g=0;else
var
g=0;if(!g){if(i(N,e)){var
u=l(EG,c);if(typeof
u==="number")if(1<(u+d3|0)>>>0)var
r=0;else
var
v=[0,m(d,c,0)],r=1;else
var
r=0;if(!r)var
v=[1,i(f,c)];var
w=v;}else
var
w=[1,i(f,c)];var
b=w;}if(0===b[0])var
s=b;else{var
o=b[1];if(a[14])var
t=b;else{var
p=l(0,a);if(typeof
p==="number")if(6===p)if(12===l(EF,a))var
n=[0,m(d,a,[0,m(h,a,o),0])],j=1;else
var
n=[1,o],j=1;else
if(10===p){k(a,10);var
n=[0,m(d,a,[0,m(h,a,o),0])],j=1;}else
var
j=0;else
var
j=0;if(!j)var
n=b;var
t=n;}var
s=t;}k(a,6);return s});e($,function(a){var
b=m(u[13],0,a),c=l(0,a);if(typeof
c==="number")if(!(1<(c+d3|0)>>>0)){var
e=m(O,a,b);ao(a,10);return[0,m(d,a,[0,e,0])]}return[1,m(z,a,m(C,a,m(G,a,m(g,a,m(ad,a,b)))))]});e(aa,function(a){var
c=o(0,a),b=i(_,a);return 0===b[0]?bp(r,a,c,0,b[1]):b[1]});e(ac,function(a){var
b=o(0,a),c=m(y,0,a);return bp(r,a,b,c,i(p,a))});e(r,function(a,b,c,d){k(a,12);var
e=i(f,a);return[0,n(b,e[1]),[1,[0,d,e,c]]]});function
T(a,b,c){var
e=i(p,a);k(a,80);var
d=i(f,a);return[0,n(b,d[1]),[0,e,d,c]]}function
U(a,b,c,d){var
e=T(a,b,m(y,0,a)),f=[0,e[1],[1,e[2]]];return[0,[0,f[1],[0,d,[0,f],0,c,1,0]]]}function
V(a,b,c,d,e){if(1-at(a))t(a,7);var
h=ao(a,79);k(a,80);var
g=i(f,a);return[0,[0,n(b,g[1]),[0,e,[0,g],h,c,0,d]]]}function
E(a,b){var
c=l(0,b);if(typeof
c==="number")if(!(11<=c))switch(c){case
2:if(!a)return 0;break;case
4:if(a)return 0;break;case
9:case
10:return K(b)}return ab(b)}function
F(a,b){return b?s(a,[0,b[1][1],5]):b}e(P,function(a,b,c,d){var
p=b?3===l(0,d)?1:0:b,aC=o(0,d),aD=p?3:1;k(d,aD);var
g=0;for(;;){if(a)if(c)throw[0,v,EJ];var
e=o(0,d),t=a?ao(d,42):a,h=i(L,d),w=l(0,d);if(typeof
w==="number"){if(92===w)var
x=1;else{if(I===w)var
Q=q(g),r=1;else
if(14<=w)var
x=0,r=0;else
switch(w){case
2:if(p)var
x=0,r=0;else
var
Q=q(g),r=1;break;case
4:if(p)var
Q=q(g),r=1;else
var
x=0,r=0;break;case
7:k(d,7);var
aa=80===l(EI,d)?1:0;if(aa){var
ay=i(u[14],d);k(d,80);var
ab=[0,ay[1]];}else
var
ab=aa;var
az=i(f,d);k(d,8);k(d,80);var
ac=i(f,d),aA=[2,[0,n(e,ac[1]),[0,ab,az,ac,t,h]]];E(p,d);var
g=[0,aA,g];continue;case
13:if(c){K(d);var
ar=i(B,d),aB=[1,[0,n(e,ar[1]),[0,ar]]];E(p,d);var
g=[0,aB,g];continue}var
x=0,r=0;break;case
5:var
x=1,r=0;break;default:var
x=0,r=0;}if(r){var
aE=o(0,d),aF=p?4:2;k(d,aF);return[0,n(aC,aE),[0,p,Q]]}}if(x){F(d,h);var
as=m(y,0,d),_=T(d,o(0,d),as),at=[3,[0,n(e,_[1]),[0,_,t]]];E(p,d);var
g=[0,at,g];continue}}if(0===t)var
A=0;else
if(h)var
A=0;else
if(typeof
w==="number")if(80===w){aS(d,[0,e,40]);var
an=[1,[0,e,EN]],P=l(0,d),ap=0;if(typeof
P==="number"){if(5===P)var
S=1;else
if(92===P)var
S=1;else
var
R=0,S=0;if(S){F(d,h);var
aq=U(d,e,ap,an),R=1;}}else
var
R=0;if(!R)var
aq=V(d,e,ap,h,an);var
ag=aq,A=1;}else
var
A=0;else
var
A=0;if(!A){var
ad=function(a){aK(a,0);var
b=i(u[21],a);a1(a);return b},z=ad(d)[2];if(1===z[0]){var
N=z[1][2];if(j(N,EK))if(j(N,EL))var
W=0,X=0;else
var
X=1;else
var
X=1;if(X){var
ah=l(0,d);if(typeof
ah==="number"){var
O=ah-6|0;if(85<O>>>0)if(87<(O+1|0)>>>0)var
G=0,H=0;else{F(d,h);var
am=U(d,e,t,z),H=1;}else
if(1<(O-73|0)>>>0)var
G=0,H=0;else
var
am=V(d,e,t,h,z),H=1;if(H)var
al=am,G=1;}else
var
G=0;if(!G){var
ai=ad(d),aj=ak(N,EM),C=T(d,e,0),D=C[2][1],J=ai[1];if(0===aj){var
$=D[1];if(D[2])s(d,[0,J,63]);else{var
aG=$?$[2]?0:1:0;if(!aG)s(d,[0,J,63]);}}else{var
aH=D[1]?0:D[2]?0:1;if(!aH)s(d,[0,J,62]);}var
au=0,av=0,aw=aj?[1,C]:[2,C],ax=[0,ai[2],aw,av,t,au,h],al=[0,[0,n(e,C[1]),ax]];}var
af=al,W=1;}}else
var
W=0;if(!W){var
M=l(0,d);if(typeof
M==="number"){if(5===M)var
Z=1;else
if(92===M)var
Z=1;else
var
Y=0,Z=0;if(Z){F(d,h);var
ae=U(d,e,t,z),Y=1;}}else
var
Y=0;if(!Y)var
ae=V(d,e,t,h,z);var
af=ae;}var
ag=af;}E(p,d);var
g=[0,ag,g];continue}});e(y,function(a,b){var
D=o(0,b),z=92===l(0,b)?1:0;if(z){if(1-at(b))t(b,7);k(b,92);var
d=0,p=0;for(;;){var
C=i(L,b),r=w(u[15],b,0,29),v=r[2],x=r[1],y=l(0,b);if(0===a)var
c=EO;else{if(typeof
y==="number")if(78===y){K(b);var
c=[0,[0,i(f,b)],1],h=1;}else
var
h=0;else
var
h=0;if(!h){if(d)s(b,[0,x,58]);var
c=[0,0,d];}}var
e=[0,[0,x,[0,v[1][2],v[2],C,c[1]]],p],g=l(0,b);if(typeof
g==="number"){if(93===g)var
m=1;else
if(I===g)var
m=1;else
var
j=0,m=0;if(m)var
A=q(e),j=1;}else
var
j=0;if(!j){k(b,10);if(93!==l(0,b)){var
d=c[2],p=e;continue}var
A=q(e);}var
E=n(D,o(0,b));k(b,93);var
B=[0,[0,E,[0,A]]];break}}else
var
B=z;return B});e(Q,function(a){var
p=o(0,a),g=92===l(0,a)?1:0;if(g){k(a,92);var
b=0;for(;;){var
c=l(0,a);if(typeof
c==="number"){if(93===c)var
e=1;else
if(I===c)var
e=1;else
var
d=0,e=0;if(e){var
j=q(b),r=n(p,o(0,a));k(a,93);var
h=[0,[0,r,[0,j]]],d=1;}}else
var
d=0;if(!d){var
m=[0,i(f,a),b];if(93!==l(0,a))k(a,10);var
b=m;continue}break}}else
var
h=g;return h});e(B,function(a){return m(R,a,m(u[13],0,a))});e(R,function(a,b){var
c=[0,b[1],[0,b]];for(;;){var
f=c[2],d=c[1];if(11===l(0,a)){k(a,11);var
g=m(u[13],0,a),h=n(d,g[1]),c=[0,h,[1,[0,h,[0,f,g]]]];continue}var
e=i(Q,a),j=e?n(d,e[1][1]):d;return[0,j,[0,f,e]]}});e(ad,function(a,b){var
c=m(R,a,b);return[0,c[1],[4,c[2]]]});e(S,function(a){var
c=l(0,a);if(typeof
c==="number")if(80===c)return[0,i(b,a)];return 0});function
W(a){var
b=dt(0,a),d=l(0,b);if(typeof
d==="number")if(65===d){var
c=o(0,b);k(b,65);if(5===l(0,b)){k(b,5);aK(b,0);var
f=i(u[8],b);a1(b);var
g=o(0,b);k(b,6);var
e=[0,n(c,g),[0,f]];}else
var
e=[0,c,0];return[0,e]}return 0}function
af(a){var
b=l(0,a),c=l(EP,a);if(typeof
b==="number")if(80===b){if(typeof
c==="number")if(65===c){k(a,80);return[0,0,W(a)]}var
d=i(S,a);return[0,d,W(a)]}return EQ}function
c(a,b){var
c=bb(1,b);aK(c,1);var
d=i(a,c);a1(c);return d}function
a(a){return c(f,a)}var
ag=i(y,1);function
ai(a){return c(ag,a)}var
aj=i(y,0);function
al(a){return c(aj,a)}function
am(a){return c(Q,a)}function
an(a,b){return c(w(P,a,0,0),b)}function
ap(a){return c(p,a)}function
aq(a){return c(b,a)}function
ar(a){return c(S,a)}function
as(a){return c(W,a)}function
av(a){return c(af,a)}return[0,a,al,ai,am,function(a){return c(B,a)},an,ap,aq,ar,as,av]}var
dw=cA([0,df]);function
ER(d){return function(g){function
f(a,b){var
d=b;for(;;){var
c=d[2];switch(c[0]){case
0:return az(A,a,c[1][1]);case
1:return az(B,a,c[1][1]);case
2:var
d=c[1][1];continue;case
3:var
e=c[1][1],f=e[2],g=a[2],h=a[1];if(m(dw[3],f,g))s(h,[0,e[1],30]);var
i=j([0,h,g],e),k=m(dw[4],f,i[2]);return[0,i[1],k];default:s(a[1],[0,d[1],19]);return a}}}function
A(a,b){if(0===b[0]){var
c=b[1][2],d=c[1],e=1===d[0]?j(a,d[1]):a;return f(e,c[2])}return f(a,b[1][2][1])}function
B(a,b){if(b){var
c=b[1];return 0===c[0]?f(a,c[1]):f(a,c[1][2][1])}return a}function
j(a,b){var
c=b[2],e=b[1],d=a[1];if(bn(c))aS(d,[0,e,29]);var
f=cE(c),g=f||b_(c);if(g)aS(d,[0,e,40]);return[0,d,a[2]]}function
p(a,b,c,d,e){var
j=b||1-c;if(j){var
g=e[2],h=b?bb(1-a[6],a):a;if(d){var
k=d[1],i=k[2],l=k[1];if(bn(i))aS(h,[0,l,31]);var
n=cE(i),o=n||b_(i);if(o)aS(h,[0,l,40]);}var
p=az(f,[0,h,dw[1]],e[1]),q=g?(f(p,g[1][2][1]),0):g,m=q;}else
var
m=j;return m}function
r(a){k(a,5);var
c=0;for(;;){var
e=l(0,a);if(typeof
e==="number"){var
f=e-6|0,v=7<f>>>0?cg===f?1:0:5<(f-1|0)>>>0?1:0;if(v){var
h=13===e?1:0;if(h){var
s=o(0,a);k(a,13);var
j=m(d[19],a,29),p=[0,[0,n(s,j[1]),[0,j]]];}else
var
p=h;if(6!==l(0,a))t(a,48);var
u=[0,q(c),p];k(a,6);return u}}var
b=m(d[19],a,29);if(78===l(0,a)){k(a,78);var
g=i(d[9],a),r=[0,n(b[1],g[1]),[2,[0,b,g]]];}else
var
r=b;if(6!==l(0,a))k(a,10);var
c=[0,r,c];continue}}function
h(a,b,c){var
g=fh(a,b,c),e=i(d[17],g),f=e[1];return[0,f,[0,[0,f,e[2]]],e[3]]}function
a(a,b,c){var
e=a.slice();e[10]=1;var
f=l(0,e);if(typeof
f==="number")if(1===f){var
g=h(e,b,c);return[0,g[2],g[3]]}var
j=fh(e,b,c),k=i(d[9],j);return[0,[1,k],j[6]]}function
c(a,b,c){var
g=o(0,a),f=l(0,a);if(typeof
f==="number")if(97===f){K(a);var
d=[0,[0,g,0]],e=1;}else
if(98===f){K(a);var
d=[0,[0,g,1]],e=1;}else
var
e=0;else
var
e=0;if(!e)var
d=0;if(d){var
h=b?0:c?0:1;if(!h){s(a,[0,d[1][1],5]);return 0}}return d}function
u(a){return ao(a,ah)}function
v(a){return ao(a,63)}function
w(a){var
d=0===a[2]?1:0;if(d){var
b=a[1];for(;;){if(b){var
e=b[2],c=3===b[1][2][0]?1:0;if(c){var
b=e;continue}return c}return 1}}return d}function
C(a){var
A=o(0,a),q=v(a);k(a,15);var
s=u(a),B=a[7],f=l(0,a);if(0===B)var
b=0;else
if(typeof
f==="number")if(5===f)var
c=ET,b=1;else
if(92===f)var
F=i(g[2],a),G=5===l(0,a)?0:[0,m(d[13],EU,a)],c=[0,F,G],b=1;else
var
b=0;else
var
b=0;if(!b)var
C=[0,m(d[13],ES,a)],c=[0,i(g[2],a),C];var
t=c[2],j=r(a),x=i(g[11],a),y=h(a,q,s),e=y[2],D=w(j);p(a,y[3],D,t,j);var
z=0===e[0]?[0,e[1][1],0]:[0,e[1][1],1],E=[17,[0,t,j,e,q,s,x[2],z[2],x[1],c[1]]];return[0,n(A,z[1]),E]}function
x(a){var
h=0,g=0;for(;;){var
b=m(d[19],a,28),f=78===l(0,a)?(k(a,78),[0,[0,i(d[9],a)],0]):3===b[2][0]?EV:[0,0,[0,[0,b[1],44],0]],e=f[1],o=e?e[1][1]:b[1],p=f[2],c=[0,[0,n(b[1],o),[0,b,e]],h],j=cv(p,g);if(10===l(0,a)){k(a,10);var
h=c,g=j;continue}var
r=bi(c),s=q(c),t=bi(c),u=q(j);return[0,n(t[1],r[1]),s,u]}}function
b(a,b,c){var
e=o(0,c);k(c,a);var
d=x(c),f=d[3],g=[0,d[2],b];return[0,[0,n(e,d[1]),g],f]}var
D=0,E=24;function
e(a){return b(E,D,a)}function
y(a){var
c=b(27,2,b8(1,a)),d=c[1],e=d[2],f=e[1],g=c[2],h=q(az(function(a,b){return b[2][2]?a:[0,[0,b[1],43],a]},g,f));return[0,[0,d[1],e],h]}function
z(a){return b(28,1,b8(1,a))}return[0,v,u,c,r,h,w,p,a,function(a){var
j=o(0,a),g=l(0,a);if(typeof
g==="number"){var
h=g+gI|0;if(4<h>>>0)var
b=0;else{switch(h){case
0:var
f=e(a),c=1;break;case
3:var
f=y(a),c=1;break;case
4:var
f=z(a),c=1;break;default:var
b=0,c=0;}if(c)var
d=f,b=1;}}else
var
b=0;if(!b){ab(a);var
d=e(a);}var
i=d[1],k=d[2],m=[18,i[2]];return[0,[0,n(j,i[1]),m],k]},x,z,y,e,C]}}function
EW(d){return function(g){return function(b){var
c=[],W=[],C=[],E=[],X=[],F=[],Y=[],h=[],G=[],p=[],Z=[],H=[],f=[],L=[],M=[],u=[],P=[],Q=[],R=[],_=[],S=[],z=[],$=[],T=[],aa=[],ac=[],A=[],B=[];function
U(a){var
b=i(F,a),f=i(X,a);if(f){if(1-i(E,b))s(a,[0,b[1],15]);var
e=b[2],k=typeof
e==="number"?0:17===e[0]?bn(e[1][2])?(aS(a,[0,b[1],37]),1):0:0,g=m(d[20],a,b),h=i(c,a),j=n(g[1],h[1]);return[0,j,[7,[0,f[1],g,h]]]}return b}function
ag(a,b){throw ca}function
ai(a){var
b=fe(ag,a),c=U(b),d=l(0,b);if(typeof
d==="number"){var
f=12===d?1:80===d?1:0;if(f)throw ca}if(aH(0,b)){var
e=c[2];if(typeof
e!=="number"&&17===e[0])if(!j(e[1][2],EX))if(!bH(b))throw ca;return c}return c}e(c,function(a){var
d=l(0,a),g=aH(0,a);if(typeof
d==="number"){var
c=d-6|0;if(85<c>>>0)var
b=87<(c+1|0)>>>0?0:1;else
if(52===c){if(a[16])return i(W,a);var
b=0;}else
var
b=0;}else
var
b=0;if(!b)if(0===g)return U(a);var
e=fl(a,ai);if(e)return e[1];var
f=fl(a,ac);return f?f[1]:U(a)});e(W,function(a){var
d=o(0,a);k(a,58);if(1-a[16])t(a,25);var
e=ao(a,ah),j=9===l(0,a)?1:0,m=j||b$(a),p=1-m,f=e||p,b=f?[0,i(c,a)]:f;if(b)var
g=b[1][1];else{var
h=N(0,a),q=h?h[1]:d;O(a);var
g=q;}return[0,n(d,g),[14,[0,b,e]]]});e(C,function(a){var
b=a[2];if(typeof
b!=="number")switch(b[0]){case
13:case
17:case
24:return 1}return 0});e(E,function(a){var
b=a[2];if(typeof
b!=="number")switch(b[0]){case
0:case
1:case
13:case
17:case
24:return 1}return 0});e(X,function(a){var
e=l(0,a);if(typeof
e==="number"){var
f=e+fU|0;if(12<f>>>0)var
d=0;else{switch(f){case
0:var
b=EY;break;case
1:var
b=EZ;break;case
2:var
b=E0;break;case
3:var
b=E1;break;case
4:var
b=E2;break;case
5:var
b=E3;break;case
6:var
b=E4;break;case
7:var
b=E5;break;case
8:var
b=E6;break;case
9:var
b=E7;break;case
10:var
b=E8;break;case
11:var
b=E9;break;default:var
b=E_;}var
c=b,d=1;}}else
var
d=0;if(!d)var
c=0;if(0!==c)K(a);return c});e(F,function(a){var
e=o(0,a),b=i(Y,a);if(79===l(0,a)){k(a,79);var
f=i(c,bm(0,a));k(a,80);var
d=bo(c,a),g=n(e,d[1]);return[0,g,[10,[0,b,f,d[2]]]]}return b});function
ad(a,b,c,d){return[0,d,[9,[0,c,a,b]]]}function
ae(a,b,c){var
e=b,d=c;for(;;){var
f=l(0,a);if(typeof
f==="number")if(82===f){k(a,82);var
g=bo(h,a),i=n(d,g[1]),e=ad(e,g[2],1,i),d=i;continue}return[0,d,e]}}e(Y,function(a){var
i=bo(h,a),j=ae(a,i[2],i[1]),b=j[2],c=j[1];for(;;){var
d=l(0,a);if(typeof
d==="number")if(81===d){k(a,81);var
e=bo(h,a),f=ae(a,e[2],e[1]),g=n(c,f[1]),b=ad(b,f[2],0,g),c=g;continue}return b}});function
af(a,b,c,d){return[0,d,[6,[0,c,a,b]]]}e(h,function(a){var
y=0;a:for(;;){var
Q=o(0,a),H=0!==i(G,a)?1:0,h=i(p,bm(0,a)),I=cD(a),R=I?I[1]:h[1],z=n(Q,R);if(92===l(0,a))var
J=h[2],T=typeof
J==="number"?0:21===J[0]?(t(a,47),1):0;var
A=l(0,a);if(typeof
A==="number"){var
e=A-17|0;if(1<e>>>0)if(66<=e)switch(e+fU|0){case
0:var
c=E$,b=1;break;case
1:var
c=Fa,b=1;break;case
2:var
c=Fb,b=1;break;case
3:var
c=Fc,b=1;break;case
4:var
c=Fd,b=1;break;case
5:var
c=Fe,b=1;break;case
6:var
c=Ff,b=1;break;case
7:var
c=Fg,b=1;break;case
8:var
c=Fh,b=1;break;case
9:var
c=Fi,b=1;break;case
10:var
c=Fj,b=1;break;case
11:var
c=Fk,b=1;break;case
12:var
c=Fl,b=1;break;case
13:var
c=Fm,b=1;break;case
14:var
c=Fn,b=1;break;case
15:var
c=Fo,b=1;break;case
16:var
c=Fp,b=1;break;case
17:var
c=Fq,b=1;break;case
18:var
c=Fr,b=1;break;case
19:var
c=Fs,b=1;break;default:var
j=0,b=0;}else
var
j=0,b=0;else
if(0===e)if(a[11])var
c=0,b=1;else
var
c=Ft,b=1;else
var
c=Fu,b=1;if(b)var
f=c,j=1;}else
var
j=0;if(!j)var
f=0;if(0!==f)K(a);if(f){var
L=f[1],M=L[1],S=H?14===M?1:0:H;if(S)s(a,[0,z,16]);var
q=h,m=[0,M,L[2]],k=z,d=y;for(;;){var
r=m[2],B=m[1];if(d){var
u=d[1],C=u[2],v=C[2],N=0===v[0]?v[1]:v[1]-1|0;if(r[1]<=N){var
D=n(u[3],k),O=af(u[1],q,C[1],D),q=O,m=[0,B,r],k=D,d=d[2];continue}}var
y=[0,[0,q,[0,B,r],k],d];continue a}}var
w=h,E=z,g=y;for(;;){if(g){var
x=g[1],F=n(x[3],E),P=g[2],w=af(x[1],w,x[2][1],F),E=F,g=P;continue}return w}}});e(G,function(a){var
b=l(0,a);if(typeof
b==="number")if(48<=b){if(97<=b){if(!(cY<=b))switch(b+fK|0){case
0:return Fv;case
1:return Fw;case
6:return Fx;case
7:return Fy}}else
if(64===b)if(a[17])return Fz}else
if(45<=b)switch(b-45|0){case
0:return FA;case
1:return FB;default:return FC}return 0});e(p,function(a){var
h=o(0,a),j=i(G,a);if(j){var
k=j[1];K(a);var
e=i(p,a),m=n(h,e[1]);if(6===k)var
q=e[2],t=typeof
q==="number"?0:17===q[0]?(aS(a,[0,m,33]),1):0;else
var
t=0;return[0,m,[5,[0,k,1,e]]]}var
f=l(0,a);if(typeof
f==="number")if(cY===f)var
c=FD,d=1;else
if(cp===f)var
c=FE,d=1;else
var
d=0;else
var
d=0;if(!d)var
c=0;if(c){K(a);var
b=i(p,a);if(1-i(C,b))s(a,[0,b[1],15]);var
g=b[2],u=typeof
g==="number"?0:17===g[0]?bn(g[1][2])?(au(a,39),1):0:0,r=[8,[0,c[1],b,1]];return[0,n(h,b[1]),r]}return i(Z,a)});e(Z,function(a){var
b=i(H,a);if(bH(a))return b;var
e=l(0,a);if(typeof
e==="number")if(cY===e)var
c=FF,d=1;else
if(cp===e)var
c=FG,d=1;else
var
d=0;else
var
d=0;if(!d)var
c=0;if(c){if(1-i(C,b))s(a,[0,b[1],15]);var
f=b[2],j=typeof
f==="number"?0:17===f[0]?bn(f[1][2])?(au(a,38),1):0:0,g=o(0,a);K(a);var
h=[8,[0,c[1],b,0]];return[0,n(b[1],g),h]}return b});e(H,function(a){var
c=o(0,a),b=a.slice(),k=1-a[15];b[15]=0;var
h=l(0,b);if(typeof
h==="number")if(44===h)if(k)var
j=i(L,b),e=1;else
var
e=0;else
var
e=0;else
var
e=0;if(!e)var
j=cF(0,b)?i(P,b):i(R,b);var
g=w(u,b,c,j),d=l(0,b);if(typeof
d==="number"){if(5===d)return w(f,b,c,g)}else
if(2===d[0])return w(u,b,c,bp(z,b,c,g,d[1]));return g});e(f,function(a,b,c){var
e=l(0,a);if(typeof
e==="number")switch(e){case
5:if(!a[12]){var
g=i(M,a),j=n(b,g[1]);return w(f,a,b,[0,j,[12,[0,c,g[2]]]])}break;case
7:k(a,7);var
m=i(d[7],a),p=n(b,o(0,a));k(a,8);return w(f,a,b,[0,p,[13,[0,c,[1,m],1]]]);case
11:k(a,11);var
h=i(B,a)[1];return w(f,a,b,[0,n(b,h[1]),[13,[0,c,[0,h],0]]])}else
if(2===e[0])return bp(z,a,b,c,e[1]);return c});e(L,function(a){var
b=o(0,a);k(a,44);if(a[10])if(11===l(0,a)){k(a,11);var
p=[0,b,FH];if(ak(J(0,a),FI)){var
q=m(d[13],0,a);return[0,n(b,q[1]),[24,[0,p,q]]]}ab(a);K(a);return[0,b,[17,p]]}var
r=o(0,a),s=l(0,a);if(typeof
s==="number")if(44===s)var
t=i(L,a),g=1;else
var
g=0;else
var
g=0;if(!g)var
t=cF(0,a)?i(P,a):i(R,a);var
v=w(u,fd(1,a),r,t),c=l(0,a);if(typeof
c==="number")var
h=0;else
if(2===c[0])var
e=bp(z,a,r,v,c[1]),h=1;else
var
h=0;if(!h)var
e=v;var
x=l(0,a);if(typeof
x==="number")if(5===x)var
f=i(M,a),j=1;else
var
j=0;else
var
j=0;if(!j)var
f=[0,e[1],0];var
y=[11,[0,e,f[2]]];return[0,n(b,f[1]),y]});e(M,function(a){var
r=o(0,a);k(a,5);var
b=0;for(;;){var
d=l(0,a);if(typeof
d==="number"){var
t=6===d?1:I===d?1:0;if(t){var
m=q(b),s=o(0,a);k(a,6);return[0,n(r,s),m]}}var
f=l(0,a);if(typeof
f==="number")if(13===f){var
j=o(0,a);k(a,13);var
g=i(c,a),h=[1,[0,n(j,g[1]),[0,g]]],e=1;}else
var
e=0;else
var
e=0;if(!e)var
h=[0,i(c,a)];var
p=[0,h,b];if(6!==l(0,a))k(a,10);var
b=p;continue}});e(u,function(a,b,c){var
e=l(0,a);if(typeof
e==="number"){if(7===e){k(a,7);var
h=fd(0,a),j=i(d[7],h),m=o(0,a);k(a,8);return w(f,a,b,[0,n(b,m),[13,[0,c,[1,j],1]]])}if(11===e){k(a,11);var
g=i(B,a)[1];return w(f,a,b,[0,n(b,g[1]),[13,[0,c,[0,g],0]]])}}return c});e(P,function(a){var
x=o(0,a),j=i(b[1],a);k(a,15);var
p=i(b[2],a);if(5===l(0,a))var
c=FJ;else{var
t=l(0,a);if(typeof
t==="number"){var
u=92!==t?1:0;if(u)var
h=0;else
var
v=u,h=1;}else
var
h=0;if(!h)var
v=[0,m(d[13],FK,a)];var
c=[0,v,i(g[2],a)];}var
q=c[1],e=i(b[4],a),r=i(g[11],a),f=w(b[5],a,j,p),s=f[2],y=i(b[6],e);cd(b[7],a,f[3],y,q,e);var
z=0===s[0]?0:1,A=[2,[0,q,e,s,j,p,r[2],z,r[1],c[2]]];return[0,n(x,f[1]),A]});e(Q,function(a,b){var
e=J(0,a);if(0===b)var
c=0;else
switch(b-1|0){case
0:au(a,32);var
d=bh(y(FL,e)),c=1;break;case
2:var
g=1;try{var
f=e8(e);}catch(f){g=0;f=al(f);if(!cy)throw f;t(a,59);var
d=c0,c=1;}if(g)var
d=f,c=1;break;default:var
c=0;}if(!c)var
d=bh(e);k(a,[0,b]);return d});e(R,function(a){var
c=o(0,a),b=l(0,a);if(typeof
b==="number")switch(b){case
1:return i(_,a);case
5:return i($,a);case
7:var
g=i(T,a);return[0,g[1],[0,g[2]]];case
21:k(a,21);return[0,c,0];case
29:var
s=J(0,a);k(a,29);return[0,c,[18,[0,0,s]]];case
40:return i(d[23],a);case
51:var
u=o(0,a);k(a,51);return[0,u,1];case
92:var
h=i(d[18],a);return[0,h[1],[21,h[2]]];case
30:case
31:var
t=J(0,a);k(a,b);return[0,c,[18,[0,[1,31===b?1:0],t]]];case
73:case
99:return i(aa,a)}else
switch(b[0]){case
0:var
v=J(0,a);return[0,c,[18,[0,[2,m(Q,a,b[1])],v]]];case
1:var
e=b[1],j=e[4],n=e[3],p=e[2],q=e[1];if(j)au(a,32);k(a,[1,[0,q,p,n,j]]);return[0,q,[18,[0,[0,p],n]]];case
2:var
r=m(S,a,b[1]);return[0,r[1],[19,r[2]]]}if(aH(0,a)){var
f=m(d[13],0,a);return[0,f[1],[17,f]]}ab(a);if(bO===b)K(a);return[0,c,[18,[0,0,FM]]]});e(_,function(a){var
b=i(d[11],a);return[0,b[1],[1,b[2]]]});e(S,function(a,b){var
y=b[3],z=b[2],m=b[1];k(a,[2,b]);var
A=[0,m,[0,[0,z[2],z[1]],y]];if(y)var
c=[0,m,[0,A,0],0];else{var
e=[0,A,0],r=0;for(;;){var
f=i(d[7],a),g=[0,f,r],s=l(0,a);if(typeof
s==="number")if(2===s){aK(a,4);var
h=l(0,a);if(typeof
h==="number")var
p=1;else
if(2===h[0]){var
j=h[1],t=j[3],u=j[2];K(a);var
w=j[1],C=[0,[0,u[2],u[1]],t];a1(a);var
x=[0,[0,w,C],e];if(!t){var
e=x,r=g;continue}var
D=q(g),B=[0,w,q(x),D],o=1,p=0;}else
var
p=1;if(p)throw[0,v,FN]}else
var
o=0;else
var
o=0;if(!o){ab(a);var
E=[0,f[1],FO],F=q(g),G=q([0,E,e]),B=[0,f[1],G,F];}var
c=B;break}}var
H=n(m,c[1]);return[0,H,[0,c[2],c[3]]]});e(z,function(a,b,c,d){var
e=m(S,a,d);return[0,n(b,e[1]),[20,[0,c,e]]]});e($,function(a){k(a,5);var
b=i(c,a),e=l(0,a);if(typeof
e==="number")if(10===e)var
f=m(A,a,[0,b,0]),d=1;else
if(80===e)var
h=i(g[8],a),f=[0,n(b[1],h[1]),[23,[0,b,h]]],d=1;else
var
d=0;else
var
d=0;if(!d)var
f=b;k(a,6);return f});e(T,function(a){var
p=o(0,a);k(a,7);var
b=0;for(;;){var
d=l(0,a);if(typeof
d==="number"){if(14<=d)var
e=I===d?1:0;else
if(8<=d)switch(d-8|0){case
2:k(a,10);var
b=[0,0,b];continue;case
5:var
j=o(0,a);k(a,13);var
f=i(c,a),m=[1,[0,n(j,f[1]),[0,f]]];if(8!==l(0,a))k(a,10);var
b=[0,[0,m],b];continue;case
0:var
e=1;break;default:var
e=0;}else
var
e=0;if(e){var
g=q(b),r=o(0,a);k(a,8);return[0,n(p,r),[0,g]]}}var
h=[0,i(c,a)];if(8!==l(0,a))k(a,10);var
b=[0,[0,h],b];continue}});e(aa,function(a){aK(a,5);var
g=o(0,a),c=l(0,a);if(typeof
c!=="number"&&3===c[0]){var
d=c[1],h=J(0,a);K(a);var
b=d[3],i=d[2];a1(a);var
e=D(x(b));es(function(a){var
b=a-103|0;if(!(18<b>>>0))switch(b){case
0:case
2:case
6:case
14:case
18:return r(e,a)}return 0},b);var
f=V(e);if(j(f,b))t(a,[3,b]);return[0,g,[18,[0,[3,[0,i,f]],h]]]}throw[0,v,FP]});function
aj(a,b){if(typeof
b==="number"){var
c=b-29|0,d=16<c>>>0?19===c?1:0:14<(c-1|0)>>>0?1:0;if(d)return 0}throw ca}e(ac,function(a){var
c=fe(aj,a),D=o(0,c),q=12!==l(FQ,c)?1:0,r=q?i(b[1],c):q,s=i(g[2],c);if(aH(0,c))if(0===s)var
u=m(d[13],FR,c),v=u[1],h=[0,[0,[0,[0,v,[3,[0,[0,v,u[2]],0,0]]],0],0],0,0],j=1;else
var
j=0;else
var
j=0;if(!j)var
J=i(b[4],c),K=dt(1,c),C=i(g[11],K),h=[0,J,C[1],C[2]];var
f=h[1];if(f[2])var
p=0;else
if(f[1])var
e=c,p=1;else
var
p=0;if(!p)var
e=fg(c);var
x=bH(e),E=x?12===l(0,e)?1:0:x;if(E)t(e,45);k(e,12);var
y=fg(e),F=b[8],z=bo(function(a){return w(F,a,r,0)},y),A=z[2],B=A[1],G=i(b[6],f);cd(b[7],y,A[2],G,0,f);var
H=0===B[0]?0:1,I=n(D,z[1]);return[0,I,[3,[0,0,f,B,r,0,h[3],H,h[2],s]]]});e(A,function(a,b){var
d=l(0,a);if(typeof
d==="number")if(10===d){k(a,10);return m(A,a,[0,i(c,a),b])}var
f=bi(b),e=q(b),g=bi(e);return[0,n(g[1],f[1]),[4,[0,e]]]});e(B,function(a){var
b=l(0,a),f=J(0,a),g=o(0,a);if(typeof
b==="number"){var
i=60<=b?64<=b?0:1:0===b?1:0;if(i)return[0,m(d[13],0,a),0]}if(typeof
b==="number"){if(65<=b)if(ci===b)var
c=1;else
if(dV<=b)var
c=1;else
var
e=0,c=0;else
if(60<=b)if(64<=b)var
c=1;else
var
e=0,c=0;else
if(15<=b)var
c=1;else
var
e=0,c=0;if(c)var
h=[0,[0,g,fj([0,b,f])]],e=1;}else
var
e=0;if(!e){ab(a);var
h=0;}K(a);return[0,[0,g,f],h]});return[0,T,c,F,B,E,H,Q,A]}}}function
FS(d){function
u(a){aK(a,0);var
b=o(0,a);k(a,1);k(a,13);var
c=i(d[9],a),e=o(0,a);k(a,2);a1(a);return[0,n(b,e),[0,c]]}function
g(a){aK(a,0);var
b=o(0,a);k(a,1);if(2===l(0,a))var
e=o(0,a)[2],c=[1,[0,b[1],b[3],e]];else
var
c=[0,i(d[7],a)];var
f=o(0,a);k(a,2);a1(a);return[0,n(b,f),[0,c]]}function
b(a){var
b=o(0,a),c=J(0,a);k(a,f6);return[0,b,[0,c]]}function
h(a){var
c=b(a),e=l(0,a);if(typeof
e==="number"){if(11===e){k(a,11);var
h=b(a),d=[0,n(c[1],h[1]),[0,[0,c],h]];for(;;){var
f=l(0,a);if(typeof
f==="number")if(11===f){k(a,11);var
g=b(a),d=[0,n(d[1],g[1]),[0,[1,d],g]];continue}return[2,d]}}if(80===e){k(a,80);var
i=b(a);return[1,[0,n(c[1],i[1]),[0,c,i]]]}}return[0,c]}function
v(a){var
x=o(0,a),d=b(a);if(80===l(0,a)){k(a,80);var
p=b(a),q=n(d[1],p[1]),f=[0,q,[1,[0,q,[0,d,p]]]];}else
var
f=[0,d[1],[0,d]];if(78===l(0,a)){k(a,78);var
c=l(0,a);if(typeof
c==="number")if(1===c){var
u=g(a),v=u[2],j=u[1];if(0!==v[1][0])s(a,[0,j,41]);var
h=[0,j,[0,[1,j,v]]],e=1;}else
var
e=0;else
if(4===c[0]){var
m=c[1],w=m[1];k(a,c);var
h=[0,w,[0,[0,w,[0,[0,m[2]],m[3]]]]],e=1;}else
var
e=0;if(!e){t(a,42);var
r=o(0,a),h=[0,r,[0,[0,r,[0,FU,FT]]]];}var
i=h;}else
var
i=[0,f[1],0];var
y=[0,f[2],i[2]];return[0,n(x,i[1]),y]}function
z(a,b){var
d=0,i=h(a);for(;;){var
c=l(0,a);if(typeof
c==="number"){if(94<=c)var
f=99===c?1:I===c?1:0;else{if(1===c){var
d=[0,[1,u(a)],d];continue}var
f=93<=c?1:0;}if(f){var
g=q(d),e=99===l(0,a)?1:0;if(e)k(a,99);var
j=o(0,a);k(a,93);a1(a);return[0,n(b,j),[0,i,e,g]]}}var
d=[0,[0,v(a)],d];continue}}function
A(a,b){k(a,99);var
j=h(a),l=o(0,a);k(a,93);var
d=a[19][1];if(d){var
e=d[2];if(e)var
f=e[2],c=1;else
var
c=0;}else
var
c=0;if(!c)var
f=ax(Ek);a[19][1]=f;var
g=b6(a),i=b5(a[20][1],g);a[21][1]=i;return[0,n(b,l),[0,j]]}var
p=[],f=[],c=[];e(p,function(a){var
b=l(0,a);if(typeof
b==="number"){if(1===b){var
f=g(a);return[0,f[1],[1,f[2]]]}}else
if(4===b[0]){var
d=b[1];k(a,b);return[0,d[1],[2,[0,d[2],d[3]]]]}var
e=i(c,a);return[0,e[1],[0,e[2]]]});function
r(a){switch(a[0]){case
0:return a[1][2][1];case
1:var
c=a[1][2],e=y(FV,c[2][2][1]);return y(c[1][2][1],e);default:var
d=a[1][2],b=d[1],f=0===b[0]?b[1][2][1]:r([2,b[1]]);return y(f,y(FW,d[2][2][1]))}}e(f,function(a,b){var
d=z(a,b);if(d[2][2])var
s=FX;else{aK(a,3);var
c=0;for(;;){var
h=l(0,a);if(typeof
h==="number"){if(92===h){aK(a,2);var
B=o(0,a);k(a,92);var
g=l(0,a);if(typeof
g==="number"){if(99===g)var
y=1;else
if(I===g)var
y=1;else
var
x=0,y=0;if(y)var
e=[0,A(a,B)],x=1;}else
var
x=0;if(!x)var
e=[1,m(f,a,B)];if(0!==e[0]){var
C=e[1],c=[0,[0,C[1],[0,C[2]]],c];continue}var
H=[0,e[1]],G=[0,q(c),H],w=1;}else
if(I===h){ab(a);var
G=[0,q(c),0],w=1;}else
var
v=0,w=0;if(w)var
s=G,v=1;}else
var
v=0;if(!v){var
c=[0,i(p,a),c];continue}break}}var
u=s[2];if(u){var
D=u[1],E=r(d[2][1]);if(j(r(D[2][1]),E))t(a,[6,E]);var
F=D[1];}else
var
F=d[1];var
J=[0,d,u,s[1]];return[0,n(d[1],F),J]});e(c,function(a){var
b=o(0,a);aK(a,2);k(a,92);return m(f,a,b)});return[0,u,g,b,h,v,z,A,p,f,c]}function
FY(u){return function(r){return function(p){return function(c){function
v(a){var
e=a[23][3];if(e){var
b=0;for(;;){var
d=l(0,a);if(typeof
d==="number")if(14===d){K(a);var
b=[0,i(c[6],a),b];continue}return q(b)}}return e}function
x(a){var
b=l(0,a);if(typeof
b==="number"){if(7===b){var
q=o(0,a);k(a,7);var
r=bm(0,a),s=i(u[9],r),t=o(0,a);k(a,8);return[0,n(q,t),[2,s]]}}else
switch(b[0]){case
0:var
v=J(0,a),g=o(0,a);return[0,g,[0,[0,g,[0,[2,m(c[7],a,b[1])],v]]]];case
1:var
d=b[1],h=d[4],j=d[3],p=d[2],e=d[1];if(h)au(a,32);k(a,[1,[0,e,p,j,h]]);return[0,e,[0,[0,e,[0,[0,p],j]]]]}var
f=i(c[4],a)[1];return[0,f[1],[1,f]]}function
y(a,b){var
g=i(p[2],a),h=x(a),e=h[1],m=o(0,a),c=i(p[4],a),f=0,q=0;if(0===b){var
j=c[1];if(c[2])s(a,[0,e,63]);else{var
y=j?j[2]?0:1:0;if(!y)s(a,[0,e,63]);}}else{var
z=c[1]?0:c[2]?0:1;if(!z)s(a,[0,e,62]);}var
t=i(r[9],a),k=w(p[5],a,f,g),d=k[2],u=i(p[6],c);cd(p[7],a,k[3],u,0,c);var
l=0===d[0]?[0,d[1][1],0]:[0,d[1][1],1],v=n(m,l[1]);return[0,h[2],[0,v,[0,0,c,d,f,g,0,l[2],t,q]]]}function
z(a,b,c,d,e){var
j=l(0,a);if(typeof
j==="number"){if(92===j)var
h=1;else
if(11<=j)var
g=0,h=0;else
switch(j){case
5:var
h=1;break;case
2:case
10:var
G=0,H=1;switch(c[0]){case
0:var
y=c[1],s=[0,y[1],[18,y[2]]];break;case
1:var
z=c[1],s=[0,z[1],[17,z]];break;default:var
s=c[1];}var
f=[0,s,H,G],g=1,h=0;break;default:var
g=0,h=0;}if(h){var
A=o(0,a),B=i(r[2],a),q=i(p[4],a),C=i(r[9],a),t=w(p[5],a,d,e),m=t[2],D=i(p[6],q);cd(p[7],a,t[3],D,0,q);var
v=0===m[0]?[0,m[1][1],0]:[0,m[1][1],1],E=n(A,v[1]),f=[0,[0,E,[2,[0,0,q,m,d,e,0,v[2],C,B]]],0,1],g=1;}}else
var
g=0;if(!g){k(a,80);var
f=[0,i(u[9],a),0,0];}var
x=f[1],F=[0,c,[0,x],f[3],f[2]];return[0,n(b,x[1]),F]}var
f=[],d=[],g=[],h=[];function
a(a){var
aa=o(0,a);k(a,1);var
t=0;for(;;){var
v=l(0,a);if(typeof
v==="number"){var
ac=2===v?1:I===v?1:0;if(ac){var
$=q(t),ab=o(0,a);k(a,2);return[0,n(aa,ab),[0,$]]}}var
b=o(0,a);if(13===l(0,a)){k(a,13);var
G=i(u[9],a),Y=[1,[0,n(b,G[1]),[0,G]]];}else{var
C=fm?fm[1]:0,D=aH([0,C],a);if(D)var
E=D,w=0;else{var
F=l([0,C],a);if(typeof
F==="number")var
A=1;else
if(1<F[0])var
A=1;else
var
E=1,w=0,A=0;if(A)var
s=0,w=1;}if(!w)var
s=E;var
H=s?i(p[1],a):s,J=i(p[2],a),K=x(a);if(0===H)if(0===J){var
h=K[2];if(1===h[0]){var
M=h[1][2];if(j(M,FZ))if(j(M,F0))var
c=0,B=0;else{var
N=l(0,a);if(typeof
N==="number"){var
m=N+f7|0;if(12<m>>>0)if(dP<=m)var
d=0,e=0;else
switch(m+80|0){case
2:case
5:case
10:var
e=1;break;default:var
d=0,e=0;}else
if(10<(m-1|0)>>>0)var
e=1;else
var
d=0,e=0;if(e)var
O=z(a,b,h,0,0),d=1;}else
var
d=0;if(!d)var
V=y(a,0),W=V[2],X=W[1],_=[0,V[1],[2,[0,X,W[2]]],0,0],O=[0,n(b,X),_];var
P=O,B=1;}else{var
Q=l(0,a);if(typeof
Q==="number"){var
r=Q+f7|0;if(12<r>>>0)if(dP<=r)var
f=0,g=0;else
switch(r+80|0){case
2:case
5:case
10:var
g=1;break;default:var
f=0,g=0;}else
if(10<(r-1|0)>>>0)var
g=1;else
var
f=0,g=0;if(g)var
R=z(a,b,h,0,0),f=1;}else
var
f=0;if(!f)var
S=y(a,1),T=S[2],U=T[1],Z=[0,S[1],[1,[0,U,T[2]]],0,0],R=[0,n(b,U),Z];var
P=R,B=1;}if(B)var
L=P,c=1;}else
var
c=0;}else
var
c=0;else
var
c=0;if(!c)var
L=z(a,b,K[2],H,J);var
Y=[0,L];}if(2!==l(0,a))k(a,10);var
t=[0,Y,t];continue}}e(f,function(a){if(41===l(0,a)){k(a,41);var
e=a.slice();e[16]=0;var
j=i(c[6],e),b=[0,[0,j],i(r[4],a)];}else
var
b=F1;var
f=52===l(0,a)?1:0;if(f){if(1-at(a))t(a,11);k(a,52);var
h=m(d,a,0);}else
var
h=f;var
n=i(g,a);return[0,n,b[1],b[2],h]});e(d,function(a,b){var
c=m(u[13],0,a),e=i(r[4],a),h=e?n(c[1],e[1][1]):c[1],f=[0,[0,h,[0,c,e]],b],g=l(0,a);if(typeof
g==="number")if(10===g){k(a,10);return m(d,a,f)}return q(f)});e(g,function(a){var
f=o(0,a);k(a,1);var
b=0;for(;;){var
d=l(0,a);if(typeof
d==="number"){var
c=d-3|0;if(dR<c>>>0){if(!(cp<(c+1|0)>>>0)){var
e=q(b),g=o(0,a);k(a,2);return[0,n(f,g),[0,e]]}}else
if(6===c){k(a,9);continue}}var
b=[0,i(h,a),b];continue}});function
A(a,b){return b?s(a,[0,b[1][1],5]):b}function
B(a,b,c,d,e,f,g,h){for(;;){var
B=l(0,a);if(typeof
B==="number"){var
v=B-78|0;if(2<v>>>0)var
M=dP===v?0:1;else{if(1===v){ab(a);K(a);continue}var
M=0;}if(!M)if(!e)if(!f){var
T=i(r[9],a),G=a[23],H=78===l(0,a)?1:0;if(H){var
I=g?G[2]:g;if(I)var
z=I;else
var
L=1-g,z=L?G[1]:L;var
J=z?(k(a,78),[0,i(u[7],a)]):z;}else
var
J=H;var
U=o(0,a);if(!ao(a,9)){var
V=7===l(0,a)?1:0,W=V||(5===l(0,a)?1:0);if(W)ab(a);}return[1,[0,n(b,U),[0,d,J,T,g,h]]]}}A(a,h);var
N=o(0,a),O=i(r[2],a),x=i(p[4],a),P=i(r[9],a),C=w(p[5],a,e,f),s=C[2],Q=i(p[6],x);cd(p[7],a,C[3],Q,0,x);var
D=0===s[0]?[0,s[1][1],0]:[0,s[1][1],1],E=D[1],R=n(N,E),S=[0,R,[0,0,x,s,e,f,0,D[2],P,O]];if(0===g){switch(d[0]){case
0:var
y=d[1][2][1];if(typeof
y==="number")var
t=1;else
if(0===y[0])if(j(y[1],F2))var
m=0,q=0,t=0;else
var
q=1,t=0;else
var
t=1;if(t)var
m=0,q=0;break;case
1:if(j(d[1][2],F3))var
m=0,q=0;else
var
q=1;break;default:var
m=0,q=0;}if(q)var
F=0,m=1;}else
var
m=0;if(!m)var
F=1;return[0,[0,n(b,E),[0,F,d,S,g,c]]]}}e(h,function(a){var
g=o(0,a),h=v(a),C=5!==l(F4,a)?1:0;if(C)var
D=92!==l(F5,a)?1:0,d=D?ao(a,42):D;else
var
d=C;var
E=5!==l(F6,a)?1:0;if(E)var
F=80!==l(F7,a)?1:0,e=F?i(p[1],a):F;else
var
e=E;var
q=i(p[2],a),f=w(p[3],a,e,q);if(0===q)if(f)var
k=i(p[2],a),r=1;else
var
r=0;else
var
r=0;if(!r)var
k=q;var
G=x(a);if(0===e)if(0===k){var
m=G[2];if(1===m[0]){var
H=m[1][2];if(!j(H,F8)){var
c=l(0,a);if(typeof
c==="number"){var
L=78<=c?81<=c?92===c?1:0:79===c?0:1:5===c?1:9===c?1:0;if(L)return B(a,g,h,m,e,k,d,f)}A(a,f);var
s=y(a,1),t=s[2],I=[0,2,s[1],t,d,h];return[0,[0,n(g,t[1]),I]]}if(!j(H,F9)){var
b=l(0,a);if(typeof
b==="number"){var
K=78<=b?81<=b?92===b?1:0:79===b?0:1:5===b?1:9===b?1:0;if(K)return B(a,g,h,m,e,k,d,f)}A(a,f);var
u=y(a,0),z=u[2],J=[0,3,u[1],z,d,h];return[0,[0,n(g,z[1]),J]]}}}return B(a,g,h,G[2],e,k,d,f)});function
b(a,b){var
c=bb(1,a),p=o(0,c),q=cv(b,v(c));k(c,40);var
g=b8(1,c),s=c[7],t=aH(0,g);if(0===s)var
e=0;else{var
l=0!==t?1:0;if(l)var
e=0;else
var
h=l,e=1;}if(!e)var
h=[0,m(u[13],0,g)];var
w=i(r[3],c),d=i(f,c),j=d[1],x=n(p,j[1]);return[0,x,[19,[0,h,j,d[2],w,d[3],d[4],q]]]}return[0,x,a,b,function(a){var
p=o(0,a),q=v(a);k(a,40);var
h=l(0,a);if(typeof
h==="number"){var
e=h-1|0;if(40<e>>>0)if(91===e)var
d=1;else
var
c=0,d=0;else
if(38<(e-1|0)>>>0)var
d=1;else
var
c=0,d=0;if(d)var
g=F_,c=1;}else
var
c=0;if(!c)var
t=[0,m(u[13],0,a)],g=[0,t,i(r[3],a)];var
b=i(f,a),j=b[1],s=n(p,j[1]);return[0,s,[22,[0,g[1],j,b[2],g[2],b[3],b[4],q]]]},v]}}}}function
F$(c){return function(u){function
f(h,b){var
a=b[2][1],d=[0,[0,bj(function(a){if(0===a[0]){var
i=a[1],d=i[2],e=d[2],b=d[1];switch(b[0]){case
0:var
f=[0,b[1]];break;case
1:var
f=[1,b[1]];break;default:var
f=[2,b[1]];}if(0===e[0])var
j=m(c[20],h,e[1]);else{var
k=e[1],g=k[1];s(h,[0,g,2]);var
j=[0,g,[4,[0,g,[2,k[2]]]]];}return[0,[0,i[1],[0,f,j,d[4]]]]}var
l=a[1],n=[0,m(c[20],h,l[2][1])];return[1,[0,l[1],n]]},a),0]];return[0,b[1],d]}function
g(f,b){var
a=b[2][1],d=[1,[0,bj(function(a){if(a){var
b=a[1];if(0===b[0]){var
d=b[1];return[0,[0,m(c[20],f,[0,d[1],d[2]])]]}var
e=b[1],g=[0,m(c[20],f,e[2][1])];return[0,[1,[0,e[1],g]]]}return a},a),0]];return[0,b[1],d]}function
a(a,b){var
c=b[2],d=b[1];if(typeof
c!=="number")switch(c[0]){case
0:return g(a,[0,d,c[1]]);case
1:return f(a,[0,d,c[1]]);case
7:var
e=c[1];if(0===e[1])return[0,d,[2,[0,e[2],e[3]]]];break;case
17:return[0,d,[3,[0,c[1],0,0]]]}return[0,d,[4,[0,d,c]]]}function
e(v){return function(a){var
H=o(0,a);k(a,1);var
j=0;for(;;){var
m=l(0,a);if(typeof
m==="number"){var
L=2===m?1:I===m?1:0;if(L){var
G=q(j),J=o(0,a);k(a,2);if(80===l(0,a))var
E=i(u[8],a),r=[0,E[1],[0,E]];else
var
r=[0,J,0];var
K=[0,[0,G,r[2]]];return[0,n(H,r[1]),K]}}var
w=o(0,a);if(ao(a,13))var
x=d(a,v),p=[0,[1,[0,n(w,x[1]),[0,x]]]];else{var
f=i(c[21],a)[2];switch(f[0]){case
0:var
b=[0,f[1]];break;case
1:var
b=[1,f[1]];break;default:var
b=[2,f[1]];}var
y=l(0,a);if(typeof
y==="number")if(80===y){k(a,80);var
e=[0,[0,d(a,v),0]],s=1;}else
var
s=0;else
var
s=0;if(!s)if(1===b[0])var
D=b[1],e=[0,[0,[0,D[1],[3,[0,D,0,0]]],1]];else{ab(a);var
e=0;}if(e){var
z=e[1],g=z[1],A=l(0,a);if(typeof
A==="number")if(78===A){k(a,78);var
B=i(c[9],a),h=[0,n(g[1],B[1]),[2,[0,g,B]]],t=1;}else
var
t=0;else
var
t=0;if(!t)var
h=g;var
F=n(w,h[1]),C=[0,[0,[0,F,[0,b,h,z[2]]]]];}else
var
C=e;var
p=C;}if(p){if(2!==l(0,a))k(a,10);var
j=[0,p[1],j];continue}continue}}}function
h(m){return function(a){var
z=o(0,a);k(a,7);var
b=0;for(;;){var
e=l(0,a);if(typeof
e==="number"){if(14<=e)var
f=I===e?1:0;else
if(8<=e)switch(e-8|0){case
2:k(a,10);var
b=[0,0,b];continue;case
5:var
y=o(0,a);k(a,13);var
t=d(a,m),b=[0,[0,[1,[0,n(y,t[1]),[0,t]]]],b];continue;case
0:var
f=1;break;default:var
f=0;}else
var
f=0;if(f){var
w=q(b),A=o(0,a);k(a,8);if(80===l(0,a))var
v=i(u[8],a),h=[0,v[1],[0,v]];else
var
h=[0,A,0];var
B=[1,[0,w,h[2]]];return[0,n(z,h[1]),B]}}var
g=d(a,m),p=l(0,a);if(typeof
p==="number")if(78===p){k(a,78);var
r=i(c[7],a),s=[0,n(g[1],r[1]),[2,[0,g,r]]],j=1;}else
var
j=0;else
var
j=0;if(!j)var
s=g;var
x=[0,s];if(8!==l(0,a))k(a,10);var
b=[0,[0,x],b];continue}}}function
d(a,b){var
d=l(0,a);if(typeof
d==="number"){if(1===d)return i(e(b),a);if(7===d)return i(h(b),a)}var
f=w(c[15],a,0,b);return[0,f[1],[3,f[2]]]}return[0,f,g,a,e,h,d]}}var
dx=cA([0,df]);function
Ga(d){return function(f){return function(g){return function(ap){var
a=[],c=[],Q=[],R=[],S=[],T=[],U=[],V=[],W=[],X=[],Y=[],Z=[],_=[],$=[],aa=[],ac=[],ad=[],b=[],C=[],u=[],D=[],x=[],z=[],ae=[],A=[],E=[],F=[],G=[],af=[],ag=[],H=[],r=[],p=[],B=[],ai=[],L=[],h=[];function
P(a,b){var
d=b;for(;;){var
c=d[2];switch(c[0]){case
0:var
e=c[1][1];return az(function(a,b){var
c=0===b[0]?b[1][2][2]:b[1][2][1];return P(a,c)},a,e);case
1:var
f=c[1][1];return az(function(a,b){if(b){var
c=b[1],d=0===c[0]?c[1]:c[1][2][1];return P(a,d)}return a},a,f);case
2:var
d=c[1][1];continue;case
3:return[0,c[1][1],a];default:return ax(Gb)}}}e(a,function(a){var
b=o(0,a);k(a,9);return[0,b,0]});e(c,function(a){var
e=o(0,a);k(a,32);if(9===l(0,a))var
c=0;else
if(b$(a))var
c=0;else{var
j=m(d[13],0,a),p=j[2];if(1-m(dx[3],p,a[3]))t(a,[4,p]);var
b=[0,j],c=1;}if(!c)var
b=0;var
f=N(0,a),q=f?f[1]:b?b[1][1]:e,g=n(e,q),h=0===b?1:0;if(h)var
r=a[8],u=r||a[9],i=1-u;else
var
i=h;if(i)s(a,[0,g,23]);O(a);return[0,g,[4,[0,b]]]});e(Q,function(a){var
e=o(0,a);k(a,35);if(9===l(0,a))var
c=0;else
if(b$(a))var
c=0;else{var
h=m(d[13],0,a),i=h[2];if(1-m(dx[3],i,a[3]))t(a,[4,i]);var
b=[0,h],c=1;}if(!c)var
b=0;var
f=N(0,a),j=f?f[1]:b?b[1][1]:e,g=n(e,j);if(1-a[8])s(a,[0,g,22]);O(a);return[0,g,[5,[0,b]]]});e(R,function(a){var
b=o(0,a);k(a,59);var
c=N(0,a),d=c?c[1]:b;O(a);return[0,n(b,d),1]});e(S,function(a){var
c=o(0,a);k(a,37);var
e=b9(1,a),f=i(d[2],e);k(a,25);k(a,5);var
g=i(d[7],a),h=o(0,a);k(a,6);var
b=N(0,a),j=b?b[1]:h;if(9===l(0,a))O(a);return[0,n(c,j),[13,[0,f,g]]]});function
aj(a,b,c){if(c){var
e=c[1];if(0===e[0]){var
g=e[1],f=g[2][1];if(f)if(!f[1][2][2]){var
h=f[2];if(!h)return h}return s(a,[0,g[1],b])}var
j=e[1],k=j[1],l=1-i(d[24],[0,k,j[2]]);return l?s(a,[0,k,b]):l}return t(a,b)}e(T,function(b){var
h=o(0,b);k(b,39);var
t=b[17],u=t?ao(b,64):t;k(b,5);var
f=l(0,b);if(typeof
f==="number")if(24<=f)if(29<=f)var
a=0;else
switch(f+gI|0){case
0:var
S=bm(1,b),F=i(g[13],S),e=[0,[0,[0,F[1]]],F[2]],a=1;break;case
3:var
T=bm(1,b),G=i(g[12],T),e=[0,[0,[0,G[1]]],G[2]],a=1;break;case
4:var
U=bm(1,b),H=i(g[11],U),e=[0,[0,[0,H[1]]],H[2]],a=1;break;default:var
a=0;}else
if(9===f)var
e=Ge,a=1;else
var
a=0;else
var
a=0;if(!a)var
I=b8(1,bm(1,b)),e=[0,[0,[1,i(d[7],I)]],0];var
c=e[1],j=l(0,b);if(62!==j)if(!u){if(typeof
j==="number")if(17===j){aj(b,17,c);if(c){var
p=c[1],N=0===p[0]?[0,p[1]]:[1,p[1]];k(b,17);var
O=i(d[7],b);k(b,6);var
P=b9(1,b),x=i(d[2],P);return[0,n(h,x[1]),[15,[0,N,O,x,0]]]}throw[0,v,Gd]}var
Q=e[2];M(function(a){return s(b,a)},Q);k(b,9);var
y=l(0,b);if(typeof
y==="number"){var
z=9!==y?1:0;if(z)var
q=0;else
var
A=z,q=1;}else
var
q=0;if(!q)var
A=[0,i(d[7],b)];k(b,9);var
B=l(0,b);if(typeof
B==="number"){var
C=6!==B?1:0;if(C)var
r=0;else
var
D=C,r=1;}else
var
r=0;if(!r)var
D=[0,i(d[7],b)];k(b,6);var
R=b9(1,b),E=i(d[2],R);return[0,n(h,E[1]),[14,[0,c,A,D,E]]]}aj(b,18,c);if(c){var
m=c[1],J=0===m[0]?[0,m[1]]:[1,m[1]];k(b,62);var
K=i(d[9],b);k(b,6);var
L=b9(1,b),w=i(d[2],L);return[0,n(h,w[1]),[16,[0,J,K,w,u]]]}throw[0,v,Gc]});e(U,function(a){var
f=o(0,a);k(a,16);k(a,5);var
h=i(d[7],a);k(a,6);l(0,a);var
c=cF(0,a)?(au(a,46),i(g[14],a)):i(d[2],a),e=43===l(0,a)?1:0,b=e?(k(a,43),[0,i(d[2],a)]):e,j=b?b[1][1]:c[1];return[0,n(f,j),[2,[0,h,c,b]]]});e(V,function(a){if(1-a[10])t(a,24);var
e=o(0,a);k(a,19);if(9===l(0,a))var
c=0;else
if(b$(a))var
c=0;else
var
b=[0,i(d[7],a)],c=1;if(!c)var
b=0;var
f=N(0,a),g=f?f[1]:b?b[1][1]:e;O(a);return[0,n(e,g),[9,[0,b]]]});e(W,function(a){var
A=o(0,a);k(a,20);k(a,5);var
B=i(d[7],a);k(a,6);k(a,1);var
b=Gf;for(;;){var
h=b[2],j=b[1],c=l(0,a);if(typeof
c==="number"){var
D=2===c?1:I===c?1:0;if(D){var
u=q(h),C=o(0,a);k(a,2);return[0,n(A,C),[8,[0,B,u]]]}}var
v=o(0,a),p=l(0,a);if(typeof
p==="number")if(36===p){if(j)t(a,20);k(a,36);var
e=0,f=1;}else
var
f=0;else
var
f=0;if(!f){k(a,33);var
e=[0,i(d[7],a)];}var
w=j||(0===e?1:0),x=o(0,a);k(a,80);var
y=function(a){if(typeof
a==="number"){var
b=a-2|0,c=31<b>>>0?34===b?1:0:29<(b-1|0)>>>0?1:0;if(c)return 1}return 0},g=a.slice();g[9]=1;var
r=m(d[4],y,g),s=q(r),z=s?s[1][1]:x,b=[0,w,[0,[0,n(v,z),[0,e,r]],h]];continue}});e(X,function(a){var
b=o(0,a);k(a,22);if(bH(a))s(a,[0,b,12]);var
c=i(d[7],a),e=N(0,a),f=e?e[1]:c[1];O(a);return[0,n(b,f),[10,[0,c]]]});e(Y,function(a){var
r=o(0,a);k(a,23);var
e=i(d[16],a),h=l(0,a);if(typeof
h==="number")if(34===h){var
t=o(0,a);k(a,34);k(a,5);var
j=m(d[13],Gg,a),u=[0,j[1],[3,[0,j,0,0]]];k(a,6);var
p=i(d[16],a),b=[0,[0,n(t,p[1]),[0,u,p]]],f=1;}else
var
f=0;else
var
f=0;if(!f)var
b=0;var
q=l(0,a);if(typeof
q==="number")if(38===q){k(a,38);var
c=[0,i(d[16],a)],g=1;}else
var
g=0;else
var
g=0;if(!g)var
c=0;var
v=c?c[1][1]:b?b[1][1]:(s(a,[0,e[1],21]),e[1]);return[0,n(r,v),[11,[0,e,b,c]]]});e(Z,function(b){var
a=i(g[9],b),c=a[1],d=c[1],e=N(0,b),f=e?e[1]:d;O(b);var
h=a[2];M(function(a){return s(b,a)},h);var
j=c[2];return[0,n(d,f),j]});e(_,function(b){var
d=o(0,b);k(b,28);var
e=b8(1,b),a=i(g[10],e),f=[18,[0,a[2],1]],c=N(0,b),h=c?c[1]:a[1];O(b);var
j=a[3];M(function(a){return s(b,a)},j);return[0,n(d,h),f]});e($,function(a){var
c=o(0,a);k(a,25);k(a,5);var
e=i(d[7],a);k(a,6);var
f=b9(1,a),b=i(d[2],f);return[0,n(c,b[1]),[12,[0,e,b]]]});e(aa,function(a){var
e=o(0,a);k(a,26);k(a,5);var
f=i(d[7],a);k(a,6);var
b=i(d[2],a),c=n(e,b[1]);aS(a,[0,c,26]);return[0,c,[6,[0,f,b]]]});e(ac,function(a){var
b=i(d[16],a);return[0,b[1],[0,b[2]]]});e(ad,function(a){var
b=i(d[7],a),g=l(0,a),c=b[2],h=b[1];if(typeof
c!=="number"&&17===c[0])if(typeof
g==="number")if(80===g){var
o=c[1],e=o[2];k(a,80);if(m(dx[3],e,a[3]))s(a,[0,h,[5,Gh,e]]);var
f=a.slice();f[3]=m(bF[4],e,a[3]);var
p=i(d[2],f);return[0,n(h,p[1]),[3,[0,o,p]]]}var
j=N(0,a),q=j?j[1]:b[1];O(a);return[0,n(b[1],q),[1,[0,b]]]});e(b,function(a){var
b=bo(d[7],a),c=b[1],e=N(0,a),f=e?n(c,e[1]):c;O(a);return[0,f,[1,[0,b[2]]]]});e(C,function(a){var
e=o(0,a);if(1-at(a))t(a,6);k(a,61);aK(a,1);var
g=m(d[13],0,a),h=i(f[3],a);k(a,78);var
b=i(f[1],a),c=N(0,a),j=c?c[1]:b[1];O(a);a1(a);return[0,n(e,j),[0,g,h,b]]});e(u,function(a){if(aH(Gi,a)){var
b=i(C,a);return[0,b[1],[7,b[2]]]}return i(d[2],a)});e(D,function(a){var
p=o(0,a);if(1-at(a))t(a,11);k(a,53);var
r=m(d[13],0,a),s=i(f[3],a),g=41===l(0,a)?1:0;if(g){k(a,41);var
b=0;for(;;){var
c=[0,i(f[5],a),b],e=l(0,a);if(typeof
e==="number")if(10===e){k(a,10);var
b=c;continue}var
h=q(c);break}}else
var
h=g;var
j=m(f[6],1,a);return[0,n(p,j[1]),[0,r,s,j,h,0]]});e(x,function(a){if(aH(Gj,a)){var
c=i(D,a);return[0,c[1],[20,c[2]]]}return i(b,a)});function
al(a,b){var
c=b;for(;;){var
d=[0,i(f[5],a),c],e=l(0,a);if(typeof
e==="number")if(10===e){k(a,10);var
c=d;continue}return q(d)}}e(z,function(a,b){var
c=bb(1,a);k(c,40);var
j=m(d[13],0,c),o=i(f[3],c),e=41===l(0,c)?1:0,p=e?(k(c,41),al(c,0)):e,g=ak(J(0,c),Gk),q=g?(aT(c,Gl),al(c,0)):g,h=m(f[6],1,c);return[0,n(b,h[1]),[0,j,o,h,p,q]]});e(ae,function(a,b){var
c=m(z,a,b);return[0,c[1],[23,c[2]]]});e(A,function(a,b){k(a,15);var
e=m(d[13],0,a),l=o(0,a),p=i(f[2],a),q=i(f[7],a);k(a,80);var
g=i(f[1],a),c=g[1],r=i(f[10],a),h=[0,n(l,c),[1,[0,q,g,p]]],s=[0,h[1],h],t=e[2],u=[0,n(e[1],c),t],j=N(0,a),v=j?j[1]:c;O(a);return[0,n(b,v),[0,u,s,r]]});e(E,function(a,b){var
c=m(A,a,b);return[0,c[1],[22,c[2]]]});e(F,function(a,b){k(a,24);var
c=w(d[15],a,Gm,28),e=c[2],f=N(0,a),g=f?f[1]:c[1],h=n(b,g);O(a);return[0,h,[0,e[1],e[2]]]});e(G,function(a,b){var
c=m(F,a,b);return[0,c[1],[21,c[2]]]});e(af,function(a,b){var
r=l(0,a);if(typeof
r==="number")var
s=0;else
if(1===r[0]){var
h=r[1],C=h[4],D=h[3],E=h[2],F=h[1];if(C)au(a,32);k(a,[1,[0,F,E,D,C]]);var
z=[1,[0,F,[0,[0,E],D]]],s=1;}else
var
s=0;if(!s)var
z=[0,m(d[13],0,a)];var
J=o(0,a);k(a,1);var
e=0,i=0;for(;;){var
j=l(0,a);if(typeof
j==="number"){var
L=2===j?1:I===j?1:0;if(L){var
G=q(i);k(a,2);var
A=[0,n(J,o(0,a)),[0,G]],B=n(b,A[1]),K=e?e[1]:[0,B];return[0,B,[24,[0,z,A,K]]]}}var
p=m(H,Gn,a),f=p[2],v=p[1];if(e)if(0===e[1][0])if(typeof
f==="number")var
c=0;else
switch(f[0]){case
25:t(a,60);var
g=e,c=1;break;case
26:var
w=f[1][2],M=w?3<w[1][0]?1:0:0;if(!M)t(a,61);var
g=e,c=1;break;default:var
c=0;}else
if(typeof
f==="number")var
c=0;else
if(25===f[0]){t(a,61);var
g=e,c=1;}else
var
c=0;else
if(typeof
f==="number")var
c=0;else
switch(f[0]){case
25:var
g=[0,[0,v]],c=1;break;case
26:var
x=f[1][2];if(x)if(3<x[1][0])var
y=e,u=1;else
var
u=0;else
var
u=0;if(!u)var
y=[0,[1,v]];var
g=y,c=1;break;default:var
c=0;}if(!c)var
g=e;var
e=g,i=[0,p,i];continue}});e(ag,function(a,b){k(a,11);aT(a,Go);var
c=i(f[8],a),d=N(0,a),e=d?d[1]:c[1];O(a);return[0,n(b,e),[25,c]]});e(H,function(a,b){var
f=a?a[1]:a;if(1-at(b))t(b,8);var
e=o(0,b),c=l(Gp,b);if(typeof
c==="number")if(24<=c){if(40<=c){if(!(64<=c))switch(c+fC|0){case
0:k(b,60);return m(ae,b,e);case
6:if(50===l(0,b))return i(h,b);break;case
9:if(f)return m(L,[0,f],b);break;case
13:k(b,60);return i(x,b);case
21:var
j=l(0,b);if(typeof
j==="number")if(50===j)if(f)return i(h,b);k(b,60);return i(u,b);case
23:k(b,60);t(b,49);k(b,63);return m(E,b,e)}}else
if(!(25<=c)){k(b,60);return m(G,b,e)}}else{if(15===c){k(b,60);return m(E,b,e)}if(0===c)if(ak(J(Gr,b),Gq)){k(b,60);aT(b,Gs);if(!f)if(11!==l(0,b))return m(af,b,e);return m(ag,b,e)}}if(f){var
g=l(0,b);if(typeof
g==="number")if(50===g){t(b,64);return i(d[2],b)}k(b,60);return m(G,b,e)}return i(d[2],b)});e(r,function(a){aT(a,Gt);var
c=l(0,a);if(typeof
c!=="number"&&1===c[0]){var
b=c[1],e=b[4],f=b[3],g=b[2],h=b[1];if(e)au(a,32);k(a,[1,[0,h,g,f,e]]);return[0,h,[0,[0,g],f]]}var
d=J(0,a),i=[0,o(0,a),[0,[0,d],d]];ab(a);return i});e(p,function(a){return a[2]});e(B,function(a,b,c){var
h=l(0,a);if(typeof
h==="number"){var
x=2===h?1:I===h?1:0;if(x){var
r=q(c);return[0,q(b),r]}}var
j=i(d[14],a),e=j[1];if(ak(J(0,a),Gu)){aT(a,Gv);var
f=i(d[14],a)[1],s=i(p,f);bG(a,[0,f[1],s]);var
g=[0,[0,f],0,f[1]];}else{var
o=e[1];bG(a,[0,o,i(p,e)]);var
g=[0,0,j[2],o];}var
m=g[2],t=n(e[1],g[3]),u=[0,t,[0,e,g[1]]];if(10===l(0,a))k(a,10);var
v=m?[0,m[1],c]:c;return w(B,a,[0,u,b],v)});e(ai,function(a,b){var
c=fc(1,bb(1,a)),e=o(0,c);k(c,49);var
j=l(0,c);if(typeof
j==="number"){if(53<=j){if(ah===j){var
aj=o(0,c);k(c,ah);var
al=c[23][4],T=ak(J(0,c),Gw),am=T?(aT(c,Gx),al?[0,m(d[13],0,c)]:(t(c,8),0)):T,U=i(r,c),V=N(0,c),an=[0,[1,aj,am]],ao=V?V[1]:U[1];O(c);return[0,n(e,ao),[27,[0,0,an,[0,U],1]]]}if(64<=j)var
f=0;else
switch(j+f$|0){case
0:if(1-at(c))t(c,10);var
z=i(x,c),F=z[2];if(typeof
F==="number")var
I=0;else
if(20===F[0]){var
av=i(p,F[1][1]);bG(c,[0,z[1],av]);var
I=1;}else
var
I=0;if(!I)ax(y(GA,Gz));return[0,n(e,z[1]),[27,[0,[0,z],0,0,0]]];case
8:if(1!==l(GB,c)){if(1-at(c))t(c,10);var
A=i(u,c),G=A[2];if(typeof
G==="number")var
L=0;else
if(7===G[0]){var
aw=i(p,G[1][1]);bG(c,[0,A[1],aw]);var
L=1;}else
var
L=0;if(!L)ax(y(GD,GC));return[0,n(e,A[1]),[27,[0,[0,A],0,0,0]]]}var
f=0;break;case
10:var
f=1;break;default:var
f=0;}}else{var
ac=j-14|0;if(26<ac>>>0)var
f=0;else
switch(ac){case
22:k(c,36);bG(c,[0,n(e,o(0,c)),GF]);var
ad=l(0,c);if(typeof
ad==="number")if(15===ad)var
ae=i(g[14],c),E=[0,ae[1],[0,ae]],Q=1;else
var
Q=0;else
var
Q=0;if(!Q)if(du(0,c))var
af=m(ap[3],c,b),E=[0,af[1],[0,af]];else{var
ag=i(d[9],c),ai=N(0,c),aC=ai?ai[1]:ag[1];O(c);var
E=[0,aC,[1,ag]];}var
aB=[28,[0,E[2],1]];return[0,n(e,E[1]),aB];case
0:case
1:case
10:case
13:case
14:case
26:var
f=1;break;default:var
f=0;}}if(f){var
C=m(d[3],[0,b],c),q=C[2],H=C[1];if(typeof
q==="number")var
h=0;else
switch(q[0]){case
17:var
$=q[1][1];if($)var
aa=$[1],h=2;else{s(c,[0,H,56]);var
D=0,h=1;}break;case
18:var
ay=q[1][1],aA=0,D=az(function(a,b){return az(P,a,[0,b[2][1],0])},aA,ay),h=1;break;case
19:var
ab=q[1][1];if(ab)var
aa=ab[1],h=2;else{s(c,[0,H,55]);var
D=0,h=1;}break;default:var
h=0;}switch(h){case
0:var
D=ax(GE),R=0;break;case
1:var
R=0;break;default:var
_=[0,[0,H,i(p,aa)],0],R=1;}if(!R)var
_=D;M(function(a){return bG(c,a)},_);return[0,n(e,C[1]),[27,[0,[0,C],0,0,1]]]}}var
W=l(0,c);if(typeof
W==="number")if(61===W){K(c);var
X=0,S=1;}else
var
S=0;else
var
S=0;if(!S)var
X=1;k(c,1);var
Y=w(B,c,0,0),aq=[0,[0,Y[1]]],ar=o(0,c);k(c,2);if(ak(J(0,c),Gy))var
v=[0,i(r,c)];else{var
au=Y[2];M(function(a){return s(c,a)},au);var
v=0;}var
Z=N(0,c),as=Z?Z[1]:v?v[1][1]:ar;O(c);return[0,n(e,as),[27,[0,0,aq,v,X]]]});e(L,function(a,b){var
H=a?a[1]:a;if(1-at(b))t(b,8);var
e=o(0,b);k(b,60);var
c=fc(1,bb(1,b));k(c,49);var
h=l(0,c);if(typeof
h==="number")if(54<=h){if(61===h){if(H){var
I=i(C,c),K=I[1],aa=n(e,K);return[0,aa,[26,[0,0,[0,[4,[0,K,I[2]]]],0,0]]]}}else
if(ah===h){var
af=o(0,c);k(c,ah);var
ag=c[23][4],Q=ak(J(0,c),GH),ai=Q?(aT(c,GI),ag?[0,m(d[13],0,c)]:(t(c,8),0)):Q,R=i(r,c),S=N(0,c),aj=[0,[1,af,ai]],al=S?S[1]:R[1];O(c);return[0,n(e,al),[26,[0,0,0,aj,[0,R]]]]}}else
if(41<=h){if(53<=h)if(H){var
T=i(D,c),U=T[1],am=n(e,U);return[0,am,[26,[0,0,[0,[5,[0,U,T[2]]]],0,0]]]}}else
if(15<=h)switch(h-15|0){case
21:k(c,36);var
E=l(0,c);if(typeof
E==="number")if(15===E)var
Y=m(A,c,e),u=[0,Y[1],[0,[1,Y]]],x=1;else
if(40===E)var
Z=m(z,c,e),u=[0,Z[1],[0,[2,Z]]],x=1;else
var
x=0;else
var
x=0;if(!x){var
_=i(f[1],c),$=N(0,c),ap=$?$[1]:_[1];O(c);var
u=[0,ap,[0,[3,_]]];}var
ao=[26,[0,1,u[2],0,0]];return[0,n(e,u[1]),ao];case
0:case
9:case
12:case
13:case
25:var
g=l(0,c);if(typeof
g==="number"){if(25<=g)if(29<=g)if(40===g)var
V=m(z,c,e),q=[0,V[1],[0,[2,V]]],j=2;else
var
j=0;else
var
j=27<=g?1:0;else
if(15===g)var
X=m(A,c,e),q=[0,X[1],[0,[1,X]]],j=2;else
var
j=24<=g?1:0;switch(j){case
0:var
G=0;break;case
1:var
aq=typeof
g==="number"?27===g?(t(c,51),1):28===g?(t(c,50),1):0:0,W=m(F,c,e),q=[0,W[1],[0,[0,W]]],G=1;break;default:var
G=1;}if(G){var
an=[26,[0,0,q[2],0,0]];return[0,n(e,q[1]),an]}}throw[0,v,GJ]}var
y=l(0,c),ar=typeof
y==="number"?53===y?(t(c,53),1):61===y?(t(c,52),1):0:0;k(c,1);var
L=w(B,c,0,0),ab=[0,[0,L[1]]],ac=o(0,c);k(c,2);if(ak(J(0,c),GG))var
p=[0,i(r,c)];else{var
ae=L[2];M(function(a){return s(c,a)},ae);var
p=0;}var
P=N(0,c),ad=P?P[1]:p?p[1][1]:ac;O(c);return[0,n(e,ad),[26,[0,0,0,ab,p]]]});function
am(a){aT(a,GK);var
c=l(0,a);if(typeof
c!=="number"&&1===c[0]){var
b=c[1],e=b[4],f=b[3],g=b[2],h=b[1];if(e)au(a,32);k(a,[1,[0,h,g,f,e]]);return[0,h,[0,[0,g],f]]}var
d=J(0,a),i=[0,o(0,a),[0,[0,d],d]];ab(a);return i}function
an(a,b){var
K=o(0,a),C=l(0,a);if(typeof
C==="number")if(ah===C){k(a,ah);aT(a,GT);var
D=m(d[13],0,a);return[0,[2,[0,n(K,D[1]),D]],0]}k(a,1);var
f=0,e=0;for(;;){var
E=f?f[1]:1,g=l(0,a);if(typeof
g==="number"){var
L=2===g?1:I===g?1:0;if(L){var
F=q(e);k(a,2);return F}}if(1-E)s(a,[0,o(0,a),66]);var
r=i(d[14],a),t=r[2],c=r[1],u=c[2],v=ak(u,GL)?GM:ak(u,GQ)?GR:GS,w=v[2],x=v[1];if(ak(J(0,a),GN)){var
G=m(d[13],0,a);if(x)if(aH(0,a))var
j=0;else{if(b)s(a,[0,c[1],65]);var
y=[0,[0,w,0,G]],j=1;}else
var
j=0;if(!j)var
y=[0,[0,0,[0,m(d[13],0,a)],c]];var
h=y;}else{if(x)if(aH(0,a)){if(b)s(a,[0,c[1],65]);var
z=i(d[14],a),A=z[2];if(A)s(a,A[1]);var
B=ak(J(0,a),GO),H=B?(aT(a,GP),[0,m(d[13],0,a)]):B,h=[0,[0,w,H,z[1]]],p=1;}else
var
p=0;else
var
p=0;if(!p){if(t)s(a,t[1]);var
h=[0,[0,0,0,c]];}}var
f=[0,ao(a,10)],e=[0,h,e];continue}}e(h,function(a){var
b=bb(1,a),q=o(0,b);k(b,50);var
r=l(0,b);if(typeof
r==="number")if(46===r){if(1-at(b))t(b,9);k(b,46);var
f=GU,i=1;}else
if(61===r){if(1-at(b))t(b,9);var
f=[0,0,[0,m(d[13],0,b)]],i=1;}else
var
i=0;else
var
i=0;if(!i)var
f=GW;var
y=f[2],c=f[1],z=2!==c?1:0,g=l(0,b),L=aH(0,b);if(typeof
g==="number")var
w=10===g?1:0;else
if(1===g[0]){if(2===c){var
h=g[1],G=h[4],H=h[3],I=h[2],v=h[1];if(G)au(b,32);k(b,[1,[0,v,I,H,G]]);var
K=N(0,b),U=[0,v,[0,[0,I],H]],V=K?K[1]:v;O(b);return[0,n(q,V),[29,[0,c,U,0]]]}var
w=0;}else
var
w=0;if(!w)if(0===L){var
M=an(b,z),A=am(b),B=N(0,b),P=B?B[1]:A[1];O(b);return[0,n(q,P),[29,[0,c,A,M]]]}var
s=l(0,b),Q=J(0,b);if(y)if(typeof
s==="number"){var
R=y[1];if(10===s)var
p=1;else
if(0===s)if(j(Q,GV))var
e=0,p=0;else
var
p=1;else
var
e=0,p=0;if(p)var
u=[0,2,[1,R]],e=1;}else
var
e=0;else
var
e=0;if(!e)var
u=[0,c,[1,m(d[13],0,b)]];var
C=l(0,b);if(typeof
C==="number")if(10===C){k(b,10);var
D=an(b,z),x=1;}else
var
x=0;else
var
x=0;if(!x)var
D=0;var
E=am(b),F=N(0,b),S=F?F[1]:E[1];O(b);var
T=[29,[0,u[1],E,[0,u[2],D]]];return[0,n(q,S),T]});return[0,T,U,_,Y,$,aa,ac,c,Q,R,H,L,S,a,ai,b,h,x,ad,V,W,X,u,Z]}}}}var
dy=cA([0,function(a,b){var
e=b[1],f=a[1],d=e[1],k=f[1];if(k)if(d){var
h=d[1],i=k[1],m=eS(h),j=eS(i)-m|0;if(0===j)var
n=eR(h),c=A(eR(i),n);else
var
c=j;}else
var
c=-1;else
var
c=d?1:0;if(0===c)var
l=eT(f[2],e[2]),g=0===l?eT(f[3],e[3]):l;else
var
g=c;return 0===g?bW(a[2],b[2]):g}]),a2=m(aD,GY,GX),bI=Eq(a2),cG=i(ER(a2),bI),a3=i(i(EW(a2),bI),cG),bJ=i(i(i(FY(a2),bI),cG),a3),c=i(i(i(Ga(a2),bI),cG),bJ),fn=i(F$(a2),bI),fo=[],dz=[],dA=[],fp=[],dB=[],dC=[],cH=[],cb=[],cI=[],fq=[],dD=[],fr=[],fs$$1=[],ft=[],GZ=FS(a2),fu=bJ[3],G0=a3[3],G1=a3[2],G2=a3[6],G3=bJ[2],G4=bJ[1],G5=bJ[4],G6=a3[1],G7=a3[5],G8=a3[4],G9=GZ[10],G_=fn[6],G$=fn[3];e(fo,function(a){var
b=m(fp,a,function(a){return 0}),d=o(0,a);k(a,I);if(b)var
e=bi(q(b))[1],c=n(bi(b)[1],e);else
var
c=d;return[0,c,b,q(a[2][1])]});e(dz,function(a,b,c){var
d=a,f=Hd;for(;;){var
g=f[2],e=f[1],h=l(0,d);if(typeof
h==="number")if(I===h)var
n=[0,d,e,g],p=1;else
var
p=0;else
var
p=0;if(!p)if(i(b,h))var
n=[0,d,e,g];else{var
A=l(0,d),B=[0,o(0,d),A],r=i(c,d),s=[0,r,g],j=r[2];if(typeof
j!=="number"&&1===j[0]){var
t=j[1][1],k=t[2];if(typeof
k==="number")var
z=0;else
if(18===k[0]){var
m=k[1][1];if(typeof
m!=="number"&&0===m[0]){var
u=t[1],v=d[6],C=u[3][2]-u[2][2]|0;if(v)var
w=v;else
var
x=ak(m[1],Hc),w=x?12===C?1:0:x;var
d=bb(w,d),f=[0,[0,B,e],s];continue}var
z=1;}else
var
z=0;}var
n=[0,d,e,s];}var
D=q(e);M(function(a){var
c=a[2];if(typeof
c!=="number"&&1===c[0]){var
f=c[1][4];return f?aS(d,[0,a[1],32]):f}if(typeof
c==="number"){var
e=c;if(59<=e)switch(e){case
59:var
b=up;break;case
60:var
b=uq;break;case
61:var
b=ur;break;case
62:var
b=us;break;case
63:var
b=ut;break;case
64:var
b=uu;break;case
65:var
b=uv;break;case
66:var
b=uw;break;case
67:var
b=ux;break;case
68:var
b=uy;break;case
69:var
b=uz;break;case
70:var
b=uA;break;case
71:var
b=uB;break;case
72:var
b=uC;break;case
73:var
b=uD;break;case
74:var
b=uE;break;case
75:var
b=uF;break;case
76:var
b=uG;break;case
77:var
b=uH;break;case
78:var
b=uI;break;case
79:var
b=uJ;break;case
80:var
b=uK;break;case
81:var
b=uL;break;case
82:var
b=uM;break;case
83:var
b=uN;break;case
84:var
b=uO;break;case
85:var
b=uP;break;case
86:var
b=uQ;break;case
87:var
b=uR;break;case
88:var
b=uS;break;case
89:var
b=uT;break;case
90:var
b=uU;break;case
91:var
b=uV;break;case
92:var
b=uW;break;case
93:var
b=uX;break;case
94:var
b=uY;break;case
95:var
b=uZ;break;case
96:var
b=u0;break;case
97:var
b=u1;break;case
98:var
b=u2;break;case
99:var
b=u3;break;case
100:var
b=u4;break;case
101:var
b=u5;break;case
102:var
b=u6;break;case
103:var
b=u7;break;case
104:var
b=u8;break;case
105:var
b=u9;break;case
106:var
b=u_;break;case
107:var
b=u$;break;case
108:var
b=va;break;case
109:var
b=vb;break;case
110:var
b=vc;break;case
111:var
b=vd;break;case
112:var
b=ve;break;case
113:var
b=vf;break;case
114:var
b=vg;break;case
115:var
b=vh;break;default:var
b=vi;}else
switch(e){case
0:var
b=tu;break;case
1:var
b=tv;break;case
2:var
b=tw;break;case
3:var
b=tx;break;case
4:var
b=ty;break;case
5:var
b=tz;break;case
6:var
b=tA;break;case
7:var
b=tB;break;case
8:var
b=tC;break;case
9:var
b=tD;break;case
10:var
b=tE;break;case
11:var
b=tF;break;case
12:var
b=tG;break;case
13:var
b=tH;break;case
14:var
b=tI;break;case
15:var
b=tJ;break;case
16:var
b=tK;break;case
17:var
b=tL;break;case
18:var
b=tM;break;case
19:var
b=tN;break;case
20:var
b=tO;break;case
21:var
b=tP;break;case
22:var
b=tQ;break;case
23:var
b=tR;break;case
24:var
b=tS;break;case
25:var
b=tT;break;case
26:var
b=tU;break;case
27:var
b=tV;break;case
28:var
b=tW;break;case
29:var
b=tX;break;case
30:var
b=tY;break;case
31:var
b=tZ;break;case
32:var
b=t0;break;case
33:var
b=t1;break;case
34:var
b=t2;break;case
35:var
b=t3;break;case
36:var
b=t4;break;case
37:var
b=t5;break;case
38:var
b=t6;break;case
39:var
b=t7;break;case
40:var
b=t8;break;case
41:var
b=t9;break;case
42:var
b=t_;break;case
43:var
b=t$;break;case
44:var
b=ua;break;case
45:var
b=ub;break;case
46:var
b=uc;break;case
47:var
b=ud;break;case
48:var
b=ue;break;case
49:var
b=uf;break;case
50:var
b=ug;break;case
51:var
b=uh;break;case
52:var
b=ui;break;case
53:var
b=uj;break;case
54:var
b=uk;break;case
55:var
b=ul;break;case
56:var
b=um;break;case
57:var
b=un;break;default:var
b=uo;}}else
switch(c[0]){case
0:var
b=vj;break;case
1:var
b=vk;break;case
2:var
b=vl;break;case
3:var
b=vm;break;case
4:var
b=vn;break;default:var
b=vo;}return ax(y(Hb,y(b,Ha)))},D);return[0,d,n[3]]}});e(dA,function(a){var
b=i(bJ[5],a),d=l(0,a);if(typeof
d==="number"){var
e=d-49|0;if(!(11<e>>>0))switch(e){case
0:return m(c[15],a,b);case
1:i(dv(a),b);return i(c[17],a);case
11:if(49===l(He,a)){i(dv(a),b);return m(c[12],0,a)}break}}return m(cb,[0,b],a)});e(fp,function(a,b){var
c=w(dz,a,b,dA),d=m(dB,b,c[1]),e=c[2];return az(function(a,b){return[0,b,a]},d,e)});e(dB,function(a,b){var
c=0;for(;;){var
d=l(0,b);if(typeof
d==="number")if(I===d)return q(c);if(i(a,d))return q(c);var
c=[0,i(dA,b),c];continue}});e(dC,function(a,b){var
c=w(dz,b,a,function(a){return m(cb,0,a)}),d=c[1],e=m(cH,a,d),f=c[2],g=az(function(a,b){return[0,b,a]},e,f);return[0,g,d[6]]});e(cH,function(a,b){var
c=0;for(;;){var
d=l(0,b);if(typeof
d==="number")if(I===d)return q(c);if(i(a,d))return q(c);var
c=[0,m(cb,0,b),c];continue}});e(cb,function(a,b){var
e=a?a[1]:a;if(1-du(0,b))i(dv(b),e);var
d=l(0,b);if(typeof
d==="number"){if(27===d)return i(c[24],b);if(28===d)return i(c[3],b)}if(cF(0,b))return i(cG[14],b);if(du(0,b))return m(fu,b,e);if(typeof
d==="number"){var
f=d+f$|0;if(!(8<f>>>0))switch(f){case
0:return i(c[18],b);case
7:return m(c[11],0,b);case
8:return i(c[23],b)}}return i(cI,b)});e(cI,function(a){var
b=l(0,a);if(typeof
b==="number"){if(I===b){ab(a);return[0,o(0,a),0]}if(!(60<=b))switch(b){case
1:return i(c[7],a);case
9:return i(c[14],a);case
16:return i(c[2],a);case
19:return i(c[20],a);case
20:return i(c[21],a);case
22:return i(c[22],a);case
23:return i(c[4],a);case
24:return i(c[24],a);case
25:return i(c[5],a);case
26:return i(c[6],a);case
32:return i(c[8],a);case
35:return i(c[9],a);case
37:return i(c[13],a);case
39:return i(c[1],a);case
59:return i(c[10],a)}}if(aH(0,a))return i(c[19],a);if(typeof
b==="number"){if(33<=b)if(51<=b)var
d=80===b?1:0;else
if(40<=b)switch(b+fC|0){case
3:return i(c[2],a);case
1:case
2:case
9:case
10:var
d=1;break;default:var
d=0;}else
var
d=1;else
if(21<=b)var
d=0;else
switch(b){case
0:case
1:case
3:case
4:case
5:case
7:case
14:case
15:case
16:var
d=0;break;default:var
d=1;}if(d){ab(a);K(a);return i(cI,a)}}return i(c[16],a)});e(fq,function(a){var
b=i(a3[2],a),c=l(0,a);if(typeof
c==="number")if(10===c)return m(a3[8],a,[0,b,0]);return b});e(dD,function(a,b){var
f=o(0,b),d=J(0,b),c=l(0,b);if(typeof
c==="number")if(28===c){if(b[6])au(b,40);else
if(b[13])t(b,[1,d]);K(b);var
e=1;}else
var
e=0;else
var
e=0;if(!e)if(b_(d)){au(b,40);K(b);}else{var
g=typeof
c==="number"?4<(c-60|0)>>>0?0:(k(b,c),1):0;if(!g)k(b,0);}var
h=a?bn(d)?(aS(b,[0,f,a[1]]),1):0:0;return[0,f,d]});e(fr,function(a,b,c){var
h=b?b[1]:b;return bo(function(a){var
b=1-h,f=m(dD,[0,c],a),d=b?79===l(0,a)?1:0:b;if(d){if(1-at(a))t(a,7);k(a,79);}var
e=80===l(0,a)?1:0,g=e?[0,i(bI[8],a)]:e;return[0,f,g,d]},a)});e(fs$$1,function(a){var
b=o(0,a);k(a,1);var
c=m(cH,function(a){return 2===a?1:0},a),d=o(0,a);k(a,2);return[0,n(b,d),[0,c]]});e(ft,function(a){var
c=o(0,a);k(a,1);var
b=m(dC,function(a){return 2===a?1:0},a),d=o(0,a);k(a,2);var
e=b[2],f=[0,b[1]];return[0,n(c,d),f,e]});w(aE,Hf,a2,[0,fo,cI,cb,cH,dC,dB,fq,G0,G1,G2,G3,G6,dD,G8,fr,fs$$1,ft,G9,G_,G$,G4,fu,G5,G7]);var
cJ=[0,0];function
Hg(a,b,c,d){var
r=a?a[1]:1,L=b?b[1]:b,M=c?c[1]:c,h=[0,M],j=[0,L],s=0,K=j?j[1]:j,o=h?h[1]:h,p=[0,o],g=[0,K],E=g?g[1]:g,l=p?o:p,u=[0],v=1,w=0,y=0,z=0,A=0,B=0,C=x(d),t=ep(d),D=[0,function(a){a[9]=1;return 0},t,C,B,A,z,y,w,v,u,eu,eu],e=l?l[1]:ds,k=[0,s,D,0,e[5],dp],F=[0,b5(k,0)],n=[0,[0,0],[0,0],bF[1],[0,bF[1]],[0,0],e[6],0,0,0,0,0,0,0,0,0,1,0,0,[0,D8],[0,k],F,[0,E],e,s],I=i(a2[1],n),G=q(n[1][1]),H=[0,dy[1],0],f=q(az(function(a,b){var
d=a[2],c=a[1];return m(dy[3],b,c)?[0,c,d]:[0,m(dy[4],b,c),[0,b,d]]},H,G)[2]),J=r?0!==f?1:0:r;if(J)throw[0,eU,f];return[0,I,f]}var
Hh=H0,Hj=H1,Hi=HZ,Hk=HY;function
Hl(a){return a}function
Hm(a,b,c){try{var
e=new
RegExp(b.toString(),c.toString()),d=e;}catch(f){cJ[1]=[0,[0,a,13],cJ[1]];var
d=new
RegExp(u,c.toString());}return d}function
Hn(a){var
b=new
Function(c3,"throw e;");return b.call(b,a)}function
Ho(a){var
f=a.esproposal_decorators;if(b4(f)){var
g=ds.slice();g[3]=f|0;var
b=g;}else
var
b=ds;var
h=a.esproposal_class_instance_fields;if(b4(h)){var
i=b.slice();i[1]=h|0;var
c=i;}else
var
c=b;var
j=a.esproposal_class_static_fields;if(b4(j)){var
k=c.slice();k[2]=j|0;var
d=k;}else
var
d=c;var
l=a.esproposal_export_star_as;if(b4(l)){var
m=d.slice();m[4]=l|0;var
e=m;}else
var
e=d;var
n=a.types;if(b4(n)){var
o=e.slice();o[5]=n|0;return o}return e}function
Hp(a,b){var
h=hc(b,eO)?{}:b,j=cr(a),k=[0,Ho(h)];try{var
e=Hg(Hr,0,[0,k],j);cJ[1]=0;var
f=lo([0,Hh,Hi,Hj,Hk,Hl,jv,Hm]),g=i(f[1],e[1]),l=cv(e[2],cJ[1]);g.errors=i(f[3],l);return g}catch(f){f=al(f);if(f[1]===eU){var
c=new
Error(y(d(u+de(f[2])),Hq).toString());c.name="Parse Error";Hn(c);return{}}throw f}}var fv;

var
fv=exports;fv.parse=Hp;hz(0);return}(function(){return this}()));
});

var index$42 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* eslint max-len: 0 */

// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function makePredicate(words) {
  words = words.split(" ");
  return function (str) {
    return words.indexOf(str) >= 0;
  };
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  6: makePredicate("enum await"),
  strict: makePredicate("implements interface let package private protected public static yield"),
  strictBind: makePredicate("eval arguments")
};

// And the keywords

var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `bin/generate-identifier-regex.js`.
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

// A second optional argument can be given to further configure
var defaultOptions = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var key in defaultOptions) {
    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
  }
  return options;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

var KeywordTokenType = function (_TokenType) {
  inherits(KeywordTokenType, _TokenType);

  function KeywordTokenType(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, KeywordTokenType);

    options.keyword = name;

    return possibleConstructorReturn(this, _TokenType.call(this, name, options));
  }

  return KeywordTokenType;
}(TokenType);

var BinopTokenType = function (_TokenType2) {
  inherits(BinopTokenType, _TokenType2);

  function BinopTokenType(name, prec) {
    classCallCheck(this, BinopTokenType);
    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));
  }

  return BinopTokenType;
}(TokenType);

var types = {
  num: new TokenType("num", { startsExpr: startsExpr }),
  regexp: new TokenType("regexp", { startsExpr: startsExpr }),
  string: new TokenType("string", { startsExpr: startsExpr }),
  name: new TokenType("name", { startsExpr: startsExpr }),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceBarL: new TokenType("{|", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", { beforeExpr: beforeExpr }),
  semi: new TokenType(";", { beforeExpr: beforeExpr }),
  colon: new TokenType(":", { beforeExpr: beforeExpr }),
  doubleColon: new TokenType("::", { beforeExpr: beforeExpr }),
  dot: new TokenType("."),
  question: new TokenType("?", { beforeExpr: beforeExpr }),
  arrow: new TokenType("=>", { beforeExpr: beforeExpr }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", { beforeExpr: beforeExpr }),
  backQuote: new TokenType("`", { startsExpr: startsExpr }),
  dollarBraceL: new TokenType("${", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  at: new TokenType("@"),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  assign: new TokenType("_=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  incDec: new TokenType("++/--", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),
  prefix: new TokenType("prefix", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  logicalOR: new BinopTokenType("||", 1),
  logicalAND: new BinopTokenType("&&", 2),
  bitwiseOR: new BinopTokenType("|", 3),
  bitwiseXOR: new BinopTokenType("^", 4),
  bitwiseAND: new BinopTokenType("&", 5),
  equality: new BinopTokenType("==/!=", 6),
  relational: new BinopTokenType("</>", 7),
  bitShift: new BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),
  modulo: new BinopTokenType("%", 10),
  star: new BinopTokenType("*", 10),
  slash: new BinopTokenType("/", 10),
  exponent: new TokenType("**", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })
};

var keywords = {
  "break": new KeywordTokenType("break"),
  "case": new KeywordTokenType("case", { beforeExpr: beforeExpr }),
  "catch": new KeywordTokenType("catch"),
  "continue": new KeywordTokenType("continue"),
  "debugger": new KeywordTokenType("debugger"),
  "default": new KeywordTokenType("default", { beforeExpr: beforeExpr }),
  "do": new KeywordTokenType("do", { isLoop: isLoop, beforeExpr: beforeExpr }),
  "else": new KeywordTokenType("else", { beforeExpr: beforeExpr }),
  "finally": new KeywordTokenType("finally"),
  "for": new KeywordTokenType("for", { isLoop: isLoop }),
  "function": new KeywordTokenType("function", { startsExpr: startsExpr }),
  "if": new KeywordTokenType("if"),
  "return": new KeywordTokenType("return", { beforeExpr: beforeExpr }),
  "switch": new KeywordTokenType("switch"),
  "throw": new KeywordTokenType("throw", { beforeExpr: beforeExpr }),
  "try": new KeywordTokenType("try"),
  "var": new KeywordTokenType("var"),
  "let": new KeywordTokenType("let"),
  "const": new KeywordTokenType("const"),
  "while": new KeywordTokenType("while", { isLoop: isLoop }),
  "with": new KeywordTokenType("with"),
  "new": new KeywordTokenType("new", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "this": new KeywordTokenType("this", { startsExpr: startsExpr }),
  "super": new KeywordTokenType("super", { startsExpr: startsExpr }),
  "class": new KeywordTokenType("class"),
  "extends": new KeywordTokenType("extends", { beforeExpr: beforeExpr }),
  "export": new KeywordTokenType("export"),
  "import": new KeywordTokenType("import"),
  "yield": new KeywordTokenType("yield", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "null": new KeywordTokenType("null", { startsExpr: startsExpr }),
  "true": new KeywordTokenType("true", { startsExpr: startsExpr }),
  "false": new KeywordTokenType("false", { startsExpr: startsExpr }),
  "in": new KeywordTokenType("in", { beforeExpr: beforeExpr, binop: 7 }),
  "instanceof": new KeywordTokenType("instanceof", { beforeExpr: beforeExpr, binop: 7 }),
  "typeof": new KeywordTokenType("typeof", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "void": new KeywordTokenType("void", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "delete": new KeywordTokenType("delete", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })
};

// Map keyword names to token types.
Object.keys(keywords).forEach(function (name) {
  types["_" + name] = keywords[name];
});

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", true),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true)
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();
  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === types$1.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};

types.name.updateContext = function (prevType) {
  this.state.exprAllowed = false;

  if (prevType === types._let || prevType === types._const || prevType === types._var) {
    if (lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = function () {
  if (this.curContext() !== types$1.braceStatement) {
    this.state.context.push(types$1.functionExpression);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }
  this.state.exprAllowed = false;
};

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

var State = function () {
  function State() {
    classCallCheck(this, State);
  }

  State.prototype.init = function init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";

    this.input = input;

    this.potentialArrowAt = -1;

    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.noAnonFunctionType = false;

    this.labels = [];

    this.decorators = [];

    this.tokens = [];

    this.comments = [];

    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];

    this.pos = this.lineStart = 0;
    this.curLine = 1;

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = [types$1.braceStatement];
    this.exprAllowed = true;

    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;

    this.exportedIdentifiers = [];

    return this;
  };

  // TODO


  // TODO


  // Used to signify the start of a potential arrow function


  // Flags to track whether we are in a function, a generator.


  // Labels in scope.


  // Leading decorators.


  // Token store.


  // Comment store.


  // Comment attachment store


  // The current position of the tokenizer in the input.


  // Properties of the current token:
  // Its type


  // For tokens that include more information than their type, the value


  // Its start and end offset


  // And, if locations are used, the {line, column} object
  // corresponding to those offsets


  // Position information for the previous token


  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.


  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.


  // TODO


  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.


  State.prototype.curPosition = function curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  };

  State.prototype.clone = function clone(skipArrays) {
    var state = new State();
    for (var key in this) {
      var val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }
    return state;
  };

  return State;
}();

/* eslint indent: 0 */

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(state) {
  classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

// ## Tokenizer

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  } else {
    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
  }
}

var Tokenizer = function () {
  function Tokenizer(options, input) {
    classCallCheck(this, Tokenizer);

    this.state = new State();
    this.state.init(options, input);
  }

  // Move to the next token

  Tokenizer.prototype.next = function next() {
    if (!this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  };

  // TODO

  Tokenizer.prototype.eat = function eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // TODO

  Tokenizer.prototype.match = function match(type) {
    return this.state.type === type;
  };

  // TODO

  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {
    return isKeyword(word);
  };

  // TODO

  Tokenizer.prototype.lookahead = function lookahead() {
    var old = this.state;
    this.state = old.clone(true);

    this.isLookahead = true;
    this.next();
    this.isLookahead = false;

    var curr = this.state.clone(true);
    this.state = old;
    return curr;
  };

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  Tokenizer.prototype.setStrict = function setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  };

  Tokenizer.prototype.curContext = function curContext() {
    return this.state.context[this.state.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  Tokenizer.prototype.nextToken = function nextToken() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();

    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);

    if (curContext.override) {
      return curContext.override(this);
    } else {
      return this.readToken(this.fullCharCodeAtPos());
    }
  };

  Tokenizer.prototype.readToken = function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) {
        return this.readWord();
      } else {
      return this.getTokenFromCode(code);
    }
  };

  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
    var code = this.input.charCodeAt(this.state.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;

    var next = this.input.charCodeAt(this.state.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };

  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  };

  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
    var startLoc = this.state.curPosition();
    var start = this.state.pos;
    var end = this.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");

    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    var match = void 0;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  };

  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
    var start = this.state.pos;
    var startLoc = this.state.curPosition();
    var ch = this.input.charCodeAt(this.state.pos += startSkip);
    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++this.state.pos;
      ch = this.input.charCodeAt(this.state.pos);
    }

    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  Tokenizer.prototype.skipSpace = function skipSpace() {
    loop: while (this.state.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 32:case 160:
          // ' '
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:case 8232:case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          // '/'
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  Tokenizer.prototype.finishToken = function finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    var prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //


  Tokenizer.prototype.readToken_dot = function readToken_dot() {
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }

    var next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.state.pos += 3;
      return this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      return this.finishToken(types.dot);
    }
  };

  Tokenizer.prototype.readToken_slash = function readToken_slash() {
    // '/'
    if (this.state.exprAllowed) {
      ++this.state.pos;
      return this.readRegexp();
    }

    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.slash, 1);
    }
  };

  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
    // '%*'
    var type = code === 42 ? types.star : types.modulo;
    var width = 1;
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 42) {
      // '*'
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61) {
      width++;
      type = types.assign;
    }

    return this.finishOp(type, width);
  };

  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
    // '|&'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    if (next === 61) return this.finishOp(types.assign, 2);
    if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(types.braceBarR, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  };

  Tokenizer.prototype.readToken_caret = function readToken_caret() {
    // '^'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.bitwiseXOR, 1);
    }
  };

  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
    // '+-'
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types.incDec, 2);
    }

    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.plusMin, 1);
    }
  };

  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
    // '<>'
    var next = this.input.charCodeAt(this.state.pos + 1);
    var size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);
      return this.finishOp(types.bitShift, size);
    }

    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      if (this.inModule) this.unexpected();
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }

    if (next === 61) {
      // <= | >=
      size = 2;
    }

    return this.finishOp(types.relational, size);
  };

  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
    // '=!'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62) {
      // '=>'
      this.state.pos += 2;
      return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
  };

  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.state.pos;return this.finishToken(types.parenL);
      case 41:
        ++this.state.pos;return this.finishToken(types.parenR);
      case 59:
        ++this.state.pos;return this.finishToken(types.semi);
      case 44:
        ++this.state.pos;return this.finishToken(types.comma);
      case 91:
        ++this.state.pos;return this.finishToken(types.bracketL);
      case 93:
        ++this.state.pos;return this.finishToken(types.bracketR);

      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.braceL);
        }

      case 125:
        ++this.state.pos;return this.finishToken(types.braceR);

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.colon);
        }

      case 63:
        ++this.state.pos;return this.finishToken(types.question);
      case 64:
        ++this.state.pos;return this.finishToken(types.at);

      case 96:
        // '`'
        ++this.state.pos;
        return this.finishToken(types.backQuote);

      case 48:
        // '0'
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();

      case 37:case 42:
        // '%*'
        return this.readToken_mult_modulo(code);

      case 124:case 38:
        // '|&'
        return this.readToken_pipe_amp(code);

      case 94:
        // '^'
        return this.readToken_caret();

      case 43:case 45:
        // '+-'
        return this.readToken_plus_min(code);

      case 60:case 62:
        // '<>'
        return this.readToken_lt_gt(code);

      case 61:case 33:
        // '=!'
        return this.readToken_eq_excl(code);

      case 126:
        // '~'
        return this.finishOp(types.prefix, 1);
    }

    this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  Tokenizer.prototype.finishOp = function finishOp(type, size) {
    var str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    return this.finishToken(type, str);
  };

  Tokenizer.prototype.readRegexp = function readRegexp() {
    var start = this.state.pos;
    var escaped = void 0,
        inClass = void 0;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.state.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    var content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = this.readWord1();
    if (mods) {
      var validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    }
    return this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  Tokenizer.prototype.readInt = function readInt(radix, len) {
    var start = this.state.pos;
    var total = 0;

    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.state.pos);
      var val = void 0;
      if (code >= 97) {
        val = code - 97 + 10; // a
      } else if (code >= 65) {
        val = code - 65 + 10; // A
      } else if (code >= 48 && code <= 57) {
        val = code - 48; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;

    return total;
  };

  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
    this.state.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
    var start = this.state.pos;
    var octal = this.input.charCodeAt(this.state.pos) === 48;
    var isFloat = false;

    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.state.pos);
    if (next === 46) {
      // '.'
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (next === 69 || next === 101) {
      // 'eE'
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) ++this.state.pos; // '+-'
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");

    var str = this.input.slice(start, this.state.pos);
    var val = void 0;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!octal || str.length === 1) {
      val = parseInt(str, 10);
    } else if (/[89]/.test(str) || this.state.strict) {
      this.raise(start, "Invalid number");
    } else {
      val = parseInt(str, 8);
    }
    return this.finishToken(types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  Tokenizer.prototype.readCodePoint = function readCodePoint() {
    var ch = this.input.charCodeAt(this.state.pos);
    var code = void 0;

    if (ch === 123) {
      var codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos);
      ++this.state.pos;
      if (code > 0x10FFFF) this.raise(codePos, "Code point out of bounds");
    } else {
      code = this.readHexChar(4);
    }
    return code;
  };

  Tokenizer.prototype.readString = function readString(quote) {
    var out = "",
        chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else {
        if (isNewLine(ch)) this.raise(this.state.start, "Unterminated string constant");
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  };

  // Reads template string tokens.

  Tokenizer.prototype.readTmplToken = function readTmplToken() {
    var out = "",
        chunkStart = this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        // '`', '${'
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            return this.finishToken(types.dollarBraceL);
          } else {
            ++this.state.pos;
            return this.finishToken(types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.template, out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(true);
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  };

  // Used to read escaped characters

  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
    var ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        return String.fromCharCode(this.readHexChar(2)); // 'x'
      case 117:
        return codePointToString(this.readCodePoint()); // 'u'
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\x0B"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n'
      case 10:
        // ' \n'
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (!this.state.containsOctal) {
              this.state.containsOctal = true;
              this.state.octalPosition = this.state.pos - 2;
            }
            if (this.state.strict || inTemplate) {
              this.raise(this.state.pos - 2, "Octal literal in strict mode");
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u', '\U').

  Tokenizer.prototype.readHexChar = function readHexChar(len) {
    var codePos = this.state.pos;
    var n = this.readInt(16, len);
    if (n === null) this.raise(codePos, "Bad character escape sequence");
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  Tokenizer.prototype.readWord1 = function readWord1() {
    this.state.containsEsc = false;
    var word = "",
        first = true,
        chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.state.containsEsc = true;

        word += this.input.slice(chunkStart, this.state.pos);
        var escStart = this.state.pos;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          // "u"
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        var esc = this.readCodePoint();
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += codePointToString(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  Tokenizer.prototype.readWord = function readWord() {
    var word = this.readWord1();
    var type = types.name;
    if (!this.state.containsEsc && this.isKeyword(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word);
  };

  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
    if (prevType === types.colon) {
      var parent = this.curContext();
      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
        return !parent.isExpr;
      }
    }

    if (prevType === types._return) {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
      return true;
    }

    if (prevType === types.braceL) {
      return this.curContext() === types$1.braceStatement;
    }

    return !this.state.exprAllowed;
  };

  Tokenizer.prototype.updateContext = function updateContext(prevType) {
    var type = this.state.type;
    var update = void 0;

    if (type.keyword && prevType === types.dot) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  };

  return Tokenizer;
}();

var plugins = {};
var frozenDeprecatedWildcardPluginList = ["jsx", "doExpressions", "objectRestSpread", "decorators", "classProperties", "exportExtensions", "asyncGenerators", "functionBind", "functionSent", "dynamicImport", "flow"];

var Parser = function (_Tokenizer) {
  inherits(Parser, _Tokenizer);

  function Parser(options, input) {
    classCallCheck(this, Parser);

    options = getOptions(options);

    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));

    _this.options = options;
    _this.inModule = _this.options.sourceType === "module";
    _this.input = input;
    _this.plugins = _this.loadPlugins(_this.options.plugins);
    _this.filename = options.sourceFilename;

    // If enabled, skip leading hashbang line.
    if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
      _this.skipLineComment(2);
    }
    return _this;
  }

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    if (word === "await") {
      return this.inModule;
    } else {
      return reservedWords[6](word);
    }
  };

  Parser.prototype.hasPlugin = function hasPlugin(name) {
    if (this.plugins["*"] && frozenDeprecatedWildcardPluginList.indexOf(name) > -1) {
      return true;
    }

    return !!this.plugins[name];
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadAllPlugins = function loadAllPlugins() {
    var _this2 = this;

    // ensure flow plugin loads last
    var pluginNames = Object.keys(plugins).filter(function (name) {
      return name !== "flow";
    });
    pluginNames.push("flow");

    pluginNames.forEach(function (name) {
      var plugin = plugins[name];
      if (plugin) plugin(_this2);
    });
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {
    // TODO: Deprecate "*" option in next major version of Babylon
    if (pluginList.indexOf("*") >= 0) {
      this.loadAllPlugins();

      return { "*": true };
    }

    var pluginMap = {};

    if (pluginList.indexOf("flow") >= 0) {
      // ensure flow plugin loads last
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "flow";
      });
      pluginList.push("flow");
    }

    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var name = _ref;

      if (!pluginMap[name]) {
        pluginMap[name] = true;

        var plugin = plugins[name];
        if (plugin) plugin(this);
      }
    }

    return pluginMap;
  };

  Parser.prototype.parse = function parse() {
    var file = this.startNode();
    var program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  };

  return Parser;
}(Tokenizer);

var pp = Parser.prototype;

// ## Parser utilities

// TODO

pp.addExtra = function (node, key, val) {
  if (!node) return;

  var extra = node.extra = node.extra || {};
  extra[key] = val;
};

// TODO

pp.isRelational = function (op) {
  return this.match(types.relational) && this.state.value === op;
};

// TODO

pp.expectRelational = function (op) {
  if (this.isRelational(op)) {
    this.next();
  } else {
    this.unexpected(null, types.relational);
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.match(types.name) && this.state.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.state.value === name && this.eat(types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name, message) {
  if (!this.eatContextual(name)) this.unexpected(null, message);
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
};

// TODO

pp.isLineTerminator = function () {
  return this.eat(types.semi) || this.canInsertSemicolon();
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.isLineTerminator()) this.unexpected(null, types.semi);
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.

pp.expect = function (type, pos) {
  return this.eat(type) || this.unexpected(pos, type);
};

// Raise an unexpected token error. Can take the expected token type
// instead of a message string.

pp.unexpected = function (pos) {
  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

  if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) {
    messageOrType = "Unexpected token, expected " + messageOrType.label;
  }
  this.raise(pos != null ? pos : this.state.start, messageOrType);
};

/* eslint indent: 0 */
/* eslint max-len: 0 */

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, types.eof);

  file.program = this.finishNode(program, "Program");
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, "File");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

// TODO

pp$1.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, "raw", raw);
  this.addExtra(directiveLiteral, "rawValue", val);

  directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);

  return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function (declaration, topLevel) {
  if (this.match(types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type;
  var node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case types._break:case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types._debugger:
      return this.parseDebuggerStatement(node);
    case types._do:
      return this.parseDoStatement(node);
    case types._for:
      return this.parseForStatement(node);
    case types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case types._class:
      if (!declaration) this.unexpected();
      this.takeDecorators(node);
      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);
    case types._return:
      return this.parseReturnStatement(node);
    case types._switch:
      return this.parseSwitchStatement(node);
    case types._throw:
      return this.parseThrowStatement(node);
    case types._try:
      return this.parseTryStatement(node);

    case types._let:
    case types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case types._var:
      return this.parseVarStatement(node, starttype);

    case types._while:
      return this.parseWhileStatement(node);
    case types._with:
      return this.parseWithStatement(node);
    case types.braceL:
      return this.parseBlock();
    case types.semi:
      return this.parseEmptyStatement(node);
    case types._export:
    case types._import:
      if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL) break;

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);

    case types.name:
      if (this.state.value === "async") {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(types._function) && !this.canInsertSemicolon()) {
          this.expect(types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

pp$1.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

pp$1.parseDecorators = function (allowExport) {
  while (this.match(types.at)) {
    var decorator = this.parseDecorator();
    this.state.decorators.push(decorator);
  }

  if (allowExport && this.match(types._export)) {
    return;
  }

  if (!this.match(types._class)) {
    this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
  }
};

pp$1.parseDecorator = function () {
  if (!this.hasPlugin("decorators")) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, "Decorator");
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i < this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  this.eat(types.semi);
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);

  var forAwait = false;
  if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
    forAwait = true;
    this.next();
  }
  this.expect(types.parenL);

  if (this.match(types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
    var _init = this.startNode();
    var varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");

    if (this.match(types._in) || this.isContextual("of")) {
      if (_init.declarations.length === 1 && !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(types._in) || this.isContextual("of")) {
    var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
    this.toAssignable(init, undefined, description);
    this.checkLVal(init, undefined, undefined, description);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, "'return' outside of function");
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.state.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(types.braceR);) {
    if (this.match(types._case) || this.match(types._default)) {
      var isCase = this.match(types._case);
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null), "catch clause");
    this.expect(types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.guardedHandlers = empty;
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
  for (var i = this.state.labels.length - 1; i >= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(types.braceL);
  this.parseBlockBody(node, allowDirectives, false, types.braceR);
  return this.finishNode(node, "BlockStatement");
};

// TODO

pp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives && !parsedNonDirective && stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined && directive.value.value === "use strict") {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, "Octal literal in strict mode");
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.match(types.semi) ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.match(types.parenR) ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function (node, init, forAwait) {
  var type = void 0;
  if (forAwait) {
    this.eatContextual("of");
    type = "ForAwaitStatement";
  } else {
    type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";
    this.next();
  }
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp$1.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
      this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) break;
  }
  return node;
};

pp$1.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true, undefined, "variable declaration");
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(types.star)) {
    if (node.async && !this.hasPlugin("asyncGenerators")) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
    this.unexpected();
  }

  if (this.match(types.name) || this.match(types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.isClassProperty = function () {
  return this.match(types.eq) || this.isLineTerminator();
};

pp$1.isClassMutatorStarter = function () {
  return false;
};

pp$1.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructorCall = false;
  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (this.eat(types.semi)) {
      continue;
    }

    if (this.match(types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    var isConstructorCall = false;
    var isMaybeStatic = this.match(types.name) && this.state.value === "static";
    var isGenerator = this.eat(types.star);
    var isGetSet = false;
    var isAsync = false;

    this.parsePropertyName(method);

    method.static = isMaybeStatic && !this.match(types.parenL);
    if (method.static) {
      isGenerator = this.eat(types.star);
      this.parsePropertyName(method);
    }

    if (!isGenerator) {
      if (this.isClassProperty()) {
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }

      if (method.key.type === "Identifier" && !method.computed && this.hasPlugin("classConstructorCall") && method.key.name === "call" && this.match(types.name) && this.state.value === "constructor") {
        isConstructorCall = true;
        this.parsePropertyName(method);
      }
    }

    var isAsyncMethod = !this.match(types.parenL) && !method.computed && method.key.type === "Identifier" && method.key.name === "async";
    if (isAsyncMethod) {
      if (this.hasPlugin("asyncGenerators") && this.eat(types.star)) isGenerator = true;
      isAsync = true;
      this.parsePropertyName(method);
    }

    method.kind = "method";

    if (!method.computed) {
      var key = method.key;

      // handle get/set methods
      // eg. class Foo { get bar() {} set bar() {} }

      if (!isAsync && !isGenerator && !this.isClassMutatorStarter() && key.type === "Identifier" && !this.match(types.parenL) && (key.name === "get" || key.name === "set")) {
        isGetSet = true;
        method.kind = key.name;
        key = this.parsePropertyName(method);
      }

      // disallow invalid constructors
      var isConstructor = !isConstructorCall && !method.static && (key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor");
      if (isConstructor) {
        if (hadConstructor) this.raise(key.start, "Duplicate constructor in the same class");
        if (isGetSet) this.raise(key.start, "Constructor can't have get/set modifier");
        if (isGenerator) this.raise(key.start, "Constructor can't be a generator");
        if (isAsync) this.raise(key.start, "Constructor can't be an async function");
        method.kind = "constructor";
        hadConstructor = true;
      }

      // disallow static prototype method
      var isStaticPrototype = method.static && (key.type === "Identifier" && key.name === "prototype" || key.type === "StringLiteral" && key.value === "prototype");
      if (isStaticPrototype) {
        this.raise(key.start, "Classes may not have static property named prototype");
      }
    }

    // convert constructor to a constructor call
    if (isConstructorCall) {
      if (hadConstructorCall) this.raise(method.start, "Duplicate constructor call in the same class");
      method.kind = "constructorCall";
      hadConstructorCall = true;
    }

    // disallow decorators on class constructors
    if ((method.kind === "constructor" || method.kind === "constructorCall") && method.decorators) {
      this.raise(method.start, "You can't attach decorators to a class constructor");
    }

    this.parseClassMethod(classBody, method, isGenerator, isAsync);

    // get methods aren't allowed to have any parameters
    // set methods must have exactly 1 parameter
    if (isGetSet) {
      var paramCount = method.kind === "get" ? 0 : 1;
      if (method.params.length !== paramCount) {
        var start = method.start;
        if (method.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no method");
  }

  node.body = this.finishNode(classBody, "ClassBody");

  this.state.strict = oldStrict;
};

pp$1.parseClassProperty = function (node) {
  if (this.match(types.eq)) {
    if (!this.hasPlugin("classProperties")) this.unexpected();
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  return this.finishNode(node, "ClassProperty");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "ClassMethod"));
};

pp$1.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
  } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
    if (this.match(types.comma) && this.lookahead().type === types.star) {
      this.expect(types.comma);
      var _specifier2 = this.startNode();
      this.expect(types.star);
      this.expectContextual("as");
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.match(types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node, true, true);
    return this.finishNode(node, "ExportDefaultDeclaration");
  } else if (this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node, true);
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

pp$1.isExportDefaultSpecifier = function () {
  if (this.match(types.name)) {
    return this.state.value !== "type" && this.state.value !== "async" && this.state.value !== "interface";
  }

  if (!this.match(types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
};

pp$1.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

pp$1.parseExportFrom = function (node, expect) {
  if (this.eatContextual("from")) {
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

pp$1.shouldParseExportDeclaration = function () {
  return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
};

pp$1.checkExport = function (node, checkNames, isDefault) {
  if (checkNames) {
    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      this.checkDuplicateExports(node, "default");
    } else if (node.specifiers && node.specifiers.length) {
      // Named exports
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        this.checkDuplicateExports(specifier, specifier.exported.name);
      }
    } else if (node.declaration) {
      // Exported declarations
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        this.checkDuplicateExports(node, node.declaration.id.name);
      } else if (node.declaration.type === "VariableDeclaration") {
        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var declaration = _ref3;

          this.checkDeclaration(declaration.id);
        }
      }
    }
  }

  if (this.state.decorators.length) {
    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
    if (!node.declaration || !isClass) {
      this.raise(node.start, "You can only use decorators on an export when exporting a class");
    }
    this.takeDecorators(node.declaration);
  }
};

pp$1.checkDeclaration = function (node) {
  if (node.type === "ObjectPattern") {
    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var prop = _ref4;

      this.checkDeclaration(prop);
    }
  } else if (node.type === "ArrayPattern") {
    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref5 = _i5.value;
      }

      var elem = _ref5;

      if (elem) {
        this.checkDeclaration(elem);
      }
    }
  } else if (node.type === "ObjectProperty") {
    this.checkDeclaration(node.value);
  } else if (node.type === "RestElement" || node.type === "RestProperty") {
    this.checkDeclaration(node.argument);
  } else if (node.type === "Identifier") {
    this.checkDuplicateExports(node, node.name);
  }
};

pp$1.checkDuplicateExports = function (node, name) {
  if (this.state.exportedIdentifiers.indexOf(name) > -1) {
    this.raiseDuplicateExportError(node, name);
  }
  this.state.exportedIdentifiers.push(name);
};

pp$1.raiseDuplicateExportError = function (node, name) {
  this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from '...']
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    var isDefault = this.match(types._default);
    if (isDefault && !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom && !this.isContextual("from")) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

pp$1.parseImport = function (node) {
  this.next();

  // import '...'
  if (this.match(types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual("from");
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(types.name)) {
    // import defaultObj, { x, y as z } from '...'
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(types.comma)) return;
  }

  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual("as");
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
    return;
  }

  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    this.parseImportSpecifier(node);
  }
};

pp$1.parseImportSpecifier = function (node) {
  var specifier = this.startNode();
  specifier.imported = this.parseIdentifier(true);
  specifier.local = this.eatContextual("as") ? this.parseIdentifier() : specifier.imported.__clone();
  this.checkLVal(specifier.local, true, undefined, "import specifier");
  node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
};

pp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true, undefined, "default import specifier");
  return this.finishNode(node, "ImportDefaultSpecifier");
};

/* eslint indent: 0 */

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, contextDescription) {
  if (node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var prop = _ref;

          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;

      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;

      case "SpreadProperty":
        node.type = "RestProperty";
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
          this.raise(node.start, message);
        }
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function (exprList, isBinding, contextDescription) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type === "RestElement") {
      --end;
    } else if (last && last.type === "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding, contextDescription);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
        this.unexpected(arg.start);
      }
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) this.toAssignable(elt, isBinding, contextDescription);
  }
  return exprList;
};

// Convert list of expression atoms to a list of

pp$2.toReferencedList = function (exprList) {
  return exprList;
};

// Parses spread element.

pp$2.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseBindingIdentifier();
  return this.finishNode(node, "RestElement");
};

pp$2.shouldAllowYieldIdentifier = function () {
  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
};

pp$2.parseBindingIdentifier = function () {
  return this.parseIdentifier(this.shouldAllowYieldIdentifier());
};

// Parses lvalue (assignable) atom.

pp$2.parseBindingAtom = function () {
  switch (this.state.type) {
    case types._yield:
      if (this.state.strict || this.state.inGenerator) this.unexpected();
    // fall-through
    case types.name:
      return this.parseIdentifier(true);

    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");

    case types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp$2.parseBindingList = function (close, allowEmpty) {
  var elts = [];
  var first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
    }
    if (allowEmpty && this.match(types.comma)) {
      elts.push(null);
    } else if (this.eat(close)) {
      break;
    } else if (this.match(types.ellipsis)) {
      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
      this.expect(close);
      break;
    } else {
      var decorators = [];
      while (this.match(types.at)) {
        decorators.push(this.parseDecorator());
      }
      var left = this.parseMaybeDefault();
      if (decorators.length) {
        left.decorators = decorators;
      }
      this.parseAssignableListItemTypes(left);
      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
    }
  }
  return elts;
};

pp$2.parseAssignableListItemTypes = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  startLoc = startLoc || this.state.startLoc;
  startPos = startPos || this.state.start;
  left = left || this.parseBindingAtom();
  if (!this.eat(types.eq)) return left;

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval  something that can be assigned
// to.

pp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
  switch (expr.type) {
    case "Identifier":
      this.checkReservedWord(expr.name, expr.start, false, true);

      if (checkClashes) {
        // we need to prefix this with an underscore for the cases where we have a key of
        // `__proto__`. there's a bug in old V8 where the following wouldn't work:
        //
        //   > var obj = Object.create(null);
        //   undefined
        //   > obj.__proto__
        //   null
        //   > obj.__proto__ = true;
        //   true
        //   > obj.__proto__
        //   null
        var key = "_" + expr.name;

        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.type === "ObjectProperty") prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;

    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var elem = _ref3;

        if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;

    case "RestProperty":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest property");
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;

    default:
      {
        var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
        this.raise(expr.start, message);
      }
  }
};

/* eslint indent: 0 */
/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash) {
  if (prop.computed) return;

  var key = prop.key;
  var name = void 0;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;

    case "StringLiteral":
    case "NumericLiteral":
      name = String(key.value);
      break;

    // istanbul ignore next: non-computed property keys are always one of the above
    default:
      return;
  }

  if (name === "__proto__" && !prop.kind) {
    if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
    propHash.proto = true;
  }
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initalization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.match(types.comma)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    }
    this.toReferencedList(node.expressions);
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;

  if (this.match(types._yield) && this.state.inGenerator) {
    var _left = this.parseYield();
    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);
    return _left;
  }

  var failOnShorthandAssign = void 0;
  if (refShorthandDefaultPos) {
    failOnShorthandAssign = false;
  } else {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  }

  if (this.match(types.parenL) || this.match(types.name)) {
    this.state.potentialArrowAt = this.state.start;
  }

  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.state.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.state.value;
    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly

    this.checkLVal(left, undefined, undefined, "assignment expression");

    if (left.extra && left.extra.parenthesized) {
      var errorMsg = void 0;
      if (left.type === "ObjectPattern") {
        errorMsg = "`({a}) = 0` use `({a} = 0)`";
      } else if (left.type === "ArrayPattern") {
        errorMsg = "`([a]) = 0` use `([a] = 0)`";
      }
      if (errorMsg) {
        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
      }
    }

    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }

  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
};

pp$3.parseConditional = function (expr, noIn, startPos, startLoc) {
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  } else {
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.state.type.binop;
  if (prec != null && (!noIn || !this.match(types._in))) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.state.value;

      if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
        this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
      }

      var op = this.state.type;
      this.next();

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);

      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.state.type.prefix) {
    var node = this.startNode();
    var update = this.match(types.incDec);
    node.operator = this.state.value;
    node.prefix = true;
    this.next();

    var argType = this.state.type;
    node.argument = this.parseMaybeUnary();

    this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (update) {
      this.checkLVal(node.argument, undefined, undefined, "prefix operation");
    } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raise(node.start, "Deleting local variable in strict mode");
    }

    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }

  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.state.type.postfix && !this.canInsertSemicolon()) {
    var _node = this.startNodeAt(startPos, startLoc);
    _node.operator = this.state.value;
    _node.prefix = false;
    _node.argument = expr;
    this.checkLVal(expr, undefined, undefined, "postfix operation");
    this.next();
    expr = this.finishNode(_node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function (refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var potentialArrowAt = this.state.potentialArrowAt;
  var expr = this.parseExprAtom(refShorthandDefaultPos);

  if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
    return expr;
  }

  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  }

  return this.parseSubscripts(expr, startPos, startLoc);
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (!noCalls && this.eat(types.doubleColon)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.eat(types.dot)) {
      var _node2 = this.startNodeAt(startPos, startLoc);
      _node2.object = base;
      _node2.property = this.parseIdentifier(true);
      _node2.computed = false;
      base = this.finishNode(_node2, "MemberExpression");
    } else if (this.eat(types.bracketL)) {
      var _node3 = this.startNodeAt(startPos, startLoc);
      _node3.object = base;
      _node3.property = this.parseExpression();
      _node3.computed = true;
      this.expect(types.bracketR);
      base = this.finishNode(_node3, "MemberExpression");
    } else if (!noCalls && this.match(types.parenL)) {
      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
      this.next();

      var _node4 = this.startNodeAt(startPos, startLoc);
      _node4.callee = base;
      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
      if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) {
        this.raise(_node4.start, "import() requires exactly one argument");
      }
      base = this.finishNode(_node4, "CallExpression");

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
      } else {
        this.toReferencedList(_node4.arguments);
      }
    } else if (this.match(types.backQuote)) {
      var _node5 = this.startNodeAt(startPos, startLoc);
      _node5.tag = base;
      _node5.quasi = this.parseTemplate();
      base = this.finishNode(_node5, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

pp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
  var elts = [];
  var innerParenStart = void 0;
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
    if (this.match(types.parenL) && !innerParenStart) {
      innerParenStart = this.state.start;
    }

    elts.push(this.parseExprListItem(undefined, possibleAsyncArrow ? { start: 0 } : undefined));
  }

  // we found an async arrow function so let's not allow any inner parens
  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
    this.unexpected();
  }

  return elts;
};

pp$3.shouldParseAsyncArrow = function () {
  return this.match(types.arrow);
};

pp$3.parseAsyncArrowFromCallExpression = function (node, call) {
  this.expect(types.arrow);
  return this.parseArrowExpression(node, call.arguments, true);
};

// Parse a no-call expression (like argument of `new` or `::` operators).

pp$3.parseNoCallExpr = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function (refShorthandDefaultPos) {
  var canBeArrow = this.state.potentialArrowAt === this.state.start;
  var node = void 0;

  switch (this.state.type) {
    case types._super:
      if (!this.state.inMethod && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.unexpected();
      }
      if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() outside of class constructor");
      }
      return this.finishNode(node, "Super");

    case types._import:
      if (!this.hasPlugin("dynamicImport")) this.unexpected();

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL)) {
        this.unexpected(null, types.parenL);
      }
      return this.finishNode(node, "Import");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types._yield:
      if (this.state.inGenerator) this.unexpected();

    case types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);

      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(types.arrow);
        // let foo = bar => {};
        return this.parseArrowExpression(node, params, true);
      }

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }

      return id;

    case types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }

    case types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;

    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");

    case types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");

    case types._true:case types._false:
      node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");

    case types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case types._function:
      return this.parseFunctionExpression();

    case types.at:
      this.parseDecorators();

    case types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate();

    case types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }

    default:
      this.unexpected();
  }
};

pp$3.parseFunctionExpression = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);
  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) {
    return this.parseMetaProperty(node, meta, "sent");
  } else {
    return this.parseFunction(node, false);
  }
};

pp$3.parseMetaProperty = function (node, meta, propertyName) {
  node.meta = meta;
  node.property = this.parseIdentifier(true);

  if (node.property.name !== propertyName) {
    this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
  }

  return this.finishNode(node, "MetaProperty");
};

pp$3.parseLiteral = function (value, type) {
  var node = this.startNode();
  this.addExtra(node, "rawValue", value);
  this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
  node.value = value;
  this.next();
  return this.finishNode(node, type);
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var val = void 0;
  this.expect(types.parenL);

  var innerStartPos = this.state.start;
  var innerStartLoc = this.state.startLoc;
  var exprList = [];
  var refShorthandDefaultPos = { start: 0 };
  var refNeedsArrowPos = { start: 0 };
  var first = true;
  var spreadStart = void 0;
  var optionalCommaStart = void 0;

  while (!this.match(types.parenR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma, refNeedsArrowPos.start || null);
      if (this.match(types.parenR)) {
        optionalCommaStart = this.state.start;
        break;
      }
    }

    if (this.match(types.ellipsis)) {
      var spreadNodeStartPos = this.state.start;
      var spreadNodeStartLoc = this.state.startLoc;
      spreadStart = this.state.start;
      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartLoc, spreadNodeStartPos));
      break;
    } else {
      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
    }
  }

  var innerEndPos = this.state.start;
  var innerEndLoc = this.state.startLoc;
  this.expect(types.parenR);

  var arrowNode = this.startNodeAt(startPos, startLoc);
  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var param = _ref;

      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);
    }

    return this.parseArrowExpression(arrowNode, exprList);
  }

  if (!exprList.length) {
    this.unexpected(this.state.lastTokStart);
  }
  if (optionalCommaStart) this.unexpected(optionalCommaStart);
  if (spreadStart) this.unexpected(spreadStart);
  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.toReferencedList(val.expressions);
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }

  this.addExtra(val, "parenthesized", true);
  this.addExtra(val, "parenStart", startPos);

  return val;
};

pp$3.shouldParseArrow = function () {
  return !this.canInsertSemicolon();
};

pp$3.parseArrow = function (node) {
  if (this.eat(types.arrow)) {
    return node;
  }
};

pp$3.parseParenItem = function (node) {
  return node;
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call  at
// least, not without wrapping it in parentheses. Thus, it uses the

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);

  if (this.eat(types.dot)) {
    return this.parseMetaProperty(node, meta, "target");
  }

  node.callee = this.parseNoCallExpr();

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR);
    this.toReferencedList(node.arguments);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp$3.parseTemplateElement = function () {
  var elem = this.startNode();
  elem.value = {
    raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
    cooked: this.state.value
  };
  this.next();
  elem.tail = this.match(types.backQuote);
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function () {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement();
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement());
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function (isPattern, refShorthandDefaultPos) {
  var decorators = [];
  var propHash = Object.create(null);
  var first = true;
  var node = this.startNode();

  node.properties = [];
  this.next();

  var firstRestLocation = null;

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    while (this.match(types.at)) {
      decorators.push(this.parseDecorator());
    }

    var prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos = void 0,
        startLoc = void 0;
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) {
      prop = this.parseSpread();
      prop.type = isPattern ? "RestProperty" : "SpreadProperty";
      node.properties.push(prop);
      if (isPattern) {
        var position = this.state.start;
        if (firstRestLocation !== null) {
          this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
        } else if (this.eat(types.braceR)) {
          break;
        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
          // TODO: temporary rollback
          // this.unexpected(position, "A trailing comma is not permitted after the rest element");
          continue;
        } else {
          firstRestLocation = position;
          continue;
        }
      } else {
        continue;
      }
    }

    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refShorthandDefaultPos) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }

    if (!isPattern && this.isContextual("async")) {
      if (isGenerator) this.unexpected();

      var asyncId = this.parseIdentifier();
      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
        prop.key = asyncId;
      } else {
        isAsync = true;
        if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      }
    } else {
      this.parsePropertyName(prop);
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
    this.checkPropClash(prop, propHash);

    if (prop.shorthand) {
      this.addExtra(prop, "shorthand", true);
    }

    node.properties.push(prop);
  }

  if (firstRestLocation !== null) {
    this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no property");
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
  if (isAsync || isGenerator || this.match(types.parenL)) {
    if (isPattern) this.unexpected();
    prop.kind = "method";
    prop.method = true;
    this.parseMethod(prop, isGenerator, isAsync);
    return this.finishNode(prop, "ObjectMethod");
  }

  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);
    return this.finishNode(prop, "ObjectProperty");
  }

  if (!isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && !this.match(types.comma) && !this.match(types.braceR)) {
    if (isGenerator || isAsync) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    this.parseMethod(prop, false);
    var paramCount = prop.kind === "get" ? 0 : 1;
    if (prop.params.length !== paramCount) {
      var start = prop.start;
      if (prop.kind === "get") {
        this.raise(start, "getter should have no params");
      } else {
        this.raise(start, "setter should have exactly one param");
      }
    }
    return this.finishNode(prop, "ObjectMethod");
  }

  if (!prop.computed && prop.key.type === "Identifier") {
    if (isPattern) {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else if (this.match(types.eq) && refShorthandDefaultPos) {
      if (!refShorthandDefaultPos.start) {
        refShorthandDefaultPos.start = this.state.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else {
      prop.value = prop.key.__clone();
    }

    prop.shorthand = true;
    return this.finishNode(prop, "ObjectProperty");
  }

  this.unexpected();
};

pp$3.parsePropertyName = function (prop) {
  if (this.eat(types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(types.bracketR);
  } else {
    prop.computed = false;
    var oldInPropertyName = this.state.inPropertyName;
    this.state.inPropertyName = true;
    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    this.state.inPropertyName = oldInPropertyName;
  }
  return prop.key;
};

// Initialize empty function node.

pp$3.initFunction = function (node, isAsync) {
  node.id = null;
  node.generator = false;
  node.expression = false;
  node.async = !!isAsync;
};

// Parse object or class method.

pp$3.parseMethod = function (node, isGenerator, isAsync) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = node.kind || true;
  this.initFunction(node, isAsync);
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
  node.generator = isGenerator;
  this.parseFunctionBody(node);
  this.state.inMethod = oldInMethod;
  return node;
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function (node, params, isAsync) {
  this.initFunction(node, isAsync);
  node.params = this.toAssignableList(params, true, "arrow function parameters");
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

// Parse function body and check parameters.

pp$3.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && !this.match(types.braceL);

  var oldInAsync = this.state.inAsync;
  this.state.inAsync = node.async;
  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.state.inFunction;
    var oldInGen = this.state.inGenerator;
    var oldLabels = this.state.labels;
    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;
  }
  this.state.inAsync = oldInAsync;

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  var checkLVal = this.state.strict;
  var isStrict = false;

  // arrow function
  if (allowExpression) checkLVal = true;

  // normal function
  if (!isExpression && node.body.directives.length) {
    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var directive = _ref2;

      if (directive.value.value === "use strict") {
        isStrict = true;
        checkLVal = true;
        break;
      }
    }
  }

  //
  if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
    this.raise(node.id.start, "Binding yield in strict mode");
  }

  if (checkLVal) {
    var nameHash = Object.create(null);
    var oldStrict = this.state.strict;
    if (isStrict) this.state.strict = true;
    if (node.id) {
      this.checkLVal(node.id, true, undefined, "function name");
    }
    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var param = _ref3;

      if (isStrict && param.type !== "Identifier") {
        this.raise(param.start, "Non-simple parameter in strict mode");
      }
      this.checkLVal(param, true, nameHash, "function parameter list");
    }
    this.state.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
  var elts = [];
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
  }
  return elts;
};

pp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos) {
  var elt = void 0;
  if (allowEmpty && this.match(types.comma)) {
    elt = null;
  } else if (this.match(types.ellipsis)) {
    elt = this.parseSpread(refShorthandDefaultPos);
  } else {
    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem);
  }
  return elt;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdentifier = function (liberal) {
  var node = this.startNode();

  if (this.match(types.name)) {
    if (!liberal) {
      this.checkReservedWord(this.state.value, this.state.start, false, false);
    }

    node.name = this.state.value;
  } else if (liberal && this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }

  if (!liberal && node.name === "await" && this.state.inAsync) {
    this.raise(node.start, "invalid use of await inside of an async function");
  }

  node.loc.identifierName = node.name;

  this.next();
  return this.finishNode(node, "Identifier");
};

pp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {
  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
    this.raise(startLoc, word + " is a reserved word");
  }

  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
    this.raise(startLoc, word + " is a reserved word in strict mode");
  }
};

// Parses await expression inside async function.

pp$3.parseAwait = function (node) {
  // istanbul ignore next: this condition is checked at the call site so won't be hit here
  if (!this.state.inAsync) {
    this.unexpected();
  }
  if (this.match(types.star)) {
    this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
  }
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};

// Parses yield expression inside generator.

pp$3.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Start an AST node, attaching a start offset.

var pp$4 = Parser.prototype;
var commentKeys = ["leadingComments", "trailingComments", "innerComments"];

var Node = function () {
  function Node(pos, loc, filename) {
    classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (filename) this.loc.filename = filename;
  }

  Node.prototype.__clone = function __clone() {
    var node2 = new Node();
    for (var key in this) {
      // Do not clone comments that are already attached to the node
      if (commentKeys.indexOf(key) < 0) {
        node2[key] = this[key];
      }
    }

    return node2;
  };

  return Node;
}();

pp$4.startNode = function () {
  return new Node(this.state.start, this.state.startLoc, this.filename);
};

pp$4.startNodeAt = function (pos, loc) {
  return new Node(pos, loc, this.filename);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  node.loc.end = loc;
  this.processComment(node);
  return node;
}

// Finish an AST node, adding `type` and `end` properties.

pp$4.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
};

// Finish node at given position

pp$4.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

var pp$5 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$5.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  throw err;
};

/* eslint max-len: 0 */

/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function last(stack) {
  return stack[stack.length - 1];
}

var pp$6 = Parser.prototype;

pp$6.addComment = function (comment) {
  if (this.filename) comment.loc.filename = this.filename;
  this.state.trailingComments.push(comment);
  this.state.leadingComments.push(comment);
};

pp$6.processComment = function (node) {
  if (node.type === "Program" && node.body.length > 0) return;

  var stack = this.state.commentStack;

  var lastChild = void 0,
      trailingComments = void 0,
      i = void 0,
      j = void 0;

  if (this.state.trailingComments.length > 0) {
    // If the first comment in trailingComments comes after the
    // current node, then we're good - all comments in the array will
    // come after the node and so it's safe to add them as official
    // trailingComments.
    if (this.state.trailingComments[0].start >= node.end) {
      trailingComments = this.state.trailingComments;
      this.state.trailingComments = [];
    } else {
      // Otherwise, if the first comment doesn't come after the
      // current node, that means we have a mix of leading and trailing
      // comments in the array and that leadingComments contains the
      // same items as trailingComments. Reset trailingComments to
      // zero items and we'll handle this by evaluating leadingComments
      // later.
      this.state.trailingComments.length = 0;
    }
  } else {
    var lastInStack = last(stack);
    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
      trailingComments = lastInStack.trailingComments;
      lastInStack.trailingComments = null;
    }
  }

  // Eating the stack.
  while (stack.length > 0 && last(stack).start >= node.start) {
    lastChild = stack.pop();
  }

  if (lastChild) {
    if (lastChild.leadingComments) {
      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
        node.leadingComments = lastChild.leadingComments;
        lastChild.leadingComments = null;
      } else {
        // A leading comment for an anonymous class had been stolen by its first ClassMethod,
        // so this takes back the leading comment.
        // See also: https://github.com/eslint/espree/issues/158
        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
          if (lastChild.leadingComments[i].end <= node.start) {
            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
            break;
          }
        }
      }
    }
  } else if (this.state.leadingComments.length > 0) {
    if (last(this.state.leadingComments).end <= node.start) {
      if (this.state.commentPreviousNode) {
        for (j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }
      }
      if (this.state.leadingComments.length > 0) {
        node.leadingComments = this.state.leadingComments;
        this.state.leadingComments = [];
      }
    } else {
      // https://github.com/eslint/espree/issues/2
      //
      // In special cases, such as return (without a value) and
      // debugger, all comments will end up as leadingComments and
      // will otherwise be eliminated. This step runs when the
      // commentStack is empty and there are comments left
      // in leadingComments.
      //
      // This loop figures out the stopping point between the actual
      // leading and trailing comments by finding the location of the
      // first comment that comes after the given node.
      for (i = 0; i < this.state.leadingComments.length; i++) {
        if (this.state.leadingComments[i].end > node.start) {
          break;
        }
      }

      // Split the array based on the location of the first comment
      // that comes after the node. Keep in mind that this could
      // result in an empty array, and if so, the array must be
      // deleted.
      node.leadingComments = this.state.leadingComments.slice(0, i);
      if (node.leadingComments.length === 0) {
        node.leadingComments = null;
      }

      // Similarly, trailing comments are attached later. The variable
      // must be reset to null if there are no trailing comments.
      trailingComments = this.state.leadingComments.slice(i);
      if (trailingComments.length === 0) {
        trailingComments = null;
      }
    }
  }

  this.state.commentPreviousNode = node;

  if (trailingComments) {
    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
      node.innerComments = trailingComments;
    } else {
      node.trailingComments = trailingComments;
    }
  }

  stack.push(node);
};

/* eslint indent: 0 */
/* eslint max-len: 0 */

var pp$7 = Parser.prototype;

pp$7.flowParseTypeInitialiser = function (tok) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || types.colon);

  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

pp$7.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node, true);
  return this.finishNode(node, "DeclareClass");
};

pp$7.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational("<")) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(types.parenR);
  typeNode.returnType = this.flowParseTypeInitialiser();

  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, "DeclareFunction");
};

pp$7.flowParseDeclare = function (node) {
  if (this.match(types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual("module")) {
    if (this.lookahead().type === types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual("type")) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual("interface")) {
    return this.flowParseDeclareInterface(node);
  } else {
    this.unexpected();
  }
};

pp$7.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, "DeclareVariable");
};

pp$7.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(types.braceL);
  while (!this.match(types.braceR)) {
    var node2 = this.startNode();

    this.expectContextual("declare", "Unexpected token. Only declares are allowed inside declare module");

    body.push(this.flowParseDeclare(node2));
  }
  this.expect(types.braceR);

  this.finishNode(bodyNode, "BlockStatement");
  return this.finishNode(node, "DeclareModule");
};

pp$7.flowParseDeclareModuleExports = function (node) {
  this.expectContextual("module");
  this.expect(types.dot);
  this.expectContextual("exports");
  node.typeAnnotation = this.flowParseTypeAnnotation();
  this.semicolon();

  return this.finishNode(node, "DeclareModuleExports");
};

pp$7.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, "DeclareTypeAlias");
};

pp$7.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareInterface");
};

// Interfaces

pp$7.flowParseInterfaceish = function (node, allowStatic) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  if (this.isContextual("mixins")) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  node.body = this.flowParseObjectType(allowStatic);
};

pp$7.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, "InterfaceExtends");
};

pp$7.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node, false);
  return this.finishNode(node, "InterfaceDeclaration");
};

// Type aliases

pp$7.flowParseTypeAlias = function (node) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(types.eq);
  this.semicolon();

  return this.finishNode(node, "TypeAlias");
};

// Type annotations

pp$7.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = this.flowParseVariance();

  var ident = this.flowParseTypeAnnotatableIdentifier();
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(types.eq)) {
    this.eat(types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, "TypeParameter");
};

pp$7.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  // istanbul ignore else: this condition is already checked at all call sites
  if (this.isRelational("<") || this.match(types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  } while (!this.isRelational(">"));
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterDeclaration");
};

pp$7.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode();
  var oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational("<");
  while (!this.isRelational(">")) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  }
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterInstantiation");
};

pp$7.flowParseObjectPropertyKey = function () {
  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

pp$7.flowParseObjectTypeIndexer = function (node, isStatic, variance) {
  node.static = isStatic;

  this.expect(types.bracketL);
  if (this.lookahead().type === types.colon) {
    node.id = this.flowParseObjectPropertyKey();
    node.key = this.flowParseTypeInitialiser();
  } else {
    node.id = null;
    node.key = this.flowParseType();
  }
  this.expect(types.bracketR);
  node.value = this.flowParseTypeInitialiser();
  node.variance = variance;

  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeIndexer");
};

pp$7.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(types.parenL);
  while (this.match(types.name)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }

  if (this.eat(types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, "FunctionTypeAnnotation");
};

pp$7.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeProperty");
};

pp$7.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeCallProperty");
};

pp$7.flowParseObjectType = function (allowStatic, allowExact) {
  var oldInType = this.state.inType;
  this.state.inType = true;

  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = false;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact && this.match(types.braceBarL)) {
    this.expect(types.braceBarL);
    endDelim = types.braceBarR;
    exact = true;
  } else {
    this.expect(types.braceL);
    endDelim = types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) {
      this.next();
      isStatic = true;
    }

    var variancePos = this.state.start;
    var variance = this.flowParseVariance();

    if (this.match(types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
    } else if (this.match(types.parenL) || this.isRelational("<")) {
      if (variance) {
        this.unexpected(variancePos);
      }
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, allowStatic));
    } else {
      propertyKey = this.flowParseObjectPropertyKey();
      if (this.isRelational("<") || this.match(types.parenL)) {
        // This is a method property
        if (variance) {
          this.unexpected(variancePos);
        }
        nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
      } else {
        if (this.eat(types.question)) {
          optional = true;
        }
        node.key = propertyKey;
        node.value = this.flowParseTypeInitialiser();
        node.optional = optional;
        node.static = isStatic;
        node.variance = variance;
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
      }
    }

    isStatic = false;
  }

  this.expect(endDelim);

  var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");

  this.state.inType = oldInType;

  return out;
};

pp$7.flowObjectTypeSemicolon = function () {
  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
    this.unexpected();
  }
};

pp$7.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, "QualifiedTypeIdentifier");
  }

  return node;
};

pp$7.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, "GenericTypeAnnotation");
};

pp$7.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, "TypeofTypeAnnotation");
};

pp$7.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(types.bracketL);
  // We allow trailing commas
  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(types.bracketR)) break;
    this.expect(types.comma);
  }
  this.expect(types.bracketR);
  return this.finishNode(node, "TupleTypeAnnotation");
};

pp$7.flowParseFunctionTypeParam = function () {
  var name = null;
  var optional = false;
  var typeAnnotation = null;
  var node = this.startNode();
  var lh = this.lookahead();
  if (lh.type === types.colon || lh.type === types.question) {
    name = this.parseIdentifier();
    if (this.eat(types.question)) {
      optional = true;
    }
    typeAnnotation = this.flowParseTypeInitialiser();
  } else {
    typeAnnotation = this.flowParseType();
  }
  node.name = name;
  node.optional = optional;
  node.typeAnnotation = typeAnnotation;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$7.reinterpretTypeAsFunctionTypeParam = function (type) {
  var node = this.startNodeAt(type.start, type.loc);
  node.name = null;
  node.optional = false;
  node.typeAnnotation = type;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$7.flowParseFunctionTypeParams = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var ret = { params: params, rest: null };
  while (this.match(types.name)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }
  if (this.eat(types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

pp$7.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");

    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");

    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");

    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");

    case "empty":
      return this.finishNode(node, "EmptyTypeAnnotation");

    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");

    case "string":
      return this.finishNode(node, "StringTypeAnnotation");

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
pp$7.flowParsePrimaryType = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;
  var oldNoAnonFunctionType = this.state.noAnonFunctionType;

  switch (this.state.type) {
    case types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case types.braceL:
      return this.flowParseObjectType(false, false);

    case types.braceBarL:
      return this.flowParseObjectType(false, true);

    case types.bracketL:
      return this.flowParseTupleType();

    case types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);

        this.expect(types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;

    case types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        if (this.match(types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== types.question && token !== types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        this.state.noAnonFunctionType = false;
        type = this.flowParseType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
          this.expect(types.parenR);
          return type;
        } else {
          // Eat a comma if there is one
          this.eat(types.comma);
        }
      }

      if (type) {
        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
      } else {
        tmp = this.flowParseFunctionTypeParams();
      }

      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(types.parenR);

      this.expect(types.arrow);

      node.returnType = this.flowParseType();

      node.typeParameters = null;

      return this.finishNode(node, "FunctionTypeAnnotation");

    case types.string:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "StringLiteralTypeAnnotation");

    case types._true:case types._false:
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");

    case types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(types.num)) this.unexpected();

        node.value = -this.state.value;
        this.addExtra(node, "rawValue", node.value);
        this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
        this.next();
        return this.finishNode(node, "NumericLiteralTypeAnnotation");
      }

    case types.num:
      node.value = this.state.value;
      this.addExtra(node, "rawValue", node.value);
      this.addExtra(node, "raw", this.input.slice(this.state.start, this.state.end));
      this.next();
      return this.finishNode(node, "NumericLiteralTypeAnnotation");

    case types._null:
      node.value = this.match(types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");

    case types._this:
      node.value = this.match(types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");

    case types.star:
      this.next();
      return this.finishNode(node, "ExistentialTypeParam");

    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

pp$7.flowParsePostfixType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var type = this.flowParsePrimaryType();
  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.elementType = type;
    this.expect(types.bracketL);
    this.expect(types.bracketR);
    type = this.finishNode(node, "ArrayTypeAnnotation");
  }
  return type;
};

pp$7.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, "NullableTypeAnnotation");
  } else {
    return this.flowParsePostfixType();
  }
};

pp$7.flowParseAnonFunctionWithoutParens = function () {
  var param = this.flowParsePrefixType();
  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
    var node = this.startNodeAt(param.start, param.loc);
    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
    node.rest = null;
    node.returnType = this.flowParseType();
    node.typeParameters = null;
    return this.finishNode(node, "FunctionTypeAnnotation");
  }
  return param;
};

pp$7.flowParseIntersectionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseAND);
  var type = this.flowParseAnonFunctionWithoutParens();
  node.types = [type];
  while (this.eat(types.bitwiseAND)) {
    node.types.push(this.flowParseAnonFunctionWithoutParens());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
};

pp$7.flowParseUnionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseOR);
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
};

pp$7.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

pp$7.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "TypeAnnotation");
};

pp$7.flowParseTypeAnnotatableIdentifier = function () {
  var ident = this.parseIdentifier();
  if (this.match(types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }
  return ident;
};

pp$7.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};

pp$7.flowParseVariance = function () {
  var variance = null;
  if (this.match(types.plusMin)) {
    if (this.state.value === "+") {
      variance = "plus";
    } else if (this.state.value === "-") {
      variance = "minus";
    }
    this.next();
  }
  return variance;
};

var flowPlugin = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend("parseFunctionBody", function (inner) {
    return function (node, allowExpression) {
      if (this.match(types.colon) && !allowExpression) {
        // if allowExpression is true then we're parsing an arrow function and if
        // there's a return type then it's been handled elsewhere
        node.returnType = this.flowParseTypeAnnotation();
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend("parseStatement", function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it's a reserved word
      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend("parseExpressionStatement", function (inner) {
    return function (node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend("shouldParseExportDeclaration", function (inner) {
    return function () {
      return this.isContextual("type") || this.isContextual("interface") || inner.call(this);
    };
  });

  instance.extend("parseConditional", function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos && this.match(types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend("parseParenItem", function (inner) {
    return function (node, startLoc, startPos) {
      node = inner.call(this, node, startLoc, startPos);
      if (this.eat(types.question)) {
        node.optional = true;
      }

      if (this.match(types.colon)) {
        var typeCastNode = this.startNodeAt(startLoc, startPos);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    };
  });

  instance.extend("parseExport", function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === "ExportNamedDeclaration") {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    };
  });

  instance.extend("parseExportDeclaration", function (inner) {
    return function (node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";

        var declarationNode = this.startNode();
        this.next();

        if (this.match(types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        var _declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend("parseClassId", function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don't consider `void` to be a keyword as then it'll use the void token type
  // and set startExpr
  instance.extend("isKeyword", function (inner) {
    return function (name) {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don't lex any token as a jsx one inside a flow type
  instance.extend("jsx_readToken", function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding, contextDescription) {
      if (node.type === "TypeCastExpression") {
        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
      } else {
        return inner.call(this, node, isBinding, contextDescription);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend("toAssignableList", function (inner) {
    return function (exprList, isBinding, contextDescription) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding, contextDescription);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we've found that are illegal in this context
  instance.extend("toReferencedList", function () {
    return function (exprList) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend("parseExprListItem", function (inner) {
    return function (allowEmpty, refShorthandDefaultPos) {
      var container = this.startNode();
      var node = inner.call(this, allowEmpty, refShorthandDefaultPos);
      if (this.match(types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (node) {
      if (node.type !== "TypeCastExpression") {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend("parseClassProperty", function (inner) {
    return function (node) {
      delete node.variancePos;
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we're currently in the position where a class property would appear
  instance.extend("isClassProperty", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // parse type parameters for class methods
  instance.extend("parseClassMethod", function () {
    return function (classBody, method, isGenerator, isAsync) {
      if (method.variance) {
        this.unexpected(method.variancePos);
      }
      delete method.variance;
      delete method.variancePos;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      this.parseMethod(method, isGenerator, isAsync);
      classBody.body.push(this.finishNode(method, "ClassMethod"));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend("parseClassSuper", function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational("<")) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, "ClassImplements"));
        } while (this.eat(types.comma));
      }
    };
  });

  instance.extend("parsePropertyName", function (inner) {
    return function (node) {
      var variancePos = this.state.start;
      var variance = this.flowParseVariance();
      var key = inner.call(this, node);
      node.variance = variance;
      node.variancePos = variancePos;
      return key;
    };
  });

  // parse type parameters for object method shorthand
  instance.extend("parseObjPropValue", function (inner) {
    return function (prop) {
      if (prop.variance) {
        this.unexpected(prop.variancePos);
      }
      delete prop.variance;
      delete prop.variancePos;

      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend("parseAssignableListItemTypes", function () {
    return function (param) {
      if (this.eat(types.question)) {
        param.optional = true;
      }
      if (this.match(types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend("parseMaybeDefault", function (inner) {
    return function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.apply(this, args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend("parseImportSpecifiers", function (inner) {
    return function (node) {
      node.importKind = "value";

      var kind = null;
      if (this.match(types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse import-type/typeof shorthand
  instance.extend("parseImportSpecifier", function () {
    return function (node) {
      var specifier = this.startNode();
      var firstIdentLoc = this.state.start;
      var firstIdent = this.parseIdentifier(true);

      var specifierTypeKind = null;
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }

      if (this.isContextual("as")) {
        var as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !this.match(types.name)) {
          // `import {type as ,` or `import {type as }`
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          // `import {type as foo`
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier(false);
        }
      } else if (specifierTypeKind !== null && this.match(types.name)) {
        // `import {type foo`
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
        specifier.local = this.eatContextual("as") ? this.parseIdentifier(false) : specifier.imported.__clone();
      } else {
        if (firstIdent.name === "typeof") {
          this.unexpected(firstIdentLoc, "Cannot import a variable named `typeof`");
        }
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      this.checkLVal(specifier.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };
  });

  // parse function type parameters - function foo<T>() {}
  instance.extend("parseFunctionParams", function (inner) {
    return function (node) {
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend("parseVarHead", function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number => {});
  instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
    return function (node, call) {
      if (this.match(types.colon)) {
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend("shouldParseAsyncArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We'll try JSX first. If that
  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
  //    error.
  // 2. This is an arrow function. We'll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend("parseMaybeAssign", function (inner) {
    return function () {
      var jsxError = null;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (types.jsxTagStart && this.match(types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            jsxError = err;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      // Need to push something onto the context to stop
      // the JSX plugin from messing with the tokens
      this.state.context.push(types$1.parenExpression);
      if (jsxError != null || this.isRelational("<")) {
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          arrowExpression.start = typeParameters.start;
          arrowExpression.loc.start = typeParameters.loc.start;
        } catch (err) {
          throw jsxError || err;
        }

        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }
      }
      this.state.context.pop();

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend("parseArrow", function (inner) {
    return function (node) {
      if (this.match(types.colon)) {
        var state = this.state.clone();
        try {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          var returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types.arrow)) this.unexpected();
          // assign after it is clear it is an arrow
          node.returnType = returnType;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend("shouldParseArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  instance.extend("isClassMutatorStarter", function (inner) {
    return function () {
      if (this.isRelational("<")) {
        return true;
      } else {
        return inner.call(this);
      }
    };
  });
};

// Adapted from String.fromcodepoint to export the function without modifying String
/*! https://mths.be/fromcodepoint v0.2.1 by @mathias */

// The MIT License (MIT)
// Copyright (c) Mathias Bynens
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
// associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT
// NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

var fromCodePoint = String.fromCodePoint;

if (!fromCodePoint) {
  (function () {
    var stringFromCharCode = String.fromCharCode;
    var floor = Math.floor;
    fromCodePoint = function fromCodePoint() {
      var MAX_SIZE = 0x4000;
      var codeUnits = [];
      var highSurrogate = void 0;
      var lowSurrogate = void 0;
      var index = -1;
      var length = arguments.length;
      if (!length) {
        return "";
      }
      var result = "";
      while (++index < length) {
        var codePoint = Number(arguments[index]);
        if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
        codePoint < 0 || // not a valid Unicode code point
        codePoint > 0x10FFFF || // not a valid Unicode code point
        floor(codePoint) != codePoint // not an integer
        ) {
            throw RangeError("Invalid code point: " + codePoint);
          }
        if (codePoint <= 0xFFFF) {
          // BMP code point
          codeUnits.push(codePoint);
        } else {
          // Astral code point; split in surrogate halves
          // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
          codePoint -= 0x10000;
          highSurrogate = (codePoint >> 10) + 0xD800;
          lowSurrogate = codePoint % 0x400 + 0xDC00;
          codeUnits.push(highSurrogate, lowSurrogate);
        }
        if (index + 1 == length || codeUnits.length > MAX_SIZE) {
          result += stringFromCharCode.apply(null, codeUnits);
          codeUnits.length = 0;
        }
      }
      return result;
    };
  })();
}

var fromCodePoint$1 = fromCodePoint;

var XHTMLEntities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

/* eslint indent: 0 */

var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;

types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);

types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", { beforeExpr: true });
types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression
  this.state.context.push(types$1.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();
  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

var pp$8 = Parser.prototype;

// Reads inline JSX contents token.

pp$8.jsxReadToken = function () {
  var out = "";
  var chunkStart = this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated JSX contents");
    }

    var ch = this.input.charCodeAt(this.state.pos);

    switch (ch) {
      case 60: // "<"
      case 123:
        // "{"
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.jsxText, out);

      case 38:
        // "&"
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;

      default:
        if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
    }
  }
};

pp$8.jsxReadNewLine = function (normalizeCRLF) {
  var ch = this.input.charCodeAt(this.state.pos);
  var out = void 0;
  ++this.state.pos;
  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    ++this.state.pos;
    out = normalizeCRLF ? "\n" : "\r\n";
  } else {
    out = String.fromCharCode(ch);
  }
  ++this.state.curLine;
  this.state.lineStart = this.state.pos;

  return out;
};

pp$8.jsxReadString = function (quote) {
  var out = "";
  var chunkStart = ++this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.state.pos);
    if (ch === quote) break;
    if (ch === 38) {
      // "&"
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadEntity();
      chunkStart = this.state.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadNewLine(false);
      chunkStart = this.state.pos;
    } else {
      ++this.state.pos;
    }
  }
  out += this.input.slice(chunkStart, this.state.pos++);
  return this.finishToken(types.string, out);
};

pp$8.jsxReadEntity = function () {
  var str = "";
  var count = 0;
  var entity = void 0;
  var ch = this.input[this.state.pos];

  var startPos = ++this.state.pos;
  while (this.state.pos < this.input.length && count++ < 10) {
    ch = this.input[this.state.pos++];
    if (ch === ";") {
      if (str[0] === "#") {
        if (str[1] === "x") {
          str = str.substr(2);
          if (HEX_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 16));
        } else {
          str = str.substr(1);
          if (DECIMAL_NUMBER.test(str)) entity = fromCodePoint$1(parseInt(str, 10));
        }
      } else {
        entity = XHTMLEntities[str];
      }
      break;
    }
    str += ch;
  }
  if (!entity) {
    this.state.pos = startPos;
    return "&";
  }
  return entity;
};

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can"t contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

pp$8.jsxReadWord = function () {
  var ch = void 0;
  var start = this.state.pos;
  do {
    ch = this.input.charCodeAt(++this.state.pos);
  } while (isIdentifierChar(ch) || ch === 45); // "-"
  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
};

// Transforms JSX element name to string.

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
}

// Parse next token as JSX identifier

pp$8.jsxParseIdentifier = function () {
  var node = this.startNode();
  if (this.match(types.jsxName)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "JSXIdentifier");
};

// Parse namespaced identifier.

pp$8.jsxParseNamespacedName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var name = this.jsxParseIdentifier();
  if (!this.eat(types.colon)) return name;

  var node = this.startNodeAt(startPos, startLoc);
  node.namespace = name;
  node.name = this.jsxParseIdentifier();
  return this.finishNode(node, "JSXNamespacedName");
};

// Parses element name in any form - namespaced, member
// or single identifier.

pp$8.jsxParseElementName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.jsxParseNamespacedName();
  while (this.eat(types.dot)) {
    var newNode = this.startNodeAt(startPos, startLoc);
    newNode.object = node;
    newNode.property = this.jsxParseIdentifier();
    node = this.finishNode(newNode, "JSXMemberExpression");
  }
  return node;
};

// Parses any type of JSX attribute value.

pp$8.jsxParseAttributeValue = function () {
  var node = void 0;
  switch (this.state.type) {
    case types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }

    case types.jsxTagStart:
    case types.string:
      node = this.parseExprAtom();
      node.extra = null;
      return node;

    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
};

// JSXEmptyExpression is unique type since it doesn't actually parse anything,
// and so it should start at the end of last read token (left brace) and finish
// at the beginning of the next one (right brace).

pp$8.jsxParseEmptyExpression = function () {
  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
  return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
};

// Parse JSX spread child

pp$8.jsxParseSpreadChild = function () {
  var node = this.startNode();
  this.expect(types.braceL);
  this.expect(types.ellipsis);
  node.expression = this.parseExpression();
  this.expect(types.braceR);

  return this.finishNode(node, "JSXSpreadChild");
};

// Parses JSX expression enclosed into curly brackets.


pp$8.jsxParseExpressionContainer = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.braceR)) {
    node.expression = this.jsxParseEmptyExpression();
  } else {
    node.expression = this.parseExpression();
  }
  this.expect(types.braceR);
  return this.finishNode(node, "JSXExpressionContainer");
};

// Parses following JSX attribute name-value pair.

pp$8.jsxParseAttribute = function () {
  var node = this.startNode();
  if (this.eat(types.braceL)) {
    this.expect(types.ellipsis);
    node.argument = this.parseMaybeAssign();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadAttribute");
  }
  node.name = this.jsxParseNamespacedName();
  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
  return this.finishNode(node, "JSXAttribute");
};

// Parses JSX opening tag starting after "<".

pp$8.jsxParseOpeningElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.attributes = [];
  node.name = this.jsxParseElementName();
  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
    node.attributes.push(this.jsxParseAttribute());
  }
  node.selfClosing = this.eat(types.slash);
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXOpeningElement");
};

// Parses JSX closing tag starting after "</".

pp$8.jsxParseClosingElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.name = this.jsxParseElementName();
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXClosingElement");
};

// Parses entire JSX element, including it"s opening tag
// (starting after "<"), attributes, contents and closing tag.

pp$8.jsxParseElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  var children = [];
  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
  var closingElement = null;

  if (!openingElement.selfClosing) {
    contents: for (;;) {
      switch (this.state.type) {
        case types.jsxTagStart:
          startPos = this.state.start;startLoc = this.state.startLoc;
          this.next();
          if (this.eat(types.slash)) {
            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsxParseElementAt(startPos, startLoc));
          break;

        case types.jsxText:
          children.push(this.parseExprAtom());
          break;

        case types.braceL:
          if (this.lookahead().type === types.ellipsis) {
            children.push(this.jsxParseSpreadChild());
          } else {
            children.push(this.jsxParseExpressionContainer());
          }

          break;

        // istanbul ignore next - should never happen
        default:
          this.unexpected();
      }
    }

    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
      this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
    }
  }

  node.openingElement = openingElement;
  node.closingElement = closingElement;
  node.children = children;
  if (this.match(types.relational) && this.state.value === "<") {
    this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
  }
  return this.finishNode(node, "JSXElement");
};

// Parses entire JSX element from current position.

pp$8.jsxParseElement = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  this.next();
  return this.jsxParseElementAt(startPos, startLoc);
};

var jsxPlugin = function (instance) {
  instance.extend("parseExprAtom", function (inner) {
    return function (refShortHandDefaultPos) {
      if (this.match(types.jsxText)) {
        var node = this.parseLiteral(this.state.value, "JSXText");
        // https://github.com/babel/babel/issues/2078
        node.extra = null;
        return node;
      } else if (this.match(types.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return inner.call(this, refShortHandDefaultPos);
      }
    };
  });

  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inPropertyName) return inner.call(this, code);

      var context = this.curContext();

      if (context === types$1.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$1.j_oTag || context === types$1.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagStart);
      }

      return inner.call(this, code);
    };
  });

  instance.extend("updateContext", function (inner) {
    return function (prevType) {
      if (this.match(types.braceL)) {
        var curContext = this.curContext();
        if (curContext === types$1.j_oTag) {
          this.state.context.push(types$1.braceExpression);
        } else if (curContext === types$1.j_expr) {
          this.state.context.push(types$1.templateQuasi);
        } else {
          inner.call(this, prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return inner.call(this, prevType);
      }
    };
  });
};

plugins.flow = flowPlugin;
plugins.jsx = jsxPlugin;

function parse(input, options) {
  return new Parser(options, input).parse();
}

exports.parse = parse;
exports.tokTypes = types;
});

function parseWithFlow(text) {
  // Inline the require to avoid loading all the JS if we don't use it
  const flowParser = flow_parser;

  const ast = flowParser.parse(text, {
    esproposal_class_instance_fields: true,
    esproposal_class_static_fields: true,
    esproposal_export_star_as: true
  });

  if (ast.errors.length > 0) {
    // Construct an error similar to the ones thrown by Babylon.
    const loc = {
      line: ast.errors[0].loc.start.line,
      column: ast.errors[0].loc.start.column
    };
    const msg = ast.errors[0].message +
      " (" +
      loc.line +
      ":" +
      loc.column +
      ")";
    const error = new SyntaxError(msg);
    error.loc = loc;
    throw error;
  }

  return ast;
}

function parseWithBabylon(text) {
  // Inline the require to avoid loading all the JS if we don't use it
  const babylon = index$42;

  return babylon.parse(text, {
    sourceType: "module",
    allowImportExportEverywhere: false,
    allowReturnOutsideFunction: false,
    plugins: [
      "jsx",
      "flow",
      "doExpressions",
      "objectRestSpread",
      "decorators",
      "classProperties",
      "exportExtensions",
      "asyncGenerators",
      "functionBind",
      "functionSent",
      "dynamicImport"
    ]
  });
}

var parser$1 = { parseWithFlow, parseWithBabylon };

function flattenDoc(doc) {
  if (doc.type === "concat") {
    var res = [];

    for (var i = 0; i < doc.parts.length; ++i) {
      const doc2 = doc.parts[i];
      if (typeof doc2 !== "string" && doc2.type === "concat") {
        [].push.apply(res, flattenDoc(doc2).parts);
      } else {
        const flattened = flattenDoc(doc2);
        if (flattened !== "") {
          res.push(flattened);
        }
      }
    }

    return Object.assign({}, doc, { parts: res });
  } else if (doc.type === "if-break") {
    return Object.assign({}, doc, {
      breakContents: doc.breakContents != null
        ? flattenDoc(doc.breakContents)
        : null,
      flatContents: doc.flatContents != null
        ? flattenDoc(doc.flatContents)
        : null
    });
  } else if (doc.type === "group") {
    return Object.assign({}, doc, {
      contents: flattenDoc(doc.contents),
      expandedStates: doc.expandedStates
        ? doc.expandedStates.map(flattenDoc)
        : doc.expandedStates
    });
  } else if (doc.contents) {
    return Object.assign({}, doc, { contents: flattenDoc(doc.contents) });
  } else {
    return doc;
  }
}

function printDoc(doc) {
  if (typeof doc === "string") {
    return JSON.stringify(doc);
  }

  if (doc.type === "line") {
    if (doc.literalline) {
      return "literalline";
    }
    if (doc.hard) {
      return "hardline";
    }
    if (doc.soft) {
      return "softline";
    }
    return "line";
  }

  if (doc.type === "break-parent") {
    return "breakParent";
  }

  if (doc.type === "concat") {
    return "[" + doc.parts.map(printDoc).join(", ") + "]";
  }

  if (doc.type === "indent") {
    return "indent(" + doc.n + ", " + printDoc(doc.contents) + ")";
  }

  if (doc.type === "if-break") {
    return "ifBreak(" +
      printDoc(doc.breakContents) +
      (doc.flatContents ? ", " + printDoc(doc.flatContents) : "") +
      ")";
  }

  if (doc.type === "group") {
    if (doc.expandedStates) {
      return "conditionalGroup(" +
        "[" +
        doc.expandedStates.map(printDoc).join(",") +
        "])";
    }

    return (doc.break ? "wrappedGroup" : "group") +
      "(" +
      printDoc(doc.contents) +
      ")";
  }

  if (doc.type === "line-suffix") {
    return "lineSuffix(" + printDoc(doc.contents) + ")";
  }

  throw new Error("Unknown doc type " + doc.type);
}

var docDebug = {
  printDocToDebug: function(doc) {
    return printDoc(flattenDoc(doc));
  }
};

var require$$2$11 = ( _package$1 && _package$1['default'] ) || _package$1;

const codeFrame = index$30;
const comments = comments$1;
const version$1 = require$$2$11.version;
const printAstToDoc = printer.printAstToDoc;
const printDocToString = docPrinter.printDocToString;
const normalizeOptions = options$1.normalize;
const parser = parser$1;
const printDocToDebug = docDebug.printDocToDebug;

function guessLineEnding(text) {
  const index = text.indexOf("\n");
  if (index >= 0 && text.charAt(index - 1) === "\r") {
    return "\r\n";
  }
  return "\n";
}

function parse$1(text, opts) {
  const parseFunction = opts.parser === "flow"
    ? parser.parseWithFlow
    : parser.parseWithBabylon;

  try {
    return parseFunction(text);
  } catch (error) {
    const loc = error.loc;

    if (loc) {
      error.codeFrame = codeFrame(text, loc.line, loc.column + 1, {
        highlightCode: true
      });
      error.message += "\n" + error.codeFrame;
    }

    throw error;
  }
}

function attachComments(text, ast, opts) {
  const astComments = ast.comments;
  if (astComments) {
    delete ast.comments;
    comments.attach(astComments, ast, text);
  }
  ast.tokens = [];
  opts.originalText = text.trimRight();
  return astComments;
}

function ensureAllCommentsPrinted(astComments) {
  astComments.forEach(comment => {
    if (!comment.printed) {
      throw new Error(
        'Comment "' +
          comment.value.trim() +
          '" was not printed. Please report this error!'
      );
    }
    delete comment.printed;
  });
}

function format$1(text, opts) {
  const ast = parse$1(text, opts);
  const astComments = attachComments(text, ast, opts);
  const doc = printAstToDoc(ast, opts);
  const str = printDocToString(doc, opts.printWidth, guessLineEnding(text));
  ensureAllCommentsPrinted(astComments);
  return str;
}

function formatWithShebang(text, opts) {
  if (!text.startsWith("#!")) {
    return format$1(text, opts);
  }

  const index = text.indexOf("\n");
  const shebang = text.slice(0, index + 1);
  const programText = text.slice(index + 1);
  const nextChar = text.charAt(index + 1);
  const newLine = nextChar === "\n" ? "\n" : nextChar === "\r" ? "\r\n" : "";

  return shebang + newLine + format$1(programText, opts);
}

var index$28 = {
  format: function(text, opts) {
    return formatWithShebang(text, normalizeOptions(opts));
  },
  version: version$1,
  __debug: {
    formatAST: function(ast, opts) {
      opts = normalizeOptions(opts);
      const doc = printAstToDoc(ast, opts);
      const str = printDocToString(doc, opts.printWidth);
      return str;
    },
    // Doesn't handle shebang for now
    formatDoc: function(doc, opts) {
      opts = normalizeOptions(opts);
      const debug = printDocToDebug(doc);
      const str = format$1(debug, opts);
      return str;
    },
    printToDoc: function(text, opts) {
      opts = normalizeOptions(opts);
      const ast = parse$1(text, opts);
      attachComments(text, ast, opts);
      const doc = printAstToDoc(ast, opts);
      return doc;
    },
    printDocToString: function(doc, opts) {
      opts = normalizeOptions(opts);
      const str = printDocToString(doc, opts.printWidth);
      return str;
    }
  }
};

var base = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports['default'] = /*istanbul ignore end*/Diff;
function Diff() {}

Diff.prototype = { /*istanbul ignore start*/
  /*istanbul ignore end*/diff: function diff(oldString, newString) {
    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

    var callback = options.callback;
    if (typeof options === 'function') {
      callback = options;
      options = {};
    }
    this.options = options;

    var self = this;

    function done(value) {
      if (callback) {
        setTimeout(function () {
          callback(undefined, value);
        }, 0);
        return true;
      } else {
        return value;
      }
    }

    // Allow subclasses to massage the input prior to running
    oldString = this.castInput(oldString);
    newString = this.castInput(newString);

    oldString = this.removeEmpty(this.tokenize(oldString));
    newString = this.removeEmpty(this.tokenize(newString));

    var newLen = newString.length,
        oldLen = oldString.length;
    var editLength = 1;
    var maxEditLength = newLen + oldLen;
    var bestPath = [{ newPos: -1, components: [] }];

    // Seed editLength = 0, i.e. the content starts with the same values
    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);
    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
      // Identity per the equality and tokenizer
      return done([{ value: this.join(newString), count: newString.length }]);
    }

    // Main worker method. checks all permutations of a given edit length for acceptance.
    function execEditLength() {
      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
        var basePath = /*istanbul ignore start*/void 0;
        var addPath = bestPath[diagonalPath - 1],
            removePath = bestPath[diagonalPath + 1],
            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;
        if (addPath) {
          // No one else is going to attempt to use this value, clear it
          bestPath[diagonalPath - 1] = undefined;
        }

        var canAdd = addPath && addPath.newPos + 1 < newLen,
            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;
        if (!canAdd && !canRemove) {
          // If this path is a terminal then prune
          bestPath[diagonalPath] = undefined;
          continue;
        }

        // Select the diagonal that we want to branch from. We select the prior
        // path whose position in the new string is the farthest from the origin
        // and does not pass the bounds of the diff graph
        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
          basePath = clonePath(removePath);
          self.pushComponent(basePath.components, undefined, true);
        } else {
          basePath = addPath; // No need to clone, we've pulled it from the list
          basePath.newPos++;
          self.pushComponent(basePath.components, true, undefined);
        }

        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);

        // If we have hit the end of both strings, then we are done
        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
        } else {
          // Otherwise track this path as a potential candidate and continue.
          bestPath[diagonalPath] = basePath;
        }
      }

      editLength++;
    }

    // Performs the length of edit iteration. Is a bit fugly as this has to support the
    // sync and async mode which is never fun. Loops over execEditLength until a value
    // is produced.
    if (callback) {
      (function exec() {
        setTimeout(function () {
          // This should not happen, but we want to be safe.
          /* istanbul ignore next */
          if (editLength > maxEditLength) {
            return callback();
          }

          if (!execEditLength()) {
            exec();
          }
        }, 0);
      })();
    } else {
      while (editLength <= maxEditLength) {
        var ret = execEditLength();
        if (ret) {
          return ret;
        }
      }
    }
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {
    var last = components[components.length - 1];
    if (last && last.added === added && last.removed === removed) {
      // We need to clone here as the component clone operation is just
      // as shallow array clone
      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };
    } else {
      components.push({ count: 1, added: added, removed: removed });
    }
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
    var newLen = newString.length,
        oldLen = oldString.length,
        newPos = basePath.newPos,
        oldPos = newPos - diagonalPath,
        commonCount = 0;
    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
      newPos++;
      oldPos++;
      commonCount++;
    }

    if (commonCount) {
      basePath.components.push({ count: commonCount });
    }

    basePath.newPos = newPos;
    return oldPos;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {
    return left === right;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {
    var ret = [];
    for (var i = 0; i < array.length; i++) {
      if (array[i]) {
        ret.push(array[i]);
      }
    }
    return ret;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {
    return value;
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {
    return value.split('');
  },
  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {
    return chars.join('');
  }
};

function buildValues(diff, components, newString, oldString, useLongestToken) {
  var componentPos = 0,
      componentLen = components.length,
      newPos = 0,
      oldPos = 0;

  for (; componentPos < componentLen; componentPos++) {
    var component = components[componentPos];
    if (!component.removed) {
      if (!component.added && useLongestToken) {
        var value = newString.slice(newPos, newPos + component.count);
        value = value.map(function (value, i) {
          var oldValue = oldString[oldPos + i];
          return oldValue.length > value.length ? oldValue : value;
        });

        component.value = diff.join(value);
      } else {
        component.value = diff.join(newString.slice(newPos, newPos + component.count));
      }
      newPos += component.count;

      // Common case
      if (!component.added) {
        oldPos += component.count;
      }
    } else {
      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
      oldPos += component.count;

      // Reverse add and remove so removes are output first to match common convention
      // The diffing algorithm is tied to add then remove output and this is the simplest
      // route to get the desired output with minimal overhead.
      if (componentPos && components[componentPos - 1].added) {
        var tmp = components[componentPos - 1];
        components[componentPos - 1] = components[componentPos];
        components[componentPos] = tmp;
      }
    }
  }

  // Special case handle for when one terminal is ignored. For this case we merge the
  // terminal into the prior string and drop the change.
  var lastComponent = components[componentLen - 1];
  if (componentLen > 1 && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
    components[componentLen - 2].value += lastComponent.value;
    components.pop();
  }

  return components;
}

function clonePath(path) {
  return { newPos: path.newPos, components: path.components.slice(0) };
}

});

var character = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.characterDiff = undefined;
exports. /*istanbul ignore end*/diffChars = diffChars;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default']();
function diffChars(oldStr, newStr, callback) {
  return characterDiff.diff(oldStr, newStr, callback);
}

});

var params = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/generateOptions = generateOptions;
function generateOptions(options, defaults) {
  if (typeof options === 'function') {
    defaults.callback = options;
  } else if (options) {
    for (var name in options) {
      /* istanbul ignore else */
      if (options.hasOwnProperty(name)) {
        defaults[name] = options[name];
      }
    }
  }
  return defaults;
}

});

var word = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.wordDiff = undefined;
exports. /*istanbul ignore end*/diffWords = diffWords;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_params = params;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/

// Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode
//
// Ranges and exceptions:
// Latin-1 Supplement, 008000FF
//  - U+00D7   Multiplication sign
//  - U+00F7   Division sign
// Latin Extended-A, 0100017F
// Latin Extended-B, 0180024F
// IPA Extensions, 025002AF
// Spacing Modifier Letters, 02B002FF
//  - U+02C7   &#711;  Caron
//  - U+02D8   &#728;  Breve
//  - U+02D9   &#729;  Dot Above
//  - U+02DA   &#730;  Ring Above
//  - U+02DB   &#731;  Ogonek
//  - U+02DC   &#732;  Small Tilde
//  - U+02DD   &#733;  Double Acute Accent
// Latin Extended Additional, 1E001EFF
var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;

var reWhitespace = /\S/;

var wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default']();
wordDiff.equals = function (left, right) {
  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
};
wordDiff.tokenize = function (value) {
  var tokens = value.split(/(\s+|\b)/);

  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.
  for (var i = 0; i < tokens.length - 1; i++) {
    // If we have an empty string in the next field and we have only word chars before and after, merge
    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
      tokens[i] += tokens[i + 2];
      tokens.splice(i + 1, 2);
      i--;
    }
  }

  return tokens;
};

function diffWords(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
  return wordDiff.diff(oldStr, newStr, options);
}
function diffWordsWithSpace(oldStr, newStr, callback) {
  return wordDiff.diff(oldStr, newStr, callback);
}

});

var line$2 = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.lineDiff = undefined;
exports. /*istanbul ignore end*/diffLines = diffLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_params = params;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default']();
lineDiff.tokenize = function (value) {
  var retLines = [],
      linesAndNewlines = value.split(/(\n|\r\n)/);

  // Ignore the final empty token that occurs if the string ends with a new line
  if (!linesAndNewlines[linesAndNewlines.length - 1]) {
    linesAndNewlines.pop();
  }

  // Merge the content and line separators into single tokens
  for (var i = 0; i < linesAndNewlines.length; i++) {
    var line = linesAndNewlines[i];

    if (i % 2 && !this.options.newlineIsToken) {
      retLines[retLines.length - 1] += line;
    } else {
      if (this.options.ignoreWhitespace) {
        line = line.trim();
      }
      retLines.push(line);
    }
  }

  return retLines;
};

function diffLines(oldStr, newStr, callback) {
  return lineDiff.diff(oldStr, newStr, callback);
}
function diffTrimmedLines(oldStr, newStr, callback) {
  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });
  return lineDiff.diff(oldStr, newStr, options);
}

});

var sentence = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.sentenceDiff = undefined;
exports. /*istanbul ignore end*/diffSentences = diffSentences;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default']();
sentenceDiff.tokenize = function (value) {
  return value.split(/(\S.+?[.!?])(?=\s+|$)/);
};

function diffSentences(oldStr, newStr, callback) {
  return sentenceDiff.diff(oldStr, newStr, callback);
}

});

var css = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.cssDiff = undefined;
exports. /*istanbul ignore end*/diffCss = diffCss;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default']();
cssDiff.tokenize = function (value) {
  return value.split(/([{}:;,]|\s+)/);
};

function diffCss(oldStr, newStr, callback) {
  return cssDiff.diff(oldStr, newStr, callback);
}

});

var json = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.jsonDiff = undefined;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

exports. /*istanbul ignore end*/diffJson = diffJson;
/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_line = line$2;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/

var objectPrototypeToString = Object.prototype.toString;

var jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default']();
// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:
jsonDiff.useLongestToken = true;

jsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff. /*istanbul ignore end*/tokenize;
jsonDiff.castInput = function (value) {
  /*istanbul ignore start*/var /*istanbul ignore end*/undefinedReplacement = this.options.undefinedReplacement;


  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value), function (k, v) {
    if (typeof v === 'undefined') {
      return undefinedReplacement;
    }

    return v;
  }, '  ');
};
jsonDiff.equals = function (left, right) {
  return (/*istanbul ignore start*/_base2['default']. /*istanbul ignore end*/prototype.equals(left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'))
  );
};

function diffJson(oldObj, newObj, options) {
  return jsonDiff.diff(oldObj, newObj, options);
}

// This function handles the presence of circular references by bailing out when encountering an
// object that is already on the "stack" of items being processed.
function canonicalize(obj, stack, replacementStack) {
  stack = stack || [];
  replacementStack = replacementStack || [];

  var i = /*istanbul ignore start*/void 0;

  for (i = 0; i < stack.length; i += 1) {
    if (stack[i] === obj) {
      return replacementStack[i];
    }
  }

  var canonicalizedObj = /*istanbul ignore start*/void 0;

  if ('[object Array]' === objectPrototypeToString.call(obj)) {
    stack.push(obj);
    canonicalizedObj = new Array(obj.length);
    replacementStack.push(canonicalizedObj);
    for (i = 0; i < obj.length; i += 1) {
      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
    return canonicalizedObj;
  }

  if (obj && obj.toJSON) {
    obj = obj.toJSON();
  }

  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {
    stack.push(obj);
    canonicalizedObj = {};
    replacementStack.push(canonicalizedObj);
    var sortedKeys = [],
        key = /*istanbul ignore start*/void 0;
    for (key in obj) {
      /* istanbul ignore else */
      if (obj.hasOwnProperty(key)) {
        sortedKeys.push(key);
      }
    }
    sortedKeys.sort();
    for (i = 0; i < sortedKeys.length; i += 1) {
      key = sortedKeys[i];
      canonicalizedObj[key] = canonicalize(obj[key], stack, replacementStack);
    }
    stack.pop();
    replacementStack.pop();
  } else {
    canonicalizedObj = obj;
  }
  return canonicalizedObj;
}

});

var array = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.arrayDiff = undefined;
exports. /*istanbul ignore end*/diffArrays = diffArrays;

var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default']();
arrayDiff.tokenize = arrayDiff.join = function (value) {
  return value.slice();
};

function diffArrays(oldArr, newArr, callback) {
  return arrayDiff.diff(oldArr, newArr, callback);
}

});

var parse$2 = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/parsePatch = parsePatch;
function parsePatch(uniDiff) {
  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      list = [],
      i = 0;

  function parseIndex() {
    var index = {};
    list.push(index);

    // Parse diff metadata
    while (i < diffstr.length) {
      var line = diffstr[i];

      // File header found, end parsing diff metadata
      if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
        break;
      }

      // Diff index
      var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);
      if (header) {
        index.index = header[1];
      }

      i++;
    }

    // Parse file headers if they are defined. Unified diff requires them, but
    // there's no technical issues to have an isolated hunk without file header
    parseFileHeader(index);
    parseFileHeader(index);

    // Parse hunks
    index.hunks = [];

    while (i < diffstr.length) {
      var _line = diffstr[i];

      if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
        break;
      } else if (/^@@/.test(_line)) {
        index.hunks.push(parseHunk());
      } else if (_line && options.strict) {
        // Ignore unexpected content unless in strict mode
        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
      } else {
        i++;
      }
    }
  }

  // Parses the --- and +++ headers, if none are found, no lines
  // are consumed.
  function parseFileHeader(index) {
    var headerPattern = /^(---|\+\+\+)\s+([\S ]*)(?:\t(.*?)\s*)?$/;
    var fileHeader = headerPattern.exec(diffstr[i]);
    if (fileHeader) {
      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
      index[keyPrefix + 'FileName'] = fileHeader[2];
      index[keyPrefix + 'Header'] = fileHeader[3];

      i++;
    }
  }

  // Parses a hunk
  // This assumes that we are at the start of a hunk.
  function parseHunk() {
    var chunkHeaderIndex = i,
        chunkHeaderLine = diffstr[i++],
        chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);

    var hunk = {
      oldStart: +chunkHeader[1],
      oldLines: +chunkHeader[2] || 1,
      newStart: +chunkHeader[3],
      newLines: +chunkHeader[4] || 1,
      lines: [],
      linedelimiters: []
    };

    var addCount = 0,
        removeCount = 0;
    for (; i < diffstr.length; i++) {
      // Lines starting with '---' could be mistaken for the "remove line" operation
      // But they could be the header for the next file. Therefore prune such cases out.
      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
        break;
      }
      var operation = diffstr[i][0];

      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
        hunk.lines.push(diffstr[i]);
        hunk.linedelimiters.push(delimiters[i] || '\n');

        if (operation === '+') {
          addCount++;
        } else if (operation === '-') {
          removeCount++;
        } else if (operation === ' ') {
          addCount++;
          removeCount++;
        }
      } else {
        break;
      }
    }

    // Handle the empty block count case
    if (!addCount && hunk.newLines === 1) {
      hunk.newLines = 0;
    }
    if (!removeCount && hunk.oldLines === 1) {
      hunk.oldLines = 0;
    }

    // Perform optional sanity checking
    if (options.strict) {
      if (addCount !== hunk.newLines) {
        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
      if (removeCount !== hunk.oldLines) {
        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
      }
    }

    return hunk;
  }

  while (i < diffstr.length) {
    parseIndex();
  }

  return list;
}

});

var distanceIterator = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/"use strict";

exports.__esModule = true;

exports["default"] = /*istanbul ignore end*/function (start, minLine, maxLine) {
  var wantForward = true,
      backwardExhausted = false,
      forwardExhausted = false,
      localOffset = 1;

  return function iterator() {
    if (wantForward && !forwardExhausted) {
      if (backwardExhausted) {
        localOffset++;
      } else {
        wantForward = false;
      }

      // Check if trying to fit beyond text length, and if not, check it fits
      // after offset location (or desired location on first iteration)
      if (start + localOffset <= maxLine) {
        return localOffset;
      }

      forwardExhausted = true;
    }

    if (!backwardExhausted) {
      if (!forwardExhausted) {
        wantForward = true;
      }

      // Check if trying to fit before text beginning, and if not, check it fits
      // before offset location
      if (minLine <= start - localOffset) {
        return -localOffset++;
      }

      backwardExhausted = true;
      return iterator();
    }

    // We tried to fit hunk before text beginning and beyond text lenght, then
    // hunk can't fit on the text. Return undefined
  };
};

});

var apply = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/applyPatch = applyPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;

var /*istanbul ignore start*/_parse = parse$2;

var /*istanbul ignore start*/_distanceIterator = distanceIterator;

/*istanbul ignore start*/
var _distanceIterator2 = _interopRequireDefault(_distanceIterator);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/*istanbul ignore end*/function applyPatch(source, uniDiff) {
  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  if (typeof uniDiff === 'string') {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  if (Array.isArray(uniDiff)) {
    if (uniDiff.length > 1) {
      throw new Error('applyPatch only works with a single input.');
    }

    uniDiff = uniDiff[0];
  }

  // Apply the diff to the input
  var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
      delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
      hunks = uniDiff.hunks,
      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{
    return (/*istanbul ignore end*/line === patchContent
    );
  },
      errorCount = 0,
      fuzzFactor = options.fuzzFactor || 0,
      minLine = 0,
      offset = 0,
      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      addEOFNL = /*istanbul ignore start*/void 0;

  /**
   * Checks if the hunk exactly fits on the provided location
   */
  function hunkFits(hunk, toPos) {
    for (var j = 0; j < hunk.lines.length; j++) {
      var line = hunk.lines[j],
          operation = line[0],
          content = line.substr(1);

      if (operation === ' ' || operation === '-') {
        // Context sanity check
        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
          errorCount++;

          if (errorCount > fuzzFactor) {
            return false;
          }
        }
        toPos++;
      }
    }

    return true;
  }

  // Search best fit offsets for each hunk based on the previous ones
  for (var i = 0; i < hunks.length; i++) {
    var hunk = hunks[i],
        maxLine = lines.length - hunk.oldLines,
        localOffset = 0,
        toPos = offset + hunk.oldStart - 1;

    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);

    for (; localOffset !== undefined; localOffset = iterator()) {
      if (hunkFits(hunk, toPos + localOffset)) {
        hunk.offset = offset += localOffset;
        break;
      }
    }

    if (localOffset === undefined) {
      return false;
    }

    // Set lower text limit to end of the current hunk, so next ones don't try
    // to fit over already patched text
    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
  }

  // Apply patch hunks
  for (var _i = 0; _i < hunks.length; _i++) {
    var _hunk = hunks[_i],
        _toPos = _hunk.offset + _hunk.newStart - 1;
    if (_hunk.newLines == 0) {
      _toPos++;
    }

    for (var j = 0; j < _hunk.lines.length; j++) {
      var line = _hunk.lines[j],
          operation = line[0],
          content = line.substr(1),
          delimiter = _hunk.linedelimiters[j];

      if (operation === ' ') {
        _toPos++;
      } else if (operation === '-') {
        lines.splice(_toPos, 1);
        delimiters.splice(_toPos, 1);
        /* istanbul ignore else */
      } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;
          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
    }
  }

  // Handle EOFNL insertion/removal
  if (removeEOFNL) {
    while (!lines[lines.length - 1]) {
      lines.pop();
      delimiters.pop();
    }
  } else if (addEOFNL) {
    lines.push('');
    delimiters.push('\n');
  }
  for (var _k = 0; _k < lines.length - 1; _k++) {
    lines[_k] = lines[_k] + delimiters[_k];
  }
  return lines.join('');
}

// Wrapper that supports multiple file patches via callbacks.
function applyPatches(uniDiff, options) {
  if (typeof uniDiff === 'string') {
    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);
  }

  var currentIndex = 0;
  function processIndex() {
    var index = uniDiff[currentIndex++];
    if (!index) {
      return options.complete();
    }

    options.loadFile(index, function (err, data) {
      if (err) {
        return options.complete(err);
      }

      var updatedContent = applyPatch(data, index, options);
      options.patched(index, updatedContent, function (err) {
        if (err) {
          return options.complete(err);
        }

        processIndex();
      });
    });
  }
  processIndex();
}

});

var create = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/structuredPatch = structuredPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;

var /*istanbul ignore start*/_line = line$2;

/*istanbul ignore start*/
function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  if (!options) {
    options = {};
  }
  if (typeof options.context === 'undefined') {
    options.context = 4;
  }

  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);
  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier

  function contextLines(lines) {
    return lines.map(function (entry) {
      return ' ' + entry;
    });
  }

  var hunks = [];
  var oldRangeStart = 0,
      newRangeStart = 0,
      curRange = [],
      oldLine = 1,
      newLine = 1;
  /*istanbul ignore start*/
  var _loop = function _loop( /*istanbul ignore end*/i) {
    var current = diff[i],
        lines = current.lines || current.value.replace(/\n$/, '').split('\n');
    current.lines = lines;

    if (current.added || current.removed) {
      /*istanbul ignore start*/
      var _curRange;

      /*istanbul ignore end*/
      // If we have previous context, start with that
      if (!oldRangeStart) {
        var prev = diff[i - 1];
        oldRangeStart = oldLine;
        newRangeStart = newLine;

        if (prev) {
          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
          oldRangeStart -= curRange.length;
          newRangeStart -= curRange.length;
        }
      }

      // Output our changes
      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {
        return (current.added ? '+' : '-') + entry;
      })));

      // Track the updated file position
      if (current.added) {
        newLine += lines.length;
      } else {
        oldLine += lines.length;
      }
    } else {
      // Identical context lines. Track line changes
      if (oldRangeStart) {
        // Close out any changes that have been output (or join overlapping)
        if (lines.length <= options.context * 2 && i < diff.length - 2) {
          /*istanbul ignore start*/
          var _curRange2;

          /*istanbul ignore end*/
          // Overlapping
          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));
        } else {
          /*istanbul ignore start*/
          var _curRange3;

          /*istanbul ignore end*/
          // end the range and output
          var contextSize = Math.min(lines.length, options.context);
          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));

          var hunk = {
            oldStart: oldRangeStart,
            oldLines: oldLine - oldRangeStart + contextSize,
            newStart: newRangeStart,
            newLines: newLine - newRangeStart + contextSize,
            lines: curRange
          };
          if (i >= diff.length - 2 && lines.length <= options.context) {
            // EOF is inside this hunk
            var oldEOFNewline = /\n$/.test(oldStr);
            var newEOFNewline = /\n$/.test(newStr);
            if (lines.length == 0 && !oldEOFNewline) {
              // special case: old has no eol and no trailing context; no-nl can end up before adds
              curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
            } else if (!oldEOFNewline || !newEOFNewline) {
              curRange.push('\\ No newline at end of file');
            }
          }
          hunks.push(hunk);

          oldRangeStart = 0;
          newRangeStart = 0;
          curRange = [];
        }
      }
      oldLine += lines.length;
      newLine += lines.length;
    }
  };

  for (var i = 0; i < diff.length; i++) {
    /*istanbul ignore start*/
    _loop( /*istanbul ignore end*/i);
  }

  return {
    oldFileName: oldFileName, newFileName: newFileName,
    oldHeader: oldHeader, newHeader: newHeader,
    hunks: hunks
  };
}

function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);

  var ret = [];
  if (oldFileName == newFileName) {
    ret.push('Index: ' + oldFileName);
  }
  ret.push('===================================================================');
  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

  for (var i = 0; i < diff.hunks.length; i++) {
    var hunk = diff.hunks[i];
    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
    ret.push.apply(ret, hunk.lines);
  }

  return ret.join('\n') + '\n';
}

function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
}

});

var dmp = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/"use strict";

exports.__esModule = true;
exports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;
// See: http://code.google.com/p/google-diff-match-patch/wiki/API
function convertChangesToDMP(changes) {
  var ret = [],
      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,
      operation = /*istanbul ignore start*/void 0;
  for (var i = 0; i < changes.length; i++) {
    change = changes[i];
    if (change.added) {
      operation = 1;
    } else if (change.removed) {
      operation = -1;
    } else {
      operation = 0;
    }

    ret.push([operation, change.value]);
  }
  return ret;
}

});

var xml = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;
function convertChangesToXML(changes) {
  var ret = [];
  for (var i = 0; i < changes.length; i++) {
    var change = changes[i];
    if (change.added) {
      ret.push('<ins>');
    } else if (change.removed) {
      ret.push('<del>');
    }

    ret.push(escapeHTML(change.value));

    if (change.added) {
      ret.push('</ins>');
    } else if (change.removed) {
      ret.push('</del>');
    }
  }
  return ret.join('');
}

function escapeHTML(s) {
  var n = s;
  n = n.replace(/&/g, '&amp;');
  n = n.replace(/</g, '&lt;');
  n = n.replace(/>/g, '&gt;');
  n = n.replace(/"/g, '&quot;');

  return n;
}

});

var index$44 = createCommonjsModule(function (module, exports) {
/*istanbul ignore start*/'use strict';

exports.__esModule = true;
exports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;
/*istanbul ignore end*/
var /*istanbul ignore start*/_base = base;

/*istanbul ignore start*/
var _base2 = _interopRequireDefault(_base);

/*istanbul ignore end*/
var /*istanbul ignore start*/_character = character;

var /*istanbul ignore start*/_word = word;

var /*istanbul ignore start*/_line = line$2;

var /*istanbul ignore start*/_sentence = sentence;

var /*istanbul ignore start*/_css = css;

var /*istanbul ignore start*/_json = json;

var /*istanbul ignore start*/_array = array;

var /*istanbul ignore start*/_apply = apply;

var /*istanbul ignore start*/_parse = parse$2;

var /*istanbul ignore start*/_create = create;

var /*istanbul ignore start*/_dmp = dmp;

var /*istanbul ignore start*/_xml = xml;

/*istanbul ignore start*/
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

exports. /*istanbul ignore end*/Diff = _base2['default'];
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;
/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;
/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;
/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;
/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;
/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;
/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize; /* See LICENSE file for terms of use */

/*
 * Text diff implementation.
 *
 * This library supports the following APIS:
 * JsDiff.diffChars: Character by character diff
 * JsDiff.diffWords: Word (as defined by \b regex) diff which ignores whitespace
 * JsDiff.diffLines: Line based diff
 *
 * JsDiff.diffCss: Diff targeted at CSS content
 *
 * These methods are based on the implementation proposed in
 * "An O(ND) Difference Algorithm and its Variations" (Myers, 1986).
 * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927
 */

});

const fs$1 = fs;
const getStdin = index;
const glob = glob_1;
const chalk = index$12;
const minimist = index$26;
const readline$1 = readline;
const prettier = index$28;

const argv = minimist(process.argv.slice(2), {
  boolean: [
    "write",
    "stdin",
    "single-quote",
    "trailing-comma",
    "bracket-spacing",
    "jsx-bracket-same-line",
    // The supports-color package (a sub sub dependency) looks directly at
    // `process.argv` for `--no-color` and such-like options. The reason it is
    // listed here is to avoid "Ignored unknown option: --no-color" warnings.
    // See https://github.com/chalk/supports-color/#info for more information.
    "color",
    "help",
    "version",
    "debug-print-doc",
    "debug-check",
    // Deprecated in 0.0.10
    "flow-parser"
  ],
  string: ["print-width", "tab-width", "parser"],
  default: { color: true, "bracket-spacing": true, parser: "babylon" },
  alias: { help: "h", version: "v" },
  unknown: param => {
    if (param.startsWith("-")) {
      console.warn("Ignored unknown option: " + param + "\n");
      return false;
    }
  }
});

if (argv["version"]) {
  console.log(prettier.version);
  process.exit(0);
}

const filepatterns = argv["_"];
const write = argv["write"];
const stdin = argv["stdin"] || !filepatterns.length && !process.stdin.isTTY;

if (argv["help"] || !filepatterns.length && !stdin) {
  console.log(
    "Usage: prettier [opts] [filename ...]\n\n" +
      "Available options:\n" +
      "  --write                  Edit the file in-place. (Beware!)\n" +
      "  --stdin                  Read input from stdin.\n" +
      "  --print-width <int>      Specify the length of line that the printer will wrap on. Defaults to 80.\n" +
      "  --tab-width <int>        Specify the number of spaces per indentation-level. Defaults to 2.\n" +
      "  --single-quote           Use single quotes instead of double.\n" +
      "  --trailing-comma         Print trailing commas wherever possible.\n" +
      "  --bracket-spacing        Put spaces between brackets. Defaults to true.\n" +
      "  --jsx-bracket-same-line  Put > on the last line. Defaults to false.\n" +
      "  --parser <flow|babylon>  Specify which parse to use. Defaults to babylon.\n" +
      "  --color                  Colorize error messages. Defaults to true.\n" +
      "  --version                Print prettier version.\n" +
      "\n" +
      "Boolean options can be turned off like this:\n" +
      "  --no-bracket-spacing\n" +
      "  --bracket-spacing=false"
  );
  process.exit(argv["help"] ? 0 : 1);
}

function getParserOption() {
  const optionName = "parser";
  const value = argv[optionName];

  if (value === undefined) {
    return value;
  }

  // For backward compatibility. Deprecated in 0.0.10
  if (argv["flow-parser"]) {
    console.warn("`--flow-parser` is deprecated. Use `--parser flow` instead.");
    return "flow";
  }

  if (value === "flow" || value === "babylon") {
    return value;
  }

  console.warn(
    "Ignoring unknown --" +
      optionName +
      ' value, falling back to "babylon":\n' +
      '  Expected "flow" or "babylon", but received: ' +
      JSON.stringify(value)
  );

  return "babylon";
}

function getIntOption(optionName) {
  const value = argv[optionName];

  if (value === undefined) {
    return value;
  }

  if (/^\d+$/.test(value)) {
    return Number(value);
  }

  console.error(
    "Invalid --" +
      optionName +
      " value. Expected an integer, but received: " +
      JSON.stringify(value)
  );
  process.exit(1);
}

const options = {
  printWidth: getIntOption("print-width"),
  tabWidth: getIntOption("tab-width"),
  bracketSpacing: argv["bracket-spacing"],
  parser: getParserOption(),
  singleQuote: argv["single-quote"],
  trailingComma: argv["trailing-comma"],
  jsxBracketSameLine: argv["jsx-bracket-same-line"]
};

function format(input) {
  if (argv["debug-print-doc"]) {
    const doc = prettier.__debug.printToDoc(input, options);
    return prettier.__debug.formatDoc(doc);
  }

  if (argv["debug-check"]) {
    const pp = prettier.format(input, options);
    const pppp = prettier.format(pp, options);
    if (pp !== pppp) {
      const diff = index$44.createTwoFilesPatch("", "", pp, pppp, "", "", { context: 2 });
      console.error(diff);
    }
    return;
  }

  return prettier.format(input, options);
}

function handleError(filename, e) {
  const isParseError = Boolean(e && e.loc);
  const isValidationError = /Validation Error/.test(e && e.message);

  // For parse errors and validation errors, we only want to show the error
  // message formatted in a nice way. `String(e)` takes care of that. Other
  // (unexpected) errors are passed as-is as a separate argument to
  // `console.error`. That includes the stack trace (if any), and shows a nice
  // `util.inspect` of throws things that aren't `Error` objects. (The Flow
  // parser has mistakenly thrown arrays sometimes.)
  if (isParseError) {
    console.error(filename + ": " + String(e));
  } else if (isValidationError) {
    console.error(String(e));
    // If validation fails for one file, it will fail for all of them.
    process.exit(1);
  } else {
    console.error(filename + ":", e);
  }

  // Don't exit the process if one file failed
  process.exitCode = 2;
}

if (stdin) {
  getStdin().then(input => {
    try {
      // Don't use `console.log` here since it adds an extra newline at the end.
      process.stdout.write(format(input));
    } catch (e) {
      handleError("stdin", e);
      return;
    }
  });
} else {
  eachFilename(filepatterns, filename => {
    fs$1.readFile(filename, "utf8", (err, input) => {
      if (write || argv["debug-check"]) {
        // Don't use `console.log` here since we need to replace this line.
        process.stdout.write(filename);
      }

      if (err) {
        // Add newline to split errors from filename line.
        process.stdout.write("\n");

        console.error("Unable to read file: " + filename + "\n" + err);
        // Don't exit the process if one file failed
        process.exitCode = 2;
        return;
      }

      const start = Date.now();

      let output;

      try {
        output = format(input);
      } catch (e) {
        // Add newline to split errors from filename line.
        process.stdout.write("\n");

        handleError(filename, e);
        return;
      }

      if (write) {
        // Remove previously printed filename to log it with duration.
        readline$1.clearLine(process.stdout, 0);
        readline$1.cursorTo(process.stdout, 0, null);

        // Don't write the file if it won't change in order not to invalidate
        // mtime based caches.
        if (output === input) {
          console.log(chalk.grey("%s %dms"), filename, Date.now() - start);
        } else {
          console.log("%s %dms", filename, Date.now() - start);

          fs$1.writeFile(filename, output, "utf8", err => {
            if (err) {
              console.error("Unable to write file: " + filename + "\n" + err);
              // Don't exit the process if one file failed
              process.exitCode = 2;
            }
          });
        }
      } else if (argv["debug-check"]) {
        process.stdout.write("\n");
        if (output) {
          console.log(output);
        }
      } else {
        // Don't use `console.log` here since it adds an extra newline at the end.
        process.stdout.write(output);
      }
    });
  });
}

function eachFilename(patterns, callback) {
  patterns.forEach(pattern => {
    glob(pattern, (err, filenames) => {
      if (err) {
        console.error("Unable to expand glob pattern: " + pattern + "\n" + err);
        // Don't exit the process if one pattern failed
        process.exitCode = 2;
        return;
      }

      filenames.forEach(filename => {
        callback(filename);
      });
    });
  });
}

var cli = {

};

module.exports = cli;

var prettier = (function () {
function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by rollup-plugin-commonjs');
}



function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var index$4 = createCommonjsModule(function (module, exports) {
// Copyright 2014, 2015, 2016, 2017 Simon Lydell
// License: MIT. (See LICENSE.)

Object.defineProperty(exports, "__esModule", {
  value: true
});

// This regex comes from regex.coffee, and is inserted here by generate-index.js
// (run `npm run build`).
exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyu]{1,5}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]{1,6}\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

exports.matchToToken = function(match) {
  var token = {type: "invalid", value: match[0]};
       if (match[ 1]) token.type = "string" , token.closed = !!(match[3] || match[4]);
  else if (match[ 5]) token.type = "comment";
  else if (match[ 6]) token.type = "comment", token.closed = !!match[7];
  else if (match[ 8]) token.type = "regex";
  else if (match[ 9]) token.type = "number";
  else if (match[10]) token.type = "name";
  else if (match[11]) token.type = "punctuator";
  else if (match[12]) token.type = "whitespace";
  return token
};
});

var ast = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    function isExpression(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'ArrayExpression':
            case 'AssignmentExpression':
            case 'BinaryExpression':
            case 'CallExpression':
            case 'ConditionalExpression':
            case 'FunctionExpression':
            case 'Identifier':
            case 'Literal':
            case 'LogicalExpression':
            case 'MemberExpression':
            case 'NewExpression':
            case 'ObjectExpression':
            case 'SequenceExpression':
            case 'ThisExpression':
            case 'UnaryExpression':
            case 'UpdateExpression':
                return true;
        }
        return false;
    }

    function isIterationStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'DoWhileStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'WhileStatement':
                return true;
        }
        return false;
    }

    function isStatement(node) {
        if (node == null) { return false; }
        switch (node.type) {
            case 'BlockStatement':
            case 'BreakStatement':
            case 'ContinueStatement':
            case 'DebuggerStatement':
            case 'DoWhileStatement':
            case 'EmptyStatement':
            case 'ExpressionStatement':
            case 'ForInStatement':
            case 'ForStatement':
            case 'IfStatement':
            case 'LabeledStatement':
            case 'ReturnStatement':
            case 'SwitchStatement':
            case 'ThrowStatement':
            case 'TryStatement':
            case 'VariableDeclaration':
            case 'WhileStatement':
            case 'WithStatement':
                return true;
        }
        return false;
    }

    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
    }

    function trailingStatement(node) {
        switch (node.type) {
        case 'IfStatement':
            if (node.alternate != null) {
                return node.alternate;
            }
            return node.consequent;

        case 'LabeledStatement':
        case 'ForStatement':
        case 'ForInStatement':
        case 'WhileStatement':
        case 'WithStatement':
            return node.body;
        }
        return null;
    }

    function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
            return false;
        }
        if (node.alternate == null) {
            return false;
        }
        current = node.consequent;
        do {
            if (current.type === 'IfStatement') {
                if (current.alternate == null)  {
                    return true;
                }
            }
            current = trailingStatement(current);
        } while (current);

        return false;
    }

    module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,

        trailingStatement: trailingStatement
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var code = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;

    // See `tools/generate-identifier-regex.js`.
    ES5Regex = {
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };

    ES6Regex = {
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v7.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B2\u08E4-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58\u0C59\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D60-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA69D\uA69F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2D\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDD0-\uDDDA\uDE00-\uDE11\uDE13-\uDE37\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF01-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|\uD809[\uDC00-\uDC6E]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };

    function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39;  // 0..9
    }

    function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 ||  // 0..9
            0x61 <= ch && ch <= 0x66 ||     // a..f
            0x41 <= ch && ch <= 0x46;       // A..F
    }

    function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37;  // 0..7
    }

    // 7.2 White Space

    NON_ASCII_WHITESPACES = [
        0x1680, 0x180E,
        0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A,
        0x202F, 0x205F,
        0x3000,
        0xFEFF
    ];

    function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 ||
            ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
    }

    // 7.3 Line Terminators

    function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
    }

    // 7.6 Identifier Names and Identifiers

    function fromCodePoint(cp) {
        if (cp <= 0xFFFF) { return String.fromCharCode(cp); }
        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode(((cp - 0x10000) % 0x400) + 0xDC00);
        return cu1 + cu2;
    }

    IDENTIFIER_START = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    IDENTIFIER_PART = new Array(0x80);
    for(ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] =
            ch >= 0x61 && ch <= 0x7A ||  // a..z
            ch >= 0x41 && ch <= 0x5A ||  // A..Z
            ch >= 0x30 && ch <= 0x39 ||  // 0..9
            ch === 0x24 || ch === 0x5F;  // $ (dollar) and _ (underscore)
    }

    function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
    }

    function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
    }

    module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var keyword = createCommonjsModule(function (module) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

(function () {
    'use strict';

    var code$$1 = code;

    function isStrictModeReservedWordES6(id) {
        switch (id) {
        case 'implements':
        case 'interface':
        case 'package':
        case 'private':
        case 'protected':
        case 'public':
        case 'static':
        case 'let':
            return true;
        default:
            return false;
        }
    }

    function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
            return false;
        }
        return isKeywordES6(id, strict);
    }

    function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
            return true;
        }

        switch (id.length) {
        case 2:
            return (id === 'if') || (id === 'in') || (id === 'do');
        case 3:
            return (id === 'var') || (id === 'for') || (id === 'new') || (id === 'try');
        case 4:
            return (id === 'this') || (id === 'else') || (id === 'case') ||
                (id === 'void') || (id === 'with') || (id === 'enum');
        case 5:
            return (id === 'while') || (id === 'break') || (id === 'catch') ||
                (id === 'throw') || (id === 'const') || (id === 'yield') ||
                (id === 'class') || (id === 'super');
        case 6:
            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
                (id === 'switch') || (id === 'export') || (id === 'import');
        case 7:
            return (id === 'default') || (id === 'finally') || (id === 'extends');
        case 8:
            return (id === 'function') || (id === 'continue') || (id === 'debugger');
        case 10:
            return (id === 'instanceof');
        default:
            return false;
        }
    }

    function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
    }

    function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
    }

    function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
    }

    function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) { return false; }

        ch = id.charCodeAt(0);
        if (!code$$1.isIdentifierStartES5(ch)) {
            return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (!code$$1.isIdentifierPartES5(ch)) {
                return false;
            }
        }
        return true;
    }

    function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
    }

    function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) { return false; }

        check = code$$1.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
            ch = id.charCodeAt(i);
            if (0xD800 <= ch && ch <= 0xDBFF) {
                ++i;
                if (i >= iz) { return false; }
                lowCh = id.charCodeAt(i);
                if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
                    return false;
                }
                ch = decodeUtf16(ch, lowCh);
            }
            if (!check(ch)) {
                return false;
            }
            check = code$$1.isIdentifierPartES6;
        }
        return true;
    }

    function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }

    function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }

    module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
    };
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var utils = createCommonjsModule(function (module, exports) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


(function () {
    'use strict';

    exports.ast = ast;
    exports.code = code;
    exports.keyword = keyword;
}());
/* vim: set sw=4 ts=4 et tw=80 : */
});

var global$1 = typeof global !== "undefined" ? global :
            typeof self !== "undefined" ? self :
            typeof window !== "undefined" ? window : {};

// shim for using process in browser
// based off https://github.com/defunctzombie/node-process/blob/master/browser.js

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
}
if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
}

function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}
function nextTick(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
}
// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
var title = 'browser';
var platform = 'browser';
var browser = true;
var env = {};
var argv = [];
var version$1 = ''; // empty string to avoid regexp issues
var versions = {};
var release = {};
var config = {};

function noop() {}

var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;

function binding(name) {
    throw new Error('process.binding is not supported');
}

function cwd () { return '/' }
function chdir (dir) {
    throw new Error('process.chdir is not supported');
}
function umask() { return 0; }

// from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js
var performance = global$1.performance || {};
var performanceNow =
  performance.now        ||
  performance.mozNow     ||
  performance.msNow      ||
  performance.oNow       ||
  performance.webkitNow  ||
  function(){ return (new Date()).getTime() };

// generate timestamp or delta
// see http://nodejs.org/api/process.html#process_process_hrtime
function hrtime(previousTimestamp){
  var clocktime = performanceNow.call(performance)*1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor((clocktime%1)*1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds<0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [seconds,nanoseconds]
}

var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1000;
}

var process = {
  nextTick: nextTick,
  title: title,
  browser: browser,
  env: env,
  argv: argv,
  version: version$1,
  versions: versions,
  on: on,
  addListener: addListener,
  once: once,
  off: off,
  removeListener: removeListener,
  removeAllListeners: removeAllListeners,
  emit: emit,
  binding: binding,
  cwd: cwd,
  chdir: chdir,
  umask: umask,
  hrtime: hrtime,
  platform: platform,
  release: release,
  config: config,
  uptime: uptime
};

var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

var index$8 = function (str) {
	if (typeof str !== 'string') {
		throw new TypeError('Expected a string');
	}

	return str.replace(matchOperatorsRe, '\\$&');
};

var index$10 = createCommonjsModule(function (module) {
'use strict';

function assembleStyles () {
	var styles = {
		modifiers: {
			reset: [0, 0],
			bold: [1, 22], // 21 isn't widely supported and 22 does the same thing
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		colors: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColors: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.colors.grey = styles.colors.gray;

	Object.keys(styles).forEach(function (groupName) {
		var group = styles[groupName];

		Object.keys(group).forEach(function (styleName) {
			var style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: '\u001b[' + style[0] + 'm',
				close: '\u001b[' + style[1] + 'm'
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
});

var index$14 = function () {
	return /[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g;
};

var ansiRegex = index$14();

var index$12 = function (str) {
	return typeof str === 'string' ? str.replace(ansiRegex, '') : str;
};

var ansiRegex$1 = index$14;
var re = new RegExp(ansiRegex$1().source); // remove the `g` flag
var index$16 = re.test.bind(re);

var argv$1 = process.argv;

var terminator = argv$1.indexOf('--');
var hasFlag = function (flag) {
	flag = '--' + flag;
	var pos = argv$1.indexOf(flag);
	return pos !== -1 && (terminator !== -1 ? pos < terminator : true);
};

var index$18 = (function () {
	if ('FORCE_COLOR' in process.env) {
		return true;
	}

	if (hasFlag('no-color') ||
		hasFlag('no-colors') ||
		hasFlag('color=false')) {
		return false;
	}

	if (hasFlag('color') ||
		hasFlag('colors') ||
		hasFlag('color=true') ||
		hasFlag('color=always')) {
		return true;
	}

	if (process.stdout && !process.stdout.isTTY) {
		return false;
	}

	if (process.platform === 'win32') {
		return true;
	}

	if ('COLORTERM' in process.env) {
		return true;
	}

	if (process.env.TERM === 'dumb') {
		return false;
	}

	if (/^screen|^xterm|^vt100|color|ansi|cygwin|linux/i.test(process.env.TERM)) {
		return true;
	}

	return false;
})();

var escapeStringRegexp = index$8;
var ansiStyles = index$10;
var stripAnsi = index$12;
var hasAnsi = index$16;
var supportsColor = index$18;
var defineProps = Object.defineProperties;
var isSimpleWindowsTerm = process.platform === 'win32' && !/^xterm/i.test(process.env.TERM);

function Chalk(options) {
	// detect mode if not set manually
	this.enabled = !options || options.enabled === undefined ? supportsColor : options.enabled;
}

// use bright blue on Windows as the normal blue color is illegible
if (isSimpleWindowsTerm) {
	ansiStyles.blue.open = '\u001b[94m';
}

var styles = (function () {
	var ret = {};

	Object.keys(ansiStyles).forEach(function (key) {
		ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');

		ret[key] = {
			get: function () {
				return build.call(this, this._styles.concat(key));
			}
		};
	});

	return ret;
})();

var proto = defineProps(function chalk() {}, styles);

function build(_styles) {
	var builder = function () {
		return applyStyle.apply(builder, arguments);
	};

	builder._styles = _styles;
	builder.enabled = this.enabled;
	// __proto__ is used because we must return a function, but there is
	// no way to create a function with a different prototype.
	/* eslint-disable no-proto */
	builder.__proto__ = proto;

	return builder;
}

function applyStyle() {
	// support varags, but simply cast to string in case there's only one arg
	var args = arguments;
	var argsLen = args.length;
	var str = argsLen !== 0 && String(arguments[0]);

	if (argsLen > 1) {
		// don't slice `arguments`, it prevents v8 optimizations
		for (var a = 1; a < argsLen; a++) {
			str += ' ' + args[a];
		}
	}

	if (!this.enabled || !str) {
		return str;
	}

	var nestedStyles = this._styles;
	var i = nestedStyles.length;

	// Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
	// see https://github.com/chalk/chalk/issues/58
	// If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.
	var originalDim = ansiStyles.dim.open;
	if (isSimpleWindowsTerm && (nestedStyles.indexOf('gray') !== -1 || nestedStyles.indexOf('grey') !== -1)) {
		ansiStyles.dim.open = '';
	}

	while (i--) {
		var code = ansiStyles[nestedStyles[i]];

		// Replace any instances already present with a re-opening code
		// otherwise only the part of the string until said closing code
		// will be colored, and the rest will simply be 'plain'.
		str = code.open + str.replace(code.closeRe, code.open) + code.close;
	}

	// Reset the original 'dim' if we changed it to work around the Windows dimmed gray issue.
	ansiStyles.dim.open = originalDim;

	return str;
}

function init() {
	var ret = {};

	Object.keys(styles).forEach(function (name) {
		ret[name] = {
			get: function () {
				return build.call(this, [name]);
			}
		};
	});

	return ret;
}

defineProps(Chalk.prototype, init());

var index$6 = new Chalk();
var styles_1 = ansiStyles;
var hasColor = hasAnsi;
var stripColor = stripAnsi;
var supportsColor_1 = supportsColor;

index$6.styles = styles_1;
index$6.hasColor = hasColor;
index$6.stripColor = stripColor;
index$6.supportsColor = supportsColor_1;

var index$2 = createCommonjsModule(function (module, exports) {
"use strict";

exports.__esModule = true;

exports.default = function (rawLines, lineNumber, colNumber) {
  var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  colNumber = Math.max(colNumber, 0);

  var highlighted = opts.highlightCode && _chalk2.default.supportsColor || opts.forceColor;
  var chalk = _chalk2.default;
  if (opts.forceColor) {
    chalk = new _chalk2.default.constructor({ enabled: true });
  }
  var maybeHighlight = function maybeHighlight(chalkFn, string) {
    return highlighted ? chalkFn(string) : string;
  };
  var defs = getDefs(chalk);
  if (highlighted) rawLines = highlight(defs, rawLines);

  var linesAbove = opts.linesAbove || 2;
  var linesBelow = opts.linesBelow || 3;

  var lines = rawLines.split(NEWLINE);
  var start = Math.max(lineNumber - (linesAbove + 1), 0);
  var end = Math.min(lines.length, lineNumber + linesBelow);

  if (!lineNumber && !colNumber) {
    start = 0;
    end = lines.length;
  }

  var numberMaxWidth = String(end).length;

  var frame = lines.slice(start, end).map(function (line, index) {
    var number = start + 1 + index;
    var paddedNumber = (" " + number).slice(-numberMaxWidth);
    var gutter = " " + paddedNumber + " | ";
    if (number === lineNumber) {
      var markerLine = "";
      if (colNumber) {
        var markerSpacing = line.slice(0, colNumber - 1).replace(/[^\t]/g, " ");
        markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^")].join("");
      }
      return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
    } else {
      return " " + maybeHighlight(defs.gutter, gutter) + line;
    }
  }).join("\n");

  if (highlighted) {
    return chalk.reset(frame);
  } else {
    return frame;
  }
};

var _jsTokens = index$4;

var _jsTokens2 = _interopRequireDefault(_jsTokens);

var _esutils = utils;

var _esutils2 = _interopRequireDefault(_esutils);

var _chalk = index$6;

var _chalk2 = _interopRequireDefault(_chalk);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getDefs(chalk) {
  return {
    keyword: chalk.cyan,
    capitalized: chalk.yellow,
    jsx_tag: chalk.yellow,
    punctuator: chalk.yellow,

    number: chalk.magenta,
    string: chalk.green,
    regex: chalk.magenta,
    comment: chalk.grey,
    invalid: chalk.white.bgRed.bold,
    gutter: chalk.grey,
    marker: chalk.red.bold
  };
}

var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

var JSX_TAG = /^[a-z][\w-]*$/i;

var BRACKET = /^[()\[\]{}]$/;

function getTokenType(match) {
  var _match$slice = match.slice(-2),
      offset = _match$slice[0],
      text = _match$slice[1];

  var token = (0, _jsTokens.matchToToken)(match);

  if (token.type === "name") {
    if (_esutils2.default.keyword.isReservedWordES6(token.value)) {
      return "keyword";
    }

    if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
      return "jsx_tag";
    }

    if (token.value[0] !== token.value[0].toLowerCase()) {
      return "capitalized";
    }
  }

  if (token.type === "punctuator" && BRACKET.test(token.value)) {
    return "bracket";
  }

  return token.type;
}

function highlight(defs, text) {
  return text.replace(_jsTokens2.default, function () {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var type = getTokenType(args);
    var colorize = defs[type];
    if (colorize) {
      return args[0].split(NEWLINE).map(function (str) {
        return colorize(str);
      }).join("\n");
    } else {
      return args[0];
    }
  });
}

module.exports = exports["default"];
});

var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var inited = false;
function init$1 () {
  inited = true;
  var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }

  revLookup['-'.charCodeAt(0)] = 62;
  revLookup['_'.charCodeAt(0)] = 63;
}

function toByteArray (b64) {
  if (!inited) {
    init$1();
  }
  var i, j, l, tmp, placeHolders, arr;
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;

  // base64 is 4/3 + up to two characters of the original data
  arr = new Arr(len * 3 / 4 - placeHolders);

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len;

  var L = 0;

  for (i = 0, j = 0; i < l; i += 4, j += 3) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)];
    arr[L++] = (tmp >> 16) & 0xFF;
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4);
    arr[L++] = tmp & 0xFF;
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2);
    arr[L++] = (tmp >> 8) & 0xFF;
    arr[L++] = tmp & 0xFF;
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp;
  var output = [];
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
    output.push(tripletToBase64(tmp));
  }
  return output.join('')
}

function fromByteArray (uint8) {
  if (!inited) {
    init$1();
  }
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
  var output = '';
  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    output += lookup[tmp >> 2];
    output += lookup[(tmp << 4) & 0x3F];
    output += '==';
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
    output += lookup[tmp >> 10];
    output += lookup[(tmp >> 4) & 0x3F];
    output += lookup[(tmp << 2) & 0x3F];
    output += '=';
  }

  parts.push(output);

  return parts.join('')
}

function read (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? (nBytes - 1) : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

function write (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
  var i = isLE ? 0 : (nBytes - 1);
  var d = isLE ? 1 : -1;
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
}

var toString = {}.toString;

var isArray$1 = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */


var INSPECT_MAX_BYTES = 50;

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined
  ? global$1.TYPED_ARRAY_SUPPORT
  : true;

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }
    that.length = length;
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192; // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr
};

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString$1(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    // Object.defineProperty(Buffer, Symbol.species, {
    //   value: null,
    //   configurable: true
    // })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size);
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
};

function allocUnsafe (that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
};

function fromString$1 (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);

  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }
  return that
}

function fromObject (that, obj) {
  if (internalIsBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len);
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray$1(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}


Buffer.isBuffer = isBuffer;
function internalIsBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
};

Buffer.concat = function concat (list, length) {
  if (!isArray$1(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i;
  if (length === undefined) {
    length = 0;
    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;
  for (i = 0; i < list.length; ++i) {
    var buf = list[i];
    if (!internalIsBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos);
    pos += buf.length;
  }
  return buffer
};

function byteLength (string, encoding) {
  if (internalIsBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}
Buffer.byteLength = byteLength;

function slowToString (encoding, start, end) {
  var loweredCase = false;

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0;
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true;

function swap (b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length;
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }
  return this
};

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length;
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }
  return this
};

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length;
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }
  return this
};

Buffer.prototype.toString = function toString () {
  var length = this.length | 0;
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
};

Buffer.prototype.equals = function equals (b) {
  if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
};

Buffer.prototype.inspect = function inspect () {
  var str = '';
  var max = INSPECT_MAX_BYTES;
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }
  return '<Buffer ' + str + '>'
};

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!internalIsBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0;
  }
  if (end === undefined) {
    end = target ? target.length : 0;
  }
  if (thisStart === undefined) {
    thisStart = 0;
  }
  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;

  if (this === target) return 0

  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);

  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
};

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }
  byteOffset = +byteOffset;  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1);
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (internalIsBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read$$1 (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i;
  if (dir) {
    var foundIndex = -1;
    for (i = byteOffset; i < arrLength; i++) {
      if (read$$1(arr, i) === read$$1(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
    for (i = byteOffset; i >= 0; i--) {
      var found = true;
      for (var j = 0; j < valLength; j++) {
        if (read$$1(arr, i + j) !== read$$1(val, j)) {
          found = false;
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
};

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
};

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
};

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;
  if (!length) {
    length = remaining;
  } else {
    length = Number(length);
    if (length > remaining) {
      length = remaining;
    }
  }

  // must be an even number of digits
  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2;
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed;
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write$$1 (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0;
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0;
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;
    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8';

  var loweredCase = false;
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
};

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return fromByteArray(buf)
  } else {
    return fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];

  var i = start;
  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }
          break
        case 2:
          secondByte = buf[i + 1];
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }
          break
        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = '';
  var i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    );
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length;

  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;

  var out = '';
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;

  var newBuf;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf
};

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val
};

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val
};

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset]
};

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | (this[offset + 1] << 8)
};

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return (this[offset] << 8) | this[offset + 1]
};

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
};

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
};

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var val = this[offset];
  var mul = 1;
  var i = 0;
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);

  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }
  mul *= 0x80;

  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

  return val
};

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
};

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | (this[offset + 1] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | (this[offset] << 8);
  return (val & 0x8000) ? val | 0xFFFF0000 : val
};

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
};

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
};

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, true, 23, 4)
};

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return read(this, offset, false, 23, 4)
};

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, true, 52, 8)
};

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return read(this, offset, false, 52, 8)
};

function checkInt (buf, value, offset, ext, max, min) {
  if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = (value & 0xff);
  return offset + 1
};

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24);
    this[offset + 2] = (value >>> 16);
    this[offset + 1] = (value >>> 8);
    this[offset] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);

    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
  }

  return offset + byteLength
};

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = (value & 0xff);
  return offset + 1
};

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
  } else {
    objectWriteUInt16(this, value, offset, true);
  }
  return offset + 2
};

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8);
    this[offset + 1] = (value & 0xff);
  } else {
    objectWriteUInt16(this, value, offset, false);
  }
  return offset + 2
};

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff);
    this[offset + 1] = (value >>> 8);
    this[offset + 2] = (value >>> 16);
    this[offset + 3] = (value >>> 24);
  } else {
    objectWriteUInt32(this, value, offset, true);
  }
  return offset + 4
};

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24);
    this[offset + 1] = (value >>> 16);
    this[offset + 2] = (value >>> 8);
    this[offset + 3] = (value & 0xff);
  } else {
    objectWriteUInt32(this, value, offset, false);
  }
  return offset + 4
};

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }
  write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
};

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
};

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }
  write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
};

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start;

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length;
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    );
  }

  return len
};

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0);
      if (code < 256) {
        val = code;
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;

  if (!val) val = 0;

  var i;
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = internalIsBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this
};

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '');
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '=';
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i);

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue
        }

        // valid lead
        leadSurrogate = codePoint;

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null;

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      );
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo;
  var byteArray = [];
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray
}


function base64ToBytes (str) {
  return toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i];
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


// the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
function isBuffer(obj) {
  return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj))
}

function isFastBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0))
}

var inherits;
if (typeof Object.create === 'function'){
  inherits = function inherits(ctor, superCtor) {
    // implementation from standard node.js 'util' module
    ctor.super_ = superCtor;
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  inherits = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  };
}
var inherits$1 = inherits;

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.






/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect$1(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    _extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect$1.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect$1.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect$1.styles[styleType];

  if (style) {
    return '\u001b[' + inspect$1.colors[style][0] + 'm' + str +
           '\u001b[' + inspect$1.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== inspect$1 &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray$2(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty$1(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty$1(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray$2(ar) {
  return Array.isArray(ar);
}

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

function isNull(arg) {
  return arg === null;
}



function isNumber(arg) {
  return typeof arg === 'number';
}

function isString(arg) {
  return typeof arg === 'string';
}



function isUndefined(arg) {
  return arg === void 0;
}

function isRegExp(re) {
  return isObject$1(re) && objectToString(re) === '[object RegExp]';
}

function isObject$1(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isDate(d) {
  return isObject$1(d) && objectToString(d) === '[object Date]';
}

function isError(e) {
  return isObject$1(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}

function isFunction(arg) {
  return typeof arg === 'function';
}

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}



function objectToString(o) {
  return Object.prototype.toString.call(o);
}


// log is just a thin wrapper to console.log that prepends a timestamp



/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
function _extend(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject$1(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
}

function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }
  if (y < x) {
    return 1;
  }
  return 0;
}
var hasOwn = Object.prototype.hasOwnProperty;

var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }
  return keys;
};
// based on node assert, original notice:

// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
var pSlice = Array.prototype.slice;
var _functionsHaveNames;
function functionsHaveNames() {
  if (typeof _functionsHaveNames !== 'undefined') {
    return _functionsHaveNames;
  }
  return _functionsHaveNames = (function () {
    return function foo() {}.name === 'foo';
  }());
}
function pToString (obj) {
  return Object.prototype.toString.call(obj);
}
function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }
  if (typeof global$1.ArrayBuffer !== 'function') {
    return false;
  }
  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }
  if (!arrbuf) {
    return false;
  }
  if (arrbuf instanceof DataView) {
    return true;
  }
  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }
  return false;
}
// 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.

function assert$1(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
// 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/;
// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js
function getName(func) {
  if (!isFunction(func)) {
    return;
  }
  if (functionsHaveNames()) {
    return func.name;
  }
  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}
assert$1.AssertionError = AssertionError;
function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;
  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }
  var stackStartFunction = options.stackStartFunction || fail;
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();
    if (err.stack) {
      var out = err.stack;

      // try to strip useless frames
      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);
      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}

// assert.AssertionError instanceof Error
inherits$1(AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}
function inspect$$1(something) {
  if (functionsHaveNames() || !isFunction(something)) {
    return inspect$1(something);
  }
  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' +  name + ']';
}
function getMessage(self) {
  return truncate(inspect$$1(self.actual), 128) + ' ' +
         self.operator + ' ' +
         truncate(inspect$$1(self.expected), 128);
}

// At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.

// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.

function fail(actual, expected, message, operator, stackStartFunction) {
  throw new AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
}

// EXTENSION! allows for well behaved errors defined elsewhere.
assert$1.fail = fail;

// 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', ok);
}
assert$1.ok = ok;
// 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);
assert$1.equal = equal;
function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', equal);
}

// 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);
assert$1.notEqual = notEqual;
function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', notEqual);
  }
}

// 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);
assert$1.deepEqual = deepEqual;
function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', deepEqual);
  }
}
assert$1.deepStrictEqual = deepStrictEqual;
function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', deepStrictEqual);
  }
}

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0;

  // 7.2. If the expected value is a Date object, the actual value is
  // equivalent if it is also a Date object that refers to the same time.
  } else if (isDate(actual) && isDate(expected)) {
    return actual.getTime() === expected.getTime();

  // 7.3 If the expected value is a RegExp object, the actual value is
  // equivalent if it is also a RegExp object with the same source and
  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (isRegExp(actual) && isRegExp(expected)) {
    return actual.source === expected.source &&
           actual.global === expected.global &&
           actual.multiline === expected.multiline &&
           actual.lastIndex === expected.lastIndex &&
           actual.ignoreCase === expected.ignoreCase;

  // 7.4. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') &&
             (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected;

  // If both values are instances of typed arrays, wrap their underlying
  // ArrayBuffers in a Buffer each to increase performance
  // This optimization requires the arrays to have the same type as checked by
  // Object.prototype.toString (aka pToString). Never perform binary
  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
  // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) &&
             pToString(actual) === pToString(expected) &&
             !(actual instanceof Float32Array ||
               actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer),
                   new Uint8Array(expected.buffer)) === 0;

  // 7.5 For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {actual: [], expected: []};

    var actualIndex = memos.actual.indexOf(actual);
    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);

    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined)
    return false;
  // if one is a primitive, the other must be same
  if (isPrimitive(a) || isPrimitive(b))
    return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))
    return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))
    return false;
  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }
  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i;
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length !== kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))
      return false;
  }
  return true;
}

// 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);
assert$1.notDeepEqual = notDeepEqual;
function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', notDeepEqual);
  }
}

assert$1.notDeepStrictEqual = notDeepStrictEqual;
function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
}


// 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);
assert$1.strictEqual = strictEqual;
function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', strictEqual);
  }
}

// 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);
assert$1.notStrictEqual = notStrictEqual;
function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', notStrictEqual);
  }
}

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {
    // Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;
  try {
    block();
  } catch (e) {
    error = e;
  }
  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);

  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +
            (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if ((isUnwantedException &&
      userProvidedMessage &&
      expectedException(actual, expected)) ||
      isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if ((shouldThrow && actual && expected &&
      !expectedException(actual, expected)) || (!shouldThrow && actual)) {
    throw actual;
  }
}

// 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);
assert$1.throws = throws;
function throws(block, /*optional*/error, /*optional*/message) {
  _throws(true, block, error, message);
}

// EXTENSION! This is annoying to write outside this module.
assert$1.doesNotThrow = doesNotThrow;
function doesNotThrow(block, /*optional*/error, /*optional*/message) {
  _throws(false, block, error, message);
}

assert$1.ifError = ifError;
function ifError(err) {
  if (err) throw err;
}


var assert$3 = Object.freeze({
	default: assert$1,
	AssertionError: AssertionError,
	fail: fail,
	ok: ok,
	assert: ok,
	equal: equal,
	notEqual: notEqual,
	deepEqual: deepEqual,
	deepStrictEqual: deepStrictEqual,
	notDeepEqual: notDeepEqual,
	notDeepStrictEqual: notDeepStrictEqual,
	strictEqual: strictEqual,
	notStrictEqual: notStrictEqual,
	throws: throws,
	doesNotThrow: doesNotThrow,
	ifError: ifError
});

var Ap = Array.prototype;
var slice = Ap.slice;
var Op = Object.prototype;
var objToStr = Op.toString;
var funObjStr = objToStr.call(function(){});
var strObjStr = objToStr.call("");
var hasOwn$1 = Op.hasOwnProperty;

var types$1 = function () {

    var exports = {};

    // A type is an object with a .check method that takes a value and returns
    // true or false according to whether the value matches the type.

    function Type(check, name) {
        var self = this;
        if (!(self instanceof Type)) {
            throw new Error("Type constructor cannot be invoked without 'new'");
        }

        // Unfortunately we can't elegantly reuse isFunction and isString,
        // here, because this code is executed while defining those types.
        if (objToStr.call(check) !== funObjStr) {
            throw new Error(check + " is not a function");
        }

        // The `name` parameter can be either a function or a string.
        var nameObjStr = objToStr.call(name);
        if (!(nameObjStr === funObjStr ||
          nameObjStr === strObjStr)) {
            throw new Error(name + " is neither a function nor a string");
        }

        Object.defineProperties(self, {
            name: {value: name},
            check: {
                value: function (value, deep) {
                    var result = check.call(self, value, deep);
                    if (!result && deep && objToStr.call(deep) === funObjStr)
                        deep(self, value);
                    return result;
                }
            }
        });
    }

    var Tp = Type.prototype;

    // Throughout this file we use Object.defineProperty to prevent
    // redefinition of exported properties.
    exports.Type = Type;

    // Like .check, except that failure triggers an AssertionError.
    Tp.assert = function (value, deep) {
        if (!this.check(value, deep)) {
            var str = shallowStringify(value);
            throw new Error(str + " does not match type " + this);
        }
        return true;
    };

    function shallowStringify(value) {
        if (isObject.check(value))
            return "{" + Object.keys(value).map(function (key) {
                  return key + ": " + value[key];
              }).join(", ") + "}";

        if (isArray.check(value))
            return "[" + value.map(shallowStringify).join(", ") + "]";

        return JSON.stringify(value);
    }

    Tp.toString = function () {
        var name = this.name;

        if (isString.check(name))
            return name;

        if (isFunction.check(name))
            return name.call(this) + "";

        return name + " type";
    };

    var builtInCtorFns = [];
    var builtInCtorTypes = [];
    var builtInTypes = {};
    exports.builtInTypes = builtInTypes;

    function defBuiltInType(example, name) {
        var objStr = objToStr.call(example);

        var type = new Type(function (value) {
            return objToStr.call(value) === objStr;
        }, name);

        builtInTypes[name] = type;

        if (example && typeof example.constructor === "function") {
            builtInCtorFns.push(example.constructor);
            builtInCtorTypes.push(type);
        }

        return type;
    }

    // These types check the underlying [[Class]] attribute of the given
    // value, rather than using the problematic typeof operator. Note however
    // that no subtyping is considered; so, for instance, isObject.check
    // returns false for [], /./, new Date, and null.
    var isString = defBuiltInType("truthy", "string");
    var isFunction = defBuiltInType(function () {}, "function");
    var isArray = defBuiltInType([], "array");
    var isObject = defBuiltInType({}, "object");
    var isRegExp = defBuiltInType(/./, "RegExp");
    var isDate = defBuiltInType(new Date, "Date");
    var isNumber = defBuiltInType(3, "number");
    var isBoolean = defBuiltInType(true, "boolean");
    var isNull = defBuiltInType(null, "null");
    var isUndefined = defBuiltInType(void 0, "undefined");

    // There are a number of idiomatic ways of expressing types, so this
    // function serves to coerce them all to actual Type objects. Note that
    // providing the name argument is not necessary in most cases.
    function toType(from, name) {
        // The toType function should of course be idempotent.
        if (from instanceof Type)
            return from;

        // The Def type is used as a helper for constructing compound
        // interface types for AST nodes.
        if (from instanceof Def)
            return from.type;

        // Support [ElemType] syntax.
        if (isArray.check(from))
            return Type.fromArray(from);

        // Support { someField: FieldType, ... } syntax.
        if (isObject.check(from))
            return Type.fromObject(from);

        if (isFunction.check(from)) {
            var bicfIndex = builtInCtorFns.indexOf(from);
            if (bicfIndex >= 0) {
                return builtInCtorTypes[bicfIndex];
            }

            // If isFunction.check(from), and from is not a built-in
            // constructor, assume from is a binary predicate function we can
            // use to define the type.
            return new Type(from, name);
        }

        // As a last resort, toType returns a type that matches any value that
        // is === from. This is primarily useful for literal values like
        // toType(null), but it has the additional advantage of allowing
        // toType to be a total function.
        return new Type(function (value) {
            return value === from;
        }, isUndefined.check(name) ? function () {
            return from + "";
        } : name);
    }

    // Returns a type that matches the given value iff any of type1, type2,
    // etc. match the value.
    Type.or = function (/* type1, type2, ... */) {
        var types = [];
        var len = arguments.length;
        for (var i = 0; i < len; ++i)
            types.push(toType(arguments[i]));

        return new Type(function (value, deep) {
            for (var i = 0; i < len; ++i)
                if (types[i].check(value, deep))
                    return true;
            return false;
        }, function () {
            return types.join(" | ");
        });
    };

    Type.fromArray = function (arr) {
        if (!isArray.check(arr)) {
            throw new Error("");
        }
        if (arr.length !== 1) {
            throw new Error("only one element type is permitted for typed arrays");
        }
        return toType(arr[0]).arrayOf();
    };

    Tp.arrayOf = function () {
        var elemType = this;
        return new Type(function (value, deep) {
            return isArray.check(value) && value.every(function (elem) {
                  return elemType.check(elem, deep);
              });
        }, function () {
            return "[" + elemType + "]";
        });
    };

    Type.fromObject = function (obj) {
        var fields = Object.keys(obj).map(function (name) {
            return new Field(name, obj[name]);
        });

        return new Type(function (value, deep) {
            return isObject.check(value) && fields.every(function (field) {
                  return field.type.check(value[field.name], deep);
              });
        }, function () {
            return "{ " + fields.join(", ") + " }";
        });
    };

    function Field(name, type, defaultFn, hidden) {
        var self = this;

        if (!(self instanceof Field)) {
            throw new Error("Field constructor cannot be invoked without 'new'");
        }
        isString.assert(name);

        type = toType(type);

        var properties = {
            name: {value: name},
            type: {value: type},
            hidden: {value: !!hidden}
        };

        if (isFunction.check(defaultFn)) {
            properties.defaultFn = {value: defaultFn};
        }

        Object.defineProperties(self, properties);
    }

    var Fp = Field.prototype;

    Fp.toString = function () {
        return JSON.stringify(this.name) + ": " + this.type;
    };

    Fp.getValue = function (obj) {
        var value = obj[this.name];

        if (!isUndefined.check(value))
            return value;

        if (this.defaultFn)
            value = this.defaultFn.call(obj);

        return value;
    };

    // Define a type whose name is registered in a namespace (the defCache) so
    // that future definitions will return the same type given the same name.
    // In particular, this system allows for circular and forward definitions.
    // The Def object d returned from Type.def may be used to configure the
    // type d.type by calling methods such as d.bases, d.build, and d.field.
    Type.def = function (typeName) {
        isString.assert(typeName);
        return hasOwn$1.call(defCache, typeName)
          ? defCache[typeName]
          : defCache[typeName] = new Def(typeName);
    };

    // In order to return the same Def instance every time Type.def is called
    // with a particular name, those instances need to be stored in a cache.
    var defCache = Object.create(null);

    function Def(typeName) {
        var self = this;
        if (!(self instanceof Def)) {
            throw new Error("Def constructor cannot be invoked without 'new'");
        }

        Object.defineProperties(self, {
            typeName: {value: typeName},
            baseNames: {value: []},
            ownFields: {value: Object.create(null)},

            // These two are populated during finalization.
            allSupertypes: {value: Object.create(null)}, // Includes own typeName.
            supertypeList: {value: []}, // Linear inheritance hierarchy.
            allFields: {value: Object.create(null)}, // Includes inherited fields.
            fieldNames: {value: []}, // Non-hidden keys of allFields.

            type: {
                value: new Type(function (value, deep) {
                    return self.check(value, deep);
                }, typeName)
            }
        });
    }

    Def.fromValue = function (value) {
        if (value && typeof value === "object") {
            var type = value.type;
            if (typeof type === "string" &&
              hasOwn$1.call(defCache, type)) {
                var d = defCache[type];
                if (d.finalized) {
                    return d;
                }
            }
        }

        return null;
    };

    var Dp = Def.prototype;

    Dp.isSupertypeOf = function (that) {
        if (that instanceof Def) {
            if (this.finalized !== true ||
              that.finalized !== true) {
                throw new Error("");
            }
            return hasOwn$1.call(that.allSupertypes, this.typeName);
        } else {
            throw new Error(that + " is not a Def");
        }
    };

    // Note that the list returned by this function is a copy of the internal
    // supertypeList, *without* the typeName itself as the first element.
    exports.getSupertypeNames = function (typeName) {
        if (!hasOwn$1.call(defCache, typeName)) {
            throw new Error("");
        }
        var d = defCache[typeName];
        if (d.finalized !== true) {
            throw new Error("");
        }
        return d.supertypeList.slice(1);
    };

    // Returns an object mapping from every known type in the defCache to the
    // most specific supertype whose name is an own property of the candidates
    // object.
    exports.computeSupertypeLookupTable = function (candidates) {
        var table = {};
        var typeNames = Object.keys(defCache);
        var typeNameCount = typeNames.length;

        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("" + typeName);
            }
            for (var j = 0; j < d.supertypeList.length; ++j) {
                var superTypeName = d.supertypeList[j];
                if (hasOwn$1.call(candidates, superTypeName)) {
                    table[typeName] = superTypeName;
                    break;
                }
            }
        }

        return table;
    };

    Dp.checkAllFields = function (value, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
            throw new Error("" + this.typeName);
        }

        function checkFieldByName(name) {
            var field = allFields[name];
            var type = field.type;
            var child = field.getValue(value);
            return type.check(child, deep);
        }

        return isObject.check(value)
          && Object.keys(allFields).every(checkFieldByName);
    };

    Dp.check = function (value, deep) {
        if (this.finalized !== true) {
            throw new Error(
              "prematurely checking unfinalized type " + this.typeName
            );
        }

        // A Def type can only match an object value.
        if (!isObject.check(value))
            return false;

        var vDef = Def.fromValue(value);
        if (!vDef) {
            // If we couldn't infer the Def associated with the given value,
            // and we expected it to be a SourceLocation or a Position, it was
            // probably just missing a "type" field (because Esprima does not
            // assign a type property to such nodes). Be optimistic and let
            // this.checkAllFields make the final decision.
            if (this.typeName === "SourceLocation" ||
              this.typeName === "Position") {
                return this.checkAllFields(value, deep);
            }

            // Calling this.checkAllFields for any other type of node is both
            // bad for performance and way too forgiving.
            return false;
        }

        // If checking deeply and vDef === this, then we only need to call
        // checkAllFields once. Calling checkAllFields is too strict when deep
        // is false, because then we only care about this.isSupertypeOf(vDef).
        if (deep && vDef === this)
            return this.checkAllFields(value, deep);

        // In most cases we rely exclusively on isSupertypeOf to make O(1)
        // subtyping determinations. This suffices in most situations outside
        // of unit tests, since interface conformance is checked whenever new
        // instances are created using builder functions.
        if (!this.isSupertypeOf(vDef))
            return false;

        // The exception is when deep is true; then, we recursively check all
        // fields.
        if (!deep)
            return true;

        // Use the more specific Def (vDef) to perform the deep check, but
        // shallow-check fields defined by the less specific Def (this).
        return vDef.checkAllFields(value, deep)
          && this.checkAllFields(value, false);
    };

    Dp.bases = function () {
        var args = slice.call(arguments);
        var bases = this.baseNames;

        if (this.finalized) {
            if (args.length !== bases.length) {
                throw new Error("");
            }
            for (var i = 0; i < args.length; i++) {
                if (args[i] !== bases[i]) {
                    throw new Error("");
                }
            }
            return this;
        }

        args.forEach(function (baseName) {
            isString.assert(baseName);

            // This indexOf lookup may be O(n), but the typical number of base
            // names is very small, and indexOf is a native Array method.
            if (bases.indexOf(baseName) < 0)
                bases.push(baseName);
        });

        return this; // For chaining.
    };

    // False by default until .build(...) is called on an instance.
    Object.defineProperty(Dp, "buildable", {value: false});

    var builders = {};
    exports.builders = builders;

    // This object is used as prototype for any node created by a builder.
    var nodePrototype = {};

    // Call this function to define a new method to be shared by all AST
     // nodes. The replaced method (if any) is returned for easy wrapping.
    exports.defineMethod = function (name, func) {
        var old = nodePrototype[name];

        // Pass undefined as func to delete nodePrototype[name].
        if (isUndefined.check(func)) {
            delete nodePrototype[name];

        } else {
            isFunction.assert(func);

            Object.defineProperty(nodePrototype, name, {
                enumerable: true, // For discoverability.
                configurable: true, // For delete proto[name].
                value: func
            });
        }

        return old;
    };

    var isArrayOfString = isString.arrayOf();

    // Calling the .build method of a Def simultaneously marks the type as
    // buildable (by defining builders[getBuilderName(typeName)]) and
    // specifies the order of arguments that should be passed to the builder
    // function to create an instance of the type.
    Dp.build = function (/* param1, param2, ... */) {
        var self = this;

        var newBuildParams = slice.call(arguments);
        isArrayOfString.assert(newBuildParams);

        // Calling Def.prototype.build multiple times has the effect of merely
        // redefining this property.
        Object.defineProperty(self, "buildParams", {
            value: newBuildParams,
            writable: false,
            enumerable: false,
            configurable: true
        });

        if (self.buildable) {
            // If this Def is already buildable, update self.buildParams and
            // continue using the old builder function.
            return self;
        }

        // Every buildable type will have its "type" field filled in
        // automatically. This includes types that are not subtypes of Node,
        // like SourceLocation, but that seems harmless (TODO?).
        self.field("type", String, function () { return self.typeName });

        // Override Dp.buildable for this Def instance.
        Object.defineProperty(self, "buildable", {value: true});

        Object.defineProperty(builders, getBuilderName(self.typeName), {
            enumerable: true,

            value: function () {
                var args = arguments;
                var argc = args.length;
                var built = Object.create(nodePrototype);

                if (!self.finalized) {
                    throw new Error(
                      "attempting to instantiate unfinalized type " +
                      self.typeName
                    );
                }

                function add(param, i) {
                    if (hasOwn$1.call(built, param))
                        return;

                    var all = self.allFields;
                    if (!hasOwn$1.call(all, param)) {
                        throw new Error("" + param);
                    }

                    var field = all[param];
                    var type = field.type;
                    var value;

                    if (isNumber.check(i) && i < argc) {
                        value = args[i];
                    } else if (field.defaultFn) {
                        // Expose the partially-built object to the default
                        // function as its `this` object.
                        value = field.defaultFn.call(built);
                    } else {
                        var message = "no value or default function given for field " +
                          JSON.stringify(param) + " of " + self.typeName + "(" +
                          self.buildParams.map(function (name) {
                              return all[name];
                          }).join(", ") + ")";
                        throw new Error(message);
                    }

                    if (!type.check(value)) {
                        throw new Error(
                          shallowStringify(value) +
                          " does not match field " + field +
                          " of type " + self.typeName
                        );
                    }

                    // TODO Could attach getters and setters here to enforce
                    // dynamic type safety.
                    built[param] = value;
                }

                self.buildParams.forEach(function (param, i) {
                    add(param, i);
                });

                Object.keys(self.allFields).forEach(function (param) {
                    add(param); // Use the default value.
                });

                // Make sure that the "type" field was filled automatically.
                if (built.type !== self.typeName) {
                    throw new Error("");
                }

                return built;
            }
        });

        return self; // For chaining.
    };

    function getBuilderName(typeName) {
        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {
            var len = upperCasePrefix.length;
            switch (len) {
                case 0: return "";
                // If there's only one initial capital letter, just lower-case it.
                case 1: return upperCasePrefix.toLowerCase();
                default:
                    // If there's more than one initial capital letter, lower-case
                    // all but the last one, so that XMLDefaultDeclaration (for
                    // example) becomes xmlDefaultDeclaration.
                    return upperCasePrefix.slice(
                        0, len - 1).toLowerCase() +
                      upperCasePrefix.charAt(len - 1);
            }
        });
    }
    exports.getBuilderName = getBuilderName;

    function getStatementBuilderName(typeName) {
        typeName = getBuilderName(typeName);
        return typeName.replace(/(Expression)?$/, "Statement");
    }
    exports.getStatementBuilderName = getStatementBuilderName;

    // The reason fields are specified using .field(...) instead of an object
    // literal syntax is somewhat subtle: the object literal syntax would
    // support only one key and one value, but with .field(...) we can pass
    // any number of arguments to specify the field.
    Dp.field = function (name, type, defaultFn, hidden) {
        if (this.finalized) {
            console.error("Ignoring attempt to redefine field " +
              JSON.stringify(name) + " of finalized type " +
              JSON.stringify(this.typeName));
            return this;
        }
        this.ownFields[name] = new Field(name, type, defaultFn, hidden);
        return this; // For chaining.
    };

    var namedTypes = {};
    exports.namedTypes = namedTypes;

    // Like Object.keys, but aware of what fields each AST type should have.
    function getFieldNames(object) {
        var d = Def.fromValue(object);
        if (d) {
            return d.fieldNames.slice(0);
        }

        if ("type" in object) {
            throw new Error(
              "did not recognize object of type " +
              JSON.stringify(object.type)
            );
        }

        return Object.keys(object);
    }
    exports.getFieldNames = getFieldNames;

    // Get the value of an object property, taking object.type and default
    // functions into account.
    function getFieldValue(object, fieldName) {
        var d = Def.fromValue(object);
        if (d) {
            var field = d.allFields[fieldName];
            if (field) {
                return field.getValue(object);
            }
        }

        return object && object[fieldName];
    }
    exports.getFieldValue = getFieldValue;

    // Iterate over all defined fields of an object, including those missing
    // or undefined, passing each field name and effective value (as returned
    // by getFieldValue) to the callback. If the object has no corresponding
    // Def, the callback will never be called.
    exports.eachField = function (object, callback, context) {
        getFieldNames(object).forEach(function (name) {
            callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // Similar to eachField, except that iteration stops as soon as the
    // callback returns a truthy value. Like Array.prototype.some, the final
    // result is either true or false to indicates whether the callback
    // returned true for any element or not.
    exports.someField = function (object, callback, context) {
        return getFieldNames(object).some(function (name) {
            return callback.call(this, name, getFieldValue(object, name));
        }, context);
    };

    // This property will be overridden as true by individual Def instances
    // when they are finalized.
    Object.defineProperty(Dp, "finalized", {value: false});

    Dp.finalize = function () {
        var self = this;

        // It's not an error to finalize a type more than once, but only the
        // first call to .finalize does anything.
        if (!self.finalized) {
            var allFields = self.allFields;
            var allSupertypes = self.allSupertypes;

            self.baseNames.forEach(function (name) {
                var def = defCache[name];
                if (def instanceof Def) {
                    def.finalize();
                    extend(allFields, def.allFields);
                    extend(allSupertypes, def.allSupertypes);
                } else {
                    var message = "unknown supertype name " +
                      JSON.stringify(name) +
                      " for subtype " +
                      JSON.stringify(self.typeName);
                    throw new Error(message);
                }
            });

            // TODO Warn if fields are overridden with incompatible types.
            extend(allFields, self.ownFields);
            allSupertypes[self.typeName] = self;

            self.fieldNames.length = 0;
            for (var fieldName in allFields) {
                if (hasOwn$1.call(allFields, fieldName) &&
                    !allFields[fieldName].hidden) {
                        self.fieldNames.push(fieldName);
                }
            }

            // Types are exported only once they have been finalized.
            Object.defineProperty(namedTypes, self.typeName, {
                enumerable: true,
                value: self.type
            });

            Object.defineProperty(self, "finalized", {value: true});

            // A linearization of the inheritance hierarchy.
            populateSupertypeList(self.typeName, self.supertypeList);

            if (self.buildable && self.supertypeList.lastIndexOf("Expression") >= 0) {
                wrapExpressionBuilderWithStatement(self.typeName);
            }
        }
    };

    // Adds an additional builder for Expression subtypes
    // that wraps the built Expression in an ExpressionStatements.
    function wrapExpressionBuilderWithStatement(typeName) {
        var wrapperName = getStatementBuilderName(typeName);

        // skip if the builder already exists
        if (builders[wrapperName]) return;

        // the builder function to wrap with builders.ExpressionStatement
        var wrapped = builders[getBuilderName(typeName)];

        // skip if there is nothing to wrap
        if (!wrapped) return;

        builders[wrapperName] = function () {
            return builders.expressionStatement(wrapped.apply(builders, arguments));
        };
    }

    function populateSupertypeList(typeName, list) {
        list.length = 0;
        list.push(typeName);

        var lastSeen = Object.create(null);

        for (var pos = 0; pos < list.length; ++pos) {
            typeName = list[pos];
            var d = defCache[typeName];
            if (d.finalized !== true) {
                throw new Error("");
            }

            // If we saw typeName earlier in the breadth-first traversal,
            // delete the last-seen occurrence.
            if (hasOwn$1.call(lastSeen, typeName)) {
                delete list[lastSeen[typeName]];
            }

            // Record the new index of the last-seen occurrence of typeName.
            lastSeen[typeName] = pos;

            // Enqueue the base names of this type.
            list.push.apply(list, d.baseNames);
        }

        // Compaction loop to remove array holes.
        for (var to = 0, from = to, len = list.length; from < len; ++from) {
            if (hasOwn$1.call(list, from)) {
                list[to++] = list[from];
            }
        }

        list.length = to;
    }

    function extend(into, from) {
        Object.keys(from).forEach(function (name) {
            into[name] = from[name];
        });

        return into;
    }

    exports.finalize = function () {
        Object.keys(defCache).forEach(function (name) {
            defCache[name].finalize();
        });
    };

    return exports;
};

var equiv = function (fork) {
    var types = fork.use(types$1);
    var getFieldNames = types.getFieldNames;
    var getFieldValue = types.getFieldValue;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isDate = types.builtInTypes.Date;
    var isRegExp = types.builtInTypes.RegExp;
    var hasOwn = Object.prototype.hasOwnProperty;

    function astNodesAreEquivalent(a, b, problemPath) {
        if (isArray.check(problemPath)) {
            problemPath.length = 0;
        } else {
            problemPath = null;
        }

        return areEquivalent(a, b, problemPath);
    }

    astNodesAreEquivalent.assert = function (a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath)) {
            if (problemPath.length === 0) {
                if (a !== b) {
                    throw new Error("Nodes must be equal");
                }
            } else {
                throw new Error(
                  "Nodes differ in the following path: " +
                  problemPath.map(subscriptForProperty).join("")
                );
            }
        }
    };

    function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
            return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
    }

    function areEquivalent(a, b, problemPath) {
        if (a === b) {
            return true;
        }

        if (isArray.check(a)) {
            return arraysAreEquivalent(a, b, problemPath);
        }

        if (isObject.check(a)) {
            return objectsAreEquivalent(a, b, problemPath);
        }

        if (isDate.check(a)) {
            return isDate.check(b) && (+a === +b);
        }

        if (isRegExp.check(a)) {
            return isRegExp.check(b) && (
                a.source === b.source &&
                a.global === b.global &&
                a.multiline === b.multiline &&
                a.ignoreCase === b.ignoreCase
              );
        }

        return a == b;
    }

    function arraysAreEquivalent(a, b, problemPath) {
        isArray.assert(a);
        var aLength = a.length;

        if (!isArray.check(b) || b.length !== aLength) {
            if (problemPath) {
                problemPath.push("length");
            }
            return false;
        }

        for (var i = 0; i < aLength; ++i) {
            if (problemPath) {
                problemPath.push(i);
            }

            if (i in a !== i in b) {
                return false;
            }

            if (!areEquivalent(a[i], b[i], problemPath)) {
                return false;
            }

            if (problemPath) {
                var problemPathTail = problemPath.pop();
                if (problemPathTail !== i) {
                    throw new Error("" + problemPathTail);
                }
            }
        }

        return true;
    }

    function objectsAreEquivalent(a, b, problemPath) {
        isObject.assert(a);
        if (!isObject.check(b)) {
            return false;
        }

        // Fast path for a common property of AST nodes.
        if (a.type !== b.type) {
            if (problemPath) {
                problemPath.push("type");
            }
            return false;
        }

        var aNames = getFieldNames(a);
        var aNameCount = aNames.length;

        var bNames = getFieldNames(b);
        var bNameCount = bNames.length;

        if (aNameCount === bNameCount) {
            for (var i = 0; i < aNameCount; ++i) {
                var name = aNames[i];
                var aChild = getFieldValue(a, name);
                var bChild = getFieldValue(b, name);

                if (problemPath) {
                    problemPath.push(name);
                }

                if (!areEquivalent(aChild, bChild, problemPath)) {
                    return false;
                }

                if (problemPath) {
                    var problemPathTail = problemPath.pop();
                    if (problemPathTail !== name) {
                        throw new Error("" + problemPathTail);
                    }
                }
            }

            return true;
        }

        if (!problemPath) {
            return false;
        }

        // Since aNameCount !== bNameCount, we need to find some name that's
        // missing in aNames but present in bNames, or vice-versa.

        var seenNames = Object.create(null);

        for (i = 0; i < aNameCount; ++i) {
            seenNames[aNames[i]] = true;
        }

        for (i = 0; i < bNameCount; ++i) {
            name = bNames[i];

            if (!hasOwn.call(seenNames, name)) {
                problemPath.push(name);
                return false;
            }

            delete seenNames[name];
        }

        for (name in seenNames) {
            problemPath.push(name);
            break;
        }

        return false;
    }
    
    return astNodesAreEquivalent;
};

var Op$1 = Object.prototype;
var hasOwn$2 = Op$1.hasOwnProperty;

var path = function (fork) {
    var types = fork.use(types$1);
    var isArray = types.builtInTypes.array;
    var isNumber = types.builtInTypes.number;

    function Path(value, parentPath, name) {
        if (!(this instanceof Path)) {
            throw new Error("Path constructor cannot be invoked without 'new'");
        }

        if (parentPath) {
            if (!(parentPath instanceof Path)) {
                throw new Error("");
            }
        } else {
            parentPath = null;
            name = null;
        }

        // The value encapsulated by this Path, generally equal to
        // parentPath.value[name] if we have a parentPath.
        this.value = value;

        // The immediate parent Path of this Path.
        this.parentPath = parentPath;

        // The name of the property of parentPath.value through which this
        // Path's value was reached.
        this.name = name;

        // Calling path.get("child") multiple times always returns the same
        // child Path object, for both performance and consistency reasons.
        this.__childCache = null;
    }

    var Pp = Path.prototype;

    function getChildCache(path) {
        // Lazily create the child cache. This also cheapens cache
        // invalidation, since you can just reset path.__childCache to null.
        return path.__childCache || (path.__childCache = Object.create(null));
    }

    function getChildPath(path, name) {
        var cache = getChildCache(path);
        var actualChildValue = path.getValueProperty(name);
        var childPath = cache[name];
        if (!hasOwn$2.call(cache, name) ||
          // Ensure consistency between cache and reality.
          childPath.value !== actualChildValue) {
            childPath = cache[name] = new path.constructor(
              actualChildValue, path, name
            );
        }
        return childPath;
    }

// This method is designed to be overridden by subclasses that need to
// handle missing properties, etc.
    Pp.getValueProperty = function getValueProperty(name) {
        return this.value[name];
    };

    Pp.get = function get(name) {
        var path = this;
        var names = arguments;
        var count = names.length;

        for (var i = 0; i < count; ++i) {
            path = getChildPath(path, names[i]);
        }

        return path;
    };

    Pp.each = function each(callback, context) {
        var childPaths = [];
        var len = this.value.length;
        var i = 0;

        // Collect all the original child paths before invoking the callback.
        for (var i = 0; i < len; ++i) {
            if (hasOwn$2.call(this.value, i)) {
                childPaths[i] = this.get(i);
            }
        }

        // Invoke the callback on just the original child paths, regardless of
        // any modifications made to the array by the callback. I chose these
        // semantics over cleverly invoking the callback on new elements because
        // this way is much easier to reason about.
        context = context || this;
        for (i = 0; i < len; ++i) {
            if (hasOwn$2.call(childPaths, i)) {
                callback.call(context, childPaths[i]);
            }
        }
    };

    Pp.map = function map(callback, context) {
        var result = [];

        this.each(function (childPath) {
            result.push(callback.call(this, childPath));
        }, context);

        return result;
    };

    Pp.filter = function filter(callback, context) {
        var result = [];

        this.each(function (childPath) {
            if (callback.call(this, childPath)) {
                result.push(childPath);
            }
        }, context);

        return result;
    };

    function emptyMoves() {}
    function getMoves(path, offset, start, end) {
        isArray.assert(path.value);

        if (offset === 0) {
            return emptyMoves;
        }

        var length = path.value.length;
        if (length < 1) {
            return emptyMoves;
        }

        var argc = arguments.length;
        if (argc === 2) {
            start = 0;
            end = length;
        } else if (argc === 3) {
            start = Math.max(start, 0);
            end = length;
        } else {
            start = Math.max(start, 0);
            end = Math.min(end, length);
        }

        isNumber.assert(start);
        isNumber.assert(end);

        var moves = Object.create(null);
        var cache = getChildCache(path);

        for (var i = start; i < end; ++i) {
            if (hasOwn$2.call(path.value, i)) {
                var childPath = path.get(i);
                if (childPath.name !== i) {
                    throw new Error("");
                }
                var newIndex = i + offset;
                childPath.name = newIndex;
                moves[newIndex] = childPath;
                delete cache[i];
            }
        }

        delete cache.length;

        return function () {
            for (var newIndex in moves) {
                var childPath = moves[newIndex];
                if (childPath.name !== +newIndex) {
                    throw new Error("");
                }
                cache[newIndex] = childPath;
                path.value[newIndex] = childPath.value;
            }
        };
    }

    Pp.shift = function shift() {
        var move = getMoves(this, -1);
        var result = this.value.shift();
        move();
        return result;
    };

    Pp.unshift = function unshift(node) {
        var move = getMoves(this, arguments.length);
        var result = this.value.unshift.apply(this.value, arguments);
        move();
        return result;
    };

    Pp.push = function push(node) {
        isArray.assert(this.value);
        delete getChildCache(this).length;
        return this.value.push.apply(this.value, arguments);
    };

    Pp.pop = function pop() {
        isArray.assert(this.value);
        var cache = getChildCache(this);
        delete cache[this.value.length - 1];
        delete cache.length;
        return this.value.pop();
    };

    Pp.insertAt = function insertAt(index, node) {
        var argc = arguments.length;
        var move = getMoves(this, argc - 1, index);
        if (move === emptyMoves) {
            return this;
        }

        index = Math.max(index, 0);

        for (var i = 1; i < argc; ++i) {
            this.value[index + i - 1] = arguments[i];
        }

        move();

        return this;
    };

    Pp.insertBefore = function insertBefore(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    Pp.insertAfter = function insertAfter(node) {
        var pp = this.parentPath;
        var argc = arguments.length;
        var insertAtArgs = [this.name + 1];
        for (var i = 0; i < argc; ++i) {
            insertAtArgs.push(arguments[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
    };

    function repairRelationshipWithParent(path) {
        if (!(path instanceof Path)) {
            throw new Error("");
        }

        var pp = path.parentPath;
        if (!pp) {
            // Orphan paths have no relationship to repair.
            return path;
        }

        var parentValue = pp.value;
        var parentCache = getChildCache(pp);

        // Make sure parentCache[path.name] is populated.
        if (parentValue[path.name] === path.value) {
            parentCache[path.name] = path;
        } else if (isArray.check(parentValue)) {
            // Something caused path.name to become out of date, so attempt to
            // recover by searching for path.value in parentValue.
            var i = parentValue.indexOf(path.value);
            if (i >= 0) {
                parentCache[path.name = i] = path;
            }
        } else {
            // If path.value disagrees with parentValue[path.name], and
            // path.name is not an array index, let path.value become the new
            // parentValue[path.name] and update parentCache accordingly.
            parentValue[path.name] = path.value;
            parentCache[path.name] = path;
        }

        if (parentValue[path.name] !== path.value) {
            throw new Error("");
        }
        if (path.parentPath.get(path.name) !== path) {
            throw new Error("");
        }

        return path;
    }

    Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;

        repairRelationshipWithParent(this);

        if (isArray.check(parentValue)) {
            var originalLength = parentValue.length;
            var move = getMoves(this.parentPath, count - 1, this.name + 1);

            var spliceArgs = [this.name, 1];
            for (var i = 0; i < count; ++i) {
                spliceArgs.push(arguments[i]);
            }

            var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);

            if (splicedOut[0] !== this.value) {
                throw new Error("");
            }
            if (parentValue.length !== (originalLength - 1 + count)) {
                throw new Error("");
            }

            move();

            if (count === 0) {
                delete this.value;
                delete parentCache[this.name];
                this.__childCache = null;

            } else {
                if (parentValue[this.name] !== replacement) {
                    throw new Error("");
                }

                if (this.value !== replacement) {
                    this.value = replacement;
                    this.__childCache = null;
                }

                for (i = 0; i < count; ++i) {
                    results.push(this.parentPath.get(this.name + i));
                }

                if (results[0] !== this) {
                    throw new Error("");
                }
            }

        } else if (count === 1) {
            if (this.value !== replacement) {
                this.__childCache = null;
            }
            this.value = parentValue[this.name] = replacement;
            results.push(this);

        } else if (count === 0) {
            delete parentValue[this.name];
            delete this.value;
            this.__childCache = null;

            // Leave this path cached as parentCache[this.name], even though
            // it no longer has a value defined.

        } else {
            throw new Error("Could not replace path");
        }

        return results;
    };

    return Path;
};

var hasOwn$3 = Object.prototype.hasOwnProperty;

var scope = function (fork) {
    var types = fork.use(types$1);
    var Type = types.Type;
    var namedTypes = types.namedTypes;
    var Node = namedTypes.Node;
    var Expression = namedTypes.Expression;
    var isArray = types.builtInTypes.array;
    var b = types.builders;

    function Scope(path, parentScope) {
        if (!(this instanceof Scope)) {
            throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        if (!(path instanceof fork.use(nodePath))) {
            throw new Error("");
        }
        ScopeType.assert(path.value);

        var depth;

        if (parentScope) {
            if (!(parentScope instanceof Scope)) {
                throw new Error("");
            }
            depth = parentScope.depth + 1;
        } else {
            parentScope = null;
            depth = 0;
        }

        Object.defineProperties(this, {
            path: { value: path },
            node: { value: path.value },
            isGlobal: { value: !parentScope, enumerable: true },
            depth: { value: depth },
            parent: { value: parentScope },
            bindings: { value: {} },
            types: { value: {} },
        });
    }

    var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes.Program,

        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes.Function,

        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes.CatchClause
    ];

    var ScopeType = Type.or.apply(Type, scopeTypes);

    Scope.isEstablishedBy = function(node) {
        return ScopeType.check(node);
    };

    var Sp = Scope.prototype;

// Will be overridden after an instance lazily calls scanScope.
    Sp.didScan = false;

    Sp.declares = function(name) {
        this.scan();
        return hasOwn$3.call(this.bindings, name);
    };

    Sp.declaresType = function(name) {
        this.scan();
        return hasOwn$3.call(this.types, name);
    };

    Sp.declareTemporary = function(prefix) {
        if (prefix) {
            if (!/^[a-z$_]/i.test(prefix)) {
                throw new Error("");
            }
        } else {
            prefix = "t$";
        }

        // Include this.depth in the name to make sure the name does not
        // collide with any variables in nested/enclosing scopes.
        prefix += this.depth.toString(36) + "$";

        this.scan();

        var index = 0;
        while (this.declares(prefix + index)) {
            ++index;
        }

        var name = prefix + index;
        return this.bindings[name] = types.builders.identifier(name);
    };

    Sp.injectTemporary = function(identifier, init) {
        identifier || (identifier = this.declareTemporary());

        var bodyPath = this.path.get("body");
        if (namedTypes.BlockStatement.check(bodyPath.value)) {
            bodyPath = bodyPath.get("body");
        }

        bodyPath.unshift(
          b.variableDeclaration(
            "var",
            [b.variableDeclarator(identifier, init || null)]
          )
        );

        return identifier;
    };

    Sp.scan = function(force) {
        if (force || !this.didScan) {
            for (var name in this.bindings) {
                // Empty out this.bindings, just in cases.
                delete this.bindings[name];
            }
            scanScope(this.path, this.bindings, this.types);
            this.didScan = true;
        }
    };

    Sp.getBindings = function () {
        this.scan();
        return this.bindings;
    };

    Sp.getTypes = function () {
        this.scan();
        return this.types;
    };

    function scanScope(path, bindings, scopeTypes) {
        var node = path.value;
        ScopeType.assert(node);

        if (namedTypes.CatchClause.check(node)) {
            // A catch clause establishes a new scope but the only variable
            // bound in that scope is the catch parameter. Any other
            // declarations create bindings in the outer scope.
            addPattern(path.get("param"), bindings);

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function recursiveScanScope(path, bindings, scopeTypes) {
        var node = path.value;

        if (path.parent &&
          namedTypes.FunctionExpression.check(path.parent.node) &&
          path.parent.node.id) {
            addPattern(path.parent.get("id"), bindings);
        }

        if (!node) {
            // None of the remaining cases matter if node is falsy.

        } else if (isArray.check(node)) {
            path.each(function(childPath) {
                recursiveScanChild(childPath, bindings, scopeTypes);
            });

        } else if (namedTypes.Function.check(node)) {
            path.get("params").each(function(paramPath) {
                addPattern(paramPath, bindings);
            });

            recursiveScanChild(path.get("body"), bindings, scopeTypes);

        } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) {
            addTypePattern(path.get("id"), scopeTypes);

        } else if (namedTypes.VariableDeclarator.check(node)) {
            addPattern(path.get("id"), bindings);
            recursiveScanChild(path.get("init"), bindings, scopeTypes);

        } else if (node.type === "ImportSpecifier" ||
          node.type === "ImportNamespaceSpecifier" ||
          node.type === "ImportDefaultSpecifier") {
            addPattern(
              // Esprima used to use the .name field to refer to the local
              // binding identifier for ImportSpecifier nodes, but .id for
              // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
              // ESTree/Acorn/ESpree use .local for all three node types.
              path.get(node.local ? "local" :
                node.name ? "name" : "id"),
              bindings
            );

        } else if (Node.check(node) && !Expression.check(node)) {
            types.eachField(node, function(name, child) {
                var childPath = path.get(name);
                if (!pathHasValue(childPath, child)) {
                    throw new Error("");
                }
                recursiveScanChild(childPath, bindings, scopeTypes);
            });
        }
    }

    function pathHasValue(path, value) {
        if (path.value === value) {
            return true;
        }

        // Empty arrays are probably produced by defaults.emptyArray, in which
        // case is makes sense to regard them as equivalent, if not ===.
        if (Array.isArray(path.value) &&
          path.value.length === 0 &&
          Array.isArray(value) &&
          value.length === 0) {
            return true;
        }

        return false;
    }

    function recursiveScanChild(path, bindings, scopeTypes) {
        var node = path.value;

        if (!node || Expression.check(node)) {
            // Ignore falsy values and Expressions.

        } else if (namedTypes.FunctionDeclaration.check(node) &&
                   node.id !== null) {
            addPattern(path.get("id"), bindings);

        } else if (namedTypes.ClassDeclaration &&
          namedTypes.ClassDeclaration.check(node)) {
            addPattern(path.get("id"), bindings);

        } else if (ScopeType.check(node)) {
            if (namedTypes.CatchClause.check(node)) {
                var catchParamName = node.param.name;
                var hadBinding = hasOwn$3.call(bindings, catchParamName);

                // Any declarations that occur inside the catch body that do
                // not have the same name as the catch parameter should count
                // as bindings in the outer scope.
                recursiveScanScope(path.get("body"), bindings, scopeTypes);

                // If a new binding matching the catch parameter name was
                // created while scanning the catch body, ignore it because it
                // actually refers to the catch parameter and not the outer
                // scope that we're currently scanning.
                if (!hadBinding) {
                    delete bindings[catchParamName];
                }
            }

        } else {
            recursiveScanScope(path, bindings, scopeTypes);
        }
    }

    function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn$3.call(bindings, pattern.name)) {
                bindings[pattern.name].push(patternPath);
            } else {
                bindings[pattern.name] = [patternPath];
            }

        } else if (namedTypes.ObjectPattern &&
          namedTypes.ObjectPattern.check(pattern)) {
            patternPath.get('properties').each(function(propertyPath) {
                var property = propertyPath.value;
                if (namedTypes.Pattern.check(property)) {
                    addPattern(propertyPath, bindings);
                } else  if (namedTypes.Property.check(property)) {
                    addPattern(propertyPath.get('value'), bindings);
                } else if (namedTypes.SpreadProperty &&
                  namedTypes.SpreadProperty.check(property)) {
                    addPattern(propertyPath.get('argument'), bindings);
                }
            });

        } else if (namedTypes.ArrayPattern &&
          namedTypes.ArrayPattern.check(pattern)) {
            patternPath.get('elements').each(function(elementPath) {
                var element = elementPath.value;
                if (namedTypes.Pattern.check(element)) {
                    addPattern(elementPath, bindings);
                } else if (namedTypes.SpreadElement &&
                  namedTypes.SpreadElement.check(element)) {
                    addPattern(elementPath.get("argument"), bindings);
                }
            });

        } else if (namedTypes.PropertyPattern &&
          namedTypes.PropertyPattern.check(pattern)) {
            addPattern(patternPath.get('pattern'), bindings);

        } else if ((namedTypes.SpreadElementPattern &&
          namedTypes.SpreadElementPattern.check(pattern)) ||
          (namedTypes.SpreadPropertyPattern &&
          namedTypes.SpreadPropertyPattern.check(pattern))) {
            addPattern(patternPath.get('argument'), bindings);
        }
    }

    function addTypePattern(patternPath, types) {
        var pattern = patternPath.value;
        namedTypes.Pattern.assert(pattern);

        if (namedTypes.Identifier.check(pattern)) {
            if (hasOwn$3.call(types, pattern.name)) {
                types[pattern.name].push(patternPath);
            } else {
                types[pattern.name] = [patternPath];
            }

        }
    }

    Sp.lookup = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declares(name))
                break;
        return scope;
    };

    Sp.lookupType = function(name) {
        for (var scope = this; scope; scope = scope.parent)
            if (scope.declaresType(name))
                break;
        return scope;
    };

    Sp.getGlobalScope = function() {
        var scope = this;
        while (!scope.isGlobal)
            scope = scope.parent;
        return scope;
    };

    return Scope;
};

var nodePath = function (fork) {
    var types = fork.use(types$1);
    var n = types.namedTypes;
    var b = types.builders;
    var isNumber = types.builtInTypes.number;
    var isArray = types.builtInTypes.array;
    var Path = fork.use(path);
    var Scope = fork.use(scope);

    function NodePath(value, parentPath, name) {
        if (!(this instanceof NodePath)) {
            throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value, parentPath, name);
    }

    var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
            value: NodePath,
            enumerable: false,
            writable: true,
            configurable: true
        }
    });

    Object.defineProperties(NPp, {
        node: {
            get: function () {
                Object.defineProperty(this, "node", {
                    configurable: true, // Enable deletion.
                    value: this._computeNode()
                });

                return this.node;
            }
        },

        parent: {
            get: function () {
                Object.defineProperty(this, "parent", {
                    configurable: true, // Enable deletion.
                    value: this._computeParent()
                });

                return this.parent;
            }
        },

        scope: {
            get: function () {
                Object.defineProperty(this, "scope", {
                    configurable: true, // Enable deletion.
                    value: this._computeScope()
                });

                return this.scope;
            }
        }
    });

    NPp.replace = function () {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
    };

    NPp.prune = function () {
        var remainingNodePath = this.parent;

        this.replace();

        return cleanUpNodesAfterPrune(remainingNodePath);
    };

    // The value of the first ancestor Path whose value is a Node.
    NPp._computeNode = function () {
        var value = this.value;
        if (n.Node.check(value)) {
            return value;
        }

        var pp = this.parentPath;
        return pp && pp.node || null;
    };

    // The first ancestor Path whose value is a Node distinct from this.node.
    NPp._computeParent = function () {
        var value = this.value;
        var pp = this.parentPath;

        if (!n.Node.check(value)) {
            while (pp && !n.Node.check(pp.value)) {
                pp = pp.parentPath;
            }

            if (pp) {
                pp = pp.parentPath;
            }
        }

        while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
        }

        return pp || null;
    };

    // The closest enclosing scope that governs this node.
    NPp._computeScope = function () {
        var value = this.value;
        var pp = this.parentPath;
        var scope$$1 = pp && pp.scope;

        if (n.Node.check(value) &&
          Scope.isEstablishedBy(value)) {
            scope$$1 = new Scope(this, scope$$1);
        }

        return scope$$1 || null;
    };

    NPp.getValueProperty = function (name) {
        return types.getFieldValue(this.value, name);
    };

    /**
     * Determine whether this.node needs to be wrapped in parentheses in order
     * for a parser to reproduce the same local AST structure.
     *
     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression
     * whose operator is "+" needs parentheses, because `1 + 2 * 3` would
     * parse differently.
     *
     * If assumeExpressionContext === true, we don't worry about edge cases
     * like an anonymous FunctionExpression appearing lexically first in its
     * enclosing statement and thus needing parentheses to avoid being parsed
     * as a FunctionDeclaration with a missing name.
     */
    NPp.needsParens = function (assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
            return false;
        }

        var node = this.value;

        // Only expressions need parentheses.
        if (!n.Expression.check(node)) {
            return false;
        }

        // Identifiers never need parentheses.
        if (node.type === "Identifier") {
            return false;
        }

        while (!n.Node.check(pp.value)) {
            pp = pp.parentPath;
            if (!pp) {
                return false;
            }
        }

        var parent = pp.value;

        switch (node.type) {
            case "UnaryExpression":
            case "SpreadElement":
            case "SpreadProperty":
                return parent.type === "MemberExpression"
                  && this.name === "object"
                  && parent.object === node;

            case "BinaryExpression":
            case "LogicalExpression":
                switch (parent.type) {
                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                        return true;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    case "BinaryExpression":
                    case "LogicalExpression":
                        var po = parent.operator;
                        var pp = PRECEDENCE[po];
                        var no = node.operator;
                        var np = PRECEDENCE[no];

                        if (pp > np) {
                            return true;
                        }

                        if (pp === np && this.name === "right") {
                            if (parent.right !== node) {
                                throw new Error("Nodes must be equal");
                            }
                            return true;
                        }

                    default:
                        return false;
                }

            case "SequenceExpression":
                switch (parent.type) {
                    case "ForStatement":
                        // Although parentheses wouldn't hurt around sequence
                        // expressions in the head of for loops, traditional style
                        // dictates that e.g. i++, j++ should not be wrapped with
                        // parentheses.
                        return false;

                    case "ExpressionStatement":
                        return this.name !== "expression";

                    default:
                        // Otherwise err on the side of overparenthesization, adding
                        // explicit exceptions above if this proves overzealous.
                        return true;
                }

            case "YieldExpression":
                switch (parent.type) {
                    case "BinaryExpression":
                    case "LogicalExpression":
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "CallExpression":
                    case "MemberExpression":
                    case "NewExpression":
                    case "ConditionalExpression":
                    case "YieldExpression":
                        return true;

                    default:
                        return false;
                }

            case "Literal":
                return parent.type === "MemberExpression"
                  && isNumber.check(node.value)
                  && this.name === "object"
                  && parent.object === node;

            case "AssignmentExpression":
            case "ConditionalExpression":
                switch (parent.type) {
                    case "UnaryExpression":
                    case "SpreadElement":
                    case "SpreadProperty":
                    case "BinaryExpression":
                    case "LogicalExpression":
                        return true;

                    case "CallExpression":
                        return this.name === "callee"
                          && parent.callee === node;

                    case "ConditionalExpression":
                        return this.name === "test"
                          && parent.test === node;

                    case "MemberExpression":
                        return this.name === "object"
                          && parent.object === node;

                    default:
                        return false;
                }

            default:
                if (parent.type === "NewExpression" &&
                  this.name === "callee" &&
                  parent.callee === node) {
                    return containsCallExpression(node);
                }
        }

        if (assumeExpressionContext !== true &&
          !this.canBeFirstInStatement() &&
          this.firstInStatement())
            return true;

        return false;
    };

    function isBinary(node) {
        return n.BinaryExpression.check(node)
          || n.LogicalExpression.check(node);
    }

    var PRECEDENCE = {};
    [["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
    ].forEach(function (tier, i) {
        tier.forEach(function (op) {
            PRECEDENCE[op] = i;
        });
    });

    function containsCallExpression(node) {
        if (n.CallExpression.check(node)) {
            return true;
        }

        if (isArray.check(node)) {
            return node.some(containsCallExpression);
        }

        if (n.Node.check(node)) {
            return types.someField(node, function (name, child) {
                return containsCallExpression(child);
            });
        }

        return false;
    }

    NPp.canBeFirstInStatement = function () {
        var node = this.node;
        return !n.FunctionExpression.check(node)
          && !n.ObjectExpression.check(node);
    };

    NPp.firstInStatement = function () {
        return firstInStatement(this);
    };

    function firstInStatement(path$$1) {
        for (var node, parent; path$$1.parent; path$$1 = path$$1.parent) {
            node = path$$1.node;
            parent = path$$1.parent.node;

            if (n.BlockStatement.check(parent) &&
              path$$1.parent.name === "body" &&
              path$$1.name === 0) {
                if (parent.body[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.ExpressionStatement.check(parent) &&
              path$$1.name === "expression") {
                if (parent.expression !== node) {
                    throw new Error("Nodes must be equal");
                }
                return true;
            }

            if (n.SequenceExpression.check(parent) &&
              path$$1.parent.name === "expressions" &&
              path$$1.name === 0) {
                if (parent.expressions[0] !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.CallExpression.check(parent) &&
              path$$1.name === "callee") {
                if (parent.callee !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.MemberExpression.check(parent) &&
              path$$1.name === "object") {
                if (parent.object !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.ConditionalExpression.check(parent) &&
              path$$1.name === "test") {
                if (parent.test !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (isBinary(parent) &&
              path$$1.name === "left") {
                if (parent.left !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            if (n.UnaryExpression.check(parent) &&
              !parent.prefix &&
              path$$1.name === "argument") {
                if (parent.argument !== node) {
                    throw new Error("Nodes must be equal");
                }
                continue;
            }

            return false;
        }

        return true;
    }

    /**
     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.
     */
    function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
            var declarations = remainingNodePath.get('declarations').value;
            if (!declarations || declarations.length === 0) {
                return remainingNodePath.prune();
            }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
            if (!remainingNodePath.get('expression').value) {
                return remainingNodePath.prune();
            }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
            cleanUpIfStatementAfterPrune(remainingNodePath);
        }

        return remainingNodePath;
    }

    function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get('test').value;
        var alternate = ifStatement.get('alternate').value;
        var consequent = ifStatement.get('consequent').value;

        if (!consequent && !alternate) {
            var testExpressionStatement = b.expressionStatement(testExpression);

            ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
            var negatedTestExpression = b.unaryExpression('!', testExpression, true);

            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {
                negatedTestExpression = testExpression.argument;
            }

            ifStatement.get("test").replace(negatedTestExpression);
            ifStatement.get("consequent").replace(alternate);
            ifStatement.get("alternate").replace();
        }
    }

    return NodePath;
};

var hasOwn$4 = Object.prototype.hasOwnProperty;

var pathVisitor = function (fork) {
    var types = fork.use(types$1);
    var NodePath = fork.use(nodePath);
    var Printable = types.namedTypes.Printable;
    var isArray = types.builtInTypes.array;
    var isObject = types.builtInTypes.object;
    var isFunction = types.builtInTypes.function;
    var undefined;

    function PathVisitor() {
        if (!(this instanceof PathVisitor)) {
            throw new Error(
              "PathVisitor constructor cannot be invoked without 'new'"
            );
        }

        // Permanent state.
        this._reusableContextStack = [];

        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments =
          hasOwn$4.call(this._methodNameTable, "Block") ||
          hasOwn$4.call(this._methodNameTable, "Line");

        this.Context = makeContextConstructor(this);

        // State reset every time PathVisitor.prototype.visit is called.
        this._visiting = false;
        this._changeReported = false;
    }

    function computeMethodNameTable(visitor) {
        var typeNames = Object.create(null);

        for (var methodName in visitor) {
            if (/^visit[A-Z]/.test(methodName)) {
                typeNames[methodName.slice("visit".length)] = true;
            }
        }

        var supertypeTable = types.computeSupertypeLookupTable(typeNames);
        var methodNameTable = Object.create(null);

        var typeNames = Object.keys(supertypeTable);
        var typeNameCount = typeNames.length;
        for (var i = 0; i < typeNameCount; ++i) {
            var typeName = typeNames[i];
            methodName = "visit" + supertypeTable[typeName];
            if (isFunction.check(visitor[methodName])) {
                methodNameTable[typeName] = methodName;
            }
        }

        return methodNameTable;
    }

    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {
        if (methods instanceof PathVisitor) {
            return methods;
        }

        if (!isObject.check(methods)) {
            // An empty visitor?
            return new PathVisitor;
        }

        function Visitor() {
            if (!(this instanceof Visitor)) {
                throw new Error(
                  "Visitor constructor cannot be invoked without 'new'"
                );
            }
            PathVisitor.call(this);
        }

        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;

        extend(Vp, methods);
        extend(Visitor, PathVisitor);

        isFunction.assert(Visitor.fromMethodsObject);
        isFunction.assert(Visitor.visit);

        return new Visitor;
    };

    function extend(target, source) {
        for (var property in source) {
            if (hasOwn$4.call(source, property)) {
                target[property] = source[property];
            }
        }

        return target;
    }

    PathVisitor.visit = function visit(node, methods) {
        return PathVisitor.fromMethodsObject(methods).visit(node);
    };

    var PVp = PathVisitor.prototype;

    PVp.visit = function () {
        if (this._visiting) {
            throw new Error(
              "Recursively calling visitor.visit(path) resets visitor state. " +
              "Try this.visit(path) or this.traverse(path) instead."
            );
        }

        // Private state that needs to be reset before every traversal.
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;

        var argc = arguments.length;
        var args = new Array(argc);
        for (var i = 0; i < argc; ++i) {
            args[i] = arguments[i];
        }

        if (!(args[0] instanceof NodePath)) {
            args[0] = new NodePath({root: args[0]}).get("root");
        }

        // Called with the same arguments as .visit.
        this.reset.apply(this, args);

        try {
            var root = this.visitWithoutReset(args[0]);
            var didNotThrow = true;
        } finally {
            this._visiting = false;

            if (!didNotThrow && this._abortRequested) {
                // If this.visitWithoutReset threw an exception and
                // this._abortRequested was set to true, return the root of
                // the AST instead of letting the exception propagate, so that
                // client code does not have to provide a try-catch block to
                // intercept the AbortRequest exception.  Other kinds of
                // exceptions will propagate without being intercepted and
                // rethrown by a catch block, so their stacks will accurately
                // reflect the original throwing context.
                return args[0].value;
            }
        }

        return root;
    };

    PVp.AbortRequest = function AbortRequest() {};
    PVp.abort = function () {
        var visitor = this;
        visitor._abortRequested = true;
        var request = new visitor.AbortRequest();

        // If you decide to catch this exception and stop it from propagating,
        // make sure to call its cancel method to avoid silencing other
        // exceptions that might be thrown later in the traversal.
        request.cancel = function () {
            visitor._abortRequested = false;
        };

        throw request;
    };

    PVp.reset = function (path/*, additional arguments */) {
        // Empty stub; may be reassigned or overridden by subclasses.
    };

    PVp.visitWithoutReset = function (path) {
        if (this instanceof this.Context) {
            // Since this.Context.prototype === this, there's a chance we
            // might accidentally call context.visitWithoutReset. If that
            // happens, re-invoke the method against context.visitor.
            return this.visitor.visitWithoutReset(path);
        }

        if (!(path instanceof NodePath)) {
            throw new Error("");
        }

        var value = path.value;

        var methodName = value &&
          typeof value === "object" &&
          typeof value.type === "string" &&
          this._methodNameTable[value.type];

        if (methodName) {
            var context = this.acquireContext(path);
            try {
                return context.invokeVisitorMethod(methodName);
            } finally {
                this.releaseContext(context);
            }

        } else {
            // If there was no visitor method to call, visit the children of
            // this node generically.
            return visitChildren(path, this);
        }
    };

    function visitChildren(path, visitor) {
        if (!(path instanceof NodePath)) {
            throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        var value = path.value;

        if (isArray.check(value)) {
            path.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject.check(value)) {
            // No children to visit.
        } else {
            var childNames = types.getFieldNames(value);

            // The .comments field of the Node type is hidden, so we only
            // visit it if the visitor defines visitBlock or visitLine, and
            // value.comments is defined.
            if (visitor._shouldVisitComments &&
              value.comments &&
              childNames.indexOf("comments") < 0) {
                childNames.push("comments");
            }

            var childCount = childNames.length;
            var childPaths = [];

            for (var i = 0; i < childCount; ++i) {
                var childName = childNames[i];
                if (!hasOwn$4.call(value, childName)) {
                    value[childName] = types.getFieldValue(value, childName);
                }
                childPaths.push(path.get(childName));
            }

            for (var i = 0; i < childCount; ++i) {
                visitor.visitWithoutReset(childPaths[i]);
            }
        }

        return path.value;
    }

    PVp.acquireContext = function (path) {
        if (this._reusableContextStack.length === 0) {
            return new this.Context(path);
        }
        return this._reusableContextStack.pop().reset(path);
    };

    PVp.releaseContext = function (context) {
        if (!(context instanceof this.Context)) {
            throw new Error("");
        }
        this._reusableContextStack.push(context);
        context.currentPath = null;
    };

    PVp.reportChanged = function () {
        this._changeReported = true;
    };

    PVp.wasChangeReported = function () {
        return this._changeReported;
    };

    function makeContextConstructor(visitor) {
        function Context(path) {
            if (!(this instanceof Context)) {
                throw new Error("");
            }
            if (!(this instanceof PathVisitor)) {
                throw new Error("");
            }
            if (!(path instanceof NodePath)) {
                throw new Error("");
            }

            Object.defineProperty(this, "visitor", {
                value: visitor,
                writable: false,
                enumerable: true,
                configurable: false
            });

            this.currentPath = path;
            this.needToCallTraverse = true;

            Object.seal(this);
        }

        if (!(visitor instanceof PathVisitor)) {
            throw new Error("");
        }

        // Note that the visitor object is the prototype of Context.prototype,
        // so all visitor methods are inherited by context objects.
        var Cp = Context.prototype = Object.create(visitor);

        Cp.constructor = Context;
        extend(Cp, sharedContextProtoMethods);

        return Context;
    }

// Every PathVisitor has a different this.Context constructor and
// this.Context.prototype object, but those prototypes can all use the
// same reset, invokeVisitorMethod, and traverse function objects.
    var sharedContextProtoMethods = Object.create(null);

    sharedContextProtoMethods.reset =
      function reset(path) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }

          this.currentPath = path;
          this.needToCallTraverse = true;

          return this;
      };

    sharedContextProtoMethods.invokeVisitorMethod =
      function invokeVisitorMethod(methodName) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          var result = this.visitor[methodName].call(this, this.currentPath);

          if (result === false) {
              // Visitor methods return false to indicate that they have handled
              // their own traversal needs, and we should not complain if
              // this.needToCallTraverse is still true.
              this.needToCallTraverse = false;

          } else if (result !== undefined) {
              // Any other non-undefined value returned from the visitor method
              // is interpreted as a replacement value.
              this.currentPath = this.currentPath.replace(result)[0];

              if (this.needToCallTraverse) {
                  // If this.traverse still hasn't been called, visit the
                  // children of the replacement node.
                  this.traverse(this.currentPath);
              }
          }

          if (this.needToCallTraverse !== false) {
              throw new Error(
                "Must either call this.traverse or return false in " + methodName
              );
          }

          var path = this.currentPath;
          return path && path.value;
      };

    sharedContextProtoMethods.traverse =
      function traverse(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return visitChildren(path, PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ));
      };

    sharedContextProtoMethods.visit =
      function visit(path, newVisitor) {
          if (!(this instanceof this.Context)) {
              throw new Error("");
          }
          if (!(path instanceof NodePath)) {
              throw new Error("");
          }
          if (!(this.currentPath instanceof NodePath)) {
              throw new Error("");
          }

          this.needToCallTraverse = false;

          return PathVisitor.fromMethodsObject(
            newVisitor || this.visitor
          ).visitWithoutReset(path);
      };

    sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
    };

    sharedContextProtoMethods.abort = function abort() {
        this.needToCallTraverse = false;
        this.visitor.abort();
    };

    return PathVisitor;
};

var fork = function (defs) {
    var used = [];
    var usedResult = [];
    var fork = {};

    function use(plugin) {
        var idx = used.indexOf(plugin);
        if (idx === -1) {
            idx = used.length;
            used.push(plugin);
            usedResult[idx] = plugin(fork);
        }
        return usedResult[idx];
    }

    fork.use = use;

    var types = use(types$1);

    defs.forEach(use);

    types.finalize();

    var exports = {
        Type: types.Type,
        builtInTypes: types.builtInTypes,
        namedTypes: types.namedTypes,
        builders: types.builders,
        defineMethod: types.defineMethod,
        getFieldNames: types.getFieldNames,
        getFieldValue: types.getFieldValue,
        eachField: types.eachField,
        someField: types.someField,
        getSupertypeNames: types.getSupertypeNames,
        astNodesAreEquivalent: use(equiv),
        finalize: types.finalize,
        Path: use(path),
        NodePath: use(nodePath),
        PathVisitor: use(pathVisitor),
        use: use
    };

    exports.visit = exports.PathVisitor.visit;

    return exports;
};

var shared = function (fork) {
    var exports = {};
    var types = fork.use(types$1);
    var Type = types.Type;
    var builtin = types.builtInTypes;
    var isNumber = builtin.number;

    // An example of constructing a new type with arbitrary constraints from
    // an existing type.
    exports.geq = function (than) {
        return new Type(function (value) {
            return isNumber.check(value) && value >= than;
        }, isNumber + " >= " + than);
    };

    // Default value-returning functions that may optionally be passed as a
    // third argument to Def.prototype.field.
    exports.defaults = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        "null": function () { return null },
        "emptyArray": function () { return [] },
        "false": function () { return false },
        "true": function () { return true },
        "undefined": function () {}
    };

    var naiveIsPrimitive = Type.or(
      builtin.string,
      builtin.number,
      builtin.boolean,
      builtin.null,
      builtin.undefined
    );

    exports.isPrimitive = new Type(function (value) {
        if (value === null)
            return true;
        var type = typeof value;
        return !(type === "object" ||
        type === "function");
    }, naiveIsPrimitive.toString());

    return exports;
};

var core = function (fork) {
    var types = fork.use(types$1);
    var Type = types.Type;
    var def = Type.def;
    var or = Type.or;
    var shared$$1 = fork.use(shared);
    var defaults = shared$$1.defaults;
    var geq = shared$$1.geq;

    // Abstract supertype of all syntactic entities that are allowed to have a
    // .loc field.
    def("Printable")
        .field("loc", or(
            def("SourceLocation"),
            null
        ), defaults["null"], true);

    def("Node")
        .bases("Printable")
        .field("type", String)
        .field("comments", or(
            [def("Comment")],
            null
        ), defaults["null"], true);

    def("SourceLocation")
        .build("start", "end", "source")
        .field("start", def("Position"))
        .field("end", def("Position"))
        .field("source", or(String, null), defaults["null"]);

    def("Position")
        .build("line", "column")
        .field("line", geq(1))
        .field("column", geq(0));

    def("File")
        .bases("Node")
        .build("program", "name")
        .field("program", def("Program"))
        .field("name", or(String, null), defaults["null"]);

    def("Program")
        .bases("Node")
        .build("body")
        .field("body", [def("Statement")]);

    def("Function")
        .bases("Node")
        .field("id", or(def("Identifier"), null), defaults["null"])
        .field("params", [def("Pattern")])
        .field("body", def("BlockStatement"));

    def("Statement").bases("Node");

// The empty .build() here means that an EmptyStatement can be constructed
// (i.e. it's not abstract) but that it needs no arguments.
    def("EmptyStatement").bases("Statement").build();

    def("BlockStatement")
        .bases("Statement")
        .build("body")
        .field("body", [def("Statement")]);

    // TODO Figure out how to silently coerce Expressions to
    // ExpressionStatements where a Statement was expected.
    def("ExpressionStatement")
        .bases("Statement")
        .build("expression")
        .field("expression", def("Expression"));

    def("IfStatement")
        .bases("Statement")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Statement"))
        .field("alternate", or(def("Statement"), null), defaults["null"]);

    def("LabeledStatement")
        .bases("Statement")
        .build("label", "body")
        .field("label", def("Identifier"))
        .field("body", def("Statement"));

    def("BreakStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("ContinueStatement")
        .bases("Statement")
        .build("label")
        .field("label", or(def("Identifier"), null), defaults["null"]);

    def("WithStatement")
        .bases("Statement")
        .build("object", "body")
        .field("object", def("Expression"))
        .field("body", def("Statement"));

    def("SwitchStatement")
        .bases("Statement")
        .build("discriminant", "cases", "lexical")
        .field("discriminant", def("Expression"))
        .field("cases", [def("SwitchCase")])
        .field("lexical", Boolean, defaults["false"]);

    def("ReturnStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", or(def("Expression"), null));

    def("ThrowStatement")
        .bases("Statement")
        .build("argument")
        .field("argument", def("Expression"));

    def("TryStatement")
        .bases("Statement")
        .build("block", "handler", "finalizer")
        .field("block", def("BlockStatement"))
        .field("handler", or(def("CatchClause"), null), function () {
            return this.handlers && this.handlers[0] || null;
        })
        .field("handlers", [def("CatchClause")], function () {
            return this.handler ? [this.handler] : [];
        }, true) // Indicates this field is hidden from eachField iteration.
        .field("guardedHandlers", [def("CatchClause")], defaults.emptyArray)
        .field("finalizer", or(def("BlockStatement"), null), defaults["null"]);

    def("CatchClause")
        .bases("Node")
        .build("param", "guard", "body")
        .field("param", def("Pattern"))
        .field("guard", or(def("Expression"), null), defaults["null"])
        .field("body", def("BlockStatement"));

    def("WhileStatement")
        .bases("Statement")
        .build("test", "body")
        .field("test", def("Expression"))
        .field("body", def("Statement"));

    def("DoWhileStatement")
        .bases("Statement")
        .build("body", "test")
        .field("body", def("Statement"))
        .field("test", def("Expression"));

    def("ForStatement")
        .bases("Statement")
        .build("init", "test", "update", "body")
        .field("init", or(
            def("VariableDeclaration"),
            def("Expression"),
            null))
        .field("test", or(def("Expression"), null))
        .field("update", or(def("Expression"), null))
        .field("body", def("Statement"));

    def("ForInStatement")
        .bases("Statement")
        .build("left", "right", "body")
        .field("left", or(
            def("VariableDeclaration"),
            def("Expression")))
        .field("right", def("Expression"))
        .field("body", def("Statement"));

    def("DebuggerStatement").bases("Statement").build();

    def("Declaration").bases("Statement");

    def("FunctionDeclaration")
        .bases("Function", "Declaration")
        .build("id", "params", "body")
        .field("id", def("Identifier"));

    def("FunctionExpression")
        .bases("Function", "Expression")
        .build("id", "params", "body");

    def("VariableDeclaration")
        .bases("Declaration")
        .build("kind", "declarations")
        .field("kind", or("var", "let", "const"))
        .field("declarations", [def("VariableDeclarator")]);

    def("VariableDeclarator")
        .bases("Node")
        .build("id", "init")
        .field("id", def("Pattern"))
        .field("init", or(def("Expression"), null));

    // TODO Are all Expressions really Patterns?
    def("Expression").bases("Node", "Pattern");

    def("ThisExpression").bases("Expression").build();

    def("ArrayExpression")
        .bases("Expression")
        .build("elements")
        .field("elements", [or(def("Expression"), null)]);

    def("ObjectExpression")
        .bases("Expression")
        .build("properties")
        .field("properties", [def("Property")]);

    // TODO Not in the Mozilla Parser API, but used by Esprima.
    def("Property")
        .bases("Node") // Want to be able to visit Property Nodes.
        .build("kind", "key", "value")
        .field("kind", or("init", "get", "set"))
        .field("key", or(def("Literal"), def("Identifier")))
        .field("value", def("Expression"));

    def("SequenceExpression")
        .bases("Expression")
        .build("expressions")
        .field("expressions", [def("Expression")]);

    var UnaryOperator = or(
        "-", "+", "!", "~",
        "typeof", "void", "delete");

    def("UnaryExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UnaryOperator)
        .field("argument", def("Expression"))
        // Esprima doesn't bother with this field, presumably because it's
        // always true for unary operators.
        .field("prefix", Boolean, defaults["true"]);

    var BinaryOperator = or(
        "==", "!=", "===", "!==",
        "<", "<=", ">", ">=",
        "<<", ">>", ">>>",
        "+", "-", "*", "/", "%",
        "&", // TODO Missing from the Parser API.
        "|", "^", "in",
        "instanceof", "..");

    def("BinaryExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", BinaryOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    var AssignmentOperator = or(
        "=", "+=", "-=", "*=", "/=", "%=",
        "<<=", ">>=", ">>>=",
        "|=", "^=", "&=");

    def("AssignmentExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", AssignmentOperator)
        .field("left", def("Pattern"))
        .field("right", def("Expression"));

    var UpdateOperator = or("++", "--");

    def("UpdateExpression")
        .bases("Expression")
        .build("operator", "argument", "prefix")
        .field("operator", UpdateOperator)
        .field("argument", def("Expression"))
        .field("prefix", Boolean);

    var LogicalOperator = or("||", "&&");

    def("LogicalExpression")
        .bases("Expression")
        .build("operator", "left", "right")
        .field("operator", LogicalOperator)
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("ConditionalExpression")
        .bases("Expression")
        .build("test", "consequent", "alternate")
        .field("test", def("Expression"))
        .field("consequent", def("Expression"))
        .field("alternate", def("Expression"));

    def("NewExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // The Mozilla Parser API gives this type as [or(def("Expression"),
        // null)], but null values don't really make sense at the call site.
        // TODO Report this nonsense.
        .field("arguments", [def("Expression")]);

    def("CallExpression")
        .bases("Expression")
        .build("callee", "arguments")
        .field("callee", def("Expression"))
        // See comment for NewExpression above.
        .field("arguments", [def("Expression")]);

    def("MemberExpression")
        .bases("Expression")
        .build("object", "property", "computed")
        .field("object", def("Expression"))
        .field("property", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean, function () {
            var type = this.property.type;
            if (type === 'Literal' ||
                type === 'MemberExpression' ||
                type === 'BinaryExpression') {
                return true;
            }
            return false;
        });

    def("Pattern").bases("Node");

    def("SwitchCase")
        .bases("Node")
        .build("test", "consequent")
        .field("test", or(def("Expression"), null))
        .field("consequent", [def("Statement")]);

    def("Identifier")
        // But aren't Expressions and Patterns already Nodes? TODO Report this.
        .bases("Node", "Expression", "Pattern")
        .build("name")
        .field("name", String);

    def("Literal")
        // But aren't Expressions already Nodes? TODO Report this.
        .bases("Node", "Expression")
        .build("value")
        .field("value", or(String, Boolean, null, Number, RegExp))
        .field("regex", or({
            pattern: String,
            flags: String
        }, null), function () {
            if (this.value instanceof RegExp) {
                var flags = "";

                if (this.value.ignoreCase) flags += "i";
                if (this.value.multiline) flags += "m";
                if (this.value.global) flags += "g";

                return {
                    pattern: this.value.source,
                    flags: flags
                };
            }

            return null;
        });

    // Abstract (non-buildable) comment supertype. Not a Node.
    def("Comment")
        .bases("Printable")
        .field("value", String)
        // A .leading comment comes before the node, whereas a .trailing
        // comment comes after it. These two fields should not both be true,
        // but they might both be false when the comment falls inside a node
        // and the node has no children for the comment to lead or trail,
        // e.g. { /*dangling*/ }.
        .field("leading", Boolean, defaults["true"])
        .field("trailing", Boolean, defaults["false"]);
};

var es6 = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(shared).defaults;

    def("Function")
      .field("generator", Boolean, defaults["false"])
      .field("expression", Boolean, defaults["false"])
      .field("defaults", [or(def("Expression"), null)], defaults.emptyArray)
      // TODO This could be represented as a RestElement in .params.
      .field("rest", or(def("Identifier"), null), defaults["null"]);

    // The ESTree way of representing a ...rest parameter.
    def("RestElement")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("SpreadElementPattern")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("FunctionDeclaration")
      .build("id", "params", "body", "generator", "expression");

    def("FunctionExpression")
      .build("id", "params", "body", "generator", "expression");

    // The Parser API calls this ArrowExpression, but Esprima and all other
    // actual parsers use ArrowFunctionExpression.
    def("ArrowFunctionExpression")
      .bases("Function", "Expression")
      .build("params", "body", "expression")
      // The forced null value here is compatible with the overridden
      // definition of the "id" field in the Function interface.
      .field("id", null, defaults["null"])
      // Arrow function bodies are allowed to be expressions.
      .field("body", or(def("BlockStatement"), def("Expression")))
      // The current spec forbids arrow generators, so I have taken the
      // liberty of enforcing that. TODO Report this.
      .field("generator", false, defaults["false"]);

    def("YieldExpression")
      .bases("Expression")
      .build("argument", "delegate")
      .field("argument", or(def("Expression"), null))
      .field("delegate", Boolean, defaults["false"]);

    def("GeneratorExpression")
      .bases("Expression")
      .build("body", "blocks", "filter")
      .field("body", def("Expression"))
      .field("blocks", [def("ComprehensionBlock")])
      .field("filter", or(def("Expression"), null));

    def("ComprehensionExpression")
      .bases("Expression")
      .build("body", "blocks", "filter")
      .field("body", def("Expression"))
      .field("blocks", [def("ComprehensionBlock")])
      .field("filter", or(def("Expression"), null));

    def("ComprehensionBlock")
      .bases("Node")
      .build("left", "right", "each")
      .field("left", def("Pattern"))
      .field("right", def("Expression"))
      .field("each", Boolean);

    def("Property")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("value", or(def("Expression"), def("Pattern")))
      .field("method", Boolean, defaults["false"])
      .field("shorthand", Boolean, defaults["false"])
      .field("computed", Boolean, defaults["false"]);

    def("PropertyPattern")
      .bases("Pattern")
      .build("key", "pattern")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("pattern", def("Pattern"))
      .field("computed", Boolean, defaults["false"]);

    def("ObjectPattern")
      .bases("Pattern")
      .build("properties")
      .field("properties", [or(def("PropertyPattern"), def("Property"))]);

    def("ArrayPattern")
      .bases("Pattern")
      .build("elements")
      .field("elements", [or(def("Pattern"), null)]);

    def("MethodDefinition")
      .bases("Declaration")
      .build("kind", "key", "value", "static")
      .field("kind", or("constructor", "method", "get", "set"))
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("value", def("Function"))
      .field("computed", Boolean, defaults["false"])
      .field("static", Boolean, defaults["false"]);

    def("SpreadElement")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ArrayExpression")
      .field("elements", [or(
        def("Expression"),
        def("SpreadElement"),
        def("RestElement"),
        null
      )]);

    def("NewExpression")
      .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

    def("CallExpression")
      .field("arguments", [or(def("Expression"), def("SpreadElement"))]);

    // Note: this node type is *not* an AssignmentExpression with a Pattern on
    // the left-hand side! The existing AssignmentExpression type already
    // supports destructuring assignments. AssignmentPattern nodes may appear
    // wherever a Pattern is allowed, and the right-hand side represents a
    // default value to be destructured against the left-hand side, if no
    // value is otherwise provided. For example: default parameter values.
    def("AssignmentPattern")
      .bases("Pattern")
      .build("left", "right")
      .field("left", def("Pattern"))
      .field("right", def("Expression"));

    var ClassBodyElement = or(
      def("MethodDefinition"),
      def("VariableDeclarator"),
      def("ClassPropertyDefinition"),
      def("ClassProperty")
    );

    def("ClassProperty")
      .bases("Declaration")
      .build("key")
      .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
      .field("computed", Boolean, defaults["false"]);

    def("ClassPropertyDefinition") // static property
      .bases("Declaration")
      .build("definition")
      // Yes, Virginia, circular definitions are permitted.
      .field("definition", ClassBodyElement);

    def("ClassBody")
      .bases("Declaration")
      .build("body")
      .field("body", [ClassBodyElement]);

    def("ClassDeclaration")
      .bases("Declaration")
      .build("id", "body", "superClass")
      .field("id", or(def("Identifier"), null))
      .field("body", def("ClassBody"))
      .field("superClass", or(def("Expression"), null), defaults["null"]);

    def("ClassExpression")
      .bases("Expression")
      .build("id", "body", "superClass")
      .field("id", or(def("Identifier"), null), defaults["null"])
      .field("body", def("ClassBody"))
      .field("superClass", or(def("Expression"), null), defaults["null"])
      .field("implements", [def("ClassImplements")], defaults.emptyArray);

    def("ClassImplements")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("superClass", or(def("Expression"), null), defaults["null"]);

    // Specifier and ModuleSpecifier are abstract non-standard types
    // introduced for definitional convenience.
    def("Specifier").bases("Node");

    // This supertype is shared/abused by both def/babel.js and
    // def/esprima.js. In the future, it will be possible to load only one set
    // of definitions appropriate for a given parser, but until then we must
    // rely on default functions to reconcile the conflicting AST formats.
    def("ModuleSpecifier")
      .bases("Specifier")
      // This local field is used by Babel/Acorn. It should not technically
      // be optional in the Babel/Acorn AST format, but it must be optional
      // in the Esprima AST format.
      .field("local", or(def("Identifier"), null), defaults["null"])
      // The id and name fields are used by Esprima. The id field should not
      // technically be optional in the Esprima AST format, but it must be
      // optional in the Babel/Acorn AST format.
      .field("id", or(def("Identifier"), null), defaults["null"])
      .field("name", or(def("Identifier"), null), defaults["null"]);

    def("TaggedTemplateExpression")
      .bases("Expression")
      .build("tag", "quasi")
      .field("tag", def("Expression"))
      .field("quasi", def("TemplateLiteral"));

    def("TemplateLiteral")
      .bases("Expression")
      .build("quasis", "expressions")
      .field("quasis", [def("TemplateElement")])
      .field("expressions", [def("Expression")]);

    def("TemplateElement")
      .bases("Node")
      .build("value", "tail")
      .field("value", {"cooked": String, "raw": String})
      .field("tail", Boolean);
};

var es7 = function (fork) {
    fork.use(es6);

    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var builtin = types.builtInTypes;
    var defaults = fork.use(shared).defaults;

    def("Function")
      .field("async", Boolean, defaults["false"]);

    def("SpreadProperty")
      .bases("Node")
      .build("argument")
      .field("argument", def("Expression"));

    def("ObjectExpression")
      .field("properties", [or(def("Property"), def("SpreadProperty"))]);

    def("SpreadPropertyPattern")
      .bases("Pattern")
      .build("argument")
      .field("argument", def("Pattern"));

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern")
      )]);

    def("AwaitExpression")
      .bases("Expression")
      .build("argument", "all")
      .field("argument", or(def("Expression"), null))
      .field("all", Boolean, defaults["false"]);
};

var mozilla = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var shared$$1 = fork.use(shared);
    var geq = shared$$1.geq;
    var defaults = shared$$1.defaults;

    def("Function")
        // SpiderMonkey allows expression closures: function(x) x+1
        .field("body", or(def("BlockStatement"), def("Expression")));

    def("ForInStatement")
        .build("left", "right", "body", "each")
        .field("each", Boolean, defaults["false"]);

    def("ForOfStatement")
        .bases("Statement")
        .build("left", "right", "body")
        .field("left", or(
            def("VariableDeclaration"),
            def("Expression")))
        .field("right", def("Expression"))
        .field("body", def("Statement"));

    def("LetStatement")
        .bases("Statement")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Statement"));

    def("LetExpression")
        .bases("Expression")
        .build("head", "body")
        // TODO Deviating from the spec by reusing VariableDeclarator here.
        .field("head", [def("VariableDeclarator")])
        .field("body", def("Expression"));

    def("GraphExpression")
        .bases("Expression")
        .build("index", "expression")
        .field("index", geq(0))
        .field("expression", def("Literal"));

    def("GraphIndexExpression")
        .bases("Expression")
        .build("index")
        .field("index", geq(0));
};

var e4x = function (fork) {
    fork.use(core);
    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;

    // Note that none of these types are buildable because the Mozilla Parser
    // API doesn't specify any builder functions, and nobody uses E4X anymore.

    def("XMLDefaultDeclaration")
        .bases("Declaration")
        .field("namespace", def("Expression"));

    def("XMLAnyName").bases("Expression");

    def("XMLQualifiedIdentifier")
        .bases("Expression")
        .field("left", or(def("Identifier"), def("XMLAnyName")))
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLFunctionQualifiedIdentifier")
        .bases("Expression")
        .field("right", or(def("Identifier"), def("Expression")))
        .field("computed", Boolean);

    def("XMLAttributeSelector")
        .bases("Expression")
        .field("attribute", def("Expression"));

    def("XMLFilterExpression")
        .bases("Expression")
        .field("left", def("Expression"))
        .field("right", def("Expression"));

    def("XMLElement")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XMLList")
        .bases("XML", "Expression")
        .field("contents", [def("XML")]);

    def("XML").bases("Node");

    def("XMLEscape")
        .bases("XML")
        .field("expression", def("Expression"));

    def("XMLText")
        .bases("XML")
        .field("text", String);

    def("XMLStartTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLEndTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLPointTag")
        .bases("XML")
        .field("contents", [def("XML")]);

    def("XMLName")
        .bases("XML")
        .field("contents", or(String, [def("XML")]));

    def("XMLAttribute")
        .bases("XML")
        .field("value", String);

    def("XMLCdata")
        .bases("XML")
        .field("contents", String);

    def("XMLComment")
        .bases("XML")
        .field("contents", String);

    def("XMLProcessingInstruction")
        .bases("XML")
        .field("target", String)
        .field("contents", or(String, null));
};

var jsx = function (fork) {
  fork.use(es7);

  var types = fork.use(types$1);
  var def = types.Type.def;
  var or = types.Type.or;
  var defaults = fork.use(shared).defaults;

  def("JSXAttribute")
    .bases("Node")
    .build("name", "value")
    .field("name", or(def("JSXIdentifier"), def("JSXNamespacedName")))
    .field("value", or(
      def("Literal"), // attr="value"
      def("JSXExpressionContainer"), // attr={value}
      null // attr= or just attr
    ), defaults["null"]);

  def("JSXIdentifier")
    .bases("Identifier")
    .build("name")
    .field("name", String);

  def("JSXNamespacedName")
    .bases("Node")
    .build("namespace", "name")
    .field("namespace", def("JSXIdentifier"))
    .field("name", def("JSXIdentifier"));

  def("JSXMemberExpression")
    .bases("MemberExpression")
    .build("object", "property")
    .field("object", or(def("JSXIdentifier"), def("JSXMemberExpression")))
    .field("property", def("JSXIdentifier"))
    .field("computed", Boolean, defaults.false);

  var JSXElementName = or(
    def("JSXIdentifier"),
    def("JSXNamespacedName"),
    def("JSXMemberExpression")
  );

  def("JSXSpreadAttribute")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  var JSXAttributes = [or(
    def("JSXAttribute"),
    def("JSXSpreadAttribute")
  )];

  def("JSXExpressionContainer")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));

  def("JSXElement")
    .bases("Expression")
    .build("openingElement", "closingElement", "children")
    .field("openingElement", def("JSXOpeningElement"))
    .field("closingElement", or(def("JSXClosingElement"), null), defaults["null"])
    .field("children", [or(
      def("JSXElement"),
      def("JSXExpressionContainer"),
      def("JSXText"),
      def("Literal") // TODO Esprima should return JSXText instead.
    )], defaults.emptyArray)
    .field("name", JSXElementName, function () {
      // Little-known fact: the `this` object inside a default function
      // is none other than the partially-built object itself, and any
      // fields initialized directly from builder function arguments
      // (like openingElement, closingElement, and children) are
      // guaranteed to be available.
      return this.openingElement.name;
    }, true) // hidden from traversal
    .field("selfClosing", Boolean, function () {
      return this.openingElement.selfClosing;
    }, true) // hidden from traversal
    .field("attributes", JSXAttributes, function () {
      return this.openingElement.attributes;
    }, true); // hidden from traversal

  def("JSXOpeningElement")
    .bases("Node") // TODO Does this make sense? Can't really be an JSXElement.
    .build("name", "attributes", "selfClosing")
    .field("name", JSXElementName)
    .field("attributes", JSXAttributes, defaults.emptyArray)
    .field("selfClosing", Boolean, defaults["false"]);

  def("JSXClosingElement")
    .bases("Node") // TODO Same concern.
    .build("name")
    .field("name", JSXElementName);

  def("JSXText")
    .bases("Literal")
    .build("value")
    .field("value", String);

  def("JSXEmptyExpression").bases("Expression").build();

  // This PR has caused many people issues, but supporting it seems like a
  // good idea anyway: https://github.com/babel/babel/pull/4988
  def("JSXSpreadChild")
    .bases("Expression")
    .build("expression")
    .field("expression", def("Expression"));
};

var flow = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var def = types.Type.def;
    var or = types.Type.or;
    var defaults = fork.use(shared).defaults;

    // Type Annotations
    def("Type").bases("Node");

    def("AnyTypeAnnotation")
      .bases("Type")
      .build();

    def("EmptyTypeAnnotation")
      .bases("Type")
      .build();

    def("MixedTypeAnnotation")
      .bases("Type")
      .build();

    def("VoidTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberTypeAnnotation")
      .bases("Type")
      .build();

    def("NumberLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    // Babylon 6 differs in AST from Flow
    // same as NumberLiteralTypeAnnotation
    def("NumericLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Number)
      .field("raw", String);

    def("StringTypeAnnotation")
      .bases("Type")
      .build();

    def("StringLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", String)
      .field("raw", String);

    def("BooleanTypeAnnotation")
      .bases("Type")
      .build();

    def("BooleanLiteralTypeAnnotation")
      .bases("Type")
      .build("value", "raw")
      .field("value", Boolean)
      .field("raw", String);

    def("TypeAnnotation")
      .bases("Node")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullableTypeAnnotation")
      .bases("Type")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("NullLiteralTypeAnnotation")
      .bases("Type")
      .build();

    def("NullTypeAnnotation")
      .bases("Type")
      .build();

    def("ThisTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistsTypeAnnotation")
      .bases("Type")
      .build();

    def("ExistentialTypeParam")
      .bases("Type")
      .build();

    def("FunctionTypeAnnotation")
      .bases("Type")
      .build("params", "returnType", "rest", "typeParameters")
      .field("params", [def("FunctionTypeParam")])
      .field("returnType", def("Type"))
      .field("rest", or(def("FunctionTypeParam"), null))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null));

    def("FunctionTypeParam")
      .bases("Node")
      .build("name", "typeAnnotation", "optional")
      .field("name", def("Identifier"))
      .field("typeAnnotation", def("Type"))
      .field("optional", Boolean);

    def("ArrayTypeAnnotation")
      .bases("Type")
      .build("elementType")
      .field("elementType", def("Type"));

    def("ObjectTypeAnnotation")
      .bases("Type")
      .build("properties", "indexers", "callProperties")
      .field("properties", [def("ObjectTypeProperty")])
      .field("indexers", [def("ObjectTypeIndexer")], defaults.emptyArray)
      .field("callProperties",
        [def("ObjectTypeCallProperty")],
        defaults.emptyArray)
      .field("exact", Boolean, defaults["false"]);

    def("ObjectTypeProperty")
      .bases("Node")
      .build("key", "value", "optional")
      .field("key", or(def("Literal"), def("Identifier")))
      .field("value", def("Type"))
      .field("optional", Boolean)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeIndexer")
      .bases("Node")
      .build("id", "key", "value")
      .field("id", def("Identifier"))
      .field("key", def("Type"))
      .field("value", def("Type"))
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ObjectTypeCallProperty")
      .bases("Node")
      .build("value")
      .field("value", def("FunctionTypeAnnotation"))
      .field("static", Boolean, defaults["false"]);

    def("QualifiedTypeIdentifier")
      .bases("Node")
      .build("qualification", "id")
      .field("qualification",
        or(def("Identifier"),
          def("QualifiedTypeIdentifier")))
      .field("id", def("Identifier"));

    def("GenericTypeAnnotation")
      .bases("Type")
      .build("id", "typeParameters")
      .field("id", or(def("Identifier"), def("QualifiedTypeIdentifier")))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("MemberTypeAnnotation")
      .bases("Type")
      .build("object", "property")
      .field("object", def("Identifier"))
      .field("property",
        or(def("MemberTypeAnnotation"),
          def("GenericTypeAnnotation")));

    def("UnionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("IntersectionTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("TypeofTypeAnnotation")
      .bases("Type")
      .build("argument")
      .field("argument", def("Type"));

    def("Identifier")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("ObjectPattern")
      .field("typeAnnotation", or(def("TypeAnnotation"), null), defaults["null"]);

    def("TypeParameterDeclaration")
      .bases("Node")
      .build("params")
      .field("params", [def("TypeParameter")]);

    def("TypeParameterInstantiation")
      .bases("Node")
      .build("params")
      .field("params", [def("Type")]);

    def("TypeParameter")
      .bases("Type")
      .build("name", "variance", "bound")
      .field("name", String)
      .field("variance",
        or("plus", "minus", null),
        defaults["null"])
      .field("bound",
        or(def("TypeAnnotation"), null),
        defaults["null"]);

    def("Function")
      .field("returnType",
        or(def("TypeAnnotation"), null),
        defaults["null"])
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"]);

    def("ClassProperty")
      .build("key", "value", "typeAnnotation", "static")
      .field("value", or(def("Expression"), null))
      .field("typeAnnotation", or(def("TypeAnnotation"), null))
      .field("static", Boolean, defaults["false"])
      .field("variance",
        or("plus", "minus", null),
        defaults["null"]);

    def("ClassImplements")
      .field("typeParameters",
        or(def("TypeParameterInstantiation"), null),
        defaults["null"]);

    def("InterfaceDeclaration")
      .bases("Declaration")
      .build("id", "body", "extends")
      .field("id", def("Identifier"))
      .field("typeParameters",
        or(def("TypeParameterDeclaration"), null),
        defaults["null"])
      .field("body", def("ObjectTypeAnnotation"))
      .field("extends", [def("InterfaceExtends")]);

    def("DeclareInterface")
      .bases("InterfaceDeclaration")
      .build("id", "body", "extends");

    def("InterfaceExtends")
      .bases("Node")
      .build("id")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterInstantiation"), null));

    def("TypeAlias")
      .bases("Declaration")
      .build("id", "typeParameters", "right")
      .field("id", def("Identifier"))
      .field("typeParameters", or(def("TypeParameterDeclaration"), null))
      .field("right", def("Type"));

    def("DeclareTypeAlias")
      .bases("TypeAlias")
      .build("id", "typeParameters", "right");

    def("TypeCastExpression")
      .bases("Expression")
      .build("expression", "typeAnnotation")
      .field("expression", def("Expression"))
      .field("typeAnnotation", def("TypeAnnotation"));

    def("TupleTypeAnnotation")
      .bases("Type")
      .build("types")
      .field("types", [def("Type")]);

    def("DeclareVariable")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareFunction")
      .bases("Statement")
      .build("id")
      .field("id", def("Identifier"));

    def("DeclareClass")
      .bases("InterfaceDeclaration")
      .build("id");

    def("DeclareModule")
      .bases("Statement")
      .build("id", "body")
      .field("id", or(def("Identifier"), def("Literal")))
      .field("body", def("BlockStatement"));

    def("DeclareModuleExports")
      .bases("Statement")
      .build("typeAnnotation")
      .field("typeAnnotation", def("Type"));

    def("DeclareExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("Type"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("DeclareExportAllDeclaration")
      .bases("Declaration")
      .build("source")
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);
};

var esprima = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var defaults = fork.use(shared).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("VariableDeclaration")
      .field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier") // Esprima deviation.
      )]);

    def("Property")
      .field("value", or(
        def("Expression"),
        def("Pattern") // Esprima deviation.
      ));

    def("ArrayPattern")
      .field("elements", [or(
        def("Pattern"),
        def("SpreadElement"),
        null
      )]);

    def("ObjectPattern")
      .field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty") // Used by Esprima.
      )]);

// Like ModuleSpecifier, except type:"ExportSpecifier" and buildable.
// export {<id [as name]>} [from ...];
    def("ExportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// export <*> from ...;
    def("ExportBatchSpecifier")
      .bases("Specifier")
      .build();

// Like ModuleSpecifier, except type:"ImportSpecifier" and buildable.
// import {<id [as name]>} from ...;
    def("ImportSpecifier")
      .bases("ModuleSpecifier")
      .build("id", "name");

// import <* as id> from ...;
    def("ImportNamespaceSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

// import <id> from ...;
    def("ImportDefaultSpecifier")
      .bases("ModuleSpecifier")
      .build("id");

    def("ExportDeclaration")
      .bases("Declaration")
      .build("default", "declaration", "specifiers", "source")
      .field("default", Boolean)
      .field("declaration", or(
        def("Declaration"),
        def("Expression"), // Implies default.
        null
      ))
      .field("specifiers", [or(
        def("ExportSpecifier"),
        def("ExportBatchSpecifier")
      )], defaults.emptyArray)
      .field("source", or(
        def("Literal"),
        null
      ), defaults["null"]);

    def("ImportDeclaration")
      .bases("Declaration")
      .build("specifiers", "source", "importKind")
      .field("specifiers", [or(
        def("ImportSpecifier"),
        def("ImportNamespaceSpecifier"),
        def("ImportDefaultSpecifier")
      )], defaults.emptyArray)
      .field("source", def("Literal"))
      .field("importKind", or(
        "value",
        "type"
      ), function() {
        return "value";
      });

    def("Block")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");

    def("Line")
      .bases("Comment")
      .build("value", /*optional:*/ "leading", "trailing");
};

var babel = function (fork) {
    fork.use(es7);

    var types = fork.use(types$1);
    var defaults = fork.use(shared).defaults;
    var def = types.Type.def;
    var or = types.Type.or;

    def("Noop")
        .bases("Node")
        .build();

    def("DoExpression")
        .bases("Expression")
        .build("body")
        .field("body", [def("Statement")]);

    def("Super")
        .bases("Expression")
        .build();

    def("BindExpression")
        .bases("Expression")
        .build("object", "callee")
        .field("object", or(def("Expression"), null))
        .field("callee", def("Expression"));

    def("Decorator")
        .bases("Node")
        .build("expression")
        .field("expression", def("Expression"));

    def("Property")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MethodDefinition")
        .field("decorators",
            or([def("Decorator")], null),
            defaults["null"]);

    def("MetaProperty")
        .bases("Expression")
        .build("meta", "property")
        .field("meta", def("Identifier"))
        .field("property", def("Identifier"));

    def("ParenthesizedExpression")
        .bases("Expression")
        .build("expression")
        .field("expression", def("Expression"));

    def("ImportSpecifier")
        .bases("ModuleSpecifier")
        .build("imported", "local")
        .field("imported", def("Identifier"));

    def("ImportDefaultSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ImportNamespaceSpecifier")
        .bases("ModuleSpecifier")
        .build("local");

    def("ExportDefaultDeclaration")
        .bases("Declaration")
        .build("declaration")
        .field("declaration", or(def("Declaration"), def("Expression")));

    def("ExportNamedDeclaration")
        .bases("Declaration")
        .build("declaration", "specifiers", "source")
        .field("declaration", or(def("Declaration"), null))
        .field("specifiers", [def("ExportSpecifier")], defaults.emptyArray)
        .field("source", or(def("Literal"), null), defaults["null"]);

    def("ExportSpecifier")
        .bases("ModuleSpecifier")
        .build("local", "exported")
        .field("exported", def("Identifier"));

    def("ExportNamespaceSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportDefaultSpecifier")
        .bases("Specifier")
        .build("exported")
        .field("exported", def("Identifier"));

    def("ExportAllDeclaration")
        .bases("Declaration")
        .build("exported", "source")
        .field("exported", or(def("Identifier"), null))
        .field("source", def("Literal"));

    def("CommentBlock")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");

    def("CommentLine")
        .bases("Comment")
        .build("value", /*optional:*/ "leading", "trailing");
};

var babel6 = function (fork) {
  fork.use(babel);
  fork.use(flow);

  // var types = fork.types;
  var types = fork.use(types$1);
  // var defaults = fork.shared.defaults;
  var defaults = fork.use(shared).defaults;
  var def = types.Type.def;
  var or = types.Type.or;

  def("Directive")
    .bases("Node")
    .build("value")
    .field("value", def("DirectiveLiteral"));

  def("DirectiveLiteral")
    .bases("Node", "Expression")
    .build("value")
    .field("value", String, defaults["use strict"]);

  def("BlockStatement")
    .bases("Statement")
    .build("body")
    .field("body", [def("Statement")])
    .field("directives", [def("Directive")], defaults.emptyArray);

  def("Program")
    .bases("Node")
    .build("body")
    .field("body", [def("Statement")])
    .field("directives", [def("Directive")], defaults.emptyArray);

  // Split Literal
  def("StringLiteral")
    .bases("Literal")
    .build("value")
    .field("value", String);

  def("NumericLiteral")
    .bases("Literal")
    .build("value")
    .field("value", Number);

  def("NullLiteral")
    .bases("Literal")
    .build()
    .field("value", null, defaults["null"]);

  def("BooleanLiteral")
    .bases("Literal")
    .build("value")
    .field("value", Boolean);

  def("RegExpLiteral")
    .bases("Literal")
    .build("pattern", "flags")
    .field("pattern", String)
    .field("flags", String)
    .field("value", RegExp, function () {
      return new RegExp(this.pattern, this.flags);
    });

  var ObjectExpressionProperty = or(
    def("Property"),
    def("ObjectMethod"),
    def("ObjectProperty"),
    def("SpreadProperty")
  );

  // Split Property -> ObjectProperty and ObjectMethod
  def("ObjectExpression")
    .bases("Expression")
    .build("properties")
    .field("properties", [ObjectExpressionProperty]);

  // ObjectMethod hoist .value properties to own properties
  def("ObjectMethod")
    .bases("Node", "Function")
    .build("kind", "key", "params", "body", "computed")
    .field("kind", or("method", "get", "set"))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("params", [def("Pattern")])
    .field("body", def("BlockStatement"))
    .field("computed", Boolean, defaults["false"])
    .field("generator", Boolean, defaults["false"])
    .field("async", Boolean, defaults["false"])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  def("ObjectProperty")
    .bases("Node")
    .build("key", "value")
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("value", or(def("Expression"), def("Pattern")))
    .field("computed", Boolean, defaults["false"]);

  var ClassBodyElement = or(
    def("MethodDefinition"),
    def("VariableDeclarator"),
    def("ClassPropertyDefinition"),
    def("ClassProperty"),
    def("ClassMethod")
  );

  // MethodDefinition -> ClassMethod
  def("ClassBody")
    .bases("Declaration")
    .build("body")
    .field("body", [ClassBodyElement]);

  def("ClassMethod")
    .bases("Declaration", "Function")
    .build("kind", "key", "params", "body", "computed", "static")
    .field("kind", or("get", "set", "method", "constructor"))
    .field("key", or(def("Literal"), def("Identifier"), def("Expression")))
    .field("params", [def("Pattern")])
    .field("body", def("BlockStatement"))
    .field("computed", Boolean, defaults["false"])
    .field("static", Boolean, defaults["false"])
    .field("generator", Boolean, defaults["false"])
    .field("async", Boolean, defaults["false"])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  var ObjectPatternProperty = or(
    def("Property"),
    def("PropertyPattern"),
    def("SpreadPropertyPattern"),
    def("SpreadProperty"), // Used by Esprima
    def("ObjectProperty"), // Babel 6
    def("RestProperty") // Babel 6
  );

  // Split into RestProperty and SpreadProperty
  def("ObjectPattern")
    .bases("Pattern")
    .build("properties")
    .field("properties", [ObjectPatternProperty])
    .field("decorators",
           or([def("Decorator")], null),
           defaults["null"]);

  def("SpreadProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  def("RestProperty")
    .bases("Node")
    .build("argument")
    .field("argument", def("Expression"));

  def("ForAwaitStatement")
    .bases("Statement")
    .build("left", "right", "body")
    .field("left", or(
      def("VariableDeclaration"),
      def("Expression")))
    .field("right", def("Expression"))
    .field("body", def("Statement"));

  // The callee node of a dynamic import(...) expression.
  def("Import")
    .bases("Expression")
    .build();
};

var typescript = function (fork) {
  fork.use(es7);
  var types = fork.use(types$1);
  var def = types.Type.def;
  var or = types.Type.or;


    def("TSAbstractClassDeclaration")
        .build("Node")
        .field("expression")
        .field("type");
    def("TSAsExpression")
        .build("Node");
    def("TSEnumDeclaration")
        .build("Node");
    def("TSImportEqualsDeclaration")
        .build("Node");
    def("TSIndexSignature")
        .build("Node");
    def("TSInterfaceDeclaration")
        .build("Node");
    def("TSModuleDeclaration")
        .build("Node");
    def("TSNamespaceExportDeclaration")
        .build("Node");
    def("TSParameterProperty")
        .build("Node");
    def("TSTypeLiteral")
        .build("Node");
    def("TSAbstractMethodDefinition")
        .build("Node");
};

var main = fork([
    // This core module of AST types captures ES5 as it is parsed today by
    // git://github.com/ariya/esprima.git#master.
    core,

    // Feel free to add to or remove from this list of extension modules to
    // configure the precise type hierarchy that you need.
    es6,
    es7,
    mozilla,
    e4x,
    jsx,
    flow,
    esprima,
    babel,
    babel6,
    typescript
]);

function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
  function traverseDocRec(doc) {
    var shouldRecurse = true;
    if (onEnter) {
      if (onEnter(doc) === false) {
        shouldRecurse = false;
      }
    }

    if (shouldRecurse) {
      if (doc.type === "concat") {
        for (var i = 0; i < doc.parts.length; i++) {
          traverseDocRec(doc.parts[i]);
        }
      } else if (doc.type === "if-break") {
        if (doc.breakContents) {
          traverseDocRec(doc.breakContents);
        }
        if (doc.flatContents) {
          traverseDocRec(doc.flatContents);
        }
      } else if (doc.type === "group" && doc.expandedStates) {
        if (shouldTraverseConditionalGroups) {
          doc.expandedStates.forEach(traverseDocRec);
        } else {
          traverseDocRec(doc.contents);
        }
      } else if (doc.contents) {
        traverseDocRec(doc.contents);
      }
    }

    if (onExit) {
      onExit(doc);
    }
  }

  traverseDocRec(doc);
}

function mapDoc(doc, func) {
  doc = func(doc);

  if (doc.type === "concat") {
    return Object.assign({}, doc, {
      parts: doc.parts.map(d => mapDoc(d, func))
    });
  } else if (doc.type === "if-break") {
    return Object.assign({}, doc, {
      breakContents: doc.breakContents && mapDoc(doc.breakContents, func),
      flatContents: doc.flatContents && mapDoc(doc.flatContents, func)
    });
  } else if (doc.contents) {
    return Object.assign({}, doc, { contents: mapDoc(doc.contents, func) });
  } else {
    return doc;
  }
}

function findInDoc(doc, fn, defaultValue) {
  var result = defaultValue;
  var hasStopped = false;
  traverseDoc(doc, function(doc) {
    var maybeResult = fn(doc);
    if (maybeResult !== undefined) {
      hasStopped = true;
      result = maybeResult;
    }
    if (hasStopped) {
      return false;
    }
  });
  return result;
}

function isEmpty(n) {
  return typeof n === "string" && n.length === 0;
}

function isLineNext(doc) {
  return findInDoc(
    doc,
    doc => {
      if (typeof doc === "string") {
        return false;
      }
      if (doc.type === "line") {
        return true;
      }
    },
    false
  );
}

function willBreak$1(doc) {
  return findInDoc(
    doc,
    doc => {
      if (doc.type === "group" && doc.break) {
        return true;
      }
      if (doc.type === "line" && doc.hard) {
        return true;
      }
      if (doc.type === "break-parent") {
        return true;
      }
    },
    false
  );
}

function breakParentGroup(groupStack) {
  if (groupStack.length > 0) {
    const parentGroup = groupStack[groupStack.length - 1];
    // Breaks are not propagated through conditional groups because
    // the user is expected to manually handle what breaks.
    if (!parentGroup.expandedStates) {
      parentGroup.break = true;
    }
  }
  return null;
}

function propagateBreaks(doc) {
  var alreadyVisited = new Map();
  const groupStack = [];
  traverseDoc(
    doc,
    doc => {
      if (doc.type === "break-parent") {
        breakParentGroup(groupStack);
      }
      if (doc.type === "group") {
        groupStack.push(doc);
        if (alreadyVisited.has(doc)) {
          return false;
        }
        alreadyVisited.set(doc, true);
      }
    },
    doc => {
      if (doc.type === "group") {
        const group = groupStack.pop();
        if (group.break) {
          breakParentGroup(groupStack);
        }
      }
    },
    /* shouldTraverseConditionalGroups */ true
  );
}

var docUtils = {
  isEmpty,
  willBreak: willBreak$1,
  isLineNext,
  traverseDoc,
  mapDoc,
  propagateBreaks
};

function assertDoc(val) {
  if (
    !(typeof val === "string" || (val != null && typeof val.type === "string"))
  ) {
    throw new Error(
      "Value " + JSON.stringify(val) + " is not a valid document"
    );
  }
}

function concat$1(parts) {
  parts.forEach(assertDoc);

  // We cannot do this until we change `printJSXElement` to not
  // access the internals of a document directly.
  // if(parts.length === 1) {
  //   // If it's a single document, no need to concat it.
  //   return parts[0];
  // }
  return { type: "concat", parts };
}

function indent$1(contents) {
  assertDoc(contents);

  return { type: "indent", contents };
}

function align$1(n, contents) {
  assertDoc(contents);

  return { type: "align", contents, n };
}

function group(contents, opts) {
  opts = opts || {};

  assertDoc(contents);

  return {
    type: "group",
    contents: contents,
    break: !!opts.shouldBreak,
    expandedStates: opts.expandedStates
  };
}

function conditionalGroup(states, opts) {
  return group(
    states[0],
    Object.assign(opts || {}, { expandedStates: states })
  );
}

function ifBreak(breakContents, flatContents) {
  if (breakContents) {
    assertDoc(breakContents);
  }
  if (flatContents) {
    assertDoc(flatContents);
  }

  return { type: "if-break", breakContents, flatContents };
}

function lineSuffix$1(contents) {
  assertDoc(contents);
  return { type: "line-suffix", contents };
}

const lineSuffixBoundary = { type: "line-suffix-boundary" };
const breakParent$1 = { type: "break-parent" };
const line = { type: "line" };
const softline = { type: "line", soft: true };
const hardline$1 = concat$1([{ type: "line", hard: true }, breakParent$1]);
const literalline = concat$1([
  { type: "line", hard: true, literal: true },
  breakParent$1
]);

function join$1(sep, arr) {
  var res = [];

  for (var i = 0; i < arr.length; i++) {
    if (i !== 0) {
      res.push(sep);
    }

    res.push(arr[i]);
  }

  return concat$1(res);
}

var docBuilders$1 = {
  concat: concat$1,
  join: join$1,
  line,
  softline,
  hardline: hardline$1,
  literalline,
  group,
  conditionalGroup,
  lineSuffix: lineSuffix$1,
  lineSuffixBoundary,
  breakParent: breakParent$1,
  ifBreak,
  indent: indent$1,
  align: align$1
};

function isExportDeclaration(node) {
  if (node)
    switch (node.type) {
      case "ExportDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportDefaultSpecifier":
      case "DeclareExportDeclaration":
      case "ExportNamedDeclaration":
      case "ExportAllDeclaration":
        return true;
    }

  return false;
}

function getParentExportDeclaration(path) {
  var parentNode = path.getParentNode();
  if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
    return parentNode;
  }

  return null;
}

function getPenultimate(arr) {
  if (arr.length > 1) {
    return arr[arr.length - 2];
  }
  return null;
}

function getLast(arr) {
  if (arr.length > 0) {
    return arr[arr.length - 1];
  }
  return null;
}

function skip(chars) {
  return (text, index, opts) => {
    const backwards = opts && opts.backwards;

    // Allow `skip` functions to be threaded together without having
    // to check for failures (did someone say monads?).
    if (index === false) {
      return false;
    }

    const length = text.length;
    let cursor = index;
    while (cursor >= 0 && cursor < length) {
      const c = text.charAt(cursor);
      if (chars instanceof RegExp) {
        if (!chars.test(c)) {
          return cursor;
        }
      } else if (chars.indexOf(c) === -1) {
        return cursor;
      }

      backwards ? cursor-- : cursor++;
    }

    if (cursor === -1 || cursor === length) {
      // If we reached the beginning or end of the file, return the
      // out-of-bounds cursor. It's up to the caller to handle this
      // correctly. We don't want to indicate `false` though if it
      // actually skipped valid characters.
      return cursor;
    }
    return false;
  };
}

const skipWhitespace = skip(/\s/);
const skipSpaces = skip(" \t");
const skipToLineEnd = skip(",; \t");
const skipEverythingButNewLine = skip(/[^\r\n]/);

function skipInlineComment(text, index) {
  if (index === false) {
    return false;
  }

  if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {
    for (var i = index + 2; i < text.length; ++i) {
      if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
        return i + 2;
      }
    }
  }
  return index;
}

function skipTrailingComment(text, index) {
  if (index === false) {
    return false;
  }

  if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {
    return skipEverythingButNewLine(text, index);
  }
  return index;
}

// This one doesn't use the above helper function because it wants to
// test \r\n in order and `skip` doesn't support ordering and we only
// want to skip one newline. It's simple to implement.
function skipNewline(text, index, opts) {
  const backwards = opts && opts.backwards;
  if (index === false) {
    return false;
  }

  const atIndex = text.charAt(index);
  if (backwards) {
    if (text.charAt(index - 1) === "\r" && atIndex === "\n") {
      return index - 2;
    }
    if (
      atIndex === "\n" ||
      atIndex === "\r" ||
      atIndex === "\u2028" ||
      atIndex === "\u2029"
    ) {
      return index - 1;
    }
  } else {
    if (atIndex === "\r" && text.charAt(index + 1) === "\n") {
      return index + 2;
    }
    if (
      atIndex === "\n" ||
      atIndex === "\r" ||
      atIndex === "\u2028" ||
      atIndex === "\u2029"
    ) {
      return index + 1;
    }
  }

  return index;
}

function hasNewline(text, index, opts) {
  opts = opts || {};
  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
  const idx2 = skipNewline(text, idx, opts);
  return idx !== idx2;
}

function hasNewlineInRange(text, start, end) {
  for (var i = start; i < end; ++i) {
    if (text.charAt(i) === "\n") {
      return true;
    }
  }
  return false;
}

// Note: this function doesn't ignore leading comments unlike isNextLineEmpty
function isPreviousLineEmpty(text, node) {
  let idx = locStart$1(node) - 1;
  idx = skipSpaces(text, idx, { backwards: true });
  idx = skipNewline(text, idx, { backwards: true });
  idx = skipSpaces(text, idx, { backwards: true });
  const idx2 = skipNewline(text, idx, { backwards: true });
  return idx !== idx2;
}

function isNextLineEmpty(text, node) {
  let oldIdx = null;
  let idx = locEnd$1(node);
  while (idx !== oldIdx) {
    // We need to skip all the potential trailing inline comments
    oldIdx = idx;
    idx = skipToLineEnd(text, idx);
    idx = skipInlineComment(text, idx);
    idx = skipSpaces(text, idx);
  }
  idx = skipTrailingComment(text, idx);
  idx = skipNewline(text, idx);
  return hasNewline(text, idx);
}

function getNextNonSpaceNonCommentCharacter$1(text, node) {
  let oldIdx = null;
  let idx = locEnd$1(node);
  while (idx !== oldIdx) {
    oldIdx = idx;
    idx = skipSpaces(text, idx);
    idx = skipInlineComment(text, idx);
    idx = skipTrailingComment(text, idx);
    idx = skipNewline(text, idx);
  }
  return text.charAt(idx);
}

function hasSpaces(text, index, opts) {
  opts = opts || {};
  const idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
  return idx !== index;
}

function locStart$1(node) {
  if (node.range) {
    return node.range[0];
  }
  return node.start;
}

function locEnd$1(node) {
  if (node.range) {
    return node.range[1];
  }
  return node.end;
}

function setLocStart(node, index) {
  if (node.range) {
    node.range[0] = index;
  } else {
    node.start = index;
  }
}

function setLocEnd(node, index) {
  if (node.range) {
    node.range[1] = index;
  } else {
    node.end = index;
  }
}

// http://stackoverflow.com/a/7124052
function htmlEscapeInsideAngleBracket(str) {
  return str.replace(/</g, "&lt;").replace(/>/g, "&gt;");
  // Intentionally disable the following since it is safe inside of a
  // angle bracket context
  //    .replace(/&/g, '&amp;')
  //    .replace(/"/g, '&quot;')
  //    .replace(/'/g, '&#39;')
}

var PRECEDENCE = {};
[
  ["||"],
  ["&&"],
  ["|"],
  ["^"],
  ["&"],
  ["==", "===", "!=", "!=="],
  ["<", ">", "<=", ">=", "in", "instanceof"],
  [">>", "<<", ">>>"],
  ["+", "-"],
  ["*", "/", "%"],
  ["**"]
].forEach(function(tier, i) {
  tier.forEach(function(op) {
    PRECEDENCE[op] = i;
  });
});

function getPrecedence(op) {
  return PRECEDENCE[op];
}

var util$2 = {
  getPrecedence,
  isExportDeclaration,
  getParentExportDeclaration,
  getPenultimate,
  getLast,
  getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter$1,
  skipWhitespace,
  skipSpaces,
  skipNewline,
  isNextLineEmpty,
  isPreviousLineEmpty,
  hasNewline,
  hasNewlineInRange,
  hasSpaces,
  locStart: locStart$1,
  locEnd: locEnd$1,
  setLocStart,
  setLocEnd,
  htmlEscapeInsideAngleBracket
};

var require$$0$11 = ( assert$3 && assert$3['default'] ) || assert$3;

var assert = require$$0$11;
var types = main;
var n = types.namedTypes;
var isArray = types.builtInTypes.array;
var isObject = types.builtInTypes.object;
var docBuilders = docBuilders$1;
var concat = docBuilders.concat;
var hardline = docBuilders.hardline;
var breakParent = docBuilders.breakParent;
var indent = docBuilders.indent;
var lineSuffix = docBuilders.lineSuffix;
var join = docBuilders.join;
var util = util$2;
var childNodesCacheKey = Symbol("child-nodes");
var locStart = util.locStart;
var locEnd = util.locEnd;
var getNextNonSpaceNonCommentCharacter =
  util.getNextNonSpaceNonCommentCharacter;

// TODO Move a non-caching implementation of this function into ast-types,
// and implement a caching wrapper function here.
function getSortedChildNodes(node, text, resultArray) {
  if (!node) {
    return;
  }

  if (resultArray) {
    if (n.Node.check(node) && node.type !== "EmptyStatement") {
      // This reverse insertion sort almost always takes constant
      // time because we almost always (maybe always?) append the
      // nodes in order anyway.
      for (var i = resultArray.length - 1; i >= 0; --i) {
        if (
          locStart(resultArray[i]) <= locStart(node) &&
          locEnd(resultArray[i]) <= locEnd(node)
        ) {
          break;
        }
      }
      resultArray.splice(i + 1, 0, node);
      return;
    }
  } else if (node[childNodesCacheKey]) {
    return node[childNodesCacheKey];
  }

  var names;
  if (isArray.check(node)) {
    names = Object.keys(node);
  } else if (isObject.check(node)) {
    names = types.getFieldNames(node);
  } else {
    return;
  }

  if (!resultArray) {
    Object.defineProperty(node, childNodesCacheKey, {
      value: (resultArray = []),
      enumerable: false
    });
  }

  for (var i = 0, nameCount = names.length; i < nameCount; ++i) {
    getSortedChildNodes(node[names[i]], text, resultArray);
  }

  return resultArray;
}

// As efficiently as possible, decorate the comment object with
// .precedingNode, .enclosingNode, and/or .followingNode properties, at
// least one of which is guaranteed to be defined.
function decorateComment(node, comment, text) {
  var childNodes = getSortedChildNodes(node, text);
  var precedingNode, followingNode;
  // Time to dust off the old binary search robes and wizard hat.
  var left = 0, right = childNodes.length;
  while (left < right) {
    var middle = (left + right) >> 1;
    var child = childNodes[middle];

    if (
      locStart(child) - locStart(comment) <= 0 &&
      locEnd(comment) - locEnd(child) <= 0
    ) {
      // The comment is completely contained by this child node.
      comment.enclosingNode = child;

      decorateComment(child, comment, text);
      return; // Abandon the binary search at this level.
    }

    if (locEnd(child) - locStart(comment) <= 0) {
      // This child node falls completely before the comment.
      // Because we will never consider this node or any nodes
      // before it again, this node must be the closest preceding
      // node we have encountered so far.
      precedingNode = child;
      left = middle + 1;
      continue;
    }

    if (locEnd(comment) - locStart(child) <= 0) {
      // This child node falls completely after the comment.
      // Because we will never consider this node or any nodes after
      // it again, this node must be the closest following node we
      // have encountered so far.
      followingNode = child;
      right = middle;
      continue;
    }

    throw new Error("Comment location overlaps with node location");
  }

  if (precedingNode) {
    comment.precedingNode = precedingNode;
  }

  if (followingNode) {
    comment.followingNode = followingNode;
  }
}

function attach(comments, ast, text, options) {
  if (!isArray.check(comments)) {
    return;
  }

  var tiesToBreak = [];

  comments.forEach((comment, i) => {
    decorateComment(ast, comment, text);

    const precedingNode = comment.precedingNode;
    const enclosingNode = comment.enclosingNode;
    const followingNode = comment.followingNode;

    const isLastComment = comments.length - 1 === i;

    if (util.hasNewline(text, locStart(comment), { backwards: true })) {
      // If a comment exists on its own line, prefer a leading comment.
      // We also need to check if it's the first line of the file.
      if (
        handleLastFunctionArgComments(
          text,
          precedingNode,
          enclosingNode,
          followingNode,
          comment
        ) ||
        handleMemberExpressionComments(enclosingNode, followingNode, comment) ||
        handleIfStatementComments(
          text,
          precedingNode,
          enclosingNode,
          followingNode,
          comment
        ) ||
        handleTryStatementComments(enclosingNode, followingNode, comment) ||
        handleClassComments(enclosingNode, comment) ||
        handleImportSpecifierComments(enclosingNode, comment) ||
        handleObjectPropertyComments(enclosingNode, comment) ||
        handleForComments(enclosingNode, precedingNode, comment) ||
        handleUnionTypeComments(
          precedingNode,
          enclosingNode,
          followingNode,
          comment
        ) ||
        handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||
        handleImportDeclarationComments(
          enclosingNode,
          precedingNode,
          comment
        ) ||
        handleAssignmentPatternComments(enclosingNode, comment)
      ) {
        // We're good
      } else if (followingNode) {
        // Always a leading comment.
        addLeadingComment(followingNode, comment);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    } else if (util.hasNewline(text, locEnd(comment))) {
      if (
        handleConditionalExpressionComments(
          enclosingNode,
          precedingNode,
          followingNode,
          comment,
          text
        ) ||
        handleImportSpecifierComments(enclosingNode, comment) ||
        handleTemplateLiteralComments(enclosingNode, comment) ||
        handleIfStatementComments(
          text,
          precedingNode,
          enclosingNode,
          followingNode,
          comment
        ) ||
        handleClassComments(enclosingNode, comment) ||
        handleLabeledStatementComments(enclosingNode, comment) ||
        handleCallExpressionComments(precedingNode, enclosingNode, comment) ||
        handlePropertyComments(enclosingNode, comment) ||
        handleExportNamedDeclarationComments(enclosingNode, comment) ||
        handleOnlyComments(enclosingNode, ast, comment, isLastComment) ||
        handleClassMethodComments(enclosingNode, comment) ||
        handleTypeAliasComments(enclosingNode, followingNode, comment) ||
        handleVariableDeclaratorComments(enclosingNode, followingNode, comment)
      ) {
        // We're good
      } else if (precedingNode) {
        // There is content before this comment on the same line, but
        // none after it, so prefer a trailing comment of the previous node.
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    } else {
      if (
        handleIfStatementComments(
          text,
          precedingNode,
          enclosingNode,
          followingNode,
          comment
        ) ||
        handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) ||
        handleTemplateLiteralComments(enclosingNode, comment) ||
        handleCommentInEmptyParens(text, enclosingNode, comment) ||
        handleOnlyComments(enclosingNode, ast, comment, isLastComment)
      ) {
        // We're good
      } else if (precedingNode && followingNode) {
        // Otherwise, text exists both before and after the comment on
        // the same line. If there is both a preceding and following
        // node, use a tie-breaking algorithm to determine if it should
        // be attached to the next or previous node. In the last case,
        // simply attach the right node;
        const tieCount = tiesToBreak.length;
        if (tieCount > 0) {
          var lastTie = tiesToBreak[tieCount - 1];
          if (lastTie.followingNode !== comment.followingNode) {
            breakTies(tiesToBreak, text);
          }
        }
        tiesToBreak.push(comment);
      } else if (precedingNode) {
        addTrailingComment(precedingNode, comment);
      } else if (followingNode) {
        addLeadingComment(followingNode, comment);
      } else if (enclosingNode) {
        addDanglingComment(enclosingNode, comment);
      } else {
        // There are no nodes, let's attach it to the root of the ast
        addDanglingComment(ast, comment);
      }
    }
  });

  breakTies(tiesToBreak, text);

  comments.forEach(function(comment) {
    // These node references were useful for breaking ties, but we
    // don't need them anymore, and they create cycles in the AST that
    // may lead to infinite recursion if we don't delete them here.
    delete comment.precedingNode;
    delete comment.enclosingNode;
    delete comment.followingNode;
  });
}

function breakTies(tiesToBreak, text) {
  var tieCount = tiesToBreak.length;
  if (tieCount === 0) {
    return;
  }

  var precedingNode = tiesToBreak[0].precedingNode;
  var followingNode = tiesToBreak[0].followingNode;
  var gapEndPos = locStart(followingNode);

  // Iterate backwards through tiesToBreak, examining the gaps
  // between the tied comments. In order to qualify as leading, a
  // comment must be separated from followingNode by an unbroken series of
  // whitespace-only gaps (or other comments).
  for (
    var indexOfFirstLeadingComment = tieCount;
    indexOfFirstLeadingComment > 0;
    --indexOfFirstLeadingComment
  ) {
    var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
    assert.strictEqual(comment.precedingNode, precedingNode);
    assert.strictEqual(comment.followingNode, followingNode);

    var gap = text.slice(locEnd(comment), gapEndPos);
    if (/\S/.test(gap)) {
      // The gap string contained something other than whitespace.
      break;
    }

    gapEndPos = locStart(comment);
  }

  tiesToBreak.forEach(function(comment, i) {
    if (i < indexOfFirstLeadingComment) {
      addTrailingComment(precedingNode, comment);
    } else {
      addLeadingComment(followingNode, comment);
    }
  });

  tiesToBreak.length = 0;
}

function addCommentHelper(node, comment) {
  var comments = node.comments || (node.comments = []);
  comments.push(comment);
  comment.printed = false;
}

function addLeadingComment(node, comment) {
  comment.leading = true;
  comment.trailing = false;
  addCommentHelper(node, comment);
}

function addDanglingComment(node, comment) {
  comment.leading = false;
  comment.trailing = false;
  addCommentHelper(node, comment);
}

function addTrailingComment(node, comment) {
  comment.leading = false;
  comment.trailing = true;
  addCommentHelper(node, comment);
}

function addBlockStatementFirstComment(node, comment) {
  const body = node.body.filter(n => n.type !== "EmptyStatement");
  if (body.length === 0) {
    addDanglingComment(node, comment);
  } else {
    addLeadingComment(body[0], comment);
  }
}

function addBlockOrNotComment(node, comment) {
  if (node.type === "BlockStatement") {
    addBlockStatementFirstComment(node, comment);
  } else {
    addLeadingComment(node, comment);
  }
}

// There are often comments before the else clause of if statements like
//
//   if (1) { ... }
//   // comment
//   else { ... }
//
// They are being attached as leading comments of the BlockExpression which
// is not well printed. What we want is to instead move the comment inside
// of the block and make it leadingComment of the first element of the block
// or dangling comment of the block if there is nothing inside
//
//   if (1) { ... }
//   else {
//     // comment
//     ...
//   }
function handleIfStatementComments(
  text,
  precedingNode,
  enclosingNode,
  followingNode,
  comment
) {
  if (
    !enclosingNode || enclosingNode.type !== "IfStatement" || !followingNode
  ) {
    return false;
  }

  // We unfortunately have no way using the AST or location of nodes to know
  // if the comment is positioned before or after the condition parenthesis:
  //   if (a /* comment */) {}
  //   if (a) /* comment */ {}
  // The only workaround I found is to look at the next character to see if
  // it is a ).
  if (getNextNonSpaceNonCommentCharacter(text, comment) === ")") {
    addTrailingComment(precedingNode, comment);
    return true;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "IfStatement") {
    addBlockOrNotComment(followingNode.consequent, comment);
    return true;
  }

  return false;
}

// Same as IfStatement but for TryStatement
function handleTryStatementComments(enclosingNode, followingNode, comment) {
  if (
    !enclosingNode || enclosingNode.type !== "TryStatement" || !followingNode
  ) {
    return false;
  }

  if (followingNode.type === "BlockStatement") {
    addBlockStatementFirstComment(followingNode, comment);
    return true;
  }

  if (followingNode.type === "TryStatement") {
    addBlockOrNotComment(followingNode.finalizer, comment);
    return true;
  }

  if (followingNode.type === "CatchClause") {
    addBlockOrNotComment(followingNode.body, comment);
    return true;
  }

  return false;
}

function handleMemberExpressionComments(enclosingNode, followingNode, comment) {
  if (
    enclosingNode &&
    enclosingNode.type === "MemberExpression" &&
    followingNode &&
    followingNode.type === "Identifier"
  ) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }

  return false;
}

function handleConditionalExpressionComments(
  enclosingNode,
  precedingNode,
  followingNode,
  comment,
  text
) {
  const isSameLineAsPrecedingNode =
    precedingNode &&
    !util.hasNewlineInRange(text, locEnd(precedingNode), locStart(comment));

  if (
    (!precedingNode || !isSameLineAsPrecedingNode) &&
    enclosingNode &&
    enclosingNode.type === "ConditionalExpression" &&
    followingNode
  ) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}

function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {
  if (
    enclosingNode &&
    (enclosingNode.type === "ObjectProperty" ||
      enclosingNode.type === "Property") &&
    enclosingNode.shorthand &&
    enclosingNode.key === precedingNode &&
    enclosingNode.value.type === "AssignmentPattern"
  ) {
    addTrailingComment(enclosingNode.value.left, comment);
    return true;
  }
  return false;
}

function handleTemplateLiteralComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "TemplateLiteral") {
    const expressionIndex = findExpressionIndexForComment(
      enclosingNode.quasis,
      comment
    );
    // Enforce all comments to be leading block comments.
    comment.type = "CommentBlock";
    addLeadingComment(enclosingNode.expressions[expressionIndex], comment);
    return true;
  }
  return false;
}

function handleCommentInEmptyParens(text, enclosingNode, comment) {
  if (getNextNonSpaceNonCommentCharacter(text, comment) !== ")") {
    return false;
  }

  // Only add dangling comments to fix the case when no params are present,
  // i.e. a function without any argument.
  if (
    enclosingNode &&
    (((enclosingNode.type === "FunctionDeclaration" ||
      enclosingNode.type === "FunctionExpression" ||
      enclosingNode.type === "ArrowFunctionExpression" ||
      enclosingNode.type === "ClassMethod" ||
      enclosingNode.type === "ObjectMethod") &&
      enclosingNode.params.length === 0) ||
      (enclosingNode.type === "CallExpression" &&
        enclosingNode.arguments.length === 0))
  ) {
    addDanglingComment(enclosingNode, comment);
    return true;
  }
  if (
    enclosingNode &&
    (enclosingNode.type === "MethodDefinition" &&
      enclosingNode.value.params.length === 0)
  ) {
    addDanglingComment(enclosingNode.value, comment);
    return true;
  }
  return false;
}

function handleLastFunctionArgComments(
  text,
  precedingNode,
  enclosingNode,
  followingNode,
  comment
) {
  // Type definitions functions
  if (
    precedingNode &&
    precedingNode.type === "FunctionTypeParam" &&
    enclosingNode &&
    enclosingNode.type === "FunctionTypeAnnotation" &&
    followingNode &&
    followingNode.type !== "FunctionTypeParam"
  ) {
    addTrailingComment(precedingNode, comment);
    return true;
  }

  // Real functions
  if (
    precedingNode &&
    (precedingNode.type === "Identifier" ||
      precedingNode.type === "AssignmentPattern") &&
    enclosingNode &&
    (enclosingNode.type === "ArrowFunctionExpression" ||
      enclosingNode.type === "FunctionExpression" ||
      enclosingNode.type === "FunctionDeclaration" ||
      enclosingNode.type === "ObjectMethod" ||
      enclosingNode.type === "ClassMethod") &&
    getNextNonSpaceNonCommentCharacter(text, comment) === ")"
  ) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}

function handleClassComments(enclosingNode, comment) {
  if (
    enclosingNode &&
    (enclosingNode.type === "ClassDeclaration" ||
      enclosingNode.type === "ClassExpression")
  ) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleImportSpecifierComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "ImportSpecifier") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleObjectPropertyComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "ObjectProperty") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleLabeledStatementComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "LabeledStatement") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleCallExpressionComments(precedingNode, enclosingNode, comment) {
  if (
    enclosingNode &&
    enclosingNode.type === "CallExpression" &&
    precedingNode &&
    enclosingNode.callee === precedingNode &&
    enclosingNode.arguments.length > 0
  ) {
    addLeadingComment(enclosingNode.arguments[0], comment);
    return true;
  }
  return false;
}

function handleUnionTypeComments(
  precedingNode,
  enclosingNode,
  followingNode,
  comment
) {
  if (enclosingNode && enclosingNode.type === "UnionTypeAnnotation") {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}

function handlePropertyComments(enclosingNode, comment) {
  if (
    enclosingNode &&
    (enclosingNode.type === "Property" ||
      enclosingNode.type === "ObjectProperty")
  ) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleExportNamedDeclarationComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "ExportNamedDeclaration") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {
  // With Flow the enclosingNode is undefined so use the AST instead.
  if (ast && ast.body && ast.body.length === 0) {
    if (isLastComment) {
      addDanglingComment(ast, comment);
    } else {
      addLeadingComment(ast, comment);
    }
    return true;
  } else if (
    enclosingNode &&
    enclosingNode.type === "Program" &&
    enclosingNode.body.length === 0 &&
    enclosingNode.directives &&
    enclosingNode.directives.length === 0
  ) {
    if (isLastComment) {
      addDanglingComment(enclosingNode, comment);
    } else {
      addLeadingComment(enclosingNode, comment);
    }
    return true;
  }
  return false;
}

function handleForComments(enclosingNode, precedingNode, comment) {
  if (
    enclosingNode &&
    (enclosingNode.type === "ForInStatement" ||
      enclosingNode.type === "ForOfStatement")
  ) {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleImportDeclarationComments(
  enclosingNode,
  precedingNode,
  comment
) {
  if (
    precedingNode &&
    enclosingNode &&
    enclosingNode.type === "ImportDeclaration" &&
    comment.type !== "CommentBlock" &&
    comment.type !== "Block"
  ) {
    addTrailingComment(precedingNode, comment);
    return true;
  }
  return false;
}

function handleAssignmentPatternComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "AssignmentPattern") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleClassMethodComments(enclosingNode, comment) {
  if (enclosingNode && enclosingNode.type === "ClassMethod") {
    addTrailingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleTypeAliasComments(enclosingNode, followingNode, comment) {
  if (enclosingNode && enclosingNode.type === "TypeAlias") {
    addLeadingComment(enclosingNode, comment);
    return true;
  }
  return false;
}

function handleVariableDeclaratorComments(
  enclosingNode,
  followingNode,
  comment
) {
  if (
    enclosingNode &&
    enclosingNode.type === "VariableDeclarator" &&
    followingNode &&
    (followingNode.type === "ObjectExpression" ||
      followingNode.type === "ArrayExpression")
  ) {
    addLeadingComment(followingNode, comment);
    return true;
  }
  return false;
}

function printComment(commentPath) {
  const comment = commentPath.getValue();
  comment.printed = true;

  switch (comment.type) {
    case "CommentBlock":
    case "Block":
      return "/*" + comment.value + "*/";
    case "CommentLine":
    case "Line":
      return "//" + comment.value;
    default:
      throw new Error("Not a comment: " + JSON.stringify(comment));
  }
}

function findExpressionIndexForComment(quasis, comment) {
  const startPos = locStart(comment) - 1;

  for (let i = 1; i < quasis.length; ++i) {
    if (startPos < getQuasiRange(quasis[i]).start) {
      return i - 1;
    }
  }

  // We haven't found it, it probably means that some of the locations are off.
  // Let's just return the first one.
  return 0;
}

function getQuasiRange(expr) {
  if (expr.start !== undefined) {
    // Babylon
    return { start: expr.start, end: expr.end };
  }
  // Flow
  return { start: expr.range[0], end: expr.range[1] };
}

function printLeadingComment(commentPath, print, options) {
  const comment = commentPath.getValue();
  const contents = printComment(commentPath);
  const text = options.originalText;
  const isBlock = comment.type === "Block" || comment.type === "CommentBlock";

  // Leading block comments should see if they need to stay on the
  // same line or not.
  if (isBlock) {
    return concat([
      contents,
      util.hasNewline(options.originalText, locEnd(comment)) ? hardline : " "
    ]);
  }

  return concat([contents, hardline]);
}

function printTrailingComment(commentPath, print, options, parentNode) {
  const comment = commentPath.getValue();
  const contents = printComment(commentPath);
  const isBlock = comment.type === "Block" || comment.type === "CommentBlock";

  if (
    util.hasNewline(options.originalText, locStart(comment), {
      backwards: true
    })
  ) {
    // This allows comments at the end of nested structures:
    // {
    //   x: 1,
    //   y: 2
    //   // A comment
    // }
    // Those kinds of comments are almost always leading comments, but
    // here it doesn't go "outside" the block and turns it into a
    // trailing comment for `2`. We can simulate the above by checking
    // if this a comment on its own line; normal trailing comments are
    // always at the end of another expression.

    const isLineBeforeEmpty = util.isPreviousLineEmpty(
      options.originalText,
      comment
    );

    return lineSuffix(
      concat([hardline, isLineBeforeEmpty ? hardline : "", contents])
    );
  } else if (isBlock) {
    // Trailing block comments never need a newline
    return concat([" ", contents]);
  }

  return concat([lineSuffix(" " + contents), !isBlock ? breakParent : ""]);
}

function printDanglingComments(path, options, sameIndent) {
  const text = options.originalText;
  const parts = [];
  const node = path.getValue();

  if (!node || !node.comments) {
    return "";
  }

  path.each(commentPath => {
    const comment = commentPath.getValue();
    if (!comment.leading && !comment.trailing) {
      parts.push(printComment(commentPath));
    }
  }, "comments");

  if (parts.length === 0) {
    return "";
  }

  if (sameIndent) {
    return join(hardline, parts);
  }
  return indent(concat([hardline, join(hardline, parts)]));
}

function printComments(path, print, options, needsSemi) {
  var value = path.getValue();
  var parent = path.getParentNode();
  var printed = print(path);
  var comments = n.Node.check(value) && types.getFieldValue(value, "comments");

  if (!comments || comments.length === 0) {
    return printed;
  }

  var leadingParts = [];
  var trailingParts = [needsSemi ? ";" : "", printed];

  path.each(function(commentPath) {
    var comment = commentPath.getValue();
    var leading = types.getFieldValue(comment, "leading");
    var trailing = types.getFieldValue(comment, "trailing");

    if (leading) {
      leadingParts.push(printLeadingComment(commentPath, print, options));

      const text = options.originalText;
      if (util.hasNewline(text, util.skipNewline(text, util.locEnd(comment)))) {
        leadingParts.push(hardline);
      }
    } else if (trailing) {
      trailingParts.push(
        printTrailingComment(commentPath, print, options, parent)
      );
    }
  }, "comments");

  return concat(leadingParts.concat(trailingParts));
}

var comments$1 = { attach, printComments, printDanglingComments };

var name = "prettier";
var version$2 = "1.2.2";
var description = "Prettier is an opinionated JavaScript formatter";
var bin = {"prettier":"./bin/prettier.js"};
var repository = "prettier/prettier";
var author = "James Long";
var license = "MIT";
var main$2 = "./index.js";
var dependencies = {"ast-types":"0.9.8","babel-code-frame":"6.22.0","babylon":"7.0.0-beta.8","chalk":"1.1.3","esutils":"2.0.2","flow-parser":"0.43.0","get-stdin":"5.0.1","glob":"7.1.1","jest-validate":"19.0.0","minimist":"1.2.0"};
var devDependencies = {"diff":"3.2.0","jest":"19.0.1","mkdirp":"^0.5.1","rimraf":"^2.6.1","rollup":"0.41.1","rollup-plugin-commonjs":"7.0.0","rollup-plugin-json":"2.1.0","rollup-plugin-node-builtins":"2.0.0","rollup-plugin-node-globals":"1.1.0","rollup-plugin-node-resolve":"2.0.0","typescript":"2.2.1","typescript-eslint-parser":"git://github.com/eslint/typescript-eslint-parser.git#bfb1506c48b625871ffeb67dbec7941d460f8941"};
var scripts = {"test":"jest","format":"./bin/prettier.js --write","format:single":"npm run format -- src/printer.js","format:all":"npm run format -- index.js src/*.js bin/*.js","build:docs":"rollup -c docs/rollup.config.js"};
var jest = {"setupFiles":["<rootDir>/tests_config/run_spec.js"],"snapshotSerializers":["<rootDir>/tests_config/raw-serializer.js"],"testRegex":"jsfmt\\.spec\\.js$","testPathIgnorePatterns":["tests/new_react","tests/more_react"]};
var _package = {
	name: name,
	version: version$2,
	description: description,
	bin: bin,
	repository: repository,
	author: author,
	license: license,
	main: main$2,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts,
	jest: jest
};

var _package$1 = Object.freeze({
	name: name,
	version: version$2,
	description: description,
	bin: bin,
	repository: repository,
	author: author,
	license: license,
	main: main$2,
	dependencies: dependencies,
	devDependencies: devDependencies,
	scripts: scripts,
	jest: jest,
	default: _package
});

var assert$5 = require$$0$11;
var types$5 = main;
var util$5 = util$2;
var n$2 = types$5.namedTypes;
var isArray$3 = types$5.builtInTypes.array;
var isNumber$1 = types$5.builtInTypes.number;

function FastPath$1(value) {
  assert$5.ok(this instanceof FastPath$1);
  this.stack = [value];
}

var FPp = FastPath$1.prototype;

// Static convenience function for coercing a value to a FastPath.
FastPath$1.from = function(obj) {
  if (obj instanceof FastPath$1) {
    // Return a defensive copy of any existing FastPath instances.
    return obj.copy();
  }

  if (obj instanceof types$5.NodePath) {
    // For backwards compatibility, unroll NodePath instances into
    // lightweight FastPath [..., name, value] stacks.
    var copy = Object.create(FastPath$1.prototype);
    var stack = [obj.value];
    for (var pp; (pp = obj.parentPath); obj = pp)
      stack.push(obj.name, pp.value);
    copy.stack = stack.reverse();
    return copy;
  }

  // Otherwise use obj as the value of the new FastPath instance.
  return new FastPath$1(obj);
};

FPp.copy = function copy() {
  var copy = Object.create(FastPath$1.prototype);
  copy.stack = this.stack.slice(0);
  return copy;
};

// The name of the current property is always the penultimate element of
// this.stack, and always a String.
FPp.getName = function getName() {
  var s = this.stack;
  var len = s.length;
  if (len > 1) {
    return s[len - 2];
  }
  // Since the name is always a string, null is a safe sentinel value to
  // return if we do not know the name of the (root) value.
  return null;
};

// The value of the current property is always the final element of
// this.stack.
FPp.getValue = function getValue() {
  var s = this.stack;
  return s[s.length - 1];
};

function getNodeHelper(path, count) {
  var s = path.stack;

  for (var i = s.length - 1; i >= 0; i -= 2) {
    var value = s[i];
    if (n$2.Node.check(value) && --count < 0) {
      return value;
    }
  }

  return null;
}

FPp.getNode = function getNode(count) {
  return getNodeHelper(this, ~~count);
};

FPp.getParentNode = function getParentNode(count) {
  return getNodeHelper(this, ~~count + 1);
};

FPp.isLast = function isLast() {
  var s = this.stack;
  if (this.getParentNode()) {
    var idx = s[s.length - 2];
    // The name of this node should be an index
    assert$5.ok(typeof idx === "number");

    const arr = s[s.length - 3];
    // We should have an array as a parent node
    assert$5.ok(Array.isArray(arr));

    return idx === arr.length - 1;
  }
  return false;
};

// Temporarily push properties named by string arguments given after the
// callback function onto this.stack, then call the callback with a
// reference to this (modified) FastPath object. Note that the stack will
// be restored to its original state after the callback is finished, so it
// is probably a mistake to retain a reference to the path.
FPp.call = function call(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;
  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }
  var result = callback(this);
  s.length = origLen;
  return result;
};

// Similar to FastPath.prototype.call, except that the value obtained by
// accessing this.getValue()[name1][name2]... should be array-like. The
// callback will be called with a reference to this path object for each
// element of the array.
FPp.each = function each(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      // If the callback needs to know the value of i, call
      // path.getName(), assuming path is the parameter name.
      callback(this);
      s.length -= 2;
    }
  }

  s.length = origLen;
};

// Similar to FastPath.prototype.each, except that the results of the
// callback function invocations are stored in an array and returned at
// the end of the iteration.
FPp.map = function map(callback /*, name1, name2, ... */) {
  var s = this.stack;
  var origLen = s.length;
  var value = s[origLen - 1];
  var argc = arguments.length;

  for (var i = 1; i < argc; ++i) {
    var name = arguments[i];
    value = value[name];
    s.push(name, value);
  }

  var result = new Array(value.length);

  for (var i = 0; i < value.length; ++i) {
    if (i in value) {
      s.push(i, value[i]);
      result[i] = callback(this, i);
      s.length -= 2;
    }
  }

  s.length = origLen;

  return result;
};

// Inspired by require("ast-types").NodePath.prototype.needsParens, but
// more efficient because we're iterating backwards through a stack.
FPp.needsParens = function(assumeExpressionContext) {
  var parent = this.getParentNode();
  if (!parent) {
    return false;
  }

  var name = this.getName();
  var node = this.getNode();

  // If the value of this path is some child of a Node and not a Node
  // itself, then it doesn't need parentheses. Only Node objects (in
  // fact, only Expression nodes) need parentheses.
  if (this.getValue() !== node) {
    return false;
  }

  // Only statements don't need parentheses.
  if (n$2.Statement.check(node)) {
    return false;
  }

  // Identifiers never need parentheses.
  if (node.type === "Identifier") {
    return false;
  }

  if (parent.type === "ParenthesizedExpression") {
    return false;
  }

  // Add parens around the extends clause of a class. It is needed for almost
  // all expressions.
  if (
    (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") &&
    parent.superClass === node &&
    (node.type === "ArrowFunctionExpression" ||
      node.type === "AssignmentExpression" ||
      node.type === "AwaitExpression" ||
      node.type === "BinaryExpression" ||
      node.type === "ConditionalExpression" ||
      node.type === "LogicalExpression" ||
      node.type === "NewExpression" ||
      node.type === "ObjectExpression" ||
      node.type === "ParenthesizedExpression" ||
      node.type === "SequenceExpression" ||
      node.type === "TaggedTemplateExpression" ||
      node.type === "UnaryExpression" ||
      node.type === "UpdateExpression" ||
      node.type === "YieldExpression")
  ) {
    return true;
  }

  if (
    (parent.type === "ArrowFunctionExpression" &&
      parent.body === node &&
      startsWithNoLookaheadToken(node, /* forbidFunctionAndClass */ false)) ||
    (parent.type === "ExpressionStatement" &&
      startsWithNoLookaheadToken(node, /* forbidFunctionAndClass */ true))
  ) {
    return true;
  }

  switch (node.type) {
    case "CallExpression":
      if (parent.type === "NewExpression" && parent.callee === node) {
        return true;
      }
      return false;

    case "SpreadElement":
    case "SpreadProperty":
      return (
        parent.type === "MemberExpression" &&
        name === "object" &&
        parent.object === node
      );

    case "UpdateExpression":
      if (parent.type === "UnaryExpression") {
        return (
          node.prefix &&
          ((node.operator === "++" && parent.operator === "+") ||
            (node.operator === "--" && parent.operator === "-"))
        );
      }
    // else fall through
    case "UnaryExpression":
      switch (parent.type) {
        case "UnaryExpression":
          return (
            node.operator === parent.operator &&
            (node.operator === "+" || node.operator === "-")
          );

        case "MemberExpression":
          return name === "object" && parent.object === node;

        case "TaggedTemplateExpression":
          return true;

        case "NewExpression":
        case "CallExpression":
          return name === "callee" && parent.callee === node;

        case "BinaryExpression":
          return parent.operator === "**" && name === "left";

        default:
          return false;
      }

    case "BinaryExpression":
      const isLeftOfAForStatement = node => {
        let i = 0;
        while (node) {
          let parent = this.getParentNode(i++);
          if (!parent) {
            return false;
          }
          if (parent.type === "ForStatement" && parent.init === node) {
            return true;
          }
          node = parent;
        }
        return false;
      };
      if (node.operator === "in" && isLeftOfAForStatement(node)) {
        return true;
      }
    // else fall through
    case "LogicalExpression":
      switch (parent.type) {
        case "CallExpression":
        case "NewExpression":
          return name === "callee" && parent.callee === node;

        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
          return true;

        case "MemberExpression":
          return name === "object" && parent.object === node;

        case "BinaryExpression":
        case "LogicalExpression":
          var po = parent.operator;
          var pp = util$5.getPrecedence(po);
          var no = node.operator;
          var np = util$5.getPrecedence(no);

          if (po === "||" && no === "&&") {
            return true;
          }

          if (pp > np) {
            return true;
          }

          if (no === "**" && po === "**") {
            return name === "left";
          }

          if (pp === np && name === "right") {
            assert$5.strictEqual(parent.right, node);
            return true;
          }

          // Add parenthesis when working with binary operators
          // It's not stricly needed but helps with code understanding
          if (["|", "^", "&", ">>", "<<", ">>>"].indexOf(po) !== -1) {
            return true;
          }

        default:
          return false;
      }

    case "SequenceExpression":
      switch (parent.type) {
        case "ReturnStatement":
          return false;

        case "ForStatement":
          // Although parentheses wouldn't hurt around sequence
          // expressions in the head of for loops, traditional style
          // dictates that e.g. i++, j++ should not be wrapped with
          // parentheses.
          return false;

        case "ExpressionStatement":
          return name !== "expression";

        default:
          // Otherwise err on the side of overparenthesization, adding
          // explicit exceptions above if this proves overzealous.
          return true;
      }

    case "YieldExpression":
      if (parent.type === "UnaryExpression") {
        return true;
      }
    // else fall through
    case "AwaitExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "BinaryExpression":
        case "LogicalExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "NewExpression":
        case "MemberExpression":
          return true;

        case "CallExpression":
          return parent.callee === node;

        case "ConditionalExpression":
          return parent.test === node;

        default:
          return false;
      }

    case "ArrayTypeAnnotation":
      return parent.type === "NullableTypeAnnotation";

    case "IntersectionTypeAnnotation":
    case "UnionTypeAnnotation":
      return (
        parent.type === "ArrayTypeAnnotation" ||
        parent.type === "NullableTypeAnnotation" ||
        parent.type === "IntersectionTypeAnnotation" ||
        parent.type === "UnionTypeAnnotation"
      );

    case "NullableTypeAnnotation":
      return parent.type === "ArrayTypeAnnotation";

    case "FunctionTypeAnnotation":
      return (
        parent.type === "UnionTypeAnnotation" ||
        parent.type === "IntersectionTypeAnnotation"
      );

    case "NumericLiteral":
    case "Literal":
      return (
        parent.type === "MemberExpression" &&
        isNumber$1.check(node.value) &&
        name === "object" &&
        parent.object === node
      );

    case "AssignmentExpression":
      if (parent.type === "ArrowFunctionExpression" && parent.body === node) {
        return true;
      } else if (
        parent.type === "ForStatement" &&
        (parent.init === node || parent.update === node)
      ) {
        return false;
      } else if (parent.type === "ExpressionStatement") {
        return node.left.type === "ObjectPattern";
      } else if (parent.type === "AssignmentExpression") {
        return false;
      }
      return true;

    case "ConditionalExpression":
      switch (parent.type) {
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "SpreadElement":
        case "SpreadProperty":
        case "BinaryExpression":
        case "LogicalExpression":
        case "ExportDefaultDeclaration":
        case "AwaitExpression":
        case "JSXSpreadAttribute":
        case "ArrowFunctionExpression":
          return true;

        case "NewExpression":
        case "CallExpression":
          return name === "callee" && parent.callee === node;

        case "ConditionalExpression":
          return name === "test" && parent.test === node;

        case "MemberExpression":
          return name === "object" && parent.object === node;

        default:
          return false;
      }

    case "FunctionExpression":
      switch (parent.type) {
        case "CallExpression":
          return name === "callee"; // Not strictly necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.
        case "TaggedTemplateExpression":
          return true; // This is basically a kind of IIFE.
        case "ExportDefaultDeclaration":
          return true;
        default:
          return false;
      }

    case "ArrowFunctionExpression":
      switch (parent.type) {
        case "CallExpression":
          return name === "callee";

        case "NewExpression":
          return name === "callee";

        case "MemberExpression":
          return name === "object";

        case "BindExpression":
        case "TaggedTemplateExpression":
        case "UnaryExpression":
        case "LogicalExpression":
        case "BinaryExpression":
          return true;

        case "ConditionalExpression":
          return name === "test";

        default:
          return false;
      }

    case "ClassExpression":
      return parent.type === "ExportDefaultDeclaration";

    case "StringLiteral":
      return parent.type === "ExpressionStatement"; // To avoid becoming a directive
  }

  if (
    parent.type === "NewExpression" &&
    name === "callee" &&
    parent.callee === node
  ) {
    return containsCallExpression(node);
  }

  return false;
};

function containsCallExpression(node) {
  if (n$2.CallExpression.check(node)) {
    return true;
  }

  if (isArray$3.check(node)) {
    return node.some(containsCallExpression);
  }

  if (n$2.Node.check(node)) {
    return types$5.someField(node, function(name, child) {
      return containsCallExpression(child);
    });
  }

  return false;
}

// Tests if an expression starts with `{`, or (if forbidFunctionAndClass holds) `function` or `class`.
// Will be overzealous if there's already necessary grouping parentheses.
function startsWithNoLookaheadToken(node, forbidFunctionAndClass) {
  node = getLeftMost(node);
  switch (node.type) {
    case "FunctionExpression":
    case "ClassExpression":
      return forbidFunctionAndClass;
    case "ObjectExpression":
      return true;
    case "MemberExpression":
      return startsWithNoLookaheadToken(node.object, forbidFunctionAndClass);
    case "TaggedTemplateExpression":
      if (node.tag.type === "FunctionExpression") {
        // IIFEs are always already parenthesized
        return false;
      }
      return startsWithNoLookaheadToken(node.tag, forbidFunctionAndClass);
    case "CallExpression":
      if (node.callee.type === "FunctionExpression") {
        // IIFEs are always already parenthesized
        return false;
      }
      return startsWithNoLookaheadToken(node.callee, forbidFunctionAndClass);
    case "ConditionalExpression":
      return startsWithNoLookaheadToken(node.test, forbidFunctionAndClass);
    case "UpdateExpression":
      return (
        !node.prefix &&
        startsWithNoLookaheadToken(node.argument, forbidFunctionAndClass)
      );
    case "BindExpression":
      return (
        node.object &&
        startsWithNoLookaheadToken(node.object, forbidFunctionAndClass)
      );
    case "SequenceExpression":
      return startsWithNoLookaheadToken(
        node.expressions[0],
        forbidFunctionAndClass
      );
    default:
      return false;
  }
}

function getLeftMost(node) {
  if (node.left) {
    return getLeftMost(node.left);
  } else {
    return node;
  }
}

var fastPath = FastPath$1;

var assert$4 = require$$0$11;
var comments$3 = comments$1;
var FastPath = fastPath;
var util$4 = util$2;
var isIdentifierName = utils.keyword.isIdentifierNameES6;

var docBuilders$3 = docBuilders$1;
var concat$2 = docBuilders$3.concat;
var join$2 = docBuilders$3.join;
var line$1 = docBuilders$3.line;
var hardline$2 = docBuilders$3.hardline;
var softline$1 = docBuilders$3.softline;
var literalline$1 = docBuilders$3.literalline;
var group$1 = docBuilders$3.group;
var indent$2 = docBuilders$3.indent;
var align$2 = docBuilders$3.align;
var conditionalGroup$1 = docBuilders$3.conditionalGroup;
var ifBreak$1 = docBuilders$3.ifBreak;
var breakParent$2 = docBuilders$3.breakParent;
var lineSuffixBoundary$1 = docBuilders$3.lineSuffixBoundary;

var docUtils$2 = docUtils;
var willBreak$2 = docUtils$2.willBreak;
var isLineNext$1 = docUtils$2.isLineNext;
var isEmpty$1 = docUtils$2.isEmpty;

var types$4 = main;
var namedTypes = types$4.namedTypes;
var isString$1 = types$4.builtInTypes.string;
function shouldPrintComma(options, level) {
  level = level || "es5";

  switch (options.trailingComma) {
    case "all":
      if (level === "all") {
        return true;
      }
    case "es5":
      if (level === "es5") {
        return true;
      }
    case "none":
    default:
      return false;
  }
}

function genericPrint(path, options, printPath, args) {
  assert$4.ok(path instanceof FastPath);

  var node = path.getValue();

  // Escape hatch
  if (
    node &&
    node.comments &&
    node.comments.length > 0 &&
    node.comments.some(comment => comment.value.trim() === "prettier-ignore")
  ) {
    return options.originalText.slice(util$4.locStart(node), util$4.locEnd(node));
  }

  var parts = [];
  var needsParens = false;
  var linesWithoutParens = genericPrintNoParens(path, options, printPath, args);

  if (!node || isEmpty$1(linesWithoutParens)) {
    return linesWithoutParens;
  }

  if (
    node.decorators &&
    node.decorators.length > 0 &&
    // If the parent node is an export declaration, it will be
    // responsible for printing node.decorators.
    !util$4.getParentExportDeclaration(path)
  ) {
    const separator = node.decorators.length === 1 &&
      (node.decorators[0].expression.type === "Identifier" ||
        node.decorators[0].expression.type === "MemberExpression")
      ? " "
      : hardline$2;
    path.each(function(decoratorPath) {
      parts.push(printPath(decoratorPath), separator);
    }, "decorators");
  } else if (
    util$4.isExportDeclaration(node) &&
    node.declaration &&
    node.declaration.decorators
  ) {
    // Export declarations are responsible for printing any decorators
    // that logically apply to node.declaration.
    path.each(
      function(decoratorPath) {
        parts.push(printPath(decoratorPath), line$1);
      },
      "declaration",
      "decorators"
    );
  } else {
    // Nodes with decorators can't have parentheses, so we can avoid
    // computing path.needsParens() except in this case.
    needsParens = path.needsParens();
  }

  if (node.type) {
    // HACK: ASI prevention in no-semi mode relies on knowledge of whether
    // or not a paren has been inserted (see `exprNeedsASIProtection()`).
    // For now, we're just passing that information by mutating the AST here,
    // but it would be nice to find a cleaner way to do this.
    node.needsParens = needsParens;
  }

  if (needsParens) {
    parts.unshift("(");
  }

  parts.push(linesWithoutParens);

  if (needsParens) {
    parts.push(")");
  }

  return concat$2(parts);
}

function genericPrintNoParens(path, options, print, args) {
  var n = path.getValue();
  const semi = options.semi ? ";" : "";

  if (!n) {
    return "";
  }

  if (typeof n === "string") {
    return n;
  }

  // TODO: Investigate types that return not printable.
  // This assert isn't very useful though.
  // namedTypes.Printable.assert(n);

  var parts = [];
  switch (n.type) {
    case "File":
      return path.call(print, "program");
    case "Program":
      // Babel 6
      if (n.directives) {
        path.each(function(childPath) {
          parts.push(print(childPath), semi, hardline$2);
          if (
            util$4.isNextLineEmpty(options.originalText, childPath.getValue())
          ) {
            parts.push(hardline$2);
          }
        }, "directives");
      }

      parts.push(
        path.call(function(bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body")
      );

      parts.push(
        comments$3.printDanglingComments(path, options, /* sameIndent */ true)
      );

      // Only force a trailing newline if there were any contents.
      if (n.body.length || n.comments) {
        parts.push(hardline$2);
      }

      return concat$2(parts);
    // Babel extension.
    case "Noop":
    case "EmptyStatement":
      return "";
    case "ExpressionStatement":
      return concat$2([path.call(print, "expression"), semi]); // Babel extension.
    case "ParenthesizedExpression":
      return concat$2(["(", path.call(print, "expression"), ")"]);
    case "AssignmentExpression":
      return printAssignment(
        n.left,
        path.call(print, "left"),
        n.operator,
        n.right,
        path.call(print, "right"),
        options
      );
    case "BinaryExpression":
    case "LogicalExpression": {
      const parent = path.getParentNode();
      const isInsideParenthesis =
        n !== parent.body &&
        (parent.type === "IfStatement" ||
          parent.type === "WhileStatement" ||
          parent.type === "DoStatement");

      const parts = printBinaryishExpressions(
        path,
        print,
        options,
        /* isNested */ false,
        isInsideParenthesis
      );

      //   if (
      //     this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
      //   ) {
      //
      // looks super weird, we want to break the children if the parent breaks
      //
      //   if (
      //     this.hasPlugin("dynamicImports") &&
      //     this.lookahead().type === tt.parenLeft
      //   ) {
      if (isInsideParenthesis) {
        return concat$2(parts);
      }

      // Avoid indenting sub-expressions in assignment/return/etc statements.
      if (
        parent.type === "AssignmentExpression" ||
        parent.type === "VariableDeclarator" ||
        shouldInlineLogicalExpression(n) ||
        parent.type === "ReturnStatement" ||
        (n === parent.body && parent.type === "ArrowFunctionExpression") ||
        (n !== parent.body && parent.type === "ForStatement")
      ) {
        return group$1(concat$2(parts));
      }

      const rest = concat$2(parts.slice(1));

      return group$1(
        concat$2([
          // Don't include the initial expression in the indentation
          // level. The first item is guaranteed to be the first
          // left-most expression.
          parts.length > 0 ? parts[0] : "",
          indent$2(rest)
        ])
      );
    }
    case "AssignmentPattern":
      return concat$2([
        path.call(print, "left"),
        " = ",
        path.call(print, "right")
      ]);
    case "MemberExpression": {
      const parent = path.getParentNode();
      let firstNonMemberParent;
      let i = 0;
      do {
        firstNonMemberParent = path.getParentNode(i);
        i++;
      } while (
        firstNonMemberParent &&
        firstNonMemberParent.type === "MemberExpression"
      );

      const shouldInline =
        firstNonMemberParent && (
          (firstNonMemberParent.type === "VariableDeclarator" &&
            firstNonMemberParent.id.type !== "Identifier") ||
          (firstNonMemberParent.type === "AssignmentExpression" &&
            firstNonMemberParent.left.type !== "Identifier")) ||
        n.computed ||
        (n.object.type === "Identifier" &&
          n.property.type === "Identifier" &&
          parent.type !== "MemberExpression");

      return concat$2([
        path.call(print, "object"),
        shouldInline
          ? printMemberLookup(path, options, print)
          : group$1(
              indent$2(
                concat$2([softline$1, printMemberLookup(path, options, print)])
              )
            )
      ]);
    }
    case "MetaProperty":
      return concat$2([
        path.call(print, "meta"),
        ".",
        path.call(print, "property")
      ]);
    case "BindExpression":
      if (n.object) {
        parts.push(path.call(print, "object"));
      }

      parts.push("::", path.call(print, "callee"));

      return concat$2(parts);
    case "Path":
      return join$2(".", n.body);
    case "Identifier":
      return concat$2([
        n.name,
        n.optional ? "?" : "",
        path.call(print, "typeAnnotation")
      ]);
    case "SpreadElement":
    case "SpreadElementPattern":
    // Babel 6 for ObjectPattern
    case "RestProperty":
    case "SpreadProperty":
    case "SpreadPropertyPattern":
    case "RestElement":
    case "ObjectTypeSpreadProperty":
      return concat$2([
        "...",
        path.call(print, "argument"),
        path.call(print, "typeAnnotation")
      ]);
    case "FunctionDeclaration":
    case "FunctionExpression":
      return printFunctionDeclaration(path, print, options);
    case "ArrowFunctionExpression": {
      if (n.async) parts.push("async ");

      if (n.typeParameters) {
        parts.push(path.call(print, "typeParameters"));
      }

      if (canPrintParamsWithoutParens(n)) {
        parts.push(path.call(print, "params", 0));
      } else {
        parts.push(
          group$1(
            concat$2([
              printFunctionParams(
                path,
                print,
                options,
                args && (args.expandLastArg || args.expandFirstArg)
              ),
              printReturnType(path, print)
            ])
          )
        );
      }

      parts.push(" =>");

      const body = path.call(print, "body");
      const collapsed = concat$2([concat$2(parts), " ", body]);

      // We want to always keep these types of nodes on the same line
      // as the arrow.
      if (
        n.body.type === "ArrayExpression" ||
        n.body.type === "ObjectExpression" ||
        n.body.type === "JSXElement" ||
        n.body.type === "BlockStatement" ||
        n.body.type === "TaggedTemplateExpression" ||
        n.body.type === "TemplateElement" ||
        n.body.type === "ClassExpression" ||
        n.body.type === "ArrowFunctionExpression"
      ) {
        return group$1(collapsed);
      }

      // if the arrow function is expanded as last argument, we are adding a
      // level of indentation and need to add a softline to align the closing )
      // with the opening (.
      const shouldAddSoftLine = args && args.expandLastArg;

      return group$1(
        concat$2([
          concat$2(parts),
          group$1(
            concat$2([
              indent$2(concat$2([line$1, body])),
              shouldAddSoftLine
                ? concat$2([
                    ifBreak$1(shouldPrintComma(options, "all") ? "," : ""),
                    softline$1
                  ])
                : ""
            ])
          )
        ])
      );
    }
    case "MethodDefinition":
      if (n.static) {
        parts.push("static ");
      }

      parts.push(printMethod(path, options, print));

      return concat$2(parts);
    case "YieldExpression":
      parts.push("yield");

      if (n.delegate) parts.push("*");

      if (n.argument) parts.push(" ", path.call(print, "argument"));

      return concat$2(parts);
    case "AwaitExpression":
      parts.push("await");

      if (n.all) parts.push("*");

      if (n.argument) parts.push(" ", path.call(print, "argument"));

      return concat$2(parts);
    case "ModuleDeclaration":
      parts.push("module", path.call(print, "id"));

      if (n.source) {
        assert$4.ok(!n.body);

        parts.push("from", path.call(print, "source"));
      } else {
        parts.push(path.call(print, "body"));
      }

      return join$2(" ", parts);
    case "ImportSpecifier":
      if (n.imported) {
        if (n.importKind) {
          parts.push(path.call(print, "importKind"), " ");
        }

        parts.push(path.call(print, "imported"));

        if (n.local && n.local.name !== n.imported.name) {
          parts.push(" as ", path.call(print, "local"));
        }
      } else if (n.id) {
        parts.push(path.call(print, "id"));

        if (n.name) {
          parts.push(" as ", path.call(print, "name"));
        }
      }

      return concat$2(parts);
    case "ExportSpecifier":
      if (n.local) {
        parts.push(path.call(print, "local"));

        if (n.exported && n.exported.name !== n.local.name) {
          parts.push(" as ", path.call(print, "exported"));
        }
      } else if (n.id) {
        parts.push(path.call(print, "id"));

        if (n.name) {
          parts.push(" as ", path.call(print, "name"));
        }
      }

      return concat$2(parts);
    case "ExportBatchSpecifier":
      return "*";
    case "ImportNamespaceSpecifier":
      parts.push("* as ");

      if (n.local) {
        parts.push(path.call(print, "local"));
      } else if (n.id) {
        parts.push(path.call(print, "id"));
      }

      return concat$2(parts);
    case "ImportDefaultSpecifier":
      if (n.local) {
        return path.call(print, "local");
      }

      return path.call(print, "id");
    case "ExportDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
      return printExportDeclaration(path, options, print);
    case "ExportAllDeclaration":
      parts.push("export *");

      if (n.exported) {
        parts.push(" as ", path.call(print, "exported"));
      }

      parts.push(" from ", path.call(print, "source"), semi);

      return concat$2(parts);
    case "ExportNamespaceSpecifier":
    case "ExportDefaultSpecifier":
      return path.call(print, "exported");
    case "ImportDeclaration":
      parts.push("import ");

      const fromParts = [];

      if (n.importKind && n.importKind !== "value") {
        parts.push(n.importKind + " ");
      }

      var standalones = [];
      var grouped = [];
      if (n.specifiers && n.specifiers.length > 0) {
        path.each(function(specifierPath) {
          var value = specifierPath.getValue();
          if (
            namedTypes.ImportDefaultSpecifier.check(value) ||
            namedTypes.ImportNamespaceSpecifier.check(value)
          ) {
            standalones.push(print(specifierPath));
          } else {
            grouped.push(print(specifierPath));
          }
        }, "specifiers");

        if (standalones.length > 0) {
          parts.push(join$2(", ", standalones));
        }

        if (standalones.length > 0 && grouped.length > 0) {
          parts.push(", ");
        }

        if (grouped.length > 0) {
          parts.push(
            group$1(
              concat$2([
                "{",
                indent$2(
                  concat$2([
                    options.bracketSpacing ? line$1 : softline$1,
                    join$2(concat$2([",", line$1]), grouped)
                  ])
                ),
                ifBreak$1(shouldPrintComma(options) ? "," : ""),
                options.bracketSpacing ? line$1 : softline$1,
                "}"
              ])
            )
          );
        }

        fromParts.push(grouped.length === 0 ? line$1 : " ", "from ");
      } else if (n.importKind && n.importKind === "type") {
        parts.push("{} from ");
      }

      fromParts.push(path.call(print, "source"), semi);

      // If there's a very long import, break the following way:
      //
      //   import veryLong
      //     from 'verylong'
      //
      // In case there are grouped elements, they will already break the way
      // we want and this break would take precedence instead.
      if (grouped.length === 0) {
        return group$1(concat$2([concat$2(parts), indent$2(concat$2(fromParts))]));
      }

      return concat$2([concat$2(parts), concat$2(fromParts)]);

    case "Import": {
      return "import";
    }
    case "BlockStatement": {
      var naked = path.call(function(bodyPath) {
        return printStatementSequence(bodyPath, options, print);
      }, "body");

      const hasContent = n.body.find(node => node.type !== "EmptyStatement");
      const hasDirectives = n.directives && n.directives.length > 0;

      var parent = path.getParentNode();
      const parentParent = path.getParentNode(1);
      if (
        !hasContent &&
        !hasDirectives &&
        !n.comments &&
        (parent.type === "ArrowFunctionExpression" ||
          parent.type === "FunctionExpression" ||
          parent.type === "FunctionDeclaration" ||
          parent.type === "ObjectMethod" ||
          parent.type === "ClassMethod" ||
          (parent.type === "CatchClause" && !parentParent.finalizer))
      ) {
        return "{}";
      }

      parts.push("{");

      // Babel 6
      if (hasDirectives) {
        path.each(function(childPath) {
          parts.push(indent$2(concat$2([hardline$2, print(childPath), semi])));
        }, "directives");
      }

      if (hasContent) {
        parts.push(indent$2(concat$2([hardline$2, naked])));
      }

      parts.push(comments$3.printDanglingComments(path, options));
      parts.push(hardline$2, "}");

      return concat$2(parts);
    }
    case "ReturnStatement":
      parts.push("return");

      if (n.argument) {
        if (returnArgumentHasLeadingComment(options, n.argument)) {
          parts.push(
            concat$2([
              " (",
              indent$2(concat$2([softline$1, path.call(print, "argument")])),
              line$1,
              ")"
            ])
          );
        } else if (
          n.argument.type === "LogicalExpression" ||
          n.argument.type === "BinaryExpression"
        ) {
          parts.push(
            group$1(
              concat$2([
                ifBreak$1(" (", " "),
                indent$2(concat$2([softline$1, path.call(print, "argument")])),
                softline$1,
                ifBreak$1(")")
              ])
            )
          );
        } else {
          parts.push(" ", path.call(print, "argument"));
        }
      }

      const hasDanglingComments =
        n.comments &&
        n.comments.some(comment => !comment.leading && !comment.trailing);

      if (hasDanglingComments) {
        parts.push(
          " ",
          comments$3.printDanglingComments(path, options, /* sameIndent */ true)
        );
      }

      parts.push(semi);

      return concat$2(parts);
    case "CallExpression": {
      if (
        // We want to keep require calls as a unit
        (n.callee.type === "Identifier" && n.callee.name === "require") ||
        // Keep test declarations on a single line
        // e.g. `it('long name', () => {`
        (n.callee.type === "Identifier" &&
          (n.callee.name === "it" ||
            n.callee.name === "test" ||
            n.callee.name === "describe") &&
          n.arguments.length === 2 &&
          (n.arguments[0].type === "StringLiteral" ||
            n.arguments[0].type === "TemplateLiteral" ||
            (n.arguments[0].type === "Literal" &&
              typeof n.arguments[0].value === "string")) &&
          (n.arguments[1].type === "FunctionExpression" ||
            n.arguments[1].type === "ArrowFunctionExpression") &&
          n.arguments[1].params.length <= 1)
      ) {
        return concat$2([
          path.call(print, "callee"),
          path.call(print, "typeParameters"),
          concat$2(["(", join$2(", ", path.map(print, "arguments")), ")"])
        ]);
      }

      // We detect calls on member lookups and possibly print them in a
      // special chain format. See `printMemberChain` for more info.
      if (n.callee.type === "MemberExpression") {
        return printMemberChain(path, options, print);
      }

      return concat$2([
        path.call(print, "callee"),
        path.call(print, "typeParameters"),
        printArgumentsList(path, options, print)
      ]);
    }

    case "ObjectExpression":
    case "ObjectPattern":
    case "ObjectTypeAnnotation":
    case "TSTypeLiteral":
      var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
      var isTypeScriptTypeAnnotaion = n.type === "TSTypeLiteral";
      // Leave this here because we *might* want to make this
      // configurable later -- flow accepts ";" for type separators,
      // typescript accepts ";" and newlines
      var separator = isTypeAnnotation ? "," : ",";
      var fields = [];
      var leftBrace = n.exact ? "{|" : "{";
      var rightBrace = n.exact ? "|}" : "}";
      var parent = path.getParentNode(0);
      var parentIsUnionTypeAnnotation = parent.type === "UnionTypeAnnotation";
      var propertiesField = isTypeScriptTypeAnnotaion
        ? "members"
        : "properties";

      if (isTypeAnnotation) {
        fields.push("indexers", "callProperties");
      }

      fields.push(propertiesField);

      var props = [];
      let separatorParts = [];

      fields.forEach(function(field) {
        path.each(function(childPath) {
          props.push(concat$2(separatorParts));
          props.push(group$1(print(childPath)));

          separatorParts = [separator, line$1];
          if (
            util$4.isNextLineEmpty(options.originalText, childPath.getValue())
          ) {
            separatorParts.push(hardline$2);
          }
        }, field);
      });

      const lastElem = util$4.getLast(n[propertiesField]);

      const canHaveTrailingComma = !(
        lastElem &&
        (lastElem.type === "RestProperty" || lastElem.type === "RestElement")
      );

      const shouldBreak =
        n.type !== "ObjectPattern" &&
        util$4.hasNewlineInRange(
          options.originalText,
          util$4.locStart(n),
          util$4.locEnd(n)
        );

      if (props.length === 0) {
        return group$1(
          concat$2([
            leftBrace,
            comments$3.printDanglingComments(path, options),
            softline$1,
            rightBrace
          ])
        );
      } else {
        return group$1(
          concat$2([
            leftBrace,
            indent$2(
              align$2(
                parentIsUnionTypeAnnotation ? 2 : 0,
                concat$2([
                  options.bracketSpacing ? line$1 : softline$1,
                  concat$2(props)
                ])
              )
            ),
            ifBreak$1(
              canHaveTrailingComma && shouldPrintComma(options) ? "," : ""
            ),
            align$2(
              parentIsUnionTypeAnnotation ? 2 : 0,
              concat$2([options.bracketSpacing ? line$1 : softline$1, rightBrace])
            ),
            path.call(print, "typeAnnotation")
          ]),
          { shouldBreak }
        );
      }

    case "PropertyPattern":
      return concat$2([
        path.call(print, "key"),
        ": ",
        path.call(print, "pattern")
      ]);
    // Babel 6
    case "ObjectProperty": // Non-standard AST node type.
    case "Property":
      if (n.method || n.kind === "get" || n.kind === "set") {
        return printMethod(path, options, print);
      }

      if (n.shorthand) {
        parts.push(path.call(print, "value"));
      } else {
        if (n.computed) {
          parts.push("[", path.call(print, "key"), "]");
        } else {
          parts.push(printPropertyKey(path, options, print));
        }
        parts.push(concat$2([": ", path.call(print, "value")]));
      }

      return concat$2(parts); // Babel 6
    case "ClassMethod":
      if (n.static) {
        parts.push("static ");
      }

      parts = parts.concat(printObjectMethod(path, options, print));

      return concat$2(parts); // Babel 6
    case "ObjectMethod":
      return printObjectMethod(path, options, print);
    case "Decorator":
      return concat$2(["@", path.call(print, "expression")]);
    case "ArrayExpression":
    case "ArrayPattern":
      if (n.elements.length === 0) {
        parts.push(
          group$1(
            concat$2([
              "[",
              comments$3.printDanglingComments(path, options),
              softline$1,
              "]"
            ])
          )
        );
      } else {
        const lastElem = util$4.getLast(n.elements);
        const canHaveTrailingComma = !(lastElem &&
          lastElem.type === "RestElement");

        // JavaScript allows you to have empty elements in an array which
        // changes its length based on the number of commas. The algorithm
        // is that if the last argument is null, we need to force insert
        // a comma to ensure JavaScript recognizes it.
        //   [,].length === 1
        //   [1,].length === 1
        //   [1,,].length === 2
        //
        // Note that util.getLast returns null if the array is empty, but
        // we already check for an empty array just above so we are safe
        const needsForcedTrailingComma =
          canHaveTrailingComma && lastElem === null;

        parts.push(
          group$1(
            concat$2([
              "[",
              indent$2(
                concat$2([
                  softline$1,
                  printArrayItems(path, options, "elements", print)
                ])
              ),
              needsForcedTrailingComma ? "," : "",
              ifBreak$1(
                canHaveTrailingComma &&
                  !needsForcedTrailingComma &&
                  shouldPrintComma(options)
                  ? ","
                  : ""
              ),
              comments$3.printDanglingComments(
                path,
                options,
                /* sameIndent */ true
              ),
              softline$1,
              "]"
            ])
          )
        );
      }

      if (n.typeAnnotation) parts.push(path.call(print, "typeAnnotation"));

      return concat$2(parts);
    case "SequenceExpression":
      return join$2(", ", path.map(print, "expressions"));
    case "ThisExpression":
      return "this";
    case "Super":
      return "super";
    // Babel 6 Literal split
    case "NullLiteral":
      return "null";
    // Babel 6 Literal split
    case "RegExpLiteral":
      return printRegex(n);
    // Babel 6 Literal split
    case "NumericLiteral":
      return printNumber(n.extra.raw);
    // Babel 6 Literal split
    case "BooleanLiteral":
    // Babel 6 Literal split
    case "StringLiteral":
    case "Literal":
      if (typeof n.value === "number") return printNumber(n.raw);
      if (n.regex) return printRegex(n.regex);
      if (typeof n.value !== "string") return "" + n.value;

      return nodeStr(n, options); // Babel 6
    case "Directive":
      return path.call(print, "value"); // Babel 6
    case "DirectiveLiteral":
      return nodeStr(n, options);
    case "ModuleSpecifier":
      if (n.local) {
        throw new Error("The ESTree ModuleSpecifier type should be abstract");
      }

      // The Esprima ModuleSpecifier type is just a string-valued
      // Literal identifying the imported-from module.
      return nodeStr(n, options);
    case "UnaryExpression":
      parts.push(n.operator);

      if (/[a-z]$/.test(n.operator)) parts.push(" ");

      parts.push(path.call(print, "argument"));

      return concat$2(parts);
    case "UpdateExpression":
      parts.push(path.call(print, "argument"), n.operator);

      if (n.prefix) parts.reverse();

      return concat$2(parts);
    case "ConditionalExpression":
      return group$1(
        concat$2([
          path.call(print, "test"),
          indent$2(
            concat$2([
              line$1,
              "? ",
              align$2(2, path.call(print, "consequent")),
              line$1,
              ": ",
              align$2(2, path.call(print, "alternate"))
            ])
          )
        ])
      );
    case "NewExpression":
      parts.push("new ", path.call(print, "callee"));

      if (n.typeParameters) {
        parts.push(path.call(print, "typeParameters"));
      }

      var args = n.arguments;

      if (args) {
        parts.push(printArgumentsList(path, options, print));
      }

      return concat$2(parts);
    case "VariableDeclaration":
      var printed = path.map(function(childPath) {
        return print(childPath);
      }, "declarations");

      parts = [
        n.kind,
        " ",
        printed[0],
        indent$2(concat$2(printed.slice(1).map(p => concat$2([",", line$1, p]))))
      ];

      // We generally want to terminate all variable declarations with a
      // semicolon, except when they in the () part of for loops.
      var parentNode = path.getParentNode();

      var isParentForLoop =
        namedTypes.ForStatement.check(parentNode) ||
        namedTypes.ForInStatement.check(parentNode) ||
        (namedTypes.ForOfStatement &&
          namedTypes.ForOfStatement.check(parentNode)) ||
        (namedTypes.ForAwaitStatement &&
          namedTypes.ForAwaitStatement.check(parentNode));

      if (!(isParentForLoop && parentNode.body !== n)) {
        parts.push(semi);
      }

      return group$1(concat$2(parts));
    case "VariableDeclarator":
      return printAssignment(
        n.id,
        path.call(print, "id"),
        "=",
        n.init,
        n.init && path.call(print, "init"),
        options
      );
    case "WithStatement":
      return concat$2([
        "with (",
        path.call(print, "object"),
        ")",
        adjustClause(n.body, path.call(print, "body"))
      ]);
    case "IfStatement":
      const con = adjustClause(n.consequent, path.call(print, "consequent"));
      const opening = group$1(
        concat$2([
          "if (",
          group$1(
            concat$2([
              indent$2(concat$2([softline$1, path.call(print, "test")])),
              softline$1
            ])
          ),
          ")",
          con
        ])
      );

      parts.push(opening);

      if (n.alternate) {
        if (n.consequent.type === "BlockStatement") {
          parts.push(" else");
        } else {
          parts.push(hardline$2, "else");
        }

        parts.push(
          group$1(
            adjustClause(
              n.alternate,
              path.call(print, "alternate"),
              n.alternate.type === "IfStatement"
            )
          )
        );
      }

      return concat$2(parts);
    case "ForStatement": {
      const body = adjustClause(n.body, path.call(print, "body"));

      // We want to keep dangling comments above the loop to stay consistent.
      // Any comment positioned between the for statement and the parentheses
      // is going to be printed before the statement.
      const dangling = comments$3.printDanglingComments(
        path,
        options,
        /* sameLine */ true
      );
      const printedComments = dangling ? concat$2([dangling, softline$1]) : "";

      if (!n.init && !n.test && !n.update) {
        return concat$2([printedComments, "for (;;)", body]);
      }

      return concat$2([
        printedComments,
        "for (",
        group$1(
          concat$2([
            indent$2(
              concat$2([
                softline$1,
                path.call(print, "init"),
                ";",
                line$1,
                path.call(print, "test"),
                ";",
                line$1,
                path.call(print, "update")
              ])
            ),
            softline$1
          ])
        ),
        ")",
        body
      ]);
    }
    case "WhileStatement":
      return concat$2([
        "while (",
        group$1(
          concat$2([
            indent$2(concat$2([softline$1, path.call(print, "test")])),
            softline$1
          ])
        ),
        ")",
        adjustClause(n.body, path.call(print, "body"))
      ]);
    case "ForInStatement":
      // Note: esprima can't actually parse "for each (".
      return concat$2([
        n.each ? "for each (" : "for (",
        path.call(print, "left"),
        " in ",
        path.call(print, "right"),
        ")",
        adjustClause(n.body, path.call(print, "body"))
      ]);

    case "ForOfStatement":
    case "ForAwaitStatement":
      // Babylon 7 removed ForAwaitStatement in favor of ForOfStatement
      // with `"await": true`:
      // https://github.com/estree/estree/pull/138
      const isAwait = n.type === "ForAwaitStatement" || n.await;

      return concat$2([
        "for",
        isAwait ? " await" : "",
        " (",
        path.call(print, "left"),
        " of ",
        path.call(print, "right"),
        ")",
        adjustClause(n.body, path.call(print, "body"))
      ]);

    case "DoWhileStatement":
      var clause = adjustClause(n.body, path.call(print, "body"));
      var doBody = concat$2(["do", clause]);
      var parts = [doBody];

      if (n.body.type === "BlockStatement") {
        parts.push(" ");
      } else {
        parts.push(hardline$2);
      }
      parts.push("while");

      parts.push(" (", path.call(print, "test"), ")", semi);

      return concat$2(parts);
    case "DoExpression":
      return concat$2(["do ", path.call(print, "body")]);
    case "BreakStatement":
      parts.push("break");

      if (n.label) parts.push(" ", path.call(print, "label"));

      parts.push(semi);

      return concat$2(parts);
    case "ContinueStatement":
      parts.push("continue");

      if (n.label) parts.push(" ", path.call(print, "label"));

      parts.push(semi);

      return concat$2(parts);
    case "LabeledStatement":
      if (n.body.type === "EmptyStatement") {
        return concat$2([path.call(print, "label"), ":;"]);
      }

      return concat$2([
        path.call(print, "label"),
        ": ",
        path.call(print, "body")
      ]);
    case "TryStatement":
      parts.push("try ", path.call(print, "block"));

      if (n.handler) {
        parts.push(" ", path.call(print, "handler"));
      } else if (n.handlers) {
        path.each(function(handlerPath) {
          parts.push(" ", print(handlerPath));
        }, "handlers");
      }

      if (n.finalizer) {
        parts.push(" finally ", path.call(print, "finalizer"));
      }

      return concat$2(parts);
    case "CatchClause":
      parts.push("catch (", path.call(print, "param"));

      if (n.guard)
        // Note: esprima does not recognize conditional catch clauses.
        parts.push(" if ", path.call(print, "guard"));

      parts.push(") ", path.call(print, "body"));

      return concat$2(parts);
    case "ThrowStatement":
      return concat$2(["throw ", path.call(print, "argument"), semi]);
    // Note: ignoring n.lexical because it has no printing consequences.
    case "SwitchStatement":
      return concat$2([
        "switch (",
        path.call(print, "discriminant"),
        ") {",
        n.cases.length > 0
          ? indent$2(concat$2([hardline$2, join$2(hardline$2, path.map(print, "cases"))]))
          : "",
        hardline$2,
        "}"
      ]);
    case "SwitchCase":
      if (n.test) parts.push("case ", path.call(print, "test"), ":");
      else parts.push("default:");

      const isFirstCase = path.getNode() === path.getParentNode().cases[0];

      if (
        !isFirstCase &&
        util$4.isPreviousLineEmpty(options.originalText, path.getValue())
      ) {
        parts.unshift(hardline$2);
      }

      if (n.consequent.find(node => node.type !== "EmptyStatement")) {
        const cons = path.call(consequentPath => {
          return join$2(
            hardline$2,
            consequentPath
              .map((p, i) => {
                if (n.consequent[i].type === "EmptyStatement") {
                  return null;
                }
                const shouldAddLine =
                  i !== n.consequent.length - 1 &&
                  util$4.isNextLineEmpty(options.originalText, p.getValue());
                return concat$2([print(p), shouldAddLine ? hardline$2 : ""]);
              })
              .filter(e => e !== null)
          );
        }, "consequent");
        parts.push(
          n.consequent.length === 1 && n.consequent[0].type === "BlockStatement"
            ? concat$2([" ", cons])
            : indent$2(concat$2([hardline$2, cons]))
        );
      }

      return concat$2(parts);
    // JSX extensions below.
    case "DebuggerStatement":
      return concat$2(["debugger", semi]);
    case "JSXAttribute":
      parts.push(path.call(print, "name"));

      if (n.value) {
        let res;
        if (
          (n.value.type === "StringLiteral" || n.value.type === "Literal") &&
          typeof n.value.value === "string"
        ) {
          const value = n.value.extra ? n.value.extra.raw : n.value.raw;
          res =
            '"' +
            value.slice(1, value.length - 1).replace(/"/g, "&quot;") +
            '"';
        } else {
          res = path.call(print, "value");
        }
        parts.push("=", res);
      }

      return concat$2(parts);
    case "JSXIdentifier":
      return "" + n.name;
    case "JSXNamespacedName":
      return join$2(":", [
        path.call(print, "namespace"),
        path.call(print, "name")
      ]);
    case "JSXMemberExpression":
      return join$2(".", [
        path.call(print, "object"),
        path.call(print, "property")
      ]);
    case "JSXSpreadAttribute":
      return concat$2(["{...", path.call(print, "argument"), "}"]);
    case "JSXExpressionContainer": {
      const parent = path.getParentNode(0);

      const shouldInline =
        n.expression.type === "ArrayExpression" ||
        n.expression.type === "ObjectExpression" ||
        n.expression.type === "ArrowFunctionExpression" ||
        n.expression.type === "CallExpression" ||
        n.expression.type === "FunctionExpression" ||
        n.expression.type === "JSXEmptyExpression" ||
        n.expression.type === "TemplateLiteral" ||
        n.expression.type === "TaggedTemplateExpression" ||
        (parent.type === "JSXElement" &&
          (n.expression.type === "ConditionalExpression" ||
            isBinaryish(n.expression)));

      if (shouldInline) {
        return group$1(
          concat$2(["{", path.call(print, "expression"), lineSuffixBoundary$1, "}"])
        );
      }

      return group$1(
        concat$2([
          "{",
          indent$2(concat$2([softline$1, path.call(print, "expression")])),
          softline$1,
          lineSuffixBoundary$1,
          "}"
        ])
      );
    }
    case "JSXElement": {
      const elem = printJSXElement(path, options, print);
      return maybeWrapJSXElementInParens(path, elem, options);
    }
    case "JSXOpeningElement": {
      const n = path.getValue();

      // don't break up opening elements with a single long text attribute
      if (
        n.attributes.length === 1 &&
        n.attributes[0].value &&
        (n.attributes[0].value.type === "Literal" ||
          n.attributes[0].value.type === "StringLiteral") &&
        typeof n.attributes[0].value.value === "string"
      ) {
        return group$1(
          concat$2([
            "<",
            path.call(print, "name"),
            " ",
            concat$2(path.map(print, "attributes")),
            n.selfClosing ? " />" : ">"
          ])
        );
      }

      return group$1(
        concat$2([
          "<",
          path.call(print, "name"),
          concat$2([
            indent$2(
              concat$2(
                path.map(attr => concat$2([line$1, print(attr)]), "attributes")
              )
            ),
            n.selfClosing ? line$1 : options.jsxBracketSameLine ? ">" : softline$1
          ]),
          n.selfClosing ? "/>" : options.jsxBracketSameLine ? "" : ">"
        ])
      );
    }
    case "JSXClosingElement":
      return concat$2(["</", path.call(print, "name"), ">"]);
    case "JSXText":
      throw new Error("JSXTest should be handled by JSXElement");
    case "JSXEmptyExpression":
      const requiresHardline = n.comments && n.comments.some(
        comment => comment.type === "Line" || comment.type === "CommentLine"
      );

      return concat$2([
        comments$3.printDanglingComments(
          path,
          options,
          /* sameIndent */ !requiresHardline
        ),
        requiresHardline ? hardline$2 : ""
      ]);
    case "TypeAnnotatedIdentifier":
      return concat$2([
        path.call(print, "annotation"),
        " ",
        path.call(print, "identifier")
      ]);
    case "ClassBody":
      if (!n.comments && n.body.length === 0) {
        return "{}";
      }

      return concat$2([
        "{",
        n.body.length > 0
          ? indent$2(
              concat$2([
                hardline$2,
                path.call(function(bodyPath) {
                  return printStatementSequence(bodyPath, options, print);
                }, "body")
              ])
            )
          : comments$3.printDanglingComments(path, options),
        hardline$2,
        "}"
      ]);
    case "ClassPropertyDefinition":
      parts.push("static ", path.call(print, "definition"));

      if (!namedTypes.MethodDefinition.check(n.definition)) parts.push(semi);

      return concat$2(parts);
    case "ClassProperty":
      if (n.static) parts.push("static ");

      var key;

      if (n.computed) {
        key = concat$2(["[", path.call(print, "key"), "]"]);
      } else {
        key = printPropertyKey(path, options, print);

        var variance = getFlowVariance(n, options);

        if (variance) {
          key = concat$2([variance, key]);
        } else if (n.accessibility === "public") {
          key = concat$2(["public ", key]);
        } else if (n.accessibility === "protected") {
          key = concat$2(["protected ", key]);
        } else if (n.accessibility === "private") {
          key = concat$2(["private ", key]);
        }
      }

      parts.push(key);

      if (n.typeAnnotation) parts.push(path.call(print, "typeAnnotation"));

      if (n.value) parts.push(" = ", path.call(print, "value"));

      parts.push(semi);

      return concat$2(parts);
    case "ClassDeclaration":
    case "ClassExpression":
      return concat$2(printClass(path, options, print));
    case "TemplateElement":
      return join$2(literalline$1, n.value.raw.split("\n"));
    case "TemplateLiteral":
      var expressions = path.map(print, "expressions");

      parts.push("`");

      path.each(function(childPath) {
        var i = childPath.getName();

        parts.push(print(childPath));

        if (i < expressions.length) {
          parts.push(
            "${",
            removeLines(expressions[i]),
            lineSuffixBoundary$1,
            "}"
          );
        }
      }, "quasis");

      parts.push("`");

      return concat$2(parts);
    // These types are unprintable because they serve as abstract
    // supertypes for other (printable) types.
    case "TaggedTemplateExpression":
      return concat$2([path.call(print, "tag"), path.call(print, "quasi")]);
    case "Node":
    case "Printable":
    case "SourceLocation":
    case "Position":
    case "Statement":
    case "Function":
    case "Pattern":
    case "Expression":
    case "Declaration":
    case "Specifier":
    case "NamedSpecifier":
    // Supertype of Block and Line.
    case "Comment":
    // Flow
    case "MemberTypeAnnotation": // Flow
    case "Type":
      throw new Error("unprintable type: " + JSON.stringify(n.type));
    // Type Annotations for Facebook Flow, typically stripped out or
    // transformed away before printing.
    case "TypeAnnotation":
      if (n.typeAnnotation) {
        if (
          n.typeAnnotation.type !== "FunctionTypeAnnotation" &&
          !shouldTypeScriptTypeAvoidColon(path) &&
          // TypeScript should not have a colon before type parameter constraints
          !(path.getParentNode().type === "TypeParameter" &&
            path.getParentNode().constraint) &&
          // TypeScript should not have a colon in TSFirstTypeNode nodes
          // `a is number`
          !(path.getParentNode().type === "TypeAnnotation" &&
           path.getParentNode().typeAnnotation.type === 'TSFirstTypeNode')
        ) {
          parts.push(": ");
        }

        parts.push(path.call(print, "typeAnnotation"));

        return concat$2(parts);
      }

      return "";
    case "TSTupleType":
    case "TupleTypeAnnotation":
      let typesField = n.type === "TSTupleType" ? "elementTypes" : "types";
      return group$1(
        concat$2([
          "[",
          indent$2(
            concat$2([
              softline$1,
              printArrayItems(path, options, typesField, print)
            ])
          ),
          ifBreak$1(shouldPrintComma(options) ? "," : ""),
          comments$3.printDanglingComments(path, options, /* sameIndent */ true),
          softline$1,
          "]"
        ])
      );

    case "ExistsTypeAnnotation":
      return "*";
    case "EmptyTypeAnnotation":
      return "empty";
    case "AnyTypeAnnotation":
      return "any";
    case "MixedTypeAnnotation":
      return "mixed";
    case "ArrayTypeAnnotation":
      return concat$2([path.call(print, "elementType"), "[]"]);
    case "BooleanTypeAnnotation":
      return "boolean";
    case "BooleanLiteralTypeAnnotation":
      return "" + n.value;
    case "DeclareClass":
      return printFlowDeclaration(path, printClass(path, options, print));
    case "DeclareFunction":
      // For TypeScript the DeclareFunction node shares the AST
      // structure with FunctionDeclaration
      if (n.params) {
        return concat$2([
          "declare ",
          printFunctionDeclaration(path, print, options)
        ]);
      }
      return printFlowDeclaration(path, [
        "function ",
        path.call(print, "id"),
        n.predicate ? " " : "",
        path.call(print, "predicate"),
        semi
      ]);
    case "DeclareModule":
      return printFlowDeclaration(path, [
        "module ",
        path.call(print, "id"),
        " ",
        path.call(print, "body")
      ]);
    case "DeclareModuleExports":
      return printFlowDeclaration(path, [
        "module.exports",
        path.call(print, "typeAnnotation"),
        semi
      ]);
    case "DeclareVariable":
      return printFlowDeclaration(path, ["var ", path.call(print, "id"), semi]);
    case "DeclareExportAllDeclaration":
      return concat$2(["declare export * from ", path.call(print, "source")]);
    case "DeclareExportDeclaration":
      return concat$2(["declare ", printExportDeclaration(path, options, print)]);
    case "FunctionTypeAnnotation":
    case "TSFunctionType":
      // FunctionTypeAnnotation is ambiguous:
      // declare function foo(a: B): void; OR
      // var A: (a: B) => void;
      var parent = path.getParentNode(0);
      var parentParent = path.getParentNode(1);
      var isArrowFunctionTypeAnnotation =
        n.type === "TSFunctionType" ||
        !((!getFlowVariance(parent, options) &&
          !parent.optional &&
          namedTypes.ObjectTypeProperty.check(parent)) ||
          namedTypes.ObjectTypeCallProperty.check(parent) ||
          namedTypes.DeclareFunction.check(path.getParentNode(2)));

      var needsColon =
        isArrowFunctionTypeAnnotation &&
        namedTypes.TypeAnnotation.check(parent);

      // Sadly we can't put it inside of FastPath::needsColon because we are
      // printing ":" as part of the expression and it would put parenthesis
      // around :(
      const needsParens =
        needsColon &&
        isArrowFunctionTypeAnnotation &&
        parent.type === "TypeAnnotation" &&
        parentParent.type === "ArrowFunctionExpression";

      if (isObjectTypePropertyAFunction(parent)) {
        isArrowFunctionTypeAnnotation = true;
        needsColon = true;
      }

      if (needsColon) {
        parts.push(": ");
      }
      if (needsParens) {
        parts.push("(");
      }

      parts.push(path.call(print, "typeParameters"));

      parts.push(printFunctionParams(path, print, options));

      // The returnType is not wrapped in a TypeAnnotation, so the colon
      // needs to be added separately.
      if (n.returnType || n.predicate || n.typeAnnotation) {
        parts.push(
          isArrowFunctionTypeAnnotation ? " => " : ": ",
          path.call(print, "returnType"),
          path.call(print, "predicate"),
          path.call(print, "typeAnnotation")
        );
      }
      if (needsParens) {
        parts.push(")");
      }

      return group$1(concat$2(parts));
    case "FunctionTypeParam":
      return concat$2([
        path.call(print, "name"),
        n.optional ? "?" : "",
        n.name ? ": " : "",
        path.call(print, "typeAnnotation")
      ]);
    case "GenericTypeAnnotation":
      return concat$2([
        path.call(print, "id"),
        path.call(print, "typeParameters")
      ]);
    case "DeclareInterface":
    case "InterfaceDeclaration": {
      if (
        n.type === "DeclareInterface" ||
        isFlowNodeStartingWithDeclare(n, options)
      ) {
        parts.push("declare ");
      }

      parts.push(
        "interface ",
        path.call(print, "id"),
        path.call(print, "typeParameters")
      );

      if (n["extends"].length > 0) {
        parts.push(
          group$1(
            indent$2(
              concat$2([line$1, "extends ", join$2(", ", path.map(print, "extends"))])
            )
          )
        );
      }

      parts.push(" ");
      parts.push(path.call(print, "body"));

      return group$1(concat$2(parts));
    }
    case "ClassImplements":
    case "InterfaceExtends":
      return concat$2([
        path.call(print, "id"),
        path.call(print, "typeParameters")
      ]);
    case "IntersectionTypeAnnotation": {
      const types = path.map(print, "types");
      const result = [];
      for (let i = 0; i < types.length; ++i) {
        if (i === 0) {
          result.push(types[i]);
        } else if (
          n.types[i - 1].type !== "ObjectTypeAnnotation" &&
          n.types[i].type !== "ObjectTypeAnnotation"
        ) {
          // If no object is involved, go to the next line if it breaks
          result.push(indent$2(concat$2([" &", line$1, types[i]])));
        } else {
          // If you go from object to non-object or vis-versa, then inline it
          result.push(" & ", i > 1 ? indent$2(types[i]) : types[i]);
        }
      }
      return group$1(concat$2(result));
    }
    case "TSUnionType":
    case "UnionTypeAnnotation": {
      // single-line variation
      // A | B | C

      // multi-line variation
      // | A
      // | B
      // | C

      const parent = path.getParentNode();
      // If there's a leading comment, the parent is doing the indentation
      const shouldIndent = !(parent.type === "TypeAlias" &&
        hasLeadingOwnLineComment(options.originalText, n));

      //const token = isIntersection ? "&" : "|";
      const code = concat$2([
        ifBreak$1(concat$2([shouldIndent ? line$1 : "", "| "])),
        join$2(concat$2([line$1, "| "]), path.map(print, "types"))
      ]);

      return group$1(shouldIndent ? indent$2(code) : code);
    }
    case "NullableTypeAnnotation":
      return concat$2(["?", path.call(print, "typeAnnotation")]);
    case "NullLiteralTypeAnnotation":
      return "null";
    case "ThisTypeAnnotation":
      return "this";
    case "NumberTypeAnnotation":
      return "number";
    case "ObjectTypeCallProperty":
      if (n.static) {
        parts.push("static ");
      }

      parts.push(path.call(print, "value"));

      return concat$2(parts);
    case "ObjectTypeIndexer":
      var variance = getFlowVariance(n, options);
      return concat$2([
        variance || "",
        "[",
        path.call(print, "id"),
        n.id ? ": " : "",
        path.call(print, "key"),
        "]: ",
        path.call(print, "value")
      ]);
    case "ObjectTypeProperty":
      var variance = getFlowVariance(n, options);
      // TODO: This is a bad hack and we need a better way to know
      // when to emit an arrow function or not.
      var isFunction =
        !variance && !n.optional && n.value.type === "FunctionTypeAnnotation";

      if (isObjectTypePropertyAFunction(n)) {
        isFunction = true;
      }

      return concat$2([
        n.static ? "static " : "",
        variance || "",
        path.call(print, "key"),
        n.optional ? "?" : "",
        isFunction ? "" : ": ",
        path.call(print, "value")
      ]);
    case "QualifiedTypeIdentifier":
      return concat$2([
        path.call(print, "qualification"),
        ".",
        path.call(print, "id")
      ]);
    case "StringLiteralTypeAnnotation":
      return nodeStr(n, options);
    case "NumberLiteralTypeAnnotation":
      assert$4.strictEqual(typeof n.value, "number");

      if (n.extra != null) {
        return printNumber(n.extra.raw);
      } else {
        return printNumber(n.raw);
      }
    case "StringTypeAnnotation":
      return "string";
    case "DeclareTypeAlias":
    case "TypeAlias": {
      if (
        n.type === "DeclareTypeAlias" ||
        isFlowNodeStartingWithDeclare(n, options)
      ) {
        parts.push("declare ");
      }

      parts.push(
        "type ",
        path.call(print, "id"),
        path.call(print, "typeParameters"),
        " =",
        hasLeadingOwnLineComment(options.originalText, n.right)
          ? indent$2(concat$2([hardline$2, path.call(print, "right")]))
          : concat$2([" ", path.call(print, "right")]),
        semi
      );

      return concat$2(parts);
    }
    case "TypeCastExpression":
      return concat$2([
        "(",
        path.call(print, "expression"),
        path.call(print, "typeAnnotation"),
        ")"
      ]);
    case "TypeParameterDeclaration":
    case "TypeParameterInstantiation": {
      const shouldInline =
        n.params.length === 1 && n.params[0].type === "ObjectTypeAnnotation";

      if (shouldInline) {
        return concat$2(["<", join$2(", ", path.map(print, "params")), ">"]);
      }

      return group$1(
        concat$2([
          "<",
          indent$2(
            concat$2([
              softline$1,
              join$2(concat$2([",", line$1]), path.map(print, "params"))
            ])
          ),
          softline$1,
          ">"
        ])
      );
    }
    case "TypeParameter":
      var variance = getFlowVariance(n, options);

      if (variance) {
        parts.push(variance);
      }

      parts.push(path.call(print, "name"));

      if (n.bound) {
        parts.push(path.call(print, "bound"));
      }

      if (n.constraint) {
        parts.push(" extends ", path.call(print, "constraint"));
      }

      if (n["default"]) {
        parts.push("=", path.call(print, "default"));
      }

      return concat$2(parts);
    case "TypeofTypeAnnotation":
      return concat$2(["typeof ", path.call(print, "argument")]);
    case "VoidTypeAnnotation":
      return "void";
    case "NullTypeAnnotation":
      return "null";
    case "InferredPredicate":
      return "%checks";
    // Unhandled types below. If encountered, nodes of these types should
    // be either left alone or desugared into AST types that are fully
    // supported by the pretty-printer.
    case "DeclaredPredicate":
      return concat$2(["%checks(", path.call(print, "value"), ")"]);
    case "TSAnyKeyword":
      return "any";
    case "TSBooleanKeyword":
      return "boolean";
    case "TSNumberKeyword":
      return "number";
    case "TSObjectKeyword":
      return "object";
    case "TSStringKeyword":
      return "string";
    case "TSVoidKeyword":
      return "void";
    case "TSAsExpression":
      return concat$2([
        path.call(print, "expression"),
        " as ",
        path.call(print, "typeAnnotation")
      ]);
    case "TSArrayType":
      return concat$2([path.call(print, "elementType"), "[]"]);
    case "TSPropertySignature":
      parts.push(path.call(print, "name"));
      parts.push(path.call(print, "typeAnnotation"));

      return concat$2(parts);
    case "TSTypeReference":
      return concat$2([path.call(print, "typeName")]);
    case "TSCallSignature":
      return concat$2([
        "(",
        join$2(", ", path.map(print, "parameters")),
        "): ",
        path.call(print, "typeAnnotation")
      ]);
    case "TSConstructSignature":
      return concat$2([
        "new (",
        join$2(", ", path.map(print, "parameters")),
        "): ",
        path.call(print, "typeAnnotation")
      ]);
    case "TSTypeQuery":
      return concat$2(["typeof ", path.call(print, "exprName")]);
    case "TSParenthesizedType":
      return concat$2(["(", path.call(print, "typeAnnotation"), ")"]);
    case "TSIndexSignature":
      return concat$2([
        "[",
        // This should only contain a single element, however TypeScript parses
        // it using parseDelimitedList that uses commas as delimiter.
        join$2(", ", path.map(print, "parameters")),
        "]: ",
        path.call(print, "typeAnnotation")
      ]);
    case "TSFirstTypeNode":
      return concat$2([n.parameterName.name, " is ", path.call(print, "typeAnnotation")])
    // TODO
    case "ClassHeritage":
    // TODO
    case "ComprehensionBlock":
    // TODO
    case "ComprehensionExpression":
    // TODO
    case "Glob":
    // TODO
    case "GeneratorExpression":
    // TODO
    case "LetStatement":
    // TODO
    case "LetExpression":
    // TODO
    case "GraphExpression":
    // TODO
    // XML types that nobody cares about or needs to print.
    case "GraphIndexExpression":
    case "XMLDefaultDeclaration":
    case "XMLAnyName":
    case "XMLQualifiedIdentifier":
    case "XMLFunctionQualifiedIdentifier":
    case "XMLAttributeSelector":
    case "XMLFilterExpression":
    case "XML":
    case "XMLElement":
    case "XMLList":
    case "XMLEscape":
    case "XMLText":
    case "XMLStartTag":
    case "XMLEndTag":
    case "XMLPointTag":
    case "XMLName":
    case "XMLAttribute":
    case "XMLCdata":
    case "XMLComment":
    case "XMLProcessingInstruction":
    default:
      debugger;
      throw new Error("unknown type: " + JSON.stringify(n.type));
  }
}

function printStatementSequence(path, options, print) {
  let printed = [];

  const bodyNode = path.getNode();
  const isClass = bodyNode.type === "ClassBody";

  path.map((stmtPath, i) => {
    var stmt = stmtPath.getValue();

    // Just in case the AST has been modified to contain falsy
    // "statements," it's safer simply to skip them.
    if (!stmt) {
      return;
    }

    // Skip printing EmptyStatement nodes to avoid leaving stray
    // semicolons lying around.
    if (stmt.type === "EmptyStatement") {
      return;
    }

    const stmtPrinted = print(stmtPath);
    const text = options.originalText;
    const parts = [];

    // in no-semi mode, prepend statement with semicolon if it might break ASI
    if (!options.semi && !isClass && stmtNeedsASIProtection(stmtPath)) {
      if (
        stmt.comments &&
        stmt.comments.some(comment => comment.leading)
      ) {
        // Note: stmtNeedsASIProtection requires stmtPath to already be printed
        // as it reads needsParens which is mutated on the instance
        parts.push(print(stmtPath, { needsSemi: true }));
      } else {
        parts.push(";", stmtPrinted);
      }
    } else {
      parts.push(stmtPrinted);
    }


    if (!options.semi && isClass) {
      if (classPropMayCauseASIProblems(stmtPath)) {
        parts.push(";");
      } else if (stmt.type === "ClassProperty") {
        const nextChild = bodyNode.body[i + 1];
        if (classChildNeedsASIProtection(nextChild)) {
          parts.push(";");
        }
      }
    }

    if (util$4.isNextLineEmpty(text, stmt) && !isLastStatement(stmtPath)) {
      parts.push(hardline$2);
    }

    printed.push(concat$2(parts));
  });

  return join$2(hardline$2, printed);
}

function printPropertyKey(path, options, print) {
  const node = path.getNode();
  const key = node.key;

  if (
    (key.type === "StringLiteral" ||
      (key.type === "Literal" && typeof key.value === "string")) &&
    isIdentifierName(key.value) &&
    !node.computed &&
    // There's a bug in the flow parser where it throws if there are
    // unquoted unicode literals as keys. Let's quote them for now.
    (options.parser !== "flow" || key.value.match(/[a-zA-Z0-9$_]/))
  ) {
    // 'a' -> a
    return path.call(
      keyPath => comments$3.printComments(keyPath, p => key.value, options),
      "key"
    );
  }
  return path.call(print, "key");
}

function printMethod(path, options, print) {
  var node = path.getNode();
  var kind = node.kind;
  var parts = [];

  if (node.type === "ObjectMethod" || node.type === "ClassMethod") {
    node.value = node;
  } else {
    namedTypes.FunctionExpression.assert(node.value);
  }

  if (node.value.async) {
    parts.push("async ");
  }

  if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
    if (node.value.generator) {
      parts.push("*");
    }
  } else {
    assert$4.ok(kind === "get" || kind === "set");

    parts.push(kind, " ");
  }

  var key = printPropertyKey(path, options, print);

  if (node.computed) {
    key = concat$2(["[", key, "]"]);
  }

  parts.push(
    key,
    path.call(print, "value", "typeParameters"),
    group$1(
      concat$2([
        path.call(function(valuePath) {
          return printFunctionParams(valuePath, print, options);
        }, "value"),
        path.call(p => printReturnType(p, print), "value")
      ])
    ),
    " ",
    path.call(print, "value", "body")
  );

  return concat$2(parts);
}

function couldGroupArg(arg) {
  return (
    (arg.type === "ObjectExpression" && arg.properties.length > 0) ||
    (arg.type === "ArrayExpression" && arg.elements.length > 0) ||
    arg.type === "FunctionExpression" ||
    (arg.type === "ArrowFunctionExpression" &&
      (arg.body.type === "BlockStatement" ||
        arg.body.type === "ArrowFunctionExpression" ||
        arg.body.type === "ObjectExpression" ||
        arg.body.type === "ArrayExpression" ||
        arg.body.type === "CallExpression" ||
        arg.body.type === "JSXElement"))
  );
}

function shouldGroupLastArg(args) {
  const lastArg = util$4.getLast(args);
  const penultimateArg = util$4.getPenultimate(args);
  return (
    (!lastArg.comments || !lastArg.comments.length) &&
    couldGroupArg(lastArg) &&
    // If the last two arguments are of the same type,
    // disable last element expansion.
    (!penultimateArg || penultimateArg.type !== lastArg.type)
  );
}

function shouldGroupFirstArg(args) {
  if (args.length !== 2) {
    return false;
  }

  const firstArg = args[0];
  const secondArg = args[1];
  return (
    (!firstArg.comments || !firstArg.comments.length) &&
    (firstArg.type === "FunctionExpression" ||
      (firstArg.type === "ArrowFunctionExpression" &&
        firstArg.body.type === "BlockStatement")) &&
    !couldGroupArg(secondArg)
  );
}

function printArgumentsList(path, options, print) {
  var printed = path.map(print, "arguments");

  if (printed.length === 0) {
    return concat$2([
      "(",
      comments$3.printDanglingComments(path, options, /* sameIndent */ true),
      ")"
    ]);
  }

  const args = path.getValue().arguments;
  // This is just an optimization; I think we could return the
  // conditional group for all function calls, but it's more expensive
  // so only do it for specific forms.
  const shouldGroupFirst = shouldGroupFirstArg(args);
  const shouldGroupLast = shouldGroupLastArg(args);
  if (shouldGroupFirst || shouldGroupLast) {
    const shouldBreak = shouldGroupFirst
      ? printed.slice(1).some(willBreak$2)
      : printed.slice(0, -1).some(willBreak$2);

    // We want to print the last argument with a special flag
    let printedExpanded;
    let i = 0;
    path.each(function(argPath) {
      if (shouldGroupFirst && i === 0) {
        printedExpanded =
          [argPath.call(p => print(p, { expandFirstArg: true }))]
            .concat(printed.slice(1));
      }
      if (shouldGroupLast && i === args.length - 1) {
        printedExpanded = printed
          .slice(0, -1)
          .concat(argPath.call(p => print(p, { expandLastArg: true })));
      }
      i++;
    }, "arguments");

    return concat$2([
      printed.some(willBreak$2) ? breakParent$2 : "",
      conditionalGroup$1(
        [
          concat$2(["(", join$2(concat$2([", "]), printedExpanded), ")"]),
          shouldGroupFirst
            ? concat$2([
                "(",
                group$1(printedExpanded[0], { shouldBreak: true }),
                printed.length > 1 ? ", " : "",
                join$2(concat$2([",", line$1]), printed.slice(1)),
                ")"
              ])
            : concat$2([
                "(",
                join$2(concat$2([",", line$1]), printed.slice(0, -1)),
                printed.length > 1 ? ", " : "",
                group$1(util$4.getLast(printedExpanded), {
                  shouldBreak: true
                }),
                ")"
              ]),
          group$1(
            concat$2([
              "(",
              indent$2(concat$2([line$1, join$2(concat$2([",", line$1]), printed)])),
              shouldPrintComma(options, "all") ? "," : "",
              line$1,
              ")"
            ]),
            { shouldBreak: true }
          )
        ],
        { shouldBreak }
      )
    ]);
  }

  return group$1(
    concat$2([
      "(",
      indent$2(concat$2([softline$1, join$2(concat$2([",", line$1]), printed)])),
      ifBreak$1(shouldPrintComma(options, "all") ? "," : ""),
      softline$1,
      ")"
    ]),
    { shouldBreak: printed.some(willBreak$2) }
  );
}

function printFunctionParams(path, print, options, expandArg) {
  var fun = path.getValue();
  // namedTypes.Function.assert(fun);
  var paramsField = fun.type === "TSFunctionType" ? "parameters" : "params";
  var printed = path.map(print, paramsField);

  if (fun.defaults) {
    path.each(function(defExprPath) {
      var i = defExprPath.getName();
      var p = printed[i];

      if (p && defExprPath.getValue()) {
        printed[i] = concat$2([p, " = ", print(defExprPath)]);
      }
    }, "defaults");
  }

  if (fun.rest) {
    printed.push(concat$2(["...", path.call(print, "rest")]));
  }

  if (printed.length === 0) {
    return concat$2([
      "(",
      comments$3.printDanglingComments(path, options, /* sameIndent */ true),
      ")"
    ]);
  }

  const lastParam = util$4.getLast(fun[paramsField]);
  const canHaveTrailingComma =
    !(lastParam && lastParam.type === "RestElement") && !fun.rest;

  // If the parent is a call with the first/last argument expansion and this is the
  // params of the first/last argument, we dont want the arguments to break and instead
  // want the whole expression to be on a new line.
  //
  // Good:                 Bad:
  //   verylongcall(         verylongcall((
  //     (a, b) => {           a,
  //     }                     b,
  //   })                    ) => {
  //                         })
  if (expandArg) {
    return group$1(concat$2(["(", join$2(", ", printed.map(removeLines)), ")"]));
  }

  // Single object destructuring should hug
  //
  // function({
  //   a,
  //   b,
  //   c
  // }) {}
  if (
    fun.params &&
    fun.params.length === 1 &&
    !fun.params[0].comments &&
    (fun.params[0].type === "ObjectPattern" ||
      (fun.params[0].type === "FunctionTypeParam" &&
        fun.params[0].typeAnnotation.type === "ObjectTypeAnnotation")) &&
    !fun.rest
  ) {
    return concat$2(["(", join$2(", ", printed), ")"]);
  }

  const parent = path.getParentNode();

  const flowTypeAnnotations = [
    "AnyTypeAnnotation",
    "NullLiteralTypeAnnotation",
    "NullableTypeAnnotation",
    "GenericTypeAnnotation",
    "ThisTypeAnnotation",
    "NumberTypeAnnotation",
    "VoidTypeAnnotation",
    "NullTypeAnnotation",
    "EmptyTypeAnnotation",
    "MixedTypeAnnotation",
    "BooleanTypeAnnotation",
    "BooleanLiteralTypeAnnotation",
    "StringLiteralTypeAnnotation",
    "StringTypeAnnotation"
  ];

  const isFlowShorthandWithOneArg =
    (isObjectTypePropertyAFunction(parent) ||
      isTypeAnnotationAFunction(parent) ||
      parent.type === "TypeAlias") &&
    fun[paramsField].length === 1 &&
    fun[paramsField][0].name === null &&
    fun[paramsField][0].typeAnnotation &&
    flowTypeAnnotations.indexOf(fun[paramsField][0].typeAnnotation.type) !== -1 &&
    !fun.rest;

  return concat$2([
    isFlowShorthandWithOneArg ? "" : "(",
    indent$2(concat$2([softline$1, join$2(concat$2([",", line$1]), printed)])),
    ifBreak$1(
      canHaveTrailingComma && shouldPrintComma(options, "all") ? "," : ""
    ),
    softline$1,
    isFlowShorthandWithOneArg ? "" : ")"
  ]);
}

function canPrintParamsWithoutParens(node) {
  return (
    node.params.length === 1 &&
    !node.rest &&
    node.params[0].type === "Identifier" &&
    !node.params[0].typeAnnotation &&
    !node.params[0].comments &&
    !node.params[0].optional &&
    !node.predicate &&
    !node.returnType
  );
}

function printFunctionDeclaration(path, print, options) {
  var n = path.getValue();
  var parts = [];

  if (n.async) parts.push("async ");

  parts.push("function");

  if (n.generator) parts.push("*");

  if (n.id) {
    parts.push(" ", path.call(print, "id"));
  }

  parts.push(
    path.call(print, "typeParameters"),
    group$1(
      concat$2([
        printFunctionParams(path, print, options),
        printReturnType(path, print)
      ])
    ),
    " ",
    path.call(print, "body")
  );

  return concat$2(parts);
}

function printObjectMethod(path, options, print) {
  var objMethod = path.getValue();
  var parts = [];

  if (objMethod.async) parts.push("async ");

  if (objMethod.generator) parts.push("*");

  if (
    objMethod.method || objMethod.kind === "get" || objMethod.kind === "set"
  ) {
    return printMethod(path, options, print);
  }

  var key = printPropertyKey(path, options, print);

  if (objMethod.computed) {
    parts.push("[", key, "]");
  } else {
    parts.push(key);
  }

  if (objMethod.typeParameters) {
    parts.push(path.call(print, "typeParameters"));
  }

  parts.push(
    group$1(
      concat$2([
        printFunctionParams(path, print, options),
        printReturnType(path, print)
      ])
    ),
    " ",
    path.call(print, "body")
  );

  return concat$2(parts);
}

function printReturnType(path, print) {
  const n = path.getValue();
  const parts = [path.call(print, "returnType")];

  if (n.predicate) {
    // The return type will already add the colon, but otherwise we
    // need to do it ourselves
    parts.push(n.returnType ? " " : ": ", path.call(print, "predicate"));
  }

  return concat$2(parts);
}

function printExportDeclaration(path, options, print) {
  const decl = path.getValue();
  const semi = options.semi ? ";" : "";
  let parts = ["export "];

  namedTypes.Declaration.assert(decl);

  if (decl["default"] || decl.type === "ExportDefaultDeclaration") {
    parts.push("default ");
  }

  parts.push(
    comments$3.printDanglingComments(path, options, /* sameIndent */ true)
  );

  if (decl.declaration) {
    parts.push(path.call(print, "declaration"));

    if (
      decl.type === "ExportDefaultDeclaration" &&
      (decl.declaration.type !== "ClassDeclaration" &&
        decl.declaration.type !== "FunctionDeclaration")
    ) {
      parts.push(semi);
    }
  } else {
    if (decl.specifiers && decl.specifiers.length > 0) {
      if (
        decl.specifiers.length === 1 &&
        decl.specifiers[0].type === "ExportBatchSpecifier"
      ) {
        parts.push("*");
      } else {
        let specifiers = [];
        let defaultSpecifiers = [];
        let namespaceSpecifiers = [];

        path.map(specifierPath => {
          const specifierType = path.getValue().type;
          if (specifierType === "ExportSpecifier") {
            specifiers.push(print(specifierPath));
          } else if (specifierType === "ExportDefaultSpecifier") {
            defaultSpecifiers.push(print(specifierPath));
          } else if (specifierType === "ExportNamespaceSpecifier") {
            namespaceSpecifiers.push(concat$2(["* as ", print(specifierPath)]));
          }
        }, "specifiers");

        const isNamespaceFollowed =
          namespaceSpecifiers.length !== 0 &&
          (specifiers.length !== 0 || defaultSpecifiers.length !== 0);
        const isDefaultFollowed =
          defaultSpecifiers.length !== 0 && specifiers.length !== 0;

        parts.push(
          decl.exportKind === "type" ? "type " : "",
          concat$2(namespaceSpecifiers),
          concat$2([isNamespaceFollowed ? ", " : ""]),
          concat$2(defaultSpecifiers),
          concat$2([isDefaultFollowed ? ", " : ""]),
          specifiers.length !== 0
            ? group$1(
                concat$2([
                  "{",
                  indent$2(
                    concat$2([
                      options.bracketSpacing ? line$1 : softline$1,
                      join$2(concat$2([",", line$1]), specifiers)
                    ])
                  ),
                  ifBreak$1(shouldPrintComma(options) ? "," : ""),
                  options.bracketSpacing ? line$1 : softline$1,
                  "}"
                ])
              )
            : ""
        );
      }
    } else {
      parts.push("{}");
    }

    if (decl.source) {
      parts.push(" from ", path.call(print, "source"));
    }

    parts.push(semi);
  }

  return concat$2(parts);
}

function printFlowDeclaration(path, parts) {
  var parentExportDecl = util$4.getParentExportDeclaration(path);

  if (parentExportDecl) {
    assert$4.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
  } else {
    // If the parent node has type DeclareExportDeclaration, then it
    // will be responsible for printing the "declare" token. Otherwise
    // it needs to be printed with this non-exported declaration node.
    parts.unshift("declare ");
  }

  return concat$2(parts);
}

function getFlowVariance(path, options) {
  if (!path.variance) {
    return null;
  }

  // Babylon 7.0 currently uses variance node type, and flow should
  // follow suit soon:
  // https://github.com/babel/babel/issues/4722
  const variance = path.variance.kind || path.variance;

  switch (variance) {
    case "plus":
      return "+";

    case "minus":
      return "-";

    default:
      return variance;
  }
}

function printClass(path, options, print) {
  const n = path.getValue();
  const parts = ["class"];

  if (n.id) {
    parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
  }

  const partsGroup = [];
  if (n.superClass) {
    partsGroup.push(
      line$1,
      "extends ",
      path.call(print, "superClass"),
      path.call(print, "superTypeParameters")
    );
  } else if (n.extends && n.extends.length > 0) {
    partsGroup.push(line$1, "extends ", join$2(", ", path.map(print, "extends")));
  }

  if (n["implements"] && n["implements"].length > 0) {
    partsGroup.push(
      line$1,
      "implements ",
      join$2(", ", path.map(print, "implements"))
    );
  }

  if (partsGroup.length > 0) {
    parts.push(group$1(indent$2(concat$2(partsGroup))));
  }

  parts.push(" ", path.call(print, "body"));

  return parts;
}

function printMemberLookup(path, options, print) {
  const property = path.call(print, "property");
  const n = path.getValue();

  return concat$2(
    n.computed
      ? [
          "[",
          group$1(concat$2([indent$2(concat$2([softline$1, property])), softline$1])),
          "]"
        ]
      : [".", property]
  );
}

// We detect calls on member expressions specially to format a
// comman pattern better. The pattern we are looking for is this:
//
// arr
//   .map(x => x + 1)
//   .filter(x => x > 10)
//   .some(x => x % 2)
//
// The way it is structured in the AST is via a nested sequence of
// MemberExpression and CallExpression. We need to traverse the AST
// and make groups out of it to print it in the desired way.
function printMemberChain(path, options, print) {
  // The first phase is to linearize the AST by traversing it down.
  //
  //   a().b()
  // has the following AST structure:
  //   CallExpression(MemberExpression(CallExpression(Identifier)))
  // and we transform it into
  //   [Identifier, CallExpression, MemberExpression, CallExpression]
  const printedNodes = [];

  function rec(path) {
    const node = path.getValue();
    if (node.type === "CallExpression") {
      printedNodes.unshift({
        node: node,
        printed: comments$3.printComments(
          path,
          p => printArgumentsList(path, options, print),
          options
        )
      });
      path.call(callee => rec(callee), "callee");
    } else if (node.type === "MemberExpression") {
      printedNodes.unshift({
        node: node,
        printed: comments$3.printComments(
          path,
          p => printMemberLookup(path, options, print),
          options
        )
      });
      path.call(object => rec(object), "object");
    } else {
      printedNodes.unshift({
        node: node,
        printed: path.call(print)
      });
    }
  }
  // Note: the comments of the root node have already been printed, so we
  // need to extract this first call without printing them as they would
  // if handled inside of the recursive call.
  printedNodes.unshift({
    node: path.getValue(),
    printed: printArgumentsList(path, options, print)
  });
  path.call(callee => rec(callee), "callee");

  // Once we have a linear list of printed nodes, we want to create groups out
  // of it.
  //
  //   a().b.c().d().e
  // will be grouped as
  //   [
  //     [Identifier, CallExpression],
  //     [MemberExpression, MemberExpression, CallExpression],
  //     [MemberExpression, CallExpression],
  //     [MemberExpression],
  //   ]
  // so that we can print it as
  //   a()
  //     .b.c()
  //     .d()
  //     .e

  // The first group is the first node followed by
  //   - as many CallExpression as possible
  //       < fn()()() >.something()
  //   - then, as many MemberExpression as possible but the last one
  //       < this.items >.something()
  var groups = [];
  var currentGroup = [printedNodes[0]];
  var i = 1;
  for (; i < printedNodes.length; ++i) {
    if (printedNodes[i].node.type === "CallExpression") {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }
  for (; i + 1 < printedNodes.length; ++i) {
    if (
      printedNodes[i].node.type === "MemberExpression" &&
      printedNodes[i + 1].node.type === "MemberExpression"
    ) {
      currentGroup.push(printedNodes[i]);
    } else {
      break;
    }
  }
  groups.push(currentGroup);
  currentGroup = [];

  // Then, each following group is a sequence of MemberExpression followed by
  // a sequence of CallExpression. To compute it, we keep adding things to the
  // group until we has seen a CallExpression in the past and reach a
  // MemberExpression
  var hasSeenCallExpression = false;
  for (; i < printedNodes.length; ++i) {
    if (
      hasSeenCallExpression && printedNodes[i].node.type === "MemberExpression"
    ) {
      // [0] should be appended at the end of the group instead of the
      // beginning of the next one
      if (printedNodes[i].node.computed) {
        currentGroup.push(printedNodes[i]);
        continue;
      }

      groups.push(currentGroup);
      currentGroup = [];
      hasSeenCallExpression = false;
    }

    if (printedNodes[i].node.type === "CallExpression") {
      hasSeenCallExpression = true;
    }
    currentGroup.push(printedNodes[i]);
  }
  if (currentGroup.length > 0) {
    groups.push(currentGroup);
  }

  // There are cases like Object.keys(), Observable.of(), _.values() where
  // they are the subject of all the chained calls and therefore should
  // be kept on the same line:
  //
  //   Object.keys(items)
  //     .filter(x => x)
  //     .map(x => x)
  //
  // In order to detect those cases, we use an heuristic: if the first
  // node is just an identifier with the name starting with a capital
  // letter, just a sequence of _$ or this. The rationale is that they are
  // likely to be factories.
  const shouldMerge =
    groups.length >= 2 &&
    !groups[1][0].node.comments &&
    groups[0].length === 1 &&
    (groups[0][0].node.type === "ThisExpression" ||
      (groups[0][0].node.type === "Identifier" &&
        groups[0][0].node.name.match(/(^[A-Z])|^[_$]+$/)));

  function printGroup(printedGroup) {
    return concat$2(printedGroup.map(tuple => tuple.printed));
  }

  function printIndentedGroup(groups) {
    return indent$2(
      group$1(concat$2([hardline$2, join$2(hardline$2, groups.map(printGroup))]))
    );
  }

  const printedGroups = groups.map(printGroup);
  const oneLine = concat$2(printedGroups);
  const hasComment =
    (groups.length >= 2 && groups[1][0].node.comments) ||
    (groups.length >= 3 && groups[2][0].node.comments);

  // If we only have a single `.`, we shouldn't do anything fancy and just
  // render everything concatenated together.
  if (
    groups.length <= (shouldMerge ? 3 : 2) &&
    !hasComment &&
    // (a || b).map() should be break before .map() instead of ||
    groups[0][0].node.type !== "LogicalExpression"
  ) {
    return group$1(oneLine);
  }

  const expanded = concat$2([
    printGroup(groups[0]),
    shouldMerge ? concat$2(groups.slice(1, 2).map(printGroup)) : "",
    printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))
  ]);

  // If there's a comment, we don't want to print in one line.
  if (hasComment) {
    return group$1(expanded);
  }

  // If any group but the last one has a hard line, we want to force expand
  // it. If the last group is a function it's okay to inline if it fits.
  if (printedGroups.slice(0, -1).some(willBreak$2)) {
    return group$1(expanded);
  }

  return concat$2([
    // We only need to check `oneLine` because if `expanded` is chosen
    // that means that the parent group has already been broken
    // naturally
    willBreak$2(oneLine) ? breakParent$2 : "",
    conditionalGroup$1([oneLine, expanded])
  ]);
}

function isEmptyJSXElement(node) {
  if (node.children.length === 0) return true;
  if (node.children.length > 1) return false;

  // if there is one child but it's just a newline, treat as empty
  const value = node.children[0].value;
  if (!/\S/.test(value) && /\n/.test(value)) {
    return true;
  } else {
    return false;
  }
}

// JSX Children are strange, mostly for two reasons:
// 1. JSX reads newlines into string values, instead of skipping them like JS
// 2. up to one whitespace between elements within a line is significant,
//    but not between lines.
//
// So for one thing, '\n' needs to be parsed out of string literals
// and turned into hardlines (with string boundaries otherwise using softline)
//
// For another, leading, trailing, and lone whitespace all need to
// turn themselves into the rather ugly `{' '}` when breaking.
function printJSXChildren(path, options, print, jsxWhitespace) {
  const n = path.getValue();
  const children = [];

  // using `map` instead of `each` because it provides `i`
  path.map(function(childPath, i) {
    const child = childPath.getValue();
    const isLiteral = namedTypes.Literal.check(child);

    if (isLiteral && typeof child.value === "string") {
      // There's a bug in the flow parser where it doesn't unescape the
      // value field. To workaround this, we can use rawValue which is
      // correctly escaped (since it parsed).
      // We really want to use value and re-escape it ourself when possible
      // though.
      const partiallyEscapedValue = options.parser === "flow"
        ? child.raw
        : util$4.htmlEscapeInsideAngleBracket(child.value);
      const value = partiallyEscapedValue.replace(/\u00a0/g, "&nbsp;");

      if (/\S/.test(value)) {
        // treat each line of text as its own entity
        value.split(/(\r?\n\s*)/).forEach(line => {
          const newlines = line.match(/\n/g);
          if (newlines) {
            children.push(hardline$2);

            // allow one extra newline
            if (newlines.length > 1) {
              children.push(hardline$2);
            }
            return;
          }

          const beginSpace = /^\s+/.test(line);
          if (beginSpace) {
            children.push(jsxWhitespace);
            children.push(softline$1);
          }

          const stripped = line.replace(/^\s+|\s+$/g, "");
          if (stripped) {
            children.push(stripped);
          }

          const endSpace = /\s+$/.test(line);
          if (endSpace) {
            children.push(softline$1);
            children.push(jsxWhitespace);
          }
        });

        if (!isLineNext$1(util$4.getLast(children))) {
          children.push(softline$1);
        }
      } else if (/\n/.test(value)) {
        children.push(hardline$2);

        // allow one extra newline
        if (value.match(/\n/g).length > 1) {
          children.push(hardline$2);
        }
      } else if (/\s/.test(value)) {
        // whitespace-only without newlines,
        // eg; a single space separating two elements
        children.push(jsxWhitespace);
        children.push(softline$1);
      }
    } else {
      children.push(print(childPath));

      // add a line unless it's followed by a JSX newline
      let next = n.children[i + 1];
      if (!(next && /^\s*\n/.test(next.value))) {
        children.push(softline$1);
      }
    }
  }, "children");

  return children;
}

// JSX expands children from the inside-out, instead of the outside-in.
// This is both to break children before attributes,
// and to ensure that when children break, their parents do as well.
//
// Any element that is written without any newlines and fits on a single line
// is left that way.
// Not only that, any user-written-line containing multiple JSX siblings
// should also be kept on one line if possible,
// so each user-written-line is wrapped in its own group.
//
// Elements that contain newlines or don't fit on a single line (recursively)
// are fully-split, using hardline and shouldBreak: true.
//
// To support that case properly, all leading and trailing spaces
// are stripped from the list of children, and replaced with a single hardline.
function printJSXElement(path, options, print) {
  const n = path.getValue();

  // Turn <div></div> into <div />
  if (isEmptyJSXElement(n)) {
    n.openingElement.selfClosing = true;
    delete n.closingElement;
  }

  const openingLines = path.call(print, "openingElement");
  const closingLines = path.call(print, "closingElement");

  if (
    n.children.length === 1 &&
    n.children[0].type === "JSXExpressionContainer" &&
    (n.children[0].expression.type === "TemplateLiteral" ||
      n.children[0].expression.type === "TaggedTemplateExpression")
  ) {
    return concat$2([
      openingLines,
      concat$2(path.map(print, "children")),
      closingLines
    ]);
  }

  // If no children, just print the opening element
  if (n.openingElement.selfClosing) {
    assert$4.ok(!n.closingElement);
    return openingLines;
  }
  // Record any breaks. Should never go from true to false, only false to true.
  let forcedBreak = willBreak$2(openingLines);

  const jsxWhitespace = options.singleQuote
    ? ifBreak$1("{' '}", " ")
    : ifBreak$1('{" "}', " ");
  const children = printJSXChildren(path, options, print, jsxWhitespace);

  // Trim trailing lines, recording if there was a hardline
  let numTrailingHard = 0;
  while (children.length && isLineNext$1(util$4.getLast(children))) {
    if (willBreak$2(util$4.getLast(children))) {
      ++numTrailingHard;
      forcedBreak = true;
    }
    children.pop();
  }
  // allow one extra newline
  if (numTrailingHard > 1) {
    children.push(hardline$2);
  }

  // Trim leading lines, recording if there was a hardline
  let numLeadingHard = 0;
  while (children.length && isLineNext$1(children[0])) {
    if (willBreak$2(children[0])) {
      ++numLeadingHard;
      forcedBreak = true;
    }
    children.shift();
  }
  // allow one extra newline
  if (numLeadingHard > 1) {
    children.unshift(hardline$2);
  }

  // Group by line, recording if there was a hardline.
  let groups = [[]]; // Initialize the first line's group
  children.forEach((child, i) => {
    // leading and trailing JSX whitespace don't go into a group
    if (child === jsxWhitespace) {
      if (i === 0) {
        groups.unshift(child);
        return;
      } else if (i === children.length - 1) {
        groups.push(child);
        return;
      }
    }

    let prev = children[i - 1];
    if (prev && willBreak$2(prev)) {
      forcedBreak = true;

      // On a new line, so create a new group and put this element in it.
      groups.push([child]);
    } else {
      // Not on a newline, so add this element to the current group.
      util$4.getLast(groups).push(child);
    }

    // Ensure we record hardline of last element.
    if (!forcedBreak && i === children.length - 1) {
      if (willBreak$2(child)) forcedBreak = true;
    }
  });

  const childrenGroupedByLine = [
    hardline$2,
    // Conditional groups suppress break propagation; we want to output
    // hard lines without breaking up the entire jsx element.
    // Note that leading and trailing JSX Whitespace don't go into a group.
    concat$2(
      groups.map(
        contents =>
          (Array.isArray(contents)
            ? conditionalGroup$1([concat$2(contents)])
            : contents)
      )
    )
  ];

  const multiLineElem = group$1(
    concat$2([
      openingLines,
      indent$2(group$1(concat$2(childrenGroupedByLine), { shouldBreak: true })),
      hardline$2,
      closingLines
    ])
  );

  if (forcedBreak) {
    return multiLineElem;
  }

  return conditionalGroup$1([
    group$1(concat$2([openingLines, concat$2(children), closingLines])),
    multiLineElem
  ]);
}

function maybeWrapJSXElementInParens(path, elem, options) {
  const parent = path.getParentNode();
  if (!parent) return elem;

  const NO_WRAP_PARENTS = {
    ArrayExpression: true,
    JSXElement: true,
    JSXExpressionContainer: true,
    ExpressionStatement: true,
    CallExpression: true,
    ConditionalExpression: true,
    LogicalExpression: true
  };
  if (NO_WRAP_PARENTS[parent.type]) {
    return elem;
  }

  return group$1(
    concat$2([
      ifBreak$1("("),
      indent$2(concat$2([softline$1, elem])),
      softline$1,
      ifBreak$1(")")
    ])
  );
}

function isBinaryish(node) {
  return node.type === "BinaryExpression" || node.type === "LogicalExpression";
}

function shouldInlineLogicalExpression(node) {
  return (
    node.type === "LogicalExpression" &&
    (node.right.type === "ObjectExpression" ||
      node.right.type === "ArrayExpression")
  );
}

// For binary expressions to be consistent, we need to group
// subsequent operators with the same precedence level under a single
// group. Otherwise they will be nested such that some of them break
// onto new lines but not all. Operators with the same precedence
// level should either all break or not. Because we group them by
// precedence level and the AST is structured based on precedence
// level, things are naturally broken up correctly, i.e. `&&` is
// broken before `+`.
function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {
  let parts = [];
  let node = path.getValue();

  // We treat BinaryExpression and LogicalExpression nodes the same.
  if (isBinaryish(node)) {
    // Put all operators with the same precedence level in the same
    // group. The reason we only need to do this with the `left`
    // expression is because given an expression like `1 + 2 - 3`, it
    // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
    // is where the rest of the expression will exist. Binary
    // expressions on the right side mean they have a difference
    // precedence level and should be treated as a separate group, so
    // print them normally. (This doesn't hold for the `**` operator,
    // which is unique in that it is right-associative.)
    if (
      util$4.getPrecedence(node.left.operator) ===
        util$4.getPrecedence(node.operator) && node.operator !== "**"
    ) {
      // Flatten them out by recursively calling this function.
      parts = parts.concat(
        path.call(
          left =>
            printBinaryishExpressions(
              left,
              print,
              options,
              /* isNested */ true,
              isInsideParenthesis
            ),
          "left"
        )
      );
    } else {
      parts.push(path.call(print, "left"));
    }

    const right = concat$2([
      node.operator,
      shouldInlineLogicalExpression(node) ? " " : line$1,
      path.call(print, "right")
    ]);

    // If there's only a single binary expression, we want to create a group
    // in order to avoid having a small right part like -1 be on its own line.
    const parent = path.getParentNode();
    const shouldGroup =
      !(isInsideParenthesis && node.type === "LogicalExpression") &&
      parent.type !== node.type &&
      node.left.type !== node.type &&
      node.right.type !== node.type;

    parts.push(" ", shouldGroup ? group$1(right) : right);

    // The root comments are already printed, but we need to manually print
    // the other ones since we don't call the normal print on BinaryExpression,
    // only for the left and right parts
    if (isNested && node.comments) {
      parts = comments$3.printComments(path, p => concat$2(parts), options);
    }
  } else {
    // Our stopping case. Simply print the node normally.
    parts.push(path.call(print));
  }

  return parts;
}

function printAssignment(
  leftNode,
  printedLeft,
  operator,
  rightNode,
  printedRight,
  options
) {
  if (!rightNode) {
    return printedLeft;
  }

  let printed;
  if (hasLeadingOwnLineComment(options.originalText, rightNode)) {
    printed = indent$2(concat$2([hardline$2, printedRight]));
  } else if (
    (isBinaryish(rightNode) && !shouldInlineLogicalExpression(rightNode)) ||
    (leftNode.type === "Identifier" || leftNode.type === "MemberExpression") &&
      (rightNode.type === "StringLiteral" ||
        (rightNode.type === "Literal" && typeof rightNode.value === "string") ||
        isMemberExpressionChain(rightNode))
  ) {
    printed = indent$2(concat$2([line$1, printedRight]));
  } else {
    printed = concat$2([" ", printedRight]);
  }

  return group$1(concat$2([printedLeft, " ", operator, printed]));
}

function adjustClause(node, clause, forceSpace) {
  if (node.type === "EmptyStatement") {
    return ";";
  }

  if (node.type === "BlockStatement" || forceSpace) {
    return concat$2([" ", clause]);
  }

  return indent$2(concat$2([line$1, clause]));
}

function shouldTypeScriptTypeAvoidColon(path) {
  // As the special TS nodes isn't returned by the node helpers,
  // we use the stack directly to get the parent node.
  const parent = path.stack[path.stack.length - 3];

  switch (parent.type) {
    case "TSFunctionType":
    case "TSIndexSignature":
    case "TSParenthesizedType":
    case "TSCallSignature":
    case "TSConstructSignature":
    case "TSAsExpression":
      return true;
    default:
      return false;
  }
}

function nodeStr(node, options) {
  const str = node.value;
  isString$1.assert(str);

  // Workaround a bug in the Javascript version of the flow parser where
  // astral unicode characters like \uD801\uDC28 are incorrectly parsed as
  // a sequence of \uFFFD.
  if (options.parser === "flow" && str.indexOf("\ufffd") !== -1) {
    return node.raw;
  }

  const raw = node.extra ? node.extra.raw : node.raw;
  // `rawContent` is the string exactly like it appeared in the input source
  // code, with its enclosing quote.
  const rawContent = raw.slice(1, -1);

  const double = { quote: '"', regex: /"/g };
  const single = { quote: "'", regex: /'/g };

  const preferred = options.singleQuote ? single : double;
  const alternate = preferred === single ? double : single;

  let shouldUseAlternateQuote = false;

  // If `rawContent` contains at least one of the quote preferred for enclosing
  // the string, we might want to enclose with the alternate quote instead, to
  // minimize the number of escaped quotes.
  if (rawContent.includes(preferred.quote)) {
    const numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
    const numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;

    shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;
  }

  const enclosingQuote = shouldUseAlternateQuote
    ? alternate.quote
    : preferred.quote;

  // It might sound unnecessary to use `makeString` even if `node.raw` already
  // is enclosed with `enclosingQuote`, but it isn't. `node.raw` could contain
  // unnecessary escapes (such as in `"\'"`). Always using `makeString` makes
  // sure that we consistently output the minimum amount of escaped quotes.
  return makeString(rawContent, enclosingQuote);
}

function makeString(rawContent, enclosingQuote) {
  const otherQuote = enclosingQuote === '"' ? "'" : '"';

  // Matches _any_ escape and unescaped quotes (both single and double).
  const regex = /\\([\s\S])|(['"])/g;

  // Escape and unescape single and double quotes as needed to be able to
  // enclose `rawContent` with `enclosingQuote`.
  const newContent = rawContent.replace(regex, (match, escaped, quote) => {
    // If we matched an escape, and the escaped character is a quote of the
    // other type than we intend to enclose the string with, there's no need for
    // it to be escaped, so return it _without_ the backslash.
    if (escaped === otherQuote) {
      return escaped;
    }

    // If we matched an unescaped quote and it is of the _same_ type as we
    // intend to enclose the string with, it must be escaped, so return it with
    // a backslash.
    if (quote === enclosingQuote) {
      return "\\" + quote;
    }

    // Otherwise return the escape or unescaped quote as-is.
    return match;
  });

  return enclosingQuote + newContent + enclosingQuote;
}

function printRegex(node) {
  const flags = node.flags.split('').sort().join('');
  return `/${node.pattern}/${flags}`;
}

function printNumber(rawNumber) {
  return (
    rawNumber
      .toLowerCase()
      // Remove unnecessary plus and zeroes from scientific notation.
      .replace(/^([\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3")
      // Remove unnecessary scientific notation (1e0).
      .replace(/^([\d.]+)e[+-]?0+$/, "$1")
      // Make sure numbers always start with a digit.
      .replace(/^\./, "0.")
      // Remove trailing dot.
      .replace(/\.(?=e|$)/, "")
  );
}

function isLastStatement(path) {
  const parent = path.getParentNode();
  const node = path.getValue();
  const body = parent.body;
  return body && body[body.length - 1] === node;
}

function hasLeadingOwnLineComment(text, node) {
  const res =
    node.comments &&
    node.comments.some(
      comment => comment.leading && util$4.hasNewline(text, util$4.locEnd(comment))
    );
  return res;
}

function hasNakedLeftSide(node) {
  return (
    node.type === "AssignmentExpression" ||
    node.type === "BinaryExpression" ||
    node.type === "LogicalExpression" ||
    node.type === "ConditionalExpression" ||
    node.type === "CallExpression" ||
    node.type === "MemberExpression" ||
    node.type === "SequenceExpression" ||
    node.type === "TaggedTemplateExpression"
  );
}

function getLeftSide(node) {
  if (node.expressions) {
    return node.expressions[0];
  }
  return node.left || node.test || node.callee || node.object || node.tag;
}

function exprNeedsASIProtection(node) {
  // HACK: node.needsParens is added in `genericPrint()` for the sole purpose
  // of being used here. It'd be preferable to find a cleaner way to do this.
  const maybeASIProblem =
    node.needsParens ||
    node.type === "ParenthesizedExpression" ||
    node.type === "TypeCastExpression" ||
    (node.type === "ArrowFunctionExpression" &&
      !canPrintParamsWithoutParens(node)) ||
    node.type === "ArrayExpression" ||
    node.type === "ArrayPattern" ||
    (node.type === "UnaryExpression" &&
      node.prefix &&
      (node.operator === "+" || node.operator === "-")) ||
    node.type === "TemplateLiteral" ||
    node.type === "TemplateElement" ||
    node.type === "JSXElement" ||
    node.type === "RegExpLiteral" ||
    (node.type === "Literal" && node.pattern) ||
    (node.type === "Literal" && node.regex);

  if (maybeASIProblem) {
    return true;
  }

  if (!hasNakedLeftSide(node)) {
    return false;
  }

  return exprNeedsASIProtection(getLeftSide(node));
}

function stmtNeedsASIProtection(path) {
  if (!path) return false;
  const node = path.getNode();

  if (node.type !== "ExpressionStatement") {
    return false;
  }

  return exprNeedsASIProtection(node.expression);
}

function classPropMayCauseASIProblems(path) {
  const node = path.getNode();

  if (node.type !== "ClassProperty") {
    return false;
  }

  const name = node.key && node.key.name;
  if (!name) {
    return false;
  }

  // this isn't actually possible yet with most parsers available today
  // so isn't properly tested yet.
  if (name === "static" || name === "get" || name === "set") {
    return true;
  }
}

function classChildNeedsASIProtection(node) {
  if (!node) return;

  let isAsync, isGenerator;
  switch (node.type) {
    case "ClassProperty":
      return node.computed;
    // flow
    case "MethodDefinition":
    // babylon
    case "ClassMethod": {
      const isAsync = node.value ? node.value.async : node.async;
      const isGenerator = node.value ? node.value.generator : node.generator;
      if (
        isAsync || node.static || node.kind === "get" || node.kind === "set"
      ) {
        return false;
      }
      if (node.computed || isGenerator) {
        return true;
      }
    }

    default:
      return false;
  }
}

// This recurses the return argument, looking for the first token
// (the leftmost leaf node) and, if it (or its parents) has any
// leadingComments, returns true (so it can be wrapped in parens).
function returnArgumentHasLeadingComment(options, argument) {
  if (hasLeadingOwnLineComment(options.originalText, argument)) {
    return true;
  }

  if (hasNakedLeftSide(argument)) {
    let leftMost = argument;
    let newLeftMost;
    while ((newLeftMost = getLeftSide(leftMost))) {
      leftMost = newLeftMost;

      if (hasLeadingOwnLineComment(options.originalText, leftMost)) {
        return true;
      }
    }
  }

  return false;
}

function isMemberExpressionChain(node) {
  if (node.type !== "MemberExpression") {
    return false;
  }
  if (node.object.type === "Identifier") {
    return true;
  }
  return isMemberExpressionChain(node.object);
}

// Hack to differentiate between the following two which have the same ast
// type T = { method: () => void };
// type T = { method(): void };
function isObjectTypePropertyAFunction(node) {
  return (
    node.type === "ObjectTypeProperty" &&
    node.value.type === "FunctionTypeAnnotation" &&
    !node.static &&
    util$4.locStart(node.key) !== util$4.locStart(node.value)
  );
}

// Hack to differentiate between the following two which have the same ast
// declare function f(a): void;
// var f: (a) => void;
function isTypeAnnotationAFunction(node) {
  return (
    node.type === "TypeAnnotation" &&
    node.typeAnnotation.type === "FunctionTypeAnnotation" &&
    !node.static &&
    util$4.locStart(node) !== util$4.locStart(node.typeAnnotation)
  );
}

function isFlowNodeStartingWithDeclare(node, options) {
  if (options.parser !== "flow") {
    return false;
  }

  return options.originalText
    .slice(0, util$4.locStart(node))
    .match(/declare\s*$/);
}

function printArrayItems(path, options, printPath, print) {
  const printedElements = [];
  let separatorParts = [];

  path.each(function(childPath) {
    printedElements.push(concat$2(separatorParts));
    printedElements.push(group$1(print(childPath)));

    separatorParts = [",", line$1];
    if (
      childPath.getValue() &&
      util$4.isNextLineEmpty(options.originalText, childPath.getValue())
    ) {
      separatorParts.push(softline$1);
    }
  }, printPath);

  return concat$2(printedElements);
}

function removeLines(doc) {
  // Force this doc into flat mode by statically converting all
  // lines into spaces (or soft lines into nothing). Hard lines
  // should still output because there's too great of a chance
  // of breaking existing assumptions otherwise.
  return docUtils$2.mapDoc(doc, d => {
    if (d.type === "line" && !d.hard) {
      return d.soft ? "" : " ";
    } else if (d.type === "if-break") {
      return d.flatContents || "";
    }
    return d;
  });
}

function printAstToDoc$1(ast, options) {
  function printGenerically(path, args) {
    return comments$3.printComments(
      path,
      p => genericPrint(p, options, printGenerically, args),
      options,
      args && args.needsSemi
    );
  }

  const doc = printGenerically(FastPath.from(ast));
  docUtils$2.propagateBreaks(doc);
  return doc;
}

var printer = { printAstToDoc: printAstToDoc$1 };

const MODE_BREAK = 1;
const MODE_FLAT = 2;

function rootIndent() {
  return {
    indent: 0,
    align: {
      spaces: 0,
      tabs: 0
    }
  };
}

function makeIndent(ind) {
  return {
    indent: ind.indent + 1,
    align: ind.align
  };
}

function makeAlign(ind, n) {
  return {
    indent: ind.indent,
    align: {
      spaces: ind.align.spaces + n,
      tabs: ind.align.tabs + (n ? 1 : 0)
    }
  };
}

function fits(next, restCommands, width) {
  let restIdx = restCommands.length;
  const cmds = [next];
  while (width >= 0) {
    if (cmds.length === 0) {
      if (restIdx === 0) {
        return true;
      } else {
        cmds.push(restCommands[restIdx - 1]);

        restIdx--;

        continue;
      }
    }

    const x = cmds.pop();
    const ind = x[0];
    const mode = x[1];
    const doc = x[2];

    if (typeof doc === "string") {
      width -= doc.length;
    } else {
      switch (doc.type) {
        case "concat":
          for (var i = doc.parts.length - 1; i >= 0; i--) {
            cmds.push([ind, mode, doc.parts[i]]);
          }

          break;
        case "indent":
          cmds.push([makeIndent(ind), mode, doc.contents]);

          break;
        case "align":
          cmds.push([makeAlign(ind, doc.n), mode, doc.contents]);

          break;
        case "group":
          cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);

          break;
        case "if-break":
          if (mode === MODE_BREAK) {
            if (doc.breakContents) {
              cmds.push([ind, mode, doc.breakContents]);
            }
          }
          if (mode === MODE_FLAT) {
            if (doc.flatContents) {
              cmds.push([ind, mode, doc.flatContents]);
            }
          }

          break;
        case "line":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!doc.hard) {
                if (!doc.soft) {
                  width -= 1;
                }

                break;
              }

            case MODE_BREAK:
              return true;
          }
          break;
      }
    }
  }
  return false;
}

function printDocToString$1(doc, options) {
  let width = options.printWidth;
  let newLine = options.newLine || "\n";
  let pos = 0;
  // cmds is basically a stack. We've turned a recursive call into a
  // while loop which is much faster. The while loop below adds new
  // cmds to the array instead of recursively calling `print`.
  let cmds = [[rootIndent(), MODE_BREAK, doc]];
  let out = [];
  let shouldRemeasure = false;
  let lineSuffix = [];

  while (cmds.length !== 0) {
    const x = cmds.pop();
    const ind = x[0];
    const mode = x[1];
    const doc = x[2];

    if (typeof doc === "string") {
      out.push(doc);

      pos += doc.length;
    } else {
      switch (doc.type) {
        case "concat":
          for (var i = doc.parts.length - 1; i >= 0; i--) {
            cmds.push([ind, mode, doc.parts[i]]);
          }

          break;
        case "indent":
          cmds.push([makeIndent(ind), mode, doc.contents]);

          break;
        case "align":
          cmds.push([makeAlign(ind, doc.n), mode, doc.contents]);

          break;
        case "group":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!shouldRemeasure) {
                cmds.push([
                  ind,
                  doc.break ? MODE_BREAK : MODE_FLAT,
                  doc.contents
                ]);

                break;
              }

            case MODE_BREAK:
              shouldRemeasure = false;

              const next = [ind, MODE_FLAT, doc.contents];
              let rem = width - pos;

              if (!doc.break && fits(next, cmds, rem)) {
                cmds.push(next);
              } else {
                // Expanded states are a rare case where a document
                // can manually provide multiple representations of
                // itself. It provides an array of documents
                // going from the least expanded (most flattened)
                // representation first to the most expanded. If a
                // group has these, we need to manually go through
                // these states and find the first one that fits.
                if (doc.expandedStates) {
                  const mostExpanded =
                    doc.expandedStates[doc.expandedStates.length - 1];

                  if (doc.break) {
                    cmds.push([ind, MODE_BREAK, mostExpanded]);

                    break;
                  } else {
                    for (var i = 1; i < doc.expandedStates.length + 1; i++) {
                      if (i >= doc.expandedStates.length) {
                        cmds.push([ind, MODE_BREAK, mostExpanded]);

                        break;
                      } else {
                        const state = doc.expandedStates[i];
                        const cmd = [ind, MODE_FLAT, state];

                        if (fits(cmd, cmds, rem)) {
                          cmds.push(cmd);

                          break;
                        }
                      }
                    }
                  }
                } else {
                  cmds.push([ind, MODE_BREAK, doc.contents]);
                }
              }

              break;
          }
          break;
        case "if-break":
          if (mode === MODE_BREAK) {
            if (doc.breakContents) {
              cmds.push([ind, mode, doc.breakContents]);
            }
          }
          if (mode === MODE_FLAT) {
            if (doc.flatContents) {
              cmds.push([ind, mode, doc.flatContents]);
            }
          }

          break;
        case "line-suffix":
          lineSuffix.push([ind, mode, doc.contents]);
          break;
        case "line-suffix-boundary":
          if (lineSuffix.length > 0) {
            cmds.push([ind, mode, { type: "line", hard: true }]);
          }
          break;
        case "line":
          switch (mode) {
            // fallthrough
            case MODE_FLAT:
              if (!doc.hard) {
                if (!doc.soft) {
                  out.push(" ");

                  pos += 1;
                }

                break;
              } else {
                // This line was forced into the output even if we
                // were in flattened mode, so we need to tell the next
                // group that no matter what, it needs to remeasure
                // because the previous measurement didn't accurately
                // capture the entire expression (this is necessary
                // for nested groups)
                shouldRemeasure = true;
              }

            case MODE_BREAK:
              if (lineSuffix.length) {
                cmds.push([ind, mode, doc]);
                [].push.apply(cmds, lineSuffix.reverse());
                lineSuffix = [];
                break;
              }

              if (doc.literal) {
                out.push(newLine);
                pos = 0;
              } else {
                if (out.length > 0) {
                  // Trim whitespace at the end of line
                  while (
                    out.length > 0 &&
                    out[out.length - 1].match(/^[^\S\n]*$/)
                  ) {
                    out.pop();
                  }

                  out[out.length - 1] = out[out.length - 1].replace(
                    /[^\S\n]*$/,
                    ""
                  );
                }

                let length = ind.indent * options.tabWidth + ind.align.spaces;
                let indentString = options.useTabs
                  ? "\t".repeat(ind.indent + ind.align.tabs)
                  : " ".repeat(length);
                out.push(newLine + indentString);
                pos = length;
              }
              break;
          }
          break;
        default:
      }
    }
  }
  return out.join("");
}

var docPrinter = { printDocToString: printDocToString$1 };

var index$28 = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var conversions$1 = createCommonjsModule(function (module) {
/* MIT license */
var cssKeywords = index$28;

// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in cssKeywords) {
	if (cssKeywords.hasOwnProperty(key)) {
		reverseKeywords[cssKeywords[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var v;

	if (max === 0) {
		s = 0;
	} else {
		s = (delta / max * 1000) / 10;
	}

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	v = ((max / 255) * 1000) / 10;

	return [h, s, v];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in cssKeywords) {
		if (cssKeywords.hasOwnProperty(keyword)) {
			var value = cssKeywords[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return cssKeywords[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};
});

var conversions$3 = conversions$1;

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

// https://jsperf.com/object-keys-vs-for-in-with-closure/3
var models$1 = Object.keys(conversions$3);

function buildGraph() {
	var graph = {};

	for (var len = models$1.length, i = 0; i < len; i++) {
		graph[models$1[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions$3[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions$3[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link(conversions$3[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route$1 = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var conversions = conversions$1;
var route = route$1;

var convert = {};

var models = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var index$26 = convert;

var index$24 = createCommonjsModule(function (module) {
'use strict';
const colorConvert = index$26;

const wrapAnsi16 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${code + offset}m`;
};

const wrapAnsi256 = (fn, offset) => function () {
	const code = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};5;${code}m`;
};

const wrapAnsi16m = (fn, offset) => function () {
	const rgb = fn.apply(colorConvert, arguments);
	return `\u001B[${38 + offset};2;${rgb[0]};${rgb[1]};${rgb[2]}m`;
};

function assembleStyles() {
	const styles = {
		modifier: {
			reset: [0, 0],
			// 21 isn't widely supported and 22 does the same thing
			bold: [1, 22],
			dim: [2, 22],
			italic: [3, 23],
			underline: [4, 24],
			inverse: [7, 27],
			hidden: [8, 28],
			strikethrough: [9, 29]
		},
		color: {
			black: [30, 39],
			red: [31, 39],
			green: [32, 39],
			yellow: [33, 39],
			blue: [34, 39],
			magenta: [35, 39],
			cyan: [36, 39],
			white: [37, 39],
			gray: [90, 39]
		},
		bgColor: {
			bgBlack: [40, 49],
			bgRed: [41, 49],
			bgGreen: [42, 49],
			bgYellow: [43, 49],
			bgBlue: [44, 49],
			bgMagenta: [45, 49],
			bgCyan: [46, 49],
			bgWhite: [47, 49]
		}
	};

	// fix humans
	styles.color.grey = styles.color.gray;

	Object.keys(styles).forEach(groupName => {
		const group = styles[groupName];

		Object.keys(group).forEach(styleName => {
			const style = group[styleName];

			styles[styleName] = group[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`
			};
		});

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false
		});
	});

	const rgb2rgb = (r, g, b) => [r, g, b];

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = {};
	styles.color.ansi256 = {};
	styles.color.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 0)
	};

	styles.bgColor.ansi = {};
	styles.bgColor.ansi256 = {};
	styles.bgColor.ansi16m = {
		rgb: wrapAnsi16m(rgb2rgb, 10)
	};

	for (const key of Object.keys(colorConvert)) {
		if (typeof colorConvert[key] !== 'object') {
			continue;
		}

		const suite = colorConvert[key];

		if ('ansi16' in suite) {
			styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
			styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
		}

		if ('ansi256' in suite) {
			styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
			styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
		}

		if ('rgb' in suite) {
			styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
			styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
		}
	}

	return styles;
}

Object.defineProperty(module, 'exports', {
	enumerable: true,
	get: assembleStyles
});
});

const style = index$24;

const toString$1 = Object.prototype.toString;
const toISOString = Date.prototype.toISOString;
const errorToString = Error.prototype.toString;
const regExpToString = RegExp.prototype.toString;
const symbolToString = Symbol.prototype.toString;

const SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
const NEWLINE_REGEXP = /\n/ig;

const getSymbols = Object.getOwnPropertySymbols || (obj => []);

function isToStringedArrayType(toStringed) {
  return (
    toStringed === '[object Array]' ||
    toStringed === '[object ArrayBuffer]' ||
    toStringed === '[object DataView]' ||
    toStringed === '[object Float32Array]' ||
    toStringed === '[object Float64Array]' ||
    toStringed === '[object Int8Array]' ||
    toStringed === '[object Int16Array]' ||
    toStringed === '[object Int32Array]' ||
    toStringed === '[object Uint8Array]' ||
    toStringed === '[object Uint8ClampedArray]' ||
    toStringed === '[object Uint16Array]' ||
    toStringed === '[object Uint32Array]');

}

function printNumber$1(val) {
  if (val != +val) {
    return 'NaN';
  }
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? '-0' : '' + val;
}

function printFunction(val, printFunctionName) {
  if (!printFunctionName) {
    return '[Function]';
  } else if (val.name === '') {
    return '[Function anonymous]';
  } else {
    return '[Function ' + val.name + ']';
  }
}

function printSymbol(val) {
  return symbolToString.call(val).replace(SYMBOL_REGEXP, 'Symbol($1)');
}

function printError(val) {
  return '[' + errorToString.call(val) + ']';
}

function printBasicValue(val, printFunctionName, escapeRegex) {
  if (val === true || val === false) {
    return '' + val;
  }
  if (val === undefined) {
    return 'undefined';
  }
  if (val === null) {
    return 'null';
  }

  const typeOf = typeof val;

  if (typeOf === 'number') {
    return printNumber$1(val);
  }
  if (typeOf === 'string') {
    return '"' + val.replace(/"|\\/g, '\\$&') + '"';
  }
  if (typeOf === 'function') {
    return printFunction(val, printFunctionName);
  }
  if (typeOf === 'symbol') {
    return printSymbol(val);
  }

  const toStringed = toString$1.call(val);

  if (toStringed === '[object WeakMap]') {
    return 'WeakMap {}';
  }
  if (toStringed === '[object WeakSet]') {
    return 'WeakSet {}';
  }
  if (toStringed === '[object Function]' || toStringed === '[object GeneratorFunction]') {
    return printFunction(val, printFunctionName);
  }
  if (toStringed === '[object Symbol]') {
    return printSymbol(val);
  }
  if (toStringed === '[object Date]') {
    return toISOString.call(val);
  }
  if (toStringed === '[object Error]') {
    return printError(val);
  }
  if (toStringed === '[object RegExp]') {
    if (escapeRegex) {
      // https://github.com/benjamingr/RegExp.escape/blob/master/polyfill.js
      return regExpToString.call(val).replace(/[\\^$*+?.()|[\]{}]/g, '\\$&');
    }
    return regExpToString.call(val);
  }
  if (toStringed === '[object Arguments]' && val.length === 0) {
    return 'Arguments []';
  }
  if (isToStringedArrayType(toStringed) && val.length === 0) {
    return val.constructor.name + ' []';
  }

  if (val instanceof Error) {
    return printError(val);
  }

  return false;
}

function printList(list, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let body = '';

  if (list.length) {
    body += edgeSpacing;

    const innerIndent = prevIndent + indent;

    for (let i = 0; i < list.length; i++) {
      body += innerIndent + print(list[i], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      if (i < list.length - 1) {
        body += ',' + spacing;
      }
    }

    body += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return '[' + body + ']';
}

function printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  return (min ? '' : 'Arguments ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  return (min ? '' : val.constructor.name + ' ') + printList(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let result = 'Map {';
  const iterator = val.entries();
  let current = iterator.next();

  if (!current.done) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    while (!current.done) {
      const key = print(current.value[0], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
      const value = print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      result += innerIndent + key + ' => ' + value;

      current = iterator.next();

      if (!current.done) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  const constructor = min ? '' : val.constructor ? val.constructor.name + ' ' : 'Object ';
  let result = constructor + '{';
  let keys = Object.keys(val).sort();
  const symbols = getSymbols(val);

  if (symbols.length) {
    keys = keys.
    filter(key => !(typeof key === 'symbol' || toString$1.call(key) === '[object Symbol]')).
    concat(symbols);
  }

  if (keys.length) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const name = print(key, indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
      const value = print(val[key], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      result += innerIndent + name + ': ' + value;

      if (i < keys.length - 1) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let result = 'Set {';
  const iterator = val.entries();
  let current = iterator.next();

  if (!current.done) {
    result += edgeSpacing;

    const innerIndent = prevIndent + indent;

    while (!current.done) {
      result += innerIndent + print(current.value[1], indent, innerIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);

      current = iterator.next();

      if (!current.done) {
        result += ',' + spacing;
      }
    }

    result += (min ? '' : ',') + edgeSpacing + prevIndent;
  }

  return result + '}';
}

function printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  refs = refs.slice();
  if (refs.indexOf(val) > -1) {
    return '[Circular]';
  } else {
    refs.push(val);
  }

  currentDepth++;

  const hitMaxDepth = currentDepth > maxDepth;

  if (callToJSON && !hitMaxDepth && val.toJSON && typeof val.toJSON === 'function') {
    return print(val.toJSON(), indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  const toStringed = toString$1.call(val);
  if (toStringed === '[object Arguments]') {
    return hitMaxDepth ? '[Arguments]' : printArguments(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (isToStringedArrayType(toStringed)) {
    return hitMaxDepth ? '[Array]' : printArray(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (toStringed === '[object Map]') {
    return hitMaxDepth ? '[Map]' : printMap(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  } else if (toStringed === '[object Set]') {
    return hitMaxDepth ? '[Set]' : printSet(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  return hitMaxDepth ? '[Object]' : printObject(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

function printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  let match = false;
  let plugin;

  for (let p = 0; p < plugins.length; p++) {
    plugin = plugins[p];

    if (plugin.test(val)) {
      match = true;
      break;
    }
  }

  if (!match) {
    return false;
  }

  function boundPrint(val) {
    return print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  }

  function boundIndent(str) {
    const indentation = prevIndent + indent;
    return indentation + str.replace(NEWLINE_REGEXP, '\n' + indentation);
  }

  const opts = {
    edgeSpacing,
    min,
    spacing };

  return plugin.print(val, boundPrint, boundIndent, opts, colors);
}

function print(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors) {
  const basic = printBasicValue(val, printFunctionName, escapeRegex);
  if (basic) {
    return basic;
  }

  const plugin = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
  if (plugin) {
    return plugin;
  }

  return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, maxDepth, currentDepth, plugins, min, callToJSON, printFunctionName, escapeRegex, colors);
}

const DEFAULTS = {
  callToJSON: true,
  escapeRegex: false,
  highlight: false,
  indent: 2,
  maxDepth: Infinity,
  min: false,
  plugins: [],
  printFunctionName: true,
  theme: {
    content: 'reset',
    prop: 'yellow',
    tag: 'cyan',
    value: 'green' } };



function validateOptions(opts) {
  Object.keys(opts).forEach(key => {
    if (!DEFAULTS.hasOwnProperty(key)) {
      throw new Error('prettyFormat: Invalid option: ' + key);
    }
  });

  if (opts.min && opts.indent !== undefined && opts.indent !== 0) {
    throw new Error('prettyFormat: Cannot run with min option and indent');
  }
}

function normalizeOptions$1(opts) {
  const result = {};

  Object.keys(DEFAULTS).forEach(key =>
  result[key] = opts.hasOwnProperty(key) ? opts[key] : DEFAULTS[key]);


  if (result.min) {
    result.indent = 0;
  }

  return result;
}

function createIndent(indent) {
  return new Array(indent + 1).join(' ');
}

function prettyFormat(val, opts) {
  if (!opts) {
    opts = DEFAULTS;
  } else {
    validateOptions(opts);
    opts = normalizeOptions$1(opts);
  }

  const colors = {};
  Object.keys(opts.theme).forEach(key => {
    if (opts.highlight) {
      colors[key] = style[opts.theme[key]];
    } else {
      colors[key] = { close: '', open: '' };
    }
  });

  let indent;
  let refs;
  const prevIndent = '';
  const currentDepth = 0;
  const spacing = opts.min ? ' ' : '\n';
  const edgeSpacing = opts.min ? '' : '\n';

  if (opts && opts.plugins.length) {
    indent = createIndent(opts.indent);
    refs = [];
    const pluginsResult = printPlugin(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex, colors);
    if (pluginsResult) {
      return pluginsResult;
    }
  }

  const basicResult = printBasicValue(val, opts.printFunctionName, opts.escapeRegex);
  if (basicResult) {
    return basicResult;
  }

  if (!indent) {
    indent = createIndent(opts.indent);
  }
  if (!refs) {
    refs = [];
  }
  return printComplexValue(val, indent, prevIndent, spacing, edgeSpacing, refs, opts.maxDepth, currentDepth, opts.plugins, opts.min, opts.callToJSON, opts.printFunctionName, opts.escapeRegex, colors);
}

var index$22 = prettyFormat;

/* eslint-disable no-nested-ternary */
var arr = [];
var charCodeCache = [];

var index$30 = function (a, b) {
	if (a === b) {
		return 0;
	}

	var aLen = a.length;
	var bLen = b.length;

	if (aLen === 0) {
		return bLen;
	}

	if (bLen === 0) {
		return aLen;
	}

	var bCharCode;
	var ret;
	var tmp;
	var tmp2;
	var i = 0;
	var j = 0;

	while (i < aLen) {
		charCodeCache[i] = a.charCodeAt(i);
		arr[i] = ++i;
	}

	while (j < bLen) {
		bCharCode = b.charCodeAt(j);
		tmp = j++;
		ret = j;

		for (i = 0; i < aLen; i++) {
			tmp2 = bCharCode === charCodeCache[i] ? tmp : tmp + 1;
			tmp = arr[i];
			ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
		}
	}

	return ret;
};

const chalk$1 = index$6;
const BULLET = chalk$1.bold('\u25cf');
const DEPRECATION = `${BULLET} Deprecation Warning`;
const ERROR$1 = `${BULLET} Validation Error`;
const WARNING = `${BULLET} Validation Warning`;

const format$3 = value =>
typeof value === 'function' ?
value.toString() :
index$22(value, { min: true });

class ValidationError$1 extends Error {



  constructor(name, message, comment) {
    super();
    comment = comment ? '\n\n' + comment : '\n';
    this.name = '';
    this.message = chalk$1.red(chalk$1.bold(name) + ':\n\n' + message + comment);
    Error.captureStackTrace(this, () => {});
  }}


const logValidationWarning = (
name,
message,
comment) =>
{
  comment = comment ? '\n\n' + comment : '\n';
  console.warn(chalk$1.yellow(chalk$1.bold(name) + ':\n\n' + message + comment));
};

const createDidYouMeanMessage = (
unrecognized,
allowedOptions) =>
{
  const leven = index$30;
  const suggestion = allowedOptions.find(option => {
    const steps = leven(option, unrecognized);
    return steps < 3;
  });

  return suggestion ?
  `Did you mean ${chalk$1.bold(format$3(suggestion))}?` :
  '';
};

var utils$3 = {
  DEPRECATION,
  ERROR: ERROR$1,
  ValidationError: ValidationError$1,
  WARNING,
  createDidYouMeanMessage,
  format: format$3,
  logValidationWarning };

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 * 
 */

const asymmetricMatcher = Symbol.for('jest.asymmetricMatcher');
const SPACE = ' ';

class ArrayContaining extends Array {}
class ObjectContaining extends Object {}

const printAsymmetricMatcher = (
val,
print,
indent,
opts,
colors) =>
{
  const stringedValue = val.toString();

  if (stringedValue === 'ArrayContaining') {
    const array = ArrayContaining.from(val.sample);
    return opts.spacing === SPACE ?
    stringedValue + SPACE + print(array) :
    print(array);
  }

  if (stringedValue === 'ObjectContaining') {
    const object = Object.assign(new ObjectContaining(), val.sample);
    return opts.spacing === SPACE ?
    stringedValue + SPACE + print(object) :
    print(object);
  }

  if (stringedValue === 'StringMatching') {
    return stringedValue + SPACE + print(val.sample);
  }

  if (stringedValue === 'StringContaining') {
    return stringedValue + SPACE + print(val.sample);
  }

  return val.toAsymmetricMatcher();
};

var AsymmetricMatcher = {
  print: printAsymmetricMatcher,
  test: object => object && object.$$typeof === asymmetricMatcher };

const chalk$2 = index$6;
const prettyFormat$1 = index$22;
const AsymmetricMatcherPlugin = AsymmetricMatcher;

const PLUGINS = [AsymmetricMatcherPlugin];















const EXPECTED_COLOR = chalk$2.green;
const EXPECTED_BG = chalk$2.bgGreen;
const RECEIVED_COLOR = chalk$2.red;
const RECEIVED_BG = chalk$2.bgRed;

const NUMBERS = [
'zero',
'one',
'two',
'three',
'four',
'five',
'six',
'seven',
'eight',
'nine',
'ten',
'eleven',
'twelve',
'thirteen'];


// get the type of a value with handling the edge cases like `typeof []`
// and `typeof null`
const getType$1 = value => {
  if (typeof value === 'undefined') {
    return 'undefined';
  } else if (value === null) {
    return 'null';
  } else if (Array.isArray(value)) {
    return 'array';
  } else if (typeof value === 'boolean') {
    return 'boolean';
  } else if (typeof value === 'function') {
    return 'function';
  } else if (typeof value === 'number') {
    return 'number';
  } else if (typeof value === 'string') {
    return 'string';
  } else if (typeof value === 'object') {
    if (value.constructor === RegExp) {
      return 'regexp';
    } else if (value.constructor === Map) {
      return 'map';
    } else if (value.constructor === Set) {
      return 'set';
    }
    return 'object';
    // $FlowFixMe https://github.com/facebook/flow/issues/1015
  } else if (typeof value === 'symbol') {
    return 'symbol';
  }

  throw new Error(`value of unknown type: ${value}`);
};

const stringify = function (object) {let maxDepth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
  const MAX_LENGTH = 10000;
  let result;

  try {
    result = prettyFormat$1(object, {
      maxDepth,
      min: true,
      plugins: PLUGINS });

  } catch (e) {
    result = prettyFormat$1(object, {
      callToJSON: false,
      maxDepth,
      min: true,
      plugins: PLUGINS });

  }

  return result.length >= MAX_LENGTH && maxDepth > 1 ?
  stringify(object, Math.floor(maxDepth / 2)) :
  result;
};

const highlightTrailingWhitespace = (text, bgColor) =>
text.replace(/\s+$/gm, bgColor('$&'));

const printReceived = object => highlightTrailingWhitespace(
RECEIVED_COLOR(stringify(object)),
RECEIVED_BG);

const printExpected = value => highlightTrailingWhitespace(
EXPECTED_COLOR(stringify(value)),
EXPECTED_BG);


const printWithType = (
name,
received,
print) =>
{
  const type = getType$1(received);
  return (
    name + ':' + (
    type !== 'null' && type !== 'undefined' ?
    '\n  ' + type + ': ' :
    ' ') +
    print(received));

};

const ensureNoExpected = (expected, matcherName) => {
  matcherName || (matcherName = 'This');
  if (typeof expected !== 'undefined') {
    throw new Error(
    matcherHint('[.not]' + matcherName, undefined, '') + '\n\n' +
    'Matcher does not accept any arguments.\n' +
    printWithType('Got', expected, printExpected));

  }
};

const ensureActualIsNumber = (actual, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof actual !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
    `Actual value must be a number.\n` +
    printWithType('Received', actual, printReceived));

  }
};

const ensureExpectedIsNumber = (expected, matcherName) => {
  matcherName || (matcherName = 'This matcher');
  if (typeof expected !== 'number') {
    throw new Error(
    matcherHint('[.not]' + matcherName) + '\n\n' +
    `Expected value must be a number.\n` +
    printWithType('Got', expected, printExpected));

  }
};

const ensureNumbers = (actual, expected, matcherName) => {
  ensureActualIsNumber(actual, matcherName);
  ensureExpectedIsNumber(expected, matcherName);
};

const pluralize =
(word, count) =>
(NUMBERS[count] || count) + ' ' + word + (count === 1 ? '' : 's');

const matcherHint = function (
matcherName)






{let received = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'received';let expected = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'expected';let options = arguments[3];
  const secondArgument = options && options.secondArgument;
  const isDirectExpectCall = options && options.isDirectExpectCall;
  return (
    chalk$2.dim('expect' + (isDirectExpectCall ? '' : '(')) +
    RECEIVED_COLOR(received) +
    chalk$2.dim((isDirectExpectCall ? '' : ')') + matcherName + '(') +
    EXPECTED_COLOR(expected) + (
    secondArgument ? `, ${EXPECTED_COLOR(secondArgument)}` : '') +
    chalk$2.dim(')'));

};

var index$32 = {
  EXPECTED_BG,
  EXPECTED_COLOR,
  RECEIVED_BG,
  RECEIVED_COLOR,
  ensureActualIsNumber,
  ensureExpectedIsNumber,
  ensureNoExpected,
  ensureNumbers,
  getType: getType$1,
  highlightTrailingWhitespace,
  matcherHint,
  pluralize,
  printExpected,
  printReceived,
  printWithType,
  stringify };

const chalk = index$6;var _require =
utils$3;const format$2 = _require.format; const ValidationError = _require.ValidationError; const ERROR = _require.ERROR;var _require2 =
index$32;const getType = _require2.getType;

const errorMessage = (
option,
received,
defaultValue,
options) =>
{
  const message =
  `  Option ${chalk.bold(`"${option}"`)} must be of type:
    ${chalk.bold.green(getType(defaultValue))}
  but instead received:
    ${chalk.bold.red(getType(received))}

  Example:
  {
    ${chalk.bold(`"${option}"`)}: ${chalk.bold(format$2(defaultValue))}
  }`;

  const comment = options.comment;
  const name = options.title && options.title.error || ERROR;

  throw new ValidationError(name, message, comment);
};

var errors = {
  ValidationError,
  errorMessage };

var _require$2 =



utils$3;const logValidationWarning$1 = _require$2.logValidationWarning; const DEPRECATION$2 = _require$2.DEPRECATION;

const deprecationMessage = (message, options) => {
  const comment = options.comment;
  const name = options.title && options.title.deprecation || DEPRECATION$2;

  logValidationWarning$1(name, message, comment);
};

const deprecationWarning$1 = (
config,
option,
deprecatedOptions,
options) =>
{
  if (option in deprecatedOptions) {
    deprecationMessage(deprecatedOptions[option](config), options);

    return true;
  }

  return false;
};

var deprecated = {
  deprecationWarning: deprecationWarning$1 };

const chalk$3 = index$6;var _require$3 =





utils$3;const format$4 = _require$3.format; const logValidationWarning$2 = _require$3.logValidationWarning; const createDidYouMeanMessage$1 = _require$3.createDidYouMeanMessage; const WARNING$2 = _require$3.WARNING;

const unknownOptionWarning$1 = (
config,
exampleConfig,
option,
options) =>
{
  const didYouMean =
  createDidYouMeanMessage$1(option, Object.keys(exampleConfig));
  /* eslint-disable max-len */
  const message =
  `  Unknown option ${chalk$3.bold(`"${option}"`)} with value ${chalk$3.bold(format$4(config[option]))} was found.` + (
  didYouMean && ` ${didYouMean}`) +
  `\n  This is probably a typing mistake. Fixing it will remove this message.`;
  /* eslint-enable max-len */

  const comment = options.comment;
  const name = options.title && options.title.warning || WARNING$2;

  logValidationWarning$2(name, message, comment);
};

var warnings = {
  unknownOptionWarning: unknownOptionWarning$1 };

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

const config$1 = {
  comment: '  A comment',
  condition: (option, validOption) => true,
  deprecate: (config, option, deprecatedOptions, options) => false,
  deprecatedConfig: {
    key: config => {} },

  error: (option, received, defaultValue, options) => {},
  exampleConfig: { key: 'value', test: 'case' },
  title: {
    deprecation: 'Deprecation Warning',
    error: 'Validation Error',
    warning: 'Validation Warning' },

  unknown: (config, option, options) => {} };


var exampleConfig$2 = config$1;

/**
 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

const toString$2 = Object.prototype.toString;

const validationCondition$1 = (
option,
validOption) =>
{
  return (
    option === null ||
    option === undefined ||
    toString$2.call(option) === toString$2.call(validOption));

};

var condition = validationCondition$1;

var _require$1 =



deprecated;const deprecationWarning = _require$1.deprecationWarning;var _require2$1 =
warnings;const unknownOptionWarning = _require2$1.unknownOptionWarning;var _require3 =
errors;const errorMessage$1 = _require3.errorMessage;
const exampleConfig$1 = exampleConfig$2;
const validationCondition = condition;var _require4 =
utils$3;const ERROR$2 = _require4.ERROR; const DEPRECATION$1 = _require4.DEPRECATION; const WARNING$1 = _require4.WARNING;

var defaultConfig$1 = {
  comment: '',
  condition: validationCondition,
  deprecate: deprecationWarning,
  deprecatedConfig: {},
  error: errorMessage$1,
  exampleConfig: exampleConfig$1,
  title: {
    deprecation: DEPRECATION$1,
    error: ERROR$2,
    warning: WARNING$1 },

  unknown: unknownOptionWarning };

const defaultConfig = defaultConfig$1;

const _validate = (config, options) => {
  let hasDeprecationWarnings = false;

  for (const key in config) {
    if (
    options.deprecatedConfig &&
    key in options.deprecatedConfig &&
    typeof options.deprecate === 'function')
    {
      const isDeprecatedKey = options.deprecate(
      config,
      key,
      options.deprecatedConfig,
      options);


      hasDeprecationWarnings = hasDeprecationWarnings || isDeprecatedKey;
    } else if (hasOwnProperty.call(options.exampleConfig, key)) {
      if (
      typeof options.condition === 'function' &&
      typeof options.error === 'function' &&
      !options.condition(config[key], options.exampleConfig[key]))
      {
        options.error(key, config[key], options.exampleConfig[key], options);
      }
    } else {
      options.unknown &&
      options.unknown(config, options.exampleConfig, key, options);
    }
  }

  return { hasDeprecationWarnings };
};

const validate$1 = (config, options) => {
  _validate(options, defaultConfig); // validate against jest-validate config

  const defaultedOptions = Object.assign(
  {},
  defaultConfig,
  options,
  { title: Object.assign({}, defaultConfig.title, options.title) });var _validate2 =


  _validate(config, defaultedOptions);const hasDeprecationWarnings = _validate2.hasDeprecationWarnings;

  return {
    hasDeprecationWarnings,
    isValid: true };

};

var validate_1 = validate$1;

var index$20 = {
  ValidationError: errors.ValidationError,
  createDidYouMeanMessage: utils$3.createDidYouMeanMessage,
  format: utils$3.format,
  logValidationWarning: utils$3.logValidationWarning,
  validate: validate_1 };

const deprecated$2 = {
  useFlowParser: config =>
    `  The ${'"useFlowParser"'} option is deprecated. Use ${'"parser"'} instead.

  Prettier now treats your configuration as:
  {
    ${'"parser"'}: ${config.useFlowParser ? '"flow"' : '"babylon"'}
  }`
};

var deprecated_1 = deprecated$2;

var validate = index$20.validate;
var deprecatedConfig = deprecated_1;

var defaults = {
  useTabs: false,
  tabWidth: 2,
  printWidth: 80,
  singleQuote: false,
  trailingComma: "none",
  bracketSpacing: true,
  jsxBracketSameLine: false,
  parser: "babylon",
  semi: true
};

var exampleConfig = Object.assign({}, defaults, {
  filename: "testFilename",
  printWidth: 80,
  originalText: "text"
});

// Copy options and fill in default values.
function normalize(options) {
  const normalized = Object.assign({}, options || {});

  if (typeof normalized.trailingComma === "boolean") {
    // Support a deprecated boolean type for the trailing comma config
    // for a few versions. This code can be removed later.
    normalized.trailingComma = "es5";

    console.warn(
      "Warning: `trailingComma` without any argument is deprecated. " +
        'Specify "none", "es5", or "all".'
    );
  }

  validate(normalized, { exampleConfig, deprecatedConfig });

  // For backward compatibility. Deprecated in 0.0.10
  if ("useFlowParser" in normalized) {
    normalized.parser = normalized.useFlowParser ? "flow" : "babylon";
    delete normalized.useFlowParser;
  }

  Object.keys(defaults).forEach(k => {
    if (normalized[k] == null) {
      normalized[k] = defaults[k];
    }
  });

  return normalized;
}

var options = { normalize };

var flow_parser = createCommonjsModule(function (module, exports) {
// Generated by js_of_ocaml 2.8.1
(function(aQ){"use strict";var
cL=104,gO="filter",d8=254,G=108,gN=956,fO="expressions",gz="Invalid_argument",bv="get",gZ="Identifier",an=16777215,dS="function",cN="variance",gM="exported",dI=65599,ft="jsError",gy="%ni",go=402,dP="consequent",f5=512,gx="&",gK="src/parser/expression_parser.ml",gL="(global)",gn="End_of_file",d4=120,gl="new",gm="Failure",dW="label",cS="local",fN="empty",bW="params",fD="shorthand",P=128,aJ="0",W=248,f4=-43,dO="constructor",aP="src/parser/spider_monkey_ast.ml",f3="yield",fC="Sys_blocked_io",f1=-53,f2="fd ",gw="superTypeParameters",gY=1023,f0="var",bQ=107,V="camlinternalFormat.ml",fM="Division_by_zero",fZ="0o",gk="elements",fs=-34,gi="each",gj="Sys_error",gJ=112,d7="decorators",fB="protected",fz=-97,fA=1114111,dH=-69,cH=1073741823,fy="%u",cU=105,dV="object",gI="%d",d6="method",cK=110,fL=57343,fK="'",fr="Unix",fY="Popping lex mode from empty stack",gh=218,a9="int_of_string",cd="operator",fX=-80,ch="from",a8="name",gg=810,d3=789,cX="e",cJ="returnType",a6="-",gf="callee",gv=-24,gH=-48,cf="async",dN="src/parser/statement_parser.ml",ge="*-/",cR="predicate",bR="set",dD="types",dG=" : file already exists",fW=109,cQ=240,bu="left",bh="right",d2=2048,fq=216,fJ=-66,X="body",cG="0x",cP="optional",fV="Out_of_memory",fp="\n",fU=101,gG=227,dC=32768,fT="index out of bounds",bP="typeof",gX="package",gF="Lookahead.peek failed",gd="%Li",K=255,cT=224,fo=199,fx="public",gc="loc",fI=65536,gu="enum",gt="in",d0="src/parser/lexer_flow.mll",d1="properties",bV="type",cj=250,cm=1024,bM="source",fw="interface",dZ="arguments",gW="module",a_="static",dY="declaration",cV=246,ce=102,gb="lexing: empty token",dB="generator",cg="init",dM=113,gV="infinity",gU="private",gE=122,cI="default",p="",gD="Stack_overflow",dF="exportKind",dR=-79,gs="instanceof",gT="Property",cW="implements",ae=100,av="argument",gC="Not_found",gr=-17,bU="src/parser/type_parser.ml",d5=103,bx="raw",fv="Match_failure",fS="alternate",gq=1e3,bO=".",bt="+",bg=65535,cl=106,bT="kind",ga="prefix",gB="superClass",fu="%li",gA="const",aK="typeParameters",fH="delete",fG="blocks",f$=252,B=127,dX="false",bL="key",bN="test",gS="mixins",a7=" ",dU="void",f9="RestElement",f_="Undefined_recursive_module",gp="let",bw=256,dK=":",dT="nan",cM=192,f8=116,bS="expression",gR=65520,Y="value",aZ="typeAnnotation",gQ=191,fF="minus",fR=56320,fE=245,dA="specifiers",cO="Set.bal",ci="/",gP="Assert_failure",dE="property",fP=114,fQ=949,ck="computed",f7="%i",aY="as",af="id",dJ="true",dQ="extends",f6="importKind",dL="null";function
hj(b,a){throw[0,b,a]}var
S=[0];function
HH(b,c){function
f(a){hj(S.Undefined_recursive_module,b);}function
e(b,c,a){if(typeof
b==="number")switch(b){case
0:c[a]={fun:f};break;case
1:c[a]=[cV,f];break;default:c[a]=[];}else
switch(b[0]){case
0:c[a]=[0];for(var
d=1;d<b[1].length;d++)e(b[1][d],c[a],d);break;default:c[a]=b[1];}}var
a=[];e(c,a,0);return a[0]}function
i(c,a){if(typeof
a===dS){c.fun=a;return 0}if(a.fun){c.fun=a.fun;return 0}var
b=a.length;while(b--)c[b]=a[b];return 0}function
g1(b,c,d){if(typeof
b==="number")switch(b){case
0:c.fun=d;break;case
1:default:i(c,d);}else
switch(b[0]){case
0:for(var
a=1;a<b[1].length;a++)g1(b[1][a],c[a],d[a]);break}return 0}function
HI(c,d){var
g=c.length,h=d.length,f=g+h-1,b=new
Array(f);b[0]=0;var
a=1,e=1;for(;a<g;a++)b[a]=c[a];for(;a<f;a++,e++)b[a]=d[e];return b}function
HJ(d,b,e,c,f){if(c<=b)for(var
a=1;a<=f;a++)e[c+a]=d[b+a];else
for(var
a=f;a>=1;a--)e[c+a]=d[b+a];return 0}function
g3(e,f,d){var
a=new
Array(d+1);a[0]=0;for(var
b=1,c=f+1;b<=d;b++,c++)a[b]=e[c];return a}function
c_(d,e,c){var
b=new
Array(c);for(var
a=0;a<c;a++)b[a]=d[e+a];return b}function
ed(b,c,a){var
d=String.fromCharCode;if(c==0&&a<=4096&&a==b.length)return d.apply(null,b);var
e=p;for(;0<a;c+=cm,a-=cm)e+=d.apply(null,c_(b,c,Math.min(a,cm)));return e}function
cZ(b){if(aQ.Uint8Array)var
c=new(aQ.Uint8Array)(b.l);else
var
c=new
Array(b.l);var
e=b.c,d=e.length,a=0;for(;a<d;a++)c[a]=e.charCodeAt(a);for(d=b.l;a<d;a++)c[a]=0;b.c=c;b.t=4;return c}function
aA(d,e,a,f,c){if(c==0)return 0;if(f==0&&(c>=a.l||a.t==2&&c>=a.c.length)){a.c=d.t==4?ed(d.c,e,c):e==0&&d.c.length==c?d.c:d.c.substr(e,c);a.t=a.c.length==a.l?0:2;}else
if(a.t==2&&f==a.c.length){a.c+=d.t==4?ed(d.c,e,c):e==0&&d.c.length==c?d.c:d.c.substr(e,c);a.t=a.c.length==a.l?0:2;}else{if(a.t!=4)cZ(a);var
g=d.c,h=a.c;if(d.t==4)for(var
b=0;b<c;b++)h[f+b]=g[e+b];else{var
i=Math.min(c,g.length-e);for(var
b=0;b<i;b++)h[f+b]=g.charCodeAt(e+b);for(;b<c;b++)h[f+b]=0;}}return 0}function
IF(c,e){var
d=c.length,b=new
Array(d+1),a=0;for(;a<d;a++)b[a]=c[a];b[a]=e;return b}function
bj(b,a){if(b.fun)return bj(b.fun,a);var
c=b.length,d=a.length,e=c-d;if(e==0)return b.apply(null,a);else
if(e<0)return bj(b.apply(null,c_(a,0,c)),c_(a,c,d-c));else
return function(c){return bj(b,IF(a,c))}}function
bZ(b,a){if(a.repeat)return a.repeat(b);var
c=p,d=0;if(b==0)return c;for(;;){if(b&1)c+=a;b>>=1;if(b==0)return c;a+=a;d++;if(d==9)a.slice(0,1);}}function
a$(a){if(a.t==2)a.c+=bZ(a.l-a.c.length,"\0");else
a.c=ed(a.c,0,a.c.length);a.t=0;}function
g_(a){if(a.length<24){for(var
b=0;b<a.length;b++)if(a.charCodeAt(b)>B)return false;return true}else
return!/[^\x00-\x7f]/.test(a)}function
Iz(e){for(var
j=p,c=p,g,f,h,a,b=0,i=e.length;b<i;b++){f=e.charCodeAt(b);if(f<P){for(var
d=b+1;d<i&&(f=e.charCodeAt(d))<P;d++);if(d-b>f5){c.substr(0,1);j+=c;c=p;j+=e.slice(b,d);}else
c+=e.slice(b,d);if(d==i)break;b=d;}a=1;if(++b<i&&((h=e.charCodeAt(b))&-64)==P){g=h+(f<<6);if(f<cT){a=g-12416;if(a<P)a=1;}else{a=2;if(++b<i&&((h=e.charCodeAt(b))&-64)==P){g=h+(g<<6);if(f<cQ){a=g-925824;if(a<d2||a>=55295&&a<57344)a=2;}else{a=3;if(++b<i&&((h=e.charCodeAt(b))&-64)==P&&f<fE){a=h-63447168+(g<<6);if(a<fI||a>fA)a=3;}}}}}if(a<4){b-=a;c+="\ufffd";}else
if(a>bg)c+=String.fromCharCode(55232+(a>>10),fR+(a&gY));else
c+=String.fromCharCode(a);if(c.length>cm){c.substr(0,1);j+=c;c=p;}}return j+c}function
Iy(a){switch(a.t){case
9:return a.c;default:a$(a);case
0:if(g_(a.c)){a.t=9;return a.c}a.t=8;case
8:return Iz(a.c)}}function
aw(c,a,b){this.t=c;this.c=a;this.l=b;}aw.prototype.toString=function(){return Iy(this)};function
a(a){return new
aw(0,a,a.length)}function
ec(c,b){hj(c,a(b));}function
bz(a){ec(S.Invalid_argument,a);}function
HK(){bz(fT);}function
k(a,b){if(b>>>0>=a.length-1)HK();return a}function
HL(a){if(isFinite(a)){if(Math.abs(a)>=2.22507385850720138e-308)return 0;if(a!=0)return 1;return 2}return isNaN(a)?4:3}function
H2(a,b){var
c=a[3]<<16,d=b[3]<<16;if(c>d)return 1;if(c<d)return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
H$(a,b){if(a<b)return-1;if(a==b)return 0;return 1}function
x(a,b){a.t&6&&a$(a);b.t&6&&a$(b);return a.c<b.c?-1:a.c>b.c?1:0}function
cY(a,b,h){var
d=[];for(;;){if(!(h&&a===b))if(a
instanceof
aw)if(b
instanceof
aw){if(a!==b){var
c=x(a,b);if(c!=0)return c}}else
return 1;else
if(a
instanceof
Array&&a[0]===(a[0]|0)){var
e=a[0];if(e===d8)e=0;if(e===cj){a=a[1];continue}else
if(b
instanceof
Array&&b[0]===(b[0]|0)){var
f=b[0];if(f===d8)f=0;if(f===cj){b=b[1];continue}else
if(e!=f)return e<f?-1:1;else
switch(e){case
248:var
c=H$(a[2],b[2]);if(c!=0)return c;break;case
251:bz("equal: abstract value");case
255:var
c=H2(a,b);if(c!=0)return c;break;default:if(a.length!=b.length)return a.length<b.length?-1:1;if(a.length>1)d.push(a,b,1);}}else
return 1}else
if(b
instanceof
aw||b
instanceof
Array&&b[0]===(b[0]|0))return-1;else
if(typeof
a!="number"&&a&&a.compare)return a.compare(b,h);else
if(typeof
a==dS)bz("equal: functional value");else{if(a<b)return-1;if(a>b)return 1;if(a!=b){if(!h)return NaN;if(a==a)return 1;if(b==b)return-1}}if(d.length==0)return 0;var
g=d.pop();b=d.pop();a=d.pop();if(g+1<a.length)d.push(a,b,g+1);a=a[g];b=b[g];}}function
cn(a,b){return cY(a,b,true)}function
Z(a){if(a<0)bz("String.create");return new
aw(a?2:9,p,a)}function
g4(a,b){return+(cY(a,b,false)==0)}function
HN(a,c,b,d){if(b>0)if(c==0&&(b>=a.l||a.t==2&&b>=a.c.length))if(d==0){a.c=p;a.t=2;}else{a.c=bZ(b,String.fromCharCode(d));a.t=b==a.l?0:2;}else{if(a.t!=4)cZ(a);for(b+=c;c<b;c++)a.c[c]=d;}return 0}function
aL(a){ec(S.Failure,a);}function
bX(a){if((a.t&6)!=0)a$(a);return a.c}function
HO(a){var
b;a=bX(a);b=+a;if(a.length>0&&b===b)return b;a=a.replace(/_/g,p);b=+a;if(a.length>0&&b===b||/^[+-]?nan$/i.test(a))return b;var
c=/^ *([+-]?)0x([0-9a-f]+)\.?([0-9a-f]*)p([+-]?[0-9]+)/i.exec(a);if(c){var
d=c[3].replace(/0+$/,p),f=parseInt(c[1]+c[2]+d,16),e=(c[4]|0)-4*d.length;b=f*Math.pow(2,e);return b}if(/^\+?inf(inity)?$/i.test(a))return Infinity;if(/^-inf(inity)?$/i.test(a))return-Infinity;aL("float_of_string");}function
eb(d){d=bX(d);var
e=d.length;if(e>31)bz("format_int: format too long");var
a={justify:bt,signstyle:a6,filler:a7,alternate:false,base:0,signedconv:false,width:0,uppercase:false,sign:1,prec:-1,conv:"f"};for(var
c=0;c<e;c++){var
b=d.charAt(c);switch(b){case"-":a.justify=a6;break;case"+":case" ":a.signstyle=b;break;case"0":a.filler=aJ;break;case"#":a.alternate=true;break;case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":a.width=0;while(b=d.charCodeAt(c)-48,b>=0&&b<=9){a.width=a.width*10+b;c++;}c--;break;case".":a.prec=0;c++;while(b=d.charCodeAt(c)-48,b>=0&&b<=9){a.prec=a.prec*10+b;c++;}c--;case"d":case"i":a.signedconv=true;case"u":a.base=10;break;case"x":a.base=16;break;case"X":a.base=16;a.uppercase=true;break;case"o":a.base=8;break;case"e":case"f":case"g":a.signedconv=true;a.conv=b;break;case"E":case"F":case"G":a.signedconv=true;a.uppercase=true;a.conv=b.toLowerCase();break}}return a}function
d9(b,f){if(b.uppercase)f=f.toUpperCase();var
e=f.length;if(b.signedconv&&(b.sign<0||b.signstyle!=a6))e++;if(b.alternate){if(b.base==8)e+=1;if(b.base==16)e+=2;}var
c=p;if(b.justify==bt&&b.filler==a7)for(var
d=e;d<b.width;d++)c+=a7;if(b.signedconv)if(b.sign<0)c+=a6;else
if(b.signstyle!=a6)c+=b.signstyle;if(b.alternate&&b.base==8)c+=aJ;if(b.alternate&&b.base==16)c+=cG;if(b.justify==bt&&b.filler==aJ)for(var
d=e;d<b.width;d++)c+=aJ;c+=f;if(b.justify==a6)for(var
d=e;d<b.width;d++)c+=a7;return a(c)}function
HP(i,c){var
a,e=eb(i),d=e.prec<0?6:e.prec;if(c<0||c==0&&1/c==-Infinity){e.sign=-1;c=-c;}if(isNaN(c)){a=dT;e.filler=a7;}else
if(!isFinite(c)){a="inf";e.filler=a7;}else
switch(e.conv){case"e":var
a=c.toExponential(d),b=a.length;if(a.charAt(b-3)==cX)a=a.slice(0,b-1)+aJ+a.slice(b-1);break;case"f":a=c.toFixed(d);break;case"g":d=d?d:1;a=c.toExponential(d-1);var
h=a.indexOf(cX),g=+a.slice(h+1);if(g<-4||c>=1e+21||c.toFixed(0).length>d){var
b=h-1;while(a.charAt(b)==aJ)b--;if(a.charAt(b)==bO)b--;a=a.slice(0,b+1)+a.slice(h);b=a.length;if(a.charAt(b-3)==cX)a=a.slice(0,b-1)+aJ+a.slice(b-1);break}else{var
f=d;if(g<0){f-=g+1;a=c.toFixed(f);}else
while(a=c.toFixed(f),a.length>d+1)f--;if(f){var
b=a.length-1;while(a.charAt(b)==aJ)b--;if(a.charAt(b)==bO)b--;a=a.slice(0,b+1);}}break}return d9(e,a)}function
c0(e,c){if(bX(e)==gI)return a(p+c);var
b=eb(e);if(c<0)if(b.signedconv){b.sign=-1;c=-c;}else
c>>>=0;var
d=c.toString(b.base);if(b.prec>=0){b.filler=a7;var
f=b.prec-d.length;if(f>0)d=bZ(f,aJ)+d;}return d9(b,d)}var
In=0;function
a0(){return In++}function
HR(a,b){return+(cY(a,b,false)>=0)}if(!Math.imul)Math.imul=function(b,a){a|=0;return((b>>16)*a<<16)+(b&bg)*a|0};var
co=Math.imul;function
a1(b,a){a=co(a,3432918353|0);a=a<<15|a>>>32-15;a=co(a,461845907);b^=a;b=b<<13|b>>>32-13;return(b+(b<<2)|0)+(3864292196|0)|0}function
HV(b,a){var
d=a[1]|a[2]<<24,c=a[2]>>>8|a[3]<<16;b=a1(b,c^d);return b}var
IE=Math.log2&&Math.log2(1.12355820928894744e+307)==1020;function
ID(a){if(IE)return Math.floor(Math.log2(a));var
b=0;if(a==0)return-Infinity;if(a>=1)while(a>=2){a/=2;b++;}else
while(a<1){a*=2;b--;}return b}function
g5(a){if(!isFinite(a)){if(isNaN(a))return[K,1,0,gR];return a>0?[K,0,0,32752]:[K,0,0,gR]}var
f=a==0&&1/a==-Infinity?dC:a>=0?0:dC;if(f)a=-a;var
b=ID(a)+gY;if(b<=0){b=0;a/=Math.pow(2,-1026);}else{a/=Math.pow(2,b-1027);if(a<16){a*=2;b-=1;}if(b==0)a/=2;}var
d=Math.pow(2,24),c=a|0;a=(a-c)*d;var
e=a|0;a=(a-e)*d;var
g=a|0;c=c&15|f|b<<4;return[K,g,e,c]}function
HU(a,e){var
b=g5(e),d=b[1]|b[2]<<24,c=b[2]>>>8|b[3]<<16;a=a1(a,d);a=a1(a,c);return a}function
HX(d,b){var
e=b.length,a,c;for(a=0;a+4<=e;a+=4){c=b[a]|b[a+1]<<8|b[a+2]<<16|b[a+3]<<24;d=a1(d,c);}c=0;switch(e&3){case
3:c=b[a+2]<<16;case
2:c|=b[a+1]<<8;case
1:c|=b[a];d=a1(d,c);}d^=e;return d}function
HY(d,b){var
e=b.length,a,c;for(a=0;a+4<=e;a+=4){c=b.charCodeAt(a)|b.charCodeAt(a+1)<<8|b.charCodeAt(a+2)<<16|b.charCodeAt(a+3)<<24;d=a1(d,c);}c=0;switch(e&3){case
3:c=b.charCodeAt(a+2)<<16;case
2:c|=b.charCodeAt(a+1)<<8;case
1:c|=b.charCodeAt(a);d=a1(d,c);}d^=e;return d}function
HW(a,b){switch(b.t&6){default:a$(b);case
0:a=HY(a,b.c);break;case
2:a=HX(a,b.c);}return a}function
HT(a){a^=a>>>16;a=co(a,2246822507|0);a^=a>>>13;a=co(a,3266489909|0);a^=a>>>16;return a}var
g0=bw;function
HS(j,k,m,l){var
f,g,h,d,c,b,a,e,i;d=k;if(d<0||d>g0)d=g0;c=j;b=m;f=[l];g=0;h=1;while(g<h&&c>0){a=f[g++];if(a
instanceof
Array&&a[0]===(a[0]|0))switch(a[0]){case
248:b=a1(b,a[2]);c--;break;case
250:f[--g]=a[1];break;case
255:b=HV(b,a);c--;break;default:var
n=a.length-1<<10|a[0];b=a1(b,n);for(e=1,i=a.length;e<i;e++){if(h>=d)break;f[h++]=a[e];}break}else
if(a
instanceof
aw){b=HW(b,a);c--;}else
if(a===(a|0)){b=a1(b,a+a+1);c--;}else
if(a===+a){b=HU(b,a);c--;}}b=HT(b);return b&cH}function
H9(a){return[a[3]>>8,a[3]&K,a[2]>>16,a[2]>>8&K,a[2]&K,a[1]>>16,a[1]>>8&K,a[1]&K]}function
HZ(d,g,a){var
c=0;function
f(a){g--;if(d<0||g<0)return;if(a
instanceof
Array&&a[0]===(a[0]|0))switch(a[0]){case
248:d--;c=c*dI+a[2]|0;break;case
250:g++;f(a);break;case
255:d--;c=c*dI+a[1]+(a[2]<<24)|0;break;default:d--;c=c*19+a[0]|0;for(var
b=a.length-1;b>0;b--)f(a[b]);}else
if(a
instanceof
aw){d--;switch(a.t&6){default:a$(a);case
0:for(var
i=a.c,e=a.l,b=0;b<e;b++)c=c*19+i.charCodeAt(b)|0;break;case
2:for(var
h=a.c,e=a.l,b=0;b<e;b++)c=c*19+h[b]|0;}}else
if(a===(a|0)){d--;c=c*dI+a|0;}else
if(a===+a){d--;var
j=H9(g5(a));for(var
b=7;b>=0;b--)c=c*19+j[b]|0;}}f(a);return c&cH}function
IA(e){for(var
f=p,b=f,a,h,c=0,g=e.length;c<g;c++){a=e.charCodeAt(c);if(a<P){for(var
d=c+1;d<g&&(a=e.charCodeAt(d))<P;d++);if(d-c>f5){b.substr(0,1);f+=b;b=p;f+=e.slice(c,d);}else
b+=e.slice(c,d);if(d==g)break;c=d;}if(a<d2){b+=String.fromCharCode(cM|a>>6);b+=String.fromCharCode(P|a&63);}else
if(a<55296||a>=fL)b+=String.fromCharCode(cT|a>>12,P|a>>6&63,P|a&63);else
if(a>=56319||c+1==g||(h=e.charCodeAt(c+1))<fR||h>fL)b+="\xef\xbf\xbd";else{c++;a=(a<<10)+h-56613888;b+=String.fromCharCode(cQ|a>>18,P|a>>12&63,P|a>>6&63,P|a&63);}if(b.length>cm){b.substr(0,1);f+=b;b=p;}}return f+b}function
bk(a){var
b=9;if(!g_(a))b=8,a=IA(a);return new
aw(b,a,a.length)}function
H0(a,c,k){if(!isFinite(a)){if(isNaN(a))return bk(dT);return bk(a>0?gV:"-infinity")}var
i=a==0&&1/a==-Infinity?1:a>=0?0:1;if(i)a=-a;var
d=0;if(a==0);else
if(a<1)while(a<1&&d>-1022){a*=2;d--;}else
while(a>=2){a/=2;d++;}var
j=d<0?p:bt,e=p;if(i)e=a6;else
switch(k){case
43:e=bt;break;case
32:e=a7;break;default:break}if(c>=0&&c<13){var
g=Math.pow(2,c*4);a=Math.round(a*g)/g;}var
b=a.toString(16);if(c>=0){var
h=b.indexOf(bO);if(h<0)b+=bO+bZ(c,aJ);else{var
f=h+1+c;if(b.length<f)b+=bZ(f-b.length,aJ);else
b=b.substr(0,f);}}return bk(e+cG+b+"p"+j+d.toString(10))}function
H5(a){return(a[3]|a[2]|a[1])==0}function
c1(a){return[K,a&an,a>>24&an,a>>31&bg]}function
he(d){var
c=d.length,b=new
Array(c);for(var
a=0;a<c;a++)b[a]=d[a];return b}function
H8(a,b){var
c=a[1]-b[1],d=a[2]-b[2]+(c>>24),e=a[3]-b[3]+(d>>24);return[K,c&an,d&an,e&bg]}function
d$(a,b){if(a[3]>b[3])return 1;if(a[3]<b[3])return-1;if(a[2]>b[2])return 1;if(a[2]<b[2])return-1;if(a[1]>b[1])return 1;if(a[1]<b[1])return-1;return 0}function
g6(a){a[3]=a[3]<<1|a[2]>>23;a[2]=(a[2]<<1|a[1]>>23)&an;a[1]=a[1]<<1&an;}function
H6(a){a[1]=(a[1]>>>1|a[2]<<23)&an;a[2]=(a[2]>>>1|a[3]<<23)&an;a[3]=a[3]>>>1;}function
g9(e,f){var
c=0,b=he(e),a=he(f),d=[K,0,0,0];while(d$(b,a)>0){c++;g6(a);}while(c>=0){c--;g6(d);if(d$(b,a)>=0){d[1]++;b=H8(b,a);}H6(a);}return[0,d,b]}function
H_(a){return a[1]|a[2]<<24}function
H4(a){return a[3]<<16<0}function
g7(a){var
b=-a[1],c=-a[2]+(b>>24),d=-a[3]+(c>>24);return[K,b&an,c&an,d&bg]}function
H3(g,c){var
a=eb(g);if(a.signedconv&&H4(c)){a.sign=-1;c=g7(c);}var
b=p,h=c1(a.base),f="0123456789abcdef";do{var
e=g9(c,h);c=e[1];b=f.charAt(H_(e[2]))+b;}while(!H5(c));if(a.prec>=0){a.filler=a7;var
d=a.prec-b.length;if(d>0)b=bZ(d,aJ)+b;}return d9(a,b)}function
s(a){return a.l}function
ax(a,b){switch(a.t&6){default:if(b>=a.c.length)return 0;case
0:return a.c.charCodeAt(b);case
4:return a.c[b]}}function
H1(a,b){var
c=a[1]+b[1],d=a[2]+b[2]+(c>>24),e=a[3]+b[3]+(d>>24);return[K,c&an,d&an,e&bg]}var
g8=Math.pow(2,-24);function
H7(a,b){var
c=a[1]*b[1],d=(c*g8|0)+a[2]*b[1]+a[1]*b[2],e=(d*g8|0)+a[3]*b[1]+a[2]*b[2]+a[1]*b[3];return[K,c&an,d&an,e&bg]}function
ea(a,b){return d$(a,b)<0}function
hg(c){var
a=0,d=s(c),b=10,e=d>0&&ax(c,0)==45?(a++,-1):1;if(a+1<d&&ax(c,a)==48)switch(ax(c,a+1)){case
120:case
88:b=16;a+=2;break;case
111:case
79:b=8;a+=2;break;case
98:case
66:b=2;a+=2;break}return[a,e,b]}function
c7(a){if(a>=48&&a<=57)return a-48;if(a>=65&&a<=90)return a-55;if(a>=97&&a<=gE)return a-87;return-1}function
c2(f){var
e=hg(f),d=e[0],i=e[1],g=e[2],h=c1(g),j=g9([K,an,268435455,bg],h)[1],c=ax(f,d),a=c7(c);if(a<0||a>=g)aL(a9);var
b=c1(a);for(;;){d++;c=ax(f,d);if(c==95)continue;a=c7(c);if(a<0||a>=g)break;if(ea(j,b))aL(a9);a=c1(a);b=H1(H7(h,b),a);if(ea(b,a))aL(a9);}if(d!=s(f))aL(a9);if(e[2]==10&&ea([K,0,0,dC],b))aL(a9);if(i<0)b=g7(b);return b}function
c3(a){return(a[3]<<16)*Math.pow(2,32)+a[2]*Math.pow(2,24)+a[1]}function
c4(f){var
h=hg(f),c=h[0],i=h[1],d=h[2],g=s(f),j=-1>>>0,e=c<g?ax(f,c):0,b=c7(e);if(b<0||b>=d)aL(a9);var
a=b;for(c++;c<g;c++){e=ax(f,c);if(e==95)continue;b=c7(e);if(b<0||b>=d)break;a=d*a+b;if(a>j)aL(a9);}if(c!=g)aL(a9);a=i*a;if(d==10&&(a|0)!=a)aL(a9);return a|0}function
Ia(a){return c_(a,1,a.length-1)}function
Ib(a){return!!a}function
Ic(a){return a.toString()}function
Id(b){var
c={};for(var
a=1;a<b.length;a++){var
d=b[a];c[d[1].toString()]=d[2];}return c}function
ao(b){b=bX(b);var
d=b.length/2,c=new
Array(d);for(var
a=0;a<d;a++)c[a]=(b.charCodeAt(2*a)|b.charCodeAt(2*a+1)<<8)<<16>>16;return c}function
g2(a){if(a.t!=4)cZ(a);return a.c}function
Ie(b,t,a){var
n=2,o=3,r=5,d=6,h=7,g=8,j=9,m=1,l=2,q=3,s=4,p=5;if(!b.lex_default){b.lex_base=ao(b[m]);b.lex_backtrk=ao(b[l]);b.lex_check=ao(b[p]);b.lex_trans=ao(b[s]);b.lex_default=ao(b[q]);}var
e,c=t,k=g2(a[n]);if(c>=0){a[h]=a[r]=a[d];a[g]=-1;}else
c=-c-1;for(;;){var
f=b.lex_base[c];if(f<0)return-f-1;var
i=b.lex_backtrk[c];if(i>=0){a[h]=a[d];a[g]=i;}if(a[d]>=a[o])if(a[j]==0)return-c-1;else
e=bw;else{e=k[a[d]];a[d]++;}c=b.lex_check[f+e]==c?b.lex_trans[f+e]:b.lex_default[c];if(c<0){a[d]=a[h];if(a[g]==-1)aL(gb);else
return a[g]}else
if(e==bw)a[j]=0;}}function
ha(c){var
b=0;for(var
a=c.length-1;a>=0;a--){var
d=c[a];b=[0,d,b];}return b}function
bA(a,d){var
a=a+1|0,b=new
Array(a);b[0]=0;for(var
c=1;c<a;c++)b[c]=d;return b}function
hm(a){return new
aw(4,a,a.length)}var
Ig=function(){function
l(a,b){return a+b|0}function
a(d,a,c,f,b,e){a=l(l(a,d),l(f,e));return l(a<<b|a>>>32-b,c)}function
g(c,b,d,e,h,f,g){return a(b&d|~b&e,c,b,h,f,g)}function
h(d,b,e,c,h,f,g){return a(b&c|e&~c,d,b,h,f,g)}function
i(c,b,d,e,h,f,g){return a(b^d^e,c,b,h,f,g)}function
j(c,b,d,e,h,f,g){return a(d^(b|~e),c,b,h,f,g)}function
k(f,n){var
e=n;f[e>>2]|=P<<8*(e&3);for(e=(e&~3)+8;(e&63)<60;e+=4)f[(e>>2)-1]=0;f[(e>>2)-1]=n<<3;f[e>>2]=n>>29&536870911;var
k=[1732584193,4023233417,2562383102,271733878];for(e=0;e<f.length;e+=16){var
a=k[0],b=k[1],c=k[2],d=k[3];a=g(a,b,c,d,f[e+0],7,3614090360);d=g(d,a,b,c,f[e+1],12,3905402710);c=g(c,d,a,b,f[e+2],17,606105819);b=g(b,c,d,a,f[e+3],22,3250441966);a=g(a,b,c,d,f[e+4],7,4118548399);d=g(d,a,b,c,f[e+5],12,1200080426);c=g(c,d,a,b,f[e+6],17,2821735955);b=g(b,c,d,a,f[e+7],22,4249261313);a=g(a,b,c,d,f[e+8],7,1770035416);d=g(d,a,b,c,f[e+9],12,2336552879);c=g(c,d,a,b,f[e+10],17,4294925233);b=g(b,c,d,a,f[e+11],22,2304563134);a=g(a,b,c,d,f[e+12],7,1804603682);d=g(d,a,b,c,f[e+13],12,4254626195);c=g(c,d,a,b,f[e+14],17,2792965006);b=g(b,c,d,a,f[e+15],22,1236535329);a=h(a,b,c,d,f[e+1],5,4129170786);d=h(d,a,b,c,f[e+6],9,3225465664);c=h(c,d,a,b,f[e+11],14,643717713);b=h(b,c,d,a,f[e+0],20,3921069994);a=h(a,b,c,d,f[e+5],5,3593408605);d=h(d,a,b,c,f[e+10],9,38016083);c=h(c,d,a,b,f[e+15],14,3634488961);b=h(b,c,d,a,f[e+4],20,3889429448);a=h(a,b,c,d,f[e+9],5,568446438);d=h(d,a,b,c,f[e+14],9,3275163606);c=h(c,d,a,b,f[e+3],14,4107603335);b=h(b,c,d,a,f[e+8],20,1163531501);a=h(a,b,c,d,f[e+13],5,2850285829);d=h(d,a,b,c,f[e+2],9,4243563512);c=h(c,d,a,b,f[e+7],14,1735328473);b=h(b,c,d,a,f[e+12],20,2368359562);a=i(a,b,c,d,f[e+5],4,4294588738);d=i(d,a,b,c,f[e+8],11,2272392833);c=i(c,d,a,b,f[e+11],16,1839030562);b=i(b,c,d,a,f[e+14],23,4259657740);a=i(a,b,c,d,f[e+1],4,2763975236);d=i(d,a,b,c,f[e+4],11,1272893353);c=i(c,d,a,b,f[e+7],16,4139469664);b=i(b,c,d,a,f[e+10],23,3200236656);a=i(a,b,c,d,f[e+13],4,681279174);d=i(d,a,b,c,f[e+0],11,3936430074);c=i(c,d,a,b,f[e+3],16,3572445317);b=i(b,c,d,a,f[e+6],23,76029189);a=i(a,b,c,d,f[e+9],4,3654602809);d=i(d,a,b,c,f[e+12],11,3873151461);c=i(c,d,a,b,f[e+15],16,530742520);b=i(b,c,d,a,f[e+2],23,3299628645);a=j(a,b,c,d,f[e+0],6,4096336452);d=j(d,a,b,c,f[e+7],10,1126891415);c=j(c,d,a,b,f[e+14],15,2878612391);b=j(b,c,d,a,f[e+5],21,4237533241);a=j(a,b,c,d,f[e+12],6,1700485571);d=j(d,a,b,c,f[e+3],10,2399980690);c=j(c,d,a,b,f[e+10],15,4293915773);b=j(b,c,d,a,f[e+1],21,2240044497);a=j(a,b,c,d,f[e+8],6,1873313359);d=j(d,a,b,c,f[e+15],10,4264355552);c=j(c,d,a,b,f[e+6],15,2734768916);b=j(b,c,d,a,f[e+13],21,1309151649);a=j(a,b,c,d,f[e+4],6,4149444226);d=j(d,a,b,c,f[e+11],10,3174756917);c=j(c,d,a,b,f[e+2],15,718787259);b=j(b,c,d,a,f[e+9],21,3951481745);k[0]=l(a,k[0]);k[1]=l(b,k[1]);k[2]=l(c,k[2]);k[3]=l(d,k[3]);}var
o=new
Array(16);for(var
e=0;e<4;e++)for(var
m=0;m<4;m++)o[e*4+m]=k[e]>>8*m&K;return o}return function(h,g,f){var
e=[];switch(h.t&6){default:a$(h);case
0:var
d=h.c;for(var
a=0;a<f;a+=4){var
b=a+g;e[a>>2]=d.charCodeAt(b)|d.charCodeAt(b+1)<<8|d.charCodeAt(b+2)<<16|d.charCodeAt(b+3)<<24;}for(;a<f;a++)e[a>>2]|=d.charCodeAt(a+g)<<8*(a&3);break;case
4:var
c=h.c;for(var
a=0;a<f;a+=4){var
b=a+g;e[a>>2]=c[b]|c[b+1]<<8|c[b+2]<<16|c[b+3]<<24;}for(;a<f;a++)e[a>>2]|=c[a+g]<<8*(a&3);}return hm(k(e,f))}}();function
a2(a){ec(S.Sys_error,a);}function
Ih(a){if(!a.opened)a2("Cannot flush a closed channel");if(a.buffer==p)return 0;if(a.output)switch(a.output.length){case
2:a.output(a,a.buffer);break;default:a.output(a.buffer);}a.buffer=p;return 0}var
hn=0;function
IG(){return new
Date().getTime()/gq}function
ee(){return Math.floor(IG())}function
bi(b){this.data=b;this.inode=hn++;var
a=ee();this.atime=a;this.mtime=a;this.ctime=a;}bi.prototype={truncate:function(){this.data=Z(0);this.modified();},modified:function(){var
a=ee();this.atime=a;this.mtime=a;}};var
HM=ci;function
by(){this.content={};this.inode=hn++;var
a=ee();this.atime=a;this.mtime=a;this.ctime=a;}by.prototype={exists:function(a){return this.content[a]?1:0},mk:function(b,a){this.content[b]=a;},get:function(a){return this.content[a]},list:function(){var
a=[];for(var
b
in
this.content)a.push(b);return a},remove:function(a){delete
this.content[a];}};var
c8=new
by();c8.mk(p,new
by());function
cq(c,d,a){if(S.fds===undefined)S.fds=new
Array();a=a?a:{};var
b={};b.file=d;b.offset=a.append?s(d.data):0;b.flags=a;S.fds[c]=b;S.fd_last_idx=c;return c}cq(0,new
bi(Z(0)));cq(1,new
bi(Z(0)));cq(2,new
bi(Z(0)));function
Ii(b){var
a=S.fds[b];if(a.flags.wronly)a2(f2+b+" is writeonly");return{file:a.file,offset:a.offset,fd:b,opened:true,refill:null}}function
IB(a){var
b=aQ;if(b.process&&b.process.stdout&&b.process.stdout.write)b.process.stderr.write(a);else{if(a.charCodeAt(a.length-1)==10)a=a.substr(0,a.length-1);var
c=b.console;c&&c.error&&c.error(a);}}function
IC(a){var
b=aQ;if(b.process&&b.process.stdout&&b.process.stdout.write)b.process.stdout.write(a);else{if(a.charCodeAt(a.length-1)==10)a=a.substr(0,a.length-1);var
c=b.console;c&&c.log&&c.log(a);}}var
c6=new
Array();function
Ir(b,h){var
g=a(h),c=s(g),f=s(b.file.data),e=b.offset;if(e+c>=f){var
d=Z(e+c);aA(b.file.data,0,d,0,f);aA(g,0,d,e,c);b.file.data=d;}b.offset+=c;b.file.modified();return 0}function
hb(a){var
b;switch(a){case
1:b=IC;break;case
2:b=IB;break;default:b=Ir;}var
d=S.fds[a];if(d.flags.rdonly)a2(f2+a+" is readonly");var
c={file:d.file,offset:d.offset,fd:a,opened:true,buffer:p,output:b};c6[c.fd]=c;return c}function
Ij(){var
a=0;for(var
b
in
c6)if(c6[b].opened)a=[0,c6[b],a];return a}function
hh(a){throw a}function
Ip(){hh(S.Division_by_zero);}function
hc(b,a){if(a==0)Ip();return b%a}function
If(d,a,c,f){for(;;){var
b=d.charCodeAt(a);a++;if(b==K)return;var
e=d.charCodeAt(a);a++;c[b+1]=e==K?f:c[e+1];}}function
g$(d,a,c){for(;;){var
b=d.charCodeAt(a);a++;if(b==K)return;var
e=d.charCodeAt(a);a++;c[b+1]=e==K?-1:c[e+1];}}function
Il(a,D,b){var
t=2,u=3,A=5,e=6,i=7,h=8,n=9,j=10,r=1,p=2,y=3,B=4,v=5,s=6,q=7,z=8,C=9,w=10,x=11;if(!a.lex_default){a.lex_base=ao(a[r]);a.lex_backtrk=ao(a[p]);a.lex_check=ao(a[v]);a.lex_trans=ao(a[B]);a.lex_default=ao(a[y]);}if(!a.lex_default_code){a.lex_base_code=ao(a[s]);a.lex_backtrk_code=ao(a[q]);a.lex_check_code=ao(a[w]);a.lex_trans_code=ao(a[C]);a.lex_default_code=ao(a[z]);}if(a.lex_code==null)a.lex_code=bX(a[x]);var
d,c=D,o=g2(b[t]);if(c>=0){b[i]=b[A]=b[e];b[h]=-1;}else
c=-c-1;for(;;){var
g=a.lex_base[c];if(g<0){var
f=a.lex_base_code[c];g$(a.lex_code,f,b[j]);return-g-1}var
l=a.lex_backtrk[c];if(l>=0){var
f=a.lex_backtrk_code[c];g$(a.lex_code,f,b[j]);b[i]=b[e];b[h]=l;}if(b[e]>=b[u])if(b[n]==0)return-c-1;else
d=bw;else{d=o[b[e]];b[e]++;}var
k=c;c=a.lex_check[g+d]==c?a.lex_trans[g+d]:a.lex_default[c];if(c<0){b[e]=b[i];if(b[h]==-1)aL(gb);else
return b[h]}else{var
m=a.lex_base_code[k],f;f=a.lex_check_code[m+d]==k?a.lex_trans_code[m+d]:a.lex_default_code[k];if(f>0)If(a.lex_code,f,b[j],b[e]);if(d==bw)b[n]=0;}}}function
bY(a,b){return+(cY(a,b,false)!=0)}function
Im(b,a){b[0]=a;return 0}function
hf(a){return a
instanceof
Array?a[0]:a
instanceof
aw?f$:gq}function
aM(c,b,a){S[c+1]=b;if(a)S[a]=b;}var
hd={};function
Iq(a,b){hd[bX(a)]=b;return 0}function
ai(a,b){a.t&6&&a$(a);b.t&6&&a$(b);return a.c==b.c?1:0}function
hl(){bz(fT);}function
_(b,a){if(a>>>0>=b.l)hl();return ax(b,a)}function
c(a,b){return 1-ai(a,b)}function
Q(a,c,b){b&=K;if(a.t!=4){if(c==a.c.length){a.c+=String.fromCharCode(b);if(c+1==a.l)a.t=0;return 0}cZ(a);}a.c[c]=b;return 0}function
cp(b,a,c){if(a>>>0>=b.l)hl();return Q(b,a,c)}function
Is(){return 2147483647/4|0}function
It(){return 0}function
Iv(){return[0,a(fr),32,0]}function
Io(){hh(S.Not_found);}function
c9(c){var
a=aQ,b=c.toString();if(a.process&&a.process.env&&a.process.env[b]!=undefined)return bk(a.process.env[b]);Io();}function
Ix(){var
a=new
Date()^4294967295*Math.random();return[0,a]}function
hk(a){return a}function
Ik(a){return hd[a]}function
aj(a){if(a
instanceof
Array)return a;if(aQ.RangeError&&a
instanceof
aQ.RangeError&&a.message&&a.message.match(/maximum call stack/i))return hk(S.Stack_overflow);if(aQ.InternalError&&a
instanceof
aQ.InternalError&&a.message&&a.message.match(/too much recursion/i))return hk(S.Stack_overflow);if(a
instanceof
aQ.Error)return[0,Ik(ft),a];return[0,S.Failure,bk(String(a))]}function
b(a,b){return a.length==1?a(b):bj(a,[b])}function
f(a,b,c){return a.length==2?a(b,c):bj(a,[b,c])}function
u(a,b,c,d){return a.length==3?a(b,c,d):bj(a,[b,c,d])}function
bs(a,b,c,d,e){return a.length==4?a(b,c,d,e):bj(a,[b,c,d,e])}function
cc(a,b,c,d,e,f){return a.length==5?a(b,c,d,e,f):bj(a,[b,c,d,e,f])}var
c$=[W,a(gm),-3],ef=[W,a(gz),-4],ah=[W,a(gC),-7],t=[W,a(gP),-11],en=[0,a(p),1,0,0],dk=[0,0,0],as=[0,a('\0\0\xb2\xff\xb3\xff\xb9\xffB\0C\0T\0W\0F\0I\0J\0K\0M\0e\0\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff\xe5\xff\xe6\xff\xe7\xff\xe8\xff\xc0\0L\0e\0\x17\x01n\x01\xf6\xff\xf7\xffl\0u\0v\0\0\0\x0e\0\x0f\0\x07\x003\x01\xfe\xff\xff\xff\x01\0\x12\0(\0\f\0\x15\0*\0\f\0=\0-\0\t\0\xb6\xff\xf9\xff\xe0\x01B\0u\0\x0f\x000\x004\0\x17\0\xe5\x01(\x008\0\x1a\0K\0:\0\x17\0\xfb\xffh\0a\0\xac\0q\0m\0y\0q\0i\0{\0{\0\xa8\0\xca\xff\xfa\xff\xc9\xff\xf8\xff\x0b\x02\xa5\x02\xfc\x02S\x03\xaa\x03\x01\x04X\x04\xaf\x04\x06\x05]\x05\xb4\x05\x0b\x06b\x06\xb9\x06\xc3\x01\x10\x07g\x07\xbe\x07\x15\bl\b\xc3\b\x1a\tq\t\xc8\t\xb8\0\xe2\xffE\x02\xc7\xff\xdc\xff\xc6\xff\xdb\xff\xb7\xff\xaa\0\xda\xff\xab\0\xd9\xff\xac\0\xd8\xff\xd2\xff\xad\0\xd7\xff\xb0\0\xd0\xff\xcf\xff\xcc\xff\xd4\xff\xcb\xff\xd3\xff\xc8\xff\xc5\xff:\n\xcc\xff\xcd\xff\xcf\xff\xd3\xff\xb0\0\xd9\xff\xda\xff\xdd\xff\xde\xff\xdf\xff\xe0\xff\xe3\xff\xe4\xff~\0\xe7\xff\x80\0\xe9\xff\xea\xff\x9a\0\x94\n\xfa\n\xd6\x01Q\x0b\xa8\x0b\x1a\f\xf9\xff\xcf\0\xf1\0D\0\x9c\0\x9d\0\xa3\0\xc4\x0b\xff\xff\x83\0\xc1\0\xd1\0\xf9\0\xb4\0\xc4\0\xa7\0\xcb\t\xd4\0\x96\0\xfa\xff\x1f\f\xea\0\x1d\x01\xb7\0\xf3\0\xf4\0\xfa\0$\f\xe9\0\x15\x01\xf7\0\xdf\x0b\x17\x01\xd9\0\xfc\xff,\x01&\x01{\x01@\x01<\x01H\x01@\x018\x01J\x01d\x01\xfb\xff\xf3\x01\x0f\x01K\x01j\x01c\x01K\f>\x01N\x01P\x01\xec\x0bp\x01?\x01x\f\xff\fV\r\xad\r\0\x02\x04\x0e[\x0e\xb2\x0e\t\x0f`\x0f\xb7\x0f\x0e\x10e\x10\xbc\x10\x13\x11j\x11\xc1\x11\x18\x12o\x12\xc6\x12\x1d\x13t\x13\xcb\x13"\x14\xd1\x01\xe2\xffy\x14\xd0\x14\'\x15~\x15\x99\x01\x9d\x01\xad\x01\xa6\x01\x9f\x01\xeb\xff\xe6\xff\xe5\xff\xd1\xff\x1b\f\xfc\xff\xfd\xff\xfe\xff\xff\xff\xcf\x15\xee\xff\x01\0\xef\xff\x18\x16\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xf9\xff\xf1\x02H\x03>\x16\xfe\xff\xff\xffU\x16\xfd\xff\x9f\x03\xfc\xff{\x16\x92\x16\xb8\x16\xcf\x16\xf2\xff\xf5\x16\xf1\xff\xd7\x02\xfb\xff\xea\x01\xfe\xff\xff\xff\xe4\x01\xfd\xff\xfc\xff;\x02\xfd\xff\xfe\xff\xff\xff\0\x17\xf9\xff\xee\x01`\x01\x9c\x01\xa0\x01*\x02)\fC\x15\xfe\xff\xff\xffc\x01\xad\x01\xc7\x01+\x02\xa0\x01\xba\x01\xaa\x01\x87\x15\xca\x01\xa7\x01\xfb\xff\xfc\xff\x0b\x16\xf8\xff\x04\0\xf9\xff\xfa\xff8\x17,\x03\xff\xff\xfd\xff\x05\0\xfe\xff\xc0\x17\x96\t\xfb\xff\xfc\xff\x0b\x02\xff\xff\xfd\xff\xfe\xff2\x18\xf1\xff\xf2\xff\x8a\x18\xf4\xff\xf5\xff\xf6\xff\xf7\xff\xf8\xff\xfa\xffv\x02\xb0\x01!\x02"\x023\x02\x88\x167\x18\xfe\xff\xff\xff\x05\x02L\x02_\x02\xf3\x02@\x02Q\x02C\x02\xbd\x16c\x02%\x02\xfb\xff\xfc\xff|\f\xfb\xff\xfc\xff\xfd\xff\xfe\xff\x06\0\xff\xff\xfc\x18\xf9\xff\xf8\x18\x07\0\xfd\xff\xfe\xff\xff\xffO\x19\xdf\n_\f\x84\x17\x9c\x19\xfc\xff\xfb\xff\xd3\x19\xfa\xff*\x1a\x81\x1a\xd8\x1a/\x1b\x86\x1b\xaa\x02\xf8\x1b\xfa\xff\xfb\xff\xd6\x02G\x02\x83\x02\xa9\x02J\x03\x04\x19K\x1b\xff\xffp\x02\xb7\x02\xd7\x02\x8d\x03\xaa\x02\xba\x02\x9d\x02\xc9\x16\xd9\x02\x9b\x02\xfc\xff\xfd\xff\xc3\x16\xf9\xff\xfa\xff\b\0\xfc\xff\xe1\x02\xfe\xff\xff\xff\xfd\xff\xfb\xff'),a("\xff\xff\xff\xff\xff\xff\xff\xffD\0A\0>\0=\0<\0;\0E\0G\0B\0C\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x16\0K\0\x1e\0\x15\0\x15\0\xff\xff\xff\xffM\0?\0J\0M\0M\0M\0M\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x03\0\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff@\0\xff\xff\xff\xff\xff\xff\xff\xff\x14\0\x14\0\x15\0\x14\0\x0f\0\x14\0\x14\0\x0b\0\n\0\r\0\f\0\x0e\0\x0e\0\x0e\0\xff\xff\x0e\0\x0e\0\x13\0\x12\0\x11\0\x10\0\x15\0\x13\0\x12\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff)\0\xff\xff*\0\xff\xff.\0\xff\xff\xff\xff2\0\xff\xff1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff'\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff+\0\xff\xff\x17\0\xff\xff\xff\xff3\0\x13\0\x13\0\x1e\0\x12\0\x12\x001\0\xff\xff)\x003\x003\x003\x003\x003\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x02\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\0\x11\0\x11\0\x10\0\xff\xff\x10\0\x0f\0\x0f\0\x12\0\x11\0\f\0\x11\0\x11\0\b\0\x07\0\n\0\t\0\x0b\0\x0b\0\x0b\0\x0b\0\x0b\0\x0e\0\r\0\xff\xff\xff\xff\x13\0\x13\0\x13\0\x13\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x10\0\xff\xff\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\x05\0\x0f\0\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x06\0\x06\0\x06\0\x06\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\xff\xff\xff\xff\x04\0\x07\0\xff\xff\xff\xff\x01\0\xff\xff\x03\0\xff\xff\xff\xff\xff\xff\x04\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x06\0\x0e\0\x0e\0\x0e\0\x0e\0\x02\0\x01\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\x06\0\x02\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\x05\0\x05\0\x05\0\x05\0\x01\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\0\xff\xff\x06\0\xff\xff\xff\xff\xff\xff\xff\xff"),a("\x01\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x86\0\0\0\0\0\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\x01\x01\0\0\0\0\0\0\0\0\x06\x01\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\0\0!\x01\0\0\xff\xff\0\0\0\0\xff\xff\0\0\0\0)\x01\0\0\0\0\0\0-\x01\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0D\x01\0\0\xff\xff\0\0\0\0\xff\xffK\x01\0\0\0\0\xff\xff\0\0\xff\xffP\x01\0\0\0\0\xff\xff\0\0\0\0\0\0W\x01\0\0\0\0\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0v\x01\0\0\0\0\0\0\0\0\xff\xff\0\0}\x01\0\0\xff\xff\xff\xff\0\0\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x93\x01\0\0\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\xaa\x01\0\0\0\0\xff\xff\0\0\xff\xff\0\0\0\0\0\0\0\0"),a("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0(\0\b\x01&\0&\0F\x01M\x01{\x01\x80\x01\xb2\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0&\0\n\0\x1e\0\x1f\0\x18\0\x05\0\r\0\x1e\0\x15\0\x14\0 \0\x07\0\x10\0\x06\0\x1a\0!\0\x1c\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x0f\0\x11\0\t\0\x0b\0\b\0\x0e\0\x19\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x13\0'\0\x12\0\x04\0\x18\0\x1d\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x17\0\f\0\x16\0\x03\0\x84\0\x83\0\x82\0\x80\0{\0z\0w\0x\0u\0s\0r\0p\0o\0m\0R\x001\x000\0/\0\x81\x001\0k\0\x7f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0N\x005\0.\0n\0&\0P\x004\0.\0-\x000\0/\0&\0&\0-\0&\0D\0C\0A\0>\0O\x003\0@\0?\0<\0=\0<\0<\0<\x002\x002\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0&\0q\0B\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0<\0E\0F\0G\0H\0I\0J\0K\0L\0M\0C\0%\0$\0#\0\x18\0Q\0l\0t\0v\0y\0}\0|\0&\0~\0\xff\0\"\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0<\0\xfe\0\xfd\0\xf7\0\xcc\0\xb1\0\x02\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xb3\0\xb0\0\xaf\0\xae\0\x18\0\xb2\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0S\0&\0\xad\0\xb1\0&\0&\0\xb0\0\xa6\0\xac\0\xa6\0U\0\xa6\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaf\0\xae\0&\0\xa6\0\xa6\0\xc2\0\xc1\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xc0\0\xbf\0\xbe\0\xbd\0S\0\xba\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xad\0\xbc\0\xba\0\xba\0\xba\0\xba\0\xac\0\xbb\0\xc3\0U\0\xc4\0W\0W\0W\0W\0W\0W\0W\0W\0\x1b\0\x1b\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\xcb\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0\xc1\0\xd8\0\xd7\0\xd2\0S\0\xd2\0S\0Y\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0X\0S\0S\0S\0S\0S\0S\0S\0S\0V\0S\0S\0<\0\xd6\0\xd5\0<\0<\0<\0\xd2\0\xd2\0<\0<\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xd4\0\xd2\0\xf2\0<\0\xf8\0\xf9\0\xd3\0\xf1\0<\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xfa\0\xfb\0\xfc\0'\x01,\0+\0*\0%\x01A\x01&\x017\0@\x01?\x01B\x01@\x017\0>\x01=\x01)\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0?\x013\x01S\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\x003\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0*\x016\0>\x01=\x013\x013\x016\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\x003\x01U\x01T\x01\x18\0S\0r\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0s\x01q\x01p\x01o\x01\x18\0t\x01\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0r\x01;\0:\x009\0<\x01<\x01;\0:\x009\0S\0;\x01;\x01q\x01n\x01e\x018\0a\0e\x01a\0m\x018\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0p\x01o\x01#\x01e\x01e\x01e\x01\x8b\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa7\x01\"\x01\xa6\x01\xa5\x01S\0\xa8\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\xa4\x01\xa3\x01\xa6\x01h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0M\x01\xa5\x01\x9a\x01L\x01\x9a\x01+\x01\x9a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\xa4\x01\xa3\x01\x9a\x01\x9a\x01S\0\xb1\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0n\x01\0\0\0\0\0\0\0\0\0\0m\x01f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0f\0f\0f\0f\0f\0f\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0_\0\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01\x18\x01$\x01U\0\0\0W\0W\0W\0W\0W\0W\0W\0W\0^\0^\0\xa2\x01\0\0\0\0\0\0\0\0\0\0\xa1\x01_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0S\0\0\0\xa2\x01\0\0\0\0\0\0\0\0\xff\xff\xa1\x01\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Z\0Z\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\0\0\0\0\0\0\0\0[\0\0\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\0\0\0\0\0\0\0\0]\0\0\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0U\0\0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0`\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0\0\0\0\0a\0\0\0a\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\0\0\0\0\0\0\0\0_\0\0\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\0\0\0\0\0\0\0\0c\0\0\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0e\0\0\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0f\0f\0f\0f\0f\0f\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\0\0\0\0\0\0\0\0g\0\0\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0S\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0\0\0\0\0\0\0\0\0S\0\0\0S\0S\0S\0S\0T\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0R\x01Q\x01\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\0\0\0\0\0\0\0\0j\0\0\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xa6\0\xa7\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xa6\0\0\0\x9f\0\0\0\x99\0\x98\0\x89\0\x9f\0\x92\0\x91\0\xa0\0\x88\0\x8f\0\x9e\0\x9b\0\xa1\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x8e\0\x90\0\x8c\0\x8a\0\x8b\0\x8d\0\xa6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x97\0S\x01\x96\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9a\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x95\0\x93\0\x94\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\0\0\xa5\0\xa4\0\xa3\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xa2\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x87\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\x86\x01\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf3\0\x99\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xa6\0\0\0\0\0\xa6\0\xa6\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\x9c\0\x9c\0\0\0\0\0\xa6\0\0\0\0\0\0\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xe5\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe4\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe2\0\xda\0\xda\0\xd2\0\0\0\x02\x01\xd2\0\xd2\0\xba\0\0\0\0\0\xba\0\xba\0\xba\0\0\0\0\0\xba\0\xba\x003\x01\0\0\0\x003\x013\x01\0\0\0\0\0\0\xd2\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\x04\x01\0\0\xba\0\0\0\0\0\0\0\xcd\x003\x01\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xd2\0\0\0\0\0\xd2\0\xd2\0\xb5\0\0\0\0\0\0\0\0\0\xb5\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\xba\0\0\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\x03\x01\0\0\xcd\0\0\0\x9d\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xb4\0{\x01\0\0\0\0z\x01\xb4\0\0\0\0\0\0\0\xba\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\0\0\x89\x01\xd2\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xab\0\xaa\0\xa9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\xa8\0\0\0\0\0\0\0\0\0x\x01\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0w\x01\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\0\0\xb9\0\xb8\0\xb7\0\0\0\xce\0:\x019\x018\x01\0\0\xb6\0\0\0\0\0\0\0\0\0\xb6\0\0\0\0\0\0\0\0\x007\x01\0\0\0\0\x02\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd1\0\xd0\0\xcf\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\xce\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0y\x01\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\0\0\0\0\0\0\0\0\xdf\0\0\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\0\0\0\0\0\0\0\0\xe0\0\0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\0\0\0\0\0\0\0\0\xda\0\0\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe6\0\xe6\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\0\0\0\0\0\0\0\0\xe7\0\0\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\0\0\0\0\0\0\0\0\xe9\0\0\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xe1\0\0\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\xdd\0\0\0\xdd\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\0\0\0\0\0\0\0\0\xeb\0\0\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\0\0\0\0\0\0\0\0\xee\0\0\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\0\0\0\0\0\0\0\0\xf0\0\0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf4\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\xf5\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\x003\x015\x01\0\x003\x013\x01\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\x003\x01\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xf6\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\b\x01\0\0\0\0\x07\x01\x99\0\0\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\0\0\0\0\0\0\0\0\0\0\0\0\x11\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x013\x01\0\0\0\0\0\0F\x01\0\0\0\0E\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0:\x019\x018\x01\0\0\0\0\0\0\0\0\x13\x01\0\0\0\0\0\0\0\0\0\0\x0f\x017\x01\0\0\0\0\x0e\x013\x01\0\0\0\0\0\0H\x01\0\0\0\0\r\x01\0\0\0\0\0\0\f\x01\0\0\x0b\x01\t\x01\n\x01\0\0\x12\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0G\x01I\x01\0\0\0\0\0\0\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0e\x01\0\0\x19\x01e\x01e\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\0\0\0\0\0\0\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\0\0\0\0\0\0e\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x16\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\xab\x01\0\0\x14\x01\xac\x01\0\0\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\0\0\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0\0\0\0\0\0\0\0\0\xae\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\0\0\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x013\x015\x01J\x013\x014\x01\0\0\0\0\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\0\0\0\0\0\0\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xad\x013\x01\0\0\0\0\xaf\x01\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01.\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1d\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\0\0e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01e\x01\0\0\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\x9a\x01\0\0\0\0\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01N\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0l\x01k\x01j\x01e\x01\0\0\0\0\0\0\0\0\0\0\x1f\x01\0\0\0\0\0\0\0\0i\x01\x9a\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\xb0\x01\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\x011\x010\x01N\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\0\0\0\0/\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x006\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\0\0\0\0\0\0\0\0N\x01\0\0N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01e\x01g\x01\0\0e\x01f\x01e\x01g\x01\0\0e\x01e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0e\x01\0\0X\x01\0\0Y\x01e\x01\0\0X\x01\0\0\0\0\0\0\0\0\0\0\0\0[\x01`\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\\\x01\0\0_\x01Z\x01^\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01]\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\0\0\0\0\0\0Y\x01\0\0Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\0\0\x80\x01\0\0\0\0\x7f\x01\0\0\0\0\0\0\x9a\x01\0\0\0\0\x9a\x01\x9a\x01\0\0d\x01c\x01b\x01\0\0\0\0l\x01k\x01j\x01\x84\x01\x83\x01\0\0\x82\x01\0\0\0\0a\x01~\x01\x82\x01\x9a\x01\0\0i\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01h\x01\0\0\0\0\0\0\0\0\0\0\x82\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\0\0\0\0\0\0\0\0\x83\x01\0\0\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x8a\x01\0\0\0\0\0\0\x82\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\0\0\0\0\x8a\x01\0\0\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\x88\x01\0\0\0\0\0\0\0\0\0\0\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\x8c\x01\0\0\0\0\0\0\0\0\x81\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\0\0\0\0\0\0\0\0\x8c\x01\0\0\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\0\0\0\0\0\0\0\0\x8d\x01\0\0\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\0\0\0\0\0\0\0\0\x8e\x01\0\0\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\0\0\0\0\0\0\0\0\x8f\x01\0\0\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\x8b\x01\x9a\x01\0\0\0\0\0\0\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\0\0\0\0\0\0\0\0\x90\x01\0\0\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x91\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\x8b\x01\0\0\0\0\0\0\0\0\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\0\0\0\0\0\0\0\0\x91\x01\0\0\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x91\x01\x9a\x01\x9c\x01\0\0\x9a\x01\x9b\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9a\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x95\x01\0\0\0\0\0\0\0\0\xa0\x01\x9f\x01\x9e\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x9d\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x94\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x99\x01\x98\x01\x97\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x96\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\xff\xff"),a('\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\x07\x01\0\0\0\0E\x01L\x01z\x01\x7f\x01\xac\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\0\x05\0\x06\0\x07\0\b\0\b\0\t\0\t\0\n\0\x0b\0\x0b\0\f\0\r\0\x19\0\x1f\0#\0$\0$\0\x06\0*\0\x1a\0\x07\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0 \0!\0%\0\r\0-\0 \0!\0,\0%\0+\0+\0.\0/\0,\x001\x006\x007\x009\0;\0 \0!\0:\0:\0=\0;\0>\0?\0A\0"\0)\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x000\x002\0\f\x008\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0B\0D\0E\0F\0G\0H\0I\0J\0K\0L\0M\0\0\0\0\0\0\0\x18\0N\0k\0s\0u\0w\0z\0z\x000\0|\0\x8a\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0@\0\x93\0\x95\0\x98\0\xa0\0\xa2\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\xa1\0\xa3\0\xa4\0\xa4\0\x18\0\xa1\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x1b\0&\0\xa5\0\xa8\0&\0&\0\xa9\0\xac\0\xa5\0\xad\0\x1b\0\xae\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xaa\0\xaa\0&\0\xb0\0\xb1\0\xb4\0\xb5\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\xb6\0\xb7\0\xb8\0\xb8\0\x1b\0\xbb\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xab\0\xb9\0\xbc\0\xbd\0\xbf\0\xc0\0\xab\0\xb9\0\xc2\0\x1c\0\xc3\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xc4\0\xc5\0\xc6\0\xc7\0\xc8\0\xc9\0\xca\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\xcb\0\xce\0\xcf\0\xd3\0\x1c\0\xd4\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\x005\0\xd0\0\xd0\x005\x005\0<\0\xd5\0\xd7\0<\0<\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0\xd1\0\xd8\0\xf1\x005\0\xf7\0\xf8\0\xd1\0\x9b\0<\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\xf9\0\xfa\0\xfb\0%\x01&\0&\0&\0"\x01.\x01"\x015\0/\x010\x01.\x017\x01<\x001\x011\x01&\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\x008\x01;\x01S\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0<\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0(\x015\x009\x019\x01=\x01?\x01<\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0@\x01R\x01R\x01m\0S\0a\x01S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0S\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0`\x01b\x01c\x01c\x01m\0`\x01m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0m\0i\x015\x005\x005\x002\x01:\x01<\0<\0<\0T\x002\x01:\x01j\x01d\x01m\x015\0T\0n\x01T\0d\x01<\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0k\x01k\x01 \x01o\x01q\x01r\x01\x91\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0\x95\x01 \x01\x96\x01\x97\x01T\0\x95\x01T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x10\x01\x98\x01\x98\x01\x9d\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0I\x01\x9e\x01\xa1\x01I\x01\xa2\x01(\x01\xa3\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0\x9f\x01\x9f\x01\xa5\x01\xa6\x01U\0\xae\x01U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0V\0\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\x11\x01\xff\xff\xff\xff\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0l\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffl\x01V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xff\xff\xff\xff\xff\xff\xff\xffV\0\xff\xffV\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0W\0\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01\x17\x01 \x01W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\x99\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\x01W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0\xff\xff\xff\xff\xff\xff\xff\xffW\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0W\0X\0\xff\xff\xa0\x01\xff\xff\xff\xff\xff\xff\xff\xffI\x01\xa0\x01\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0\xff\xff\xff\xff\xff\xff\xff\xffX\0\xff\xffX\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0X\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0\xff\xff\xff\xff\xff\xff\xff\xffY\0\xff\xffY\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Y\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0\xff\xff\xff\xff\xff\xff\xff\xffZ\0\xff\xffZ\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0Z\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\xff\xff\xff\xff\xff\xff\xff\xff[\0\xff\xff[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0[\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xff\xff\xff\xff\xff\xff\xff\xff\\\0\xff\xff\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0\xff\xff\xff\xff\xff\xff\xff\xff]\0\xff\xff]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0]\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0\xff\xff\xff\xff\xff\xff\xff\xff^\0\xff\xff^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0\xff\xff\xff\xff\xff\xff\xff\xff_\0\xff\xff_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0_\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0\xff\xff\xff\xff\xff\xff\xff\xff`\0\xff\xff`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0\xff\xff\xff\xff\xff\xff\xff\xffb\0\xff\xffb\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0\xff\xff\xff\xff\xff\xff\xff\xffc\0\xff\xffc\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0c\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0\xff\xff\xff\xff\xff\xff\xff\xffd\0\xff\xffd\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\xff\xff\xff\xff\xff\xff\xff\xffe\0\xff\xffe\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xff\xff\xff\xff\xff\xff\xff\xfff\0\xff\xfff\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0\xff\xff\xff\xff\xff\xff\xff\xffg\0\xff\xffg\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0g\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0\xff\xff\xff\xff\xff\xff\xff\xffh\0\xff\xffh\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xffi\0\xff\xffi\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffO\x01O\x01\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\xff\xff\xff\xff\xff\xff\xff\xffj\0\xff\xffj\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0j\0\x85\0\x85\0\xff\xff\x85\0\x85\0\xff\xff\xff\xff\xff\xff\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xaf\0\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\xaf\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0O\x01\x85\0\xff\xff\x85\0\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\xff\xff\xff\xff\xff\xff\xff\xff\x99\0\xff\xff\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x99\0\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\x84\x01\xff\xff\xff\xff\x85\0\x85\0\x85\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x85\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\xff\xff\xff\xff\x84\x01\xff\xff\x9a\0\xff\xff\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9a\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\xff\xff\xff\xff\xff\xff\xff\xff\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xa6\0\xff\xff\xff\xff\xa6\0\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\xff\xff\xff\xff\xff\xff\xff\xff\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\0\x01\x9e\0\x9e\0\xb3\0\xff\xff\xff\xff\xb3\0\xb3\0\xba\0\xff\xff\xff\xff\xba\0\xba\x003\x01\xff\xff\xff\xff3\x013\x01\xff\xff\xff\xff\xff\xff\x9e\0\xff\xff\xff\xff\0\x01\xff\xff\xb3\0\xff\xff\xff\xff\0\x01\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\x9e\x003\x01\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\0\x01\xff\xff\xd2\0\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xb3\0u\x01\xff\xff\xff\xffu\x01\xba\0\xff\xff\xff\xff\xff\xff\xbe\0\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\x85\x01\xff\xff\x85\x01\xd6\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa6\0\xa6\0\xa6\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xa6\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xff\xd9\0\xff\xff\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xff\xff\xff\xff\xff\xff\xff\xffu\x01\xff\xff\xff\xff\xff\xff\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xb3\0\xb3\0\xb3\0\xff\xff\xff\xff\xba\0\xba\0\xba\0\xff\xff\x9e\x003\x013\x013\x01\xff\xff\xb3\0\xff\xff\xff\xff\xff\xff\xff\xff\xba\0\xff\xff\xff\xff\xff\xff\xff\xff3\x01\xff\xff\xff\xff\0\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xd2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xff\xff\xff\xff\xff\xff\xff\xff\xda\0\xff\xff\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xda\0\xdb\0\xff\xffu\x01\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xff\xff\xff\xff\xdb\0\xff\xff\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xff\xff\xff\xff\xff\xff\xff\xff\xdc\0\xff\xff\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xff\xff\xff\xff\xff\xff\xff\xff\xde\0\xff\xff\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xff\xff\xff\xff\xff\xff\xff\xff\xdf\0\xff\xff\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xdf\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xff\xff\xff\xff\xff\xff\xff\xff\xe0\0\xff\xff\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe0\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xff\xff\xff\xff\xff\xff\xff\xff\xe1\0\xff\xff\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xff\xff\xff\xff\xff\xff\xff\xff\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xe4\0\xff\xff\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xff\xff\xff\xff\xff\xff\xff\xff\xe5\0\xff\xff\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe5\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xff\xff\xff\xff\xff\xff\xff\xff\xe6\0\xff\xff\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe6\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xff\xff\xff\xff\xff\xff\xff\xff\xe7\0\xff\xff\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe7\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xff\xff\xff\xff\xff\xff\xff\xff\xe8\0\xff\xff\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xff\xff\xff\xff\xff\xff\xff\xff\xe9\0\xff\xff\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xe9\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xff\xff\xff\xff\xff\xff\xff\xff\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xff\xff\xff\xff\xff\xff\xff\xff\xeb\0\xff\xff\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xeb\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xff\xff\xff\xff\xff\xff\xff\xff\xec\0\xff\xff\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xff\xff\xff\xff\xff\xff\xff\xff\xed\0\xff\xff\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xff\xff\xff\xff\xff\xff\xff\xff\xee\0\xff\xff\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xee\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xff\xff\xff\xff\xff\xff\xff\xff\xf0\0\xff\xff\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf0\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xff\xff\xff\xff\xff\xff\xff\xff\xf3\0\xff\xff\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf3\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xff\xff\xff\xff\xff\xff\xff\xff\xf4\0\xff\xff\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf4\0\xf5\x004\x014\x01\xff\xff4\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff4\x01\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xff\xff\xff\xff\xff\xff\xff\xff\xf5\0\xff\xff\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf5\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\x05\x01\xff\xff\xff\xff\x05\x01\xf6\0\xff\xff\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xf6\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01\x05\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xffC\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff4\x014\x014\x01\xff\xff\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x05\x014\x01\xff\xff\xff\xff\x05\x01>\x01\xff\xff\xff\xff\xff\xffC\x01\xff\xff\xff\xff\x05\x01\xff\xff\xff\xff\xff\xff\x05\x01\xff\xff\x05\x01\x05\x01\x05\x01\xff\xff\x05\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffC\x01C\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\t\x01\t\x01\t\x01\t\x01\t\x01\t\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xffe\x01\xff\xff\t\x01e\x01e\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\xff\xff\xff\xff\xff\xff\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\x12\x01\xff\xff\xff\xff\xff\xffe\x01\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x15\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xa9\x01\xff\xff\x05\x01\xa9\x01\xff\xff\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\xff\xff\xff\xff\xff\xff\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\x19\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xff\xff\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1a\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01,\x01,\x01C\x01,\x01,\x01\xff\xff\xff\xff\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\xff\xff\xff\xff\xff\xff\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\x1b\x01\xa9\x01,\x01\xff\xff\xff\xff\xa9\x01\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01,\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1c\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\xff\xffp\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01p\x01\xff\xff\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xa4\x01\xff\xff\xff\xff\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01\x1e\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffe\x01e\x01e\x01p\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x1e\x01\xff\xff\xff\xff\xff\xff\xff\xffe\x01\xa4\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\xff\xff\xff\xff\xff\xffH\x01\xff\xffH\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01H\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xa9\x01\xff\xff\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01,\x01,\x01N\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\x86\x01\xff\xff\xff\xff\xff\xff\xff\xff,\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff,\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01\xff\xff\xff\xff\xff\xff\xff\xffN\x01\xff\xffN\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01N\x01V\x01V\x01\xff\xffV\x01V\x01f\x01f\x01\xff\xfff\x01f\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01\xff\xffV\x01f\x01\xff\xffV\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xffV\x01\xff\xffV\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01V\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff\xff\xff\xff\xff\xff\xffY\x01\xff\xffY\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01Y\x01\xff\xff|\x01\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\xff\xffV\x01V\x01V\x01\xff\xff\xff\xfff\x01f\x01f\x01~\x01~\x01\xff\xff|\x01\xff\xff\xff\xffV\x01|\x01|\x01\x9a\x01\xff\xfff\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01V\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff|\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\xff\xff\xff\xff\xff\xff\xff\xff~\x01\xff\xff~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01~\x01\x83\x01\xff\xff\xff\xff\xff\xff|\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\xff\xff\xff\xff\x83\x01\xff\xff\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\x83\x01\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\x87\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\xff\xff\xff\xff\x9a\x01\x9a\x01\x9a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9a\x01\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff|\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x87\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8a\x01\xff\xff\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8a\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8c\x01\xff\xff\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8c\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8d\x01\xff\xff\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8d\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8e\x01\xff\xff\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8e\x01\x8f\x01\x9b\x01\x9b\x01\xff\xff\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\x8f\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\xff\xff\xff\xff\xff\xff\xff\xff\x8f\x01\xff\xff\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x8f\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\xff\xff\xff\xff\xff\xff\xff\xff\x90\x01\xff\xff\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x90\x01\x92\x01\x92\x01\xff\xff\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\x9b\x01\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9b\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\x92\x01\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x92\x01'),a('\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\n\0\x16\0"\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x02\0\0\0\0\0\0\0\x01\0\f\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0,\x006\0_\0B\0v\0L\0N\0\0\0\x81\0\0\0\x98\0\0\0\xa2\0\xac\0\xb6\0\0\0\xc0\0\0\0\xca\0\0\0\xe1\0\xeb\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x04\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0e\x01\x1a\x01&\x01W\x01\0\0\0\0\x01\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x07\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\x0b\0\r\0\x0f\0\xe5\0\x1a\0\b\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0H\x01\0\0\0\0\0\0\0\0y\x01\r\0\x1c\0\x10\0\x1a\x01\x1d\0E\0\x83\x01\0\0\x8d\x01\x9a\x01\xa4\x01\xae\x01\0\0\0\0\xb8\x01\xc2\x01\xdb\x01\xe5\x01\x89\0\x8b\0\0\0\xf9\x01\0\0\x03\x02\0\0\r\x02\x17\x02\0\0!\x02\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0'),a("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\f\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x0f\0\x0f\0\0\0\x0f\0\0\0\x0f\0\x0f\0\0\0#\0\0\0&\0)\0)\0)\0\0\0)\0)\0\0\0,\0\0\0/\0\0\0\0\0,\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0W\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0h\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0W\0k\0k\0s\0\0\0s\0v\0v\0W\0k\0~\0k\0k\0&\0\x8f\0/\0\x94\0\x99\0\x99\0\x99\0\x99\0\x99\0\x9e\0\xa1\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),a("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),a("\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\t\0\t\0\t\0\t\0e\0\0\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\t\0\0\0\t\0\0\0\0\0\0\0\0\0e\0\0\0e\0\t\0e\0\0\0\0\0\0\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x04\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\0\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x18\0\x01\0\x01\0 \0 \0 \0 \0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0\t\0e\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0e\0e\x002\x002\x002\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0e\x002\0\t\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x1d\0\x8c\0\x8c\0\x8c\0\x8c\0\0\0\0\0\t\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0e\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x01\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\x12\0\0\0\0\0\0\0\0\0\0\0\0\0\x15\0\x15\0\x15\0\x15\0\x15\0\x15\x002\0\0\0\0\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0M\0\0\0`\0`\0`\0`\0`\0`\0`\0`\0R\0R\x002\0\0\0\0\x002\x002\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0e\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x002\0M\0M\0M\0M\0M\0M\0M\0M\0M\0M\x002\0\0\0\0\x002\x002\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0\0\0\0\0\0\0e\0\0\0\0\0\0\0\0\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\x002\0\0\0\0\0\0\0\0\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0\0\0\0\x002\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0R\0R\0R\0R\0R\0R\0R\0R\0R\0R\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0R\0\0\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x81\0\x86\0\x86\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0\x89\0R\0\0\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0\x86\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0p\0{\0{\0{\0{\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0{\0{\0{\0{\0{\0{\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"),a("\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\x005\x005\0<\0<\0\xb3\0\xff\xff\xba\0\xb3\0\xb3\0\xba\0\xba\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff5\0\xff\xff<\0\xff\xff\xff\xff\xff\xff\xff\xff\xb3\0\xff\xff\xba\0!\0\xa1\0\xff\xff\xff\xff\xff\xff\xff\xff\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1a\0\x1b\0\xff\xff\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1b\0\x1c\0\xff\xff\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0\x1c\0T\0T\0T\0T\0T\0T\0T\0T\0T\0T\0U\0U\0U\0U\0U\0U\0U\0U\0U\0U\0W\0\xff\xffW\0W\0W\0W\0W\0W\0W\0W\0W\0W\0Y\0Y\0Z\0Z\0>\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0@\0A\0\xbc\0=\0V\0V\0V\0V\0V\0V\0V\0V\0V\0V\0\xbb\0\xbf\0\xd3\0\xd4\0\xd7\0\xff\xff?\0V\0V\0V\0V\0V\0V\0X\0X\0X\0X\0X\0X\0X\0X\0\xbd\0\xd5\0@\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\\\0\xe5\0\xe5\0\xe6\0\xe6\0\xff\xff\xff\xffB\0V\0V\0V\0V\0V\0V\0^\0\xc0\0^\0^\0^\0^\0^\0^\0^\0^\0^\0^\0`\0`\0`\0`\0`\0`\0`\0`\0`\0`\0a\0a\0a\0a\0a\0a\0a\0a\0a\0a\0b\0b\0b\0b\0b\0b\0b\0b\0b\0b\0d\0d\0d\0d\0d\0d\0d\0d\0d\0d\0f\0f\0f\0f\0f\0f\0f\0f\0f\0f\0\xd8\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0h\0h\0h\0h\0h\0h\0h\0h\0h\0h\0i\0i\0i\0i\0i\0i\0i\0i\0i\0i\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xfff\0f\0f\0f\0f\0f\0\x85\0\xff\xff\xff\xff\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x85\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9b\0\x9c\0\xff\xff\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9c\0\x9d\0\xff\xff\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9d\0\x9e\0\xff\xff\xff\xff\x9e\0\x9e\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\x9e\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xcd\0\xd2\0\xff\xff\xff\xff\xd2\0\xd2\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\x9e\0\xff\xff\xff\xff\xff\xff\xbe\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xd6\0\xff\xff\xff\xff\xff\xff\xff\xff\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd2\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xd9\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xdb\0\xff\xff\xff\xff\xd6\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdc\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xdd\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xde\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe1\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe3\0\xff\xff\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe3\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xe4\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe2\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xe8\0\xea\0\xff\xff\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xea\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xec\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xed\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xef\0\xef\0\xef\0\xef\0\xef\0\xef\0\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff"),a("\xff\x01\xff\xff\x03\xff\x01\xff\xff\x02\xff\xff\0\x02\xff\0\x01\xff\x06\xff\xff\x07\xff\xff\x01\xff\x03\xff\xff\x05\xff\xff\x04\xff\xff\0\x04\xff\0\x05\xff\0\x03\xff\0\x06\xff\0\x07\xff\x11\xff\x10\xff\x0e\xff\r\xff\f\xff\x0b\xff\n\xff\t\xff\b\xff\x07\xff\x06\xff\x05\xff\x04\xff\xff\x13\xff\x12\xff\xff\x12\xff\x13\xff\xff\x03\x11\x02\x12\x01\x0f\0\x10\xff\x16\xff\x13\xff\xff\x14\xff\xff\0\x14\xff\x01\x13\0\x0e\xff\x15\xff\xff\0\r\xff\x01\x15\0\f\xff\x19\xff\xff\0\t\xff\x13\xff\x16\xff\xff\x13\xff\xff\x18\xff\xff\x17\xff\xff\x01\x17\0\x04\xff\x01\x18\0\x06\xff\x01\x16\0\b\xff\0\x0b\xff\x01\x19\0\n\xff")],dn=[0,0,0,0,0,1,0],fc=[0,0,0],fd=[0,1];aM(11,[W,a(f_),-12],f_);aM(10,t,gP);aM(9,[W,a(fC),-10],fC);aM(8,[W,a(gD),-9],gD);aM(7,[W,a(fv),-8],fv);aM(6,ah,gC);aM(5,[W,a(fM),-6],fM);aM(4,[W,a(gn),-5],gn);aM(3,ef,gz);aM(2,c$,gm);aM(1,[W,a(gj),-2],gj);aM(0,[W,a(fV),-1],fV);var
ho=a(dJ),hp=a(dX),hs=[0,a("list.ml"),gG,11],hr=a("hd"),hu=a("\\\\"),hv=a("\\'"),hw=a("\\b"),hx=a("\\t"),hy=a("\\n"),hz=a("\\r"),ht=a("Char.chr"),hF=a("String.contains_from / Bytes.contains_from"),hC=a("String.blit / Bytes.blit_string"),hB=a("Bytes.blit"),hA=a("String.sub / Bytes.sub"),hH=a(p),hK=a("Array.blit"),hJ=a("Array.init"),hP=a("Set.remove_min_elt"),hQ=[0,0,0,0],hR=[0,0,0],hS=[0,a("set.ml"),389,18],hL=a(cO),hM=a(cO),hN=a(cO),hO=a(cO),hT=a("CamlinternalLazy.Undefined"),hX=a("Buffer.add: cannot grow buffer"),h6=a("%c"),h7=a("%s"),h8=a(f7),h9=a(fu),h_=a(gy),h$=a(gd),ia=a("%f"),ib=a("%B"),ic=a("%{"),id=a("%}"),ie=a("%("),ig=a("%)"),ih=a("%a"),ii=a("%t"),ij=a("%?"),ik=a("%r"),il=a("%_r"),im=[0,a(V),845,23],iy=[0,a(V),809,21],iq=[0,a(V),gg,21],iz=[0,a(V),813,21],ir=[0,a(V),814,21],iA=[0,a(V),817,19],is=[0,a(V),818,19],iB=[0,a(V),821,22],it=[0,a(V),822,22],iC=[0,a(V),826,30],iu=[0,a(V),827,30],iw=[0,a(V),831,26],io=[0,a(V),832,26],ix=[0,a(V),841,28],ip=[0,a(V),842,28],iv=[0,a(V),846,23],jE=a(fy),jC=[0,a(V),1520,4],jD=a("Printf: bad conversion %["),jF=[0,a(V),1588,39],jG=[0,a(V),1611,31],jH=[0,a(V),1612,31],jI=a("Printf: bad conversion %_"),jJ=a("@{"),jK=a("@["),jA=a(dT),jB=a(bO),jy=a("neg_infinity"),jz=a(gV),jt=a("%.12g"),jg=a("%nd"),jh=a("%+nd"),ji=a("% nd"),jj=a(gy),jk=a("%+ni"),jl=a("% ni"),jm=a("%nx"),jn=a("%#nx"),jo=a("%nX"),jp=a("%#nX"),jq=a("%no"),jr=a("%#no"),js=a("%nu"),i5=a("%ld"),i6=a("%+ld"),i7=a("% ld"),i8=a(fu),i9=a("%+li"),i_=a("% li"),i$=a("%lx"),ja=a("%#lx"),jb=a("%lX"),jc=a("%#lX"),jd=a("%lo"),je=a("%#lo"),jf=a("%lu"),iS=a("%Ld"),iT=a("%+Ld"),iU=a("% Ld"),iV=a(gd),iW=a("%+Li"),iX=a("% Li"),iY=a("%Lx"),iZ=a("%#Lx"),i0=a("%LX"),i1=a("%#LX"),i2=a("%Lo"),i3=a("%#Lo"),i4=a("%Lu"),iF=a(gI),iG=a("%+d"),iH=a("% d"),iI=a(f7),iJ=a("%+i"),iK=a("% i"),iL=a("%x"),iM=a("%#x"),iN=a("%X"),iO=a("%#X"),iP=a("%o"),iQ=a("%#o"),iR=a(fy),hY=a("@]"),hZ=a("@}"),h0=a("@?"),h1=a("@\n"),h2=a("@."),h3=a("@@"),h4=a("@%"),h5=a("@"),iD=a("CamlinternalFormat.Type_mismatch"),jL=a("x"),HF=a("OCAMLRUNPARAM"),HD=a("CAMLRUNPARAM"),jM=a(p),HC=a("TMPDIR"),HB=a("TEMP"),jP=a("Cygwin"),jQ=a(fr),jR=a("Win32"),jS=[0,a("filename.ml"),gQ,9],jV=a("Js.Error"),jW=a(ft),jX=a(gL),jZ=a("Unexpected number"),j0=a("Unexpected string"),j1=a("Unexpected identifier"),j2=a("Unexpected reserved word"),j3=a("Unexpected end of input"),j4=a("Unexpected variance sigil"),j5=a("Type aliases are not allowed in untyped mode"),j6=a("Type annotations are not allowed in untyped mode"),j7=a("Type declarations are not allowed in untyped mode"),j8=a("Type imports are not allowed in untyped mode"),j9=a("Type exports are not allowed in untyped mode"),j_=a("Interfaces are not allowed in untyped mode"),j$=a("Illegal newline after throw"),ka=a("Invalid regular expression"),kb=a("Invalid regular expression: missing /"),kc=a("Invalid left-hand side in assignment"),kd=a("Invalid left-hand side in exponentiation expression"),ke=a("Invalid left-hand side in for-in"),kf=a("Invalid left-hand side in for-of"),kg=a("found an expression instead"),kh=a("Expected an object pattern, array pattern, or an identifier but "),ki=a("More than one default clause in switch statement"),kj=a("Missing catch or finally after try"),kk=a("Illegal continue statement"),kl=a("Illegal break statement"),km=a("Illegal return statement"),kn=a("Illegal yield expression"),ko=a("Strict mode code may not include a with statement"),kp=a("Catch variable may not be eval or arguments in strict mode"),kq=a("Variable name may not be eval or arguments in strict mode"),kr=a("Parameter name eval or arguments is not allowed in strict mode"),ks=a("Strict mode function may not have duplicate parameter names"),kt=a("Function name may not be eval or arguments in strict mode"),ku=a("Octal literals are not allowed in strict mode."),kv=a("Delete of an unqualified identifier in strict mode."),kw=a("Duplicate data property in object literal not allowed in strict mode"),kx=a("Object literal may not have data and accessor property with the same name"),ky=a("Object literal may not have multiple get/set accessors with the same name"),kz=a("Assignment to eval or arguments is not allowed in strict mode"),kA=a("Postfix increment/decrement may not have eval or arguments operand in strict mode"),kB=a("Prefix increment/decrement may not have eval or arguments operand in strict mode"),kC=a("Use of future reserved word in strict mode"),kD=a("JSX attributes must only be assigned a non-empty expression"),kE=a("JSX value should be either an expression or a quoted JSX text"),kF=a("Const must be initialized"),kG=a("Destructuring assignment must be initialized"),kH=a("Illegal newline before arrow"),kI=a(" declared at top level or immediately within another function."),kJ=a("In strict mode code, functions can only be"),kK=a("elements must be wrapped in an enclosing parent tag"),kL=a("Unexpected token <. Remember, adjacent JSX "),kM=a("Rest parameter must be final parameter of an argument list"),kN=a("async is an implementation detail and isn't necessary for your declare function statement. It is sufficient for your declare function to just have a Promise return type."),kO=a("`declare export let` is not supported. Use `declare export var` instead."),kP=a("`declare export const` is not supported. Use `declare export var` instead."),kQ=a("`declare export type` is not supported. Use `export type` instead."),kR=a("`declare export interface` is not supported. Use `export interface` instead."),kS=a("`export * as` is an early-stage proposal and is not enabled by default. To enable support in the parser, use the `esproposal_export_star_as` option"),kT=a("When exporting a class as a named export, you must specify a class name. Did you mean `export default class ...`?"),kU=a("When exporting a function as a named export, you must specify a function name. Did you mean `export default function ...`?"),kV=a("Found a decorator in an unsupported position."),kW=a("Type parameter declaration needs a default, since a preceding type parameter declaration has a default."),kX=a("The Windows version of OCaml has a bug in how it parses hexidecimal numbers. It is fixed in OCaml 4.03.0. Until we can switch to 4.03.0, please avoid either hexidecimal notation or Windows."),kY=a("Duplicate `declare module.exports` statement!"),kZ=a("Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module xor they are a CommonJS module."),k0=a("Getter should have zero parameters"),k1=a("Setter should have exactly one parameter"),k2=a("`import type` or `import typeof`!"),k3=a("Imports within a `declare module` body must always be "),k4=a("The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements"),k5=a("Missing comma between import specifiers"),k6=a("Unexpected parser state: "),k7=a("Unexpected token "),k8=[0,[11,a("Unexpected token `"),[2,0,[11,a("`. Did you mean `"),[2,0,[11,a("`?"),0]]]]],a("Unexpected token `%s`. Did you mean `%s`?")],k9=a(fK),k_=a("Invalid flags supplied to RegExp constructor '"),k$=a(fK),la=a("Undefined label '"),lb=a("' has already been declared"),lc=a(" '"),ld=a("Expected corresponding JSX closing tag for "),le=[0,[11,a("Duplicate export for `"),[2,0,[12,96,0]]],a("Duplicate export for `%s`")],jY=a("Parse_error.Error"),lf=[0,[0]],lg=[0,a(aP),18,6],lh=[0,[0,[0,[0]]]],li=[0,a(aP),39,6],lj=[0,[0]],lk=[0,a(aP),44,6],ll=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],lm=[0,a(aP),gh,6],ln=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],lo=[0,a(aP),516,6],lp=[0,[0,[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0,[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]]]],lq=[0,a(aP),781,6],lr=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],ls=[0,a(aP),884,6],lt=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],lu=[0,a(aP),fQ,6],lv=[0,[0]],lw=[0,a(aP),gN,6],lx=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],ly=[0,a(aP),1009,6],lz=[0,[0,[0,[0]]]],lA=[0,a(aP),1032,6],lB=[0,[0]],lC=[0,[0,[0,[0]]]],lD=[0,[0]],lE=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],lF=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],lG=[0,[0,[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0,[0,[0]],[0,[0]]]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]],[0,[0]]]],lH=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],lI=[0,[0,[0,[0,[0,[0]],[0,[0]]]],[0,[0,[0,[0]]]],[0,[0]],[0,[0]]]],lJ=[0,[0]],lK=[0,[0,[0,[0]],[0,[0]],[0,[0]],[0,[0]]]],lL=[0,[0,[0,[0]]]],lY=a("comments"),lZ=a(X),l0=a("Program"),l1=a("EmptyStatement"),l2=a("DebuggerStatement"),l3=a("directive"),l4=a(bS),l5=a("ExpressionStatement"),l6=a(fS),l7=a(dP),l8=a(bN),l9=a("IfStatement"),l_=a(X),l$=a(dW),ma=a("LabeledStatement"),mb=a(dW),mc=a("BreakStatement"),md=a(dW),me=a("ContinueStatement"),mf=a(X),mg=a(dV),mh=a("WithStatement"),mi=a("cases"),mj=a("discriminant"),mk=a("SwitchStatement"),ml=a(av),mm=a("ReturnStatement"),mn=a(av),mo=a("ThrowStatement"),mp=a("finalizer"),mq=a("handler"),mr=a("block"),ms=a("TryStatement"),mt=a(X),mu=a(bN),mv=a("WhileStatement"),mw=a(bN),mx=a(X),my=a("DoWhileStatement"),mz=a(X),mA=a("update"),mB=a(bN),mC=a(cg),mD=a("ForStatement"),mE=a(gi),mF=a(X),mG=a(bh),mH=a(bu),mI=a("ForInStatement"),mJ=a("ForAwaitStatement"),mN=a("ForOfStatement"),mK=a(X),mL=a(bh),mM=a(bu),mO=a("CommonJS"),mT=a("ES"),mP=a(bT),mQ=a(X),mR=a(af),mS=a("DeclareModule"),mU=a(aZ),mV=a("DeclareModuleExports"),m1=a(bM),m2=a("DeclareExportAllDeclaration"),mW=a(bM),mX=a(dA),mY=a(dY),mZ=a(cI),m0=a("DeclareExportDeclaration"),m8=a(dF),m9=a(bM),m_=a("ExportAllDeclaration"),m3=a(dF),m4=a(bM),m5=a(dA),m6=a(dY),m7=a("ExportNamedDeclaration"),m$=a(dF),na=a(dY),nb=a("ExportDefaultDeclaration"),nc=a(bV),nh=a(bP),ni=a(Y),nd=a(f6),ne=a(bM),nf=a(dA),ng=a("ImportDeclaration"),nj=a("ThisExpression"),nk=a("Super"),nl=a(gk),nm=a("ArrayExpression"),nn=a(d1),no=a("ObjectExpression"),np=a(aK),nq=a(cJ),nr=a(bS),ns=a(cR),nt=a(dB),nu=a(cf),nv=a(X),nw=a(bW),nx=a(af),ny=a("ArrowFunctionExpression"),nz=a(fO),nA=a("SequenceExpression"),nB=a(av),nC=a("AwaitExpression"),nD=a(a6),nI=a(bt),nJ=a("!"),nK=a("~"),nL=a(bP),nM=a(dU),nN=a(fH),nO=a("matched above"),nE=a(av),nF=a(ga),nG=a(cd),nH=a("UnaryExpression"),nP=a("=="),nU=a("!="),nV=a("==="),nW=a("!=="),nX=a("<"),nY=a("<="),nZ=a(">"),n0=a(">="),n1=a("<<"),n2=a(">>"),n3=a(">>>"),n4=a(bt),n5=a(a6),n6=a("*"),n7=a("**"),n8=a(ci),n9=a("%"),n_=a("|"),n$=a("^"),oa=a(gx),ob=a(gt),oc=a(gs),nQ=a(bh),nR=a(bu),nS=a(cd),nT=a("BinaryExpression"),od=a("="),oi=a("+="),oj=a("-="),ok=a("*="),ol=a("**="),om=a("/="),on=a("%="),oo=a("<<="),op=a(">>="),oq=a(">>>="),or=a("|="),os=a("^="),ot=a("&="),oe=a(bh),of=a(bu),og=a(cd),oh=a("AssignmentExpression"),oz=a("--"),ou=a("++"),ov=a(ga),ow=a(av),ox=a(cd),oy=a("UpdateExpression"),oF=a("&&"),oA=a("||"),oB=a(bh),oC=a(bu),oD=a(cd),oE=a("LogicalExpression"),oG=a(fS),oH=a(dP),oI=a(bN),oJ=a("ConditionalExpression"),oK=a(dZ),oL=a(gf),oM=a("NewExpression"),oN=a(dZ),oO=a(gf),oP=a("CallExpression"),oQ=a(ck),oR=a(dE),oS=a(dV),oT=a("MemberExpression"),oU=a("delegate"),oV=a(av),oW=a("YieldExpression"),oX=a(gO),oY=a(fG),oZ=a("ComprehensionExpression"),o0=a(gO),o1=a(fG),o2=a("GeneratorExpression"),o3=a(aZ),o4=a(bS),o5=a("TypeCastExpression"),o6=a(dE),o7=a("meta"),o8=a("MetaProperty"),o9=a(aK),o_=a(cJ),o$=a(bS),pa=a(cR),pb=a(dB),pc=a(cf),pd=a(X),pe=a(bW),pf=a(af),pg=a("FunctionDeclaration"),ph=a(aK),pi=a(cJ),pj=a(bS),pk=a(cR),pl=a(dB),pm=a(cf),pn=a(X),po=a(bW),pp=a(af),pq=a("FunctionExpression"),pr=a(cP),ps=a(aZ),pt=a(a8),pu=a(gZ),pv=a(cP),pw=a(aZ),px=a(a8),py=a(gZ),pz=a(dP),pA=a(bN),pB=a("SwitchCase"),pC=a(X),pD=a("param"),pE=a("CatchClause"),pF=a(X),pG=a("BlockStatement"),pH=a(af),pI=a("DeclareVariable"),pJ=a(cR),pK=a(af),pL=a("DeclareFunction"),pM=a(dQ),pN=a(X),pO=a(aK),pP=a(af),pQ=a("DeclareClass"),pS=a(Y),pR=a(bV),pT=a(gM),pU=a("ExportNamespaceSpecifier"),pV=a(bh),pW=a(aK),pX=a(af),pY=a("TypeAlias"),pZ=a(d7),p0=a(cW),p1=a(gw),p2=a(aK),p3=a(gB),p4=a(X),p5=a(af),p6=a("ClassDeclaration"),p7=a(d7),p8=a(cW),p9=a(gw),p_=a(aK),p$=a(gB),qa=a(X),qb=a(af),qc=a("ClassExpression"),qd=a(aK),qe=a(af),qf=a("ClassImplements"),qg=a(X),qh=a("ClassBody"),qi=a(dO),qq=a(d6),qr=a(bv),qs=a(bR),qj=a(d7),qk=a(ck),ql=a(a_),qm=a(bT),qn=a(Y),qo=a(bL),qp=a("MethodDefinition"),qt=a(cN),qu=a(a_),qv=a(ck),qw=a(aZ),qx=a(Y),qy=a(bL),qz=a("ClassProperty"),qA=a(dQ),qB=a(X),qC=a(aK),qD=a(af),qE=a("InterfaceDeclaration"),qF=a(aK),qG=a(af),qH=a("InterfaceExtends"),qI=a(aZ),qJ=a(d1),qK=a("ObjectPattern"),qL=a(aZ),qM=a(gk),qN=a("ArrayPattern"),qO=a(bh),qP=a(bu),qQ=a("AssignmentPattern"),qR=a(av),qS=a(f9),qT=a(av),qU=a(f9),qV=a(cg),q3=a(bv),q4=a(bR),qW=a(ck),qX=a(fD),qY=a(d6),qZ=a(bT),q0=a(Y),q1=a(bL),q2=a(gT),q5=a(av),q6=a("SpreadProperty"),q7=a(ck),q8=a(fD),q9=a(d6),q_=a(cg),q$=a(bT),ra=a(Y),rb=a(bL),rc=a(gT),rd=a(av),re=a("RestProperty"),rf=a(av),rg=a("SpreadElement"),rh=a(gi),ri=a(bh),rj=a(bu),rk=a("ComprehensionBlock"),ro=a("flags"),rp=a("pattern"),rq=a("regex"),rr=a(bx),rs=a(Y),rl=a(bx),rm=a(Y),rn=a("Literal"),rt=a(fO),ru=a("quasis"),rv=a("TemplateLiteral"),rw=a("cooked"),rx=a(bx),ry=a("tail"),rz=a(Y),rA=a("TemplateElement"),rB=a("quasi"),rC=a("tag"),rD=a("TaggedTemplateExpression"),rE=a(f0),rI=a(gp),rJ=a(gA),rF=a(bT),rG=a("declarations"),rH=a("VariableDeclaration"),rK=a(cg),rL=a(af),rM=a("VariableDeclarator"),rO=a(fF),rN=a("plus"),rP=a("AnyTypeAnnotation"),rQ=a("MixedTypeAnnotation"),rR=a("EmptyTypeAnnotation"),rS=a("VoidTypeAnnotation"),rT=a("NullLiteralTypeAnnotation"),rU=a("NumberTypeAnnotation"),rV=a("StringTypeAnnotation"),rW=a("BooleanTypeAnnotation"),rX=a(aZ),rY=a("NullableTypeAnnotation"),rZ=a(aK),r0=a("rest"),r1=a(cJ),r2=a(bW),r3=a("FunctionTypeAnnotation"),r4=a(cP),r5=a(aZ),r6=a(a8),r7=a("FunctionTypeParam"),r8=[0,0,0,0],r9=a("callProperties"),r_=a("indexers"),r$=a(d1),sa=a("exact"),sb=a("ObjectTypeAnnotation"),sm=a("There should not be computed object type property keys"),sc=a(cg),sk=a(bv),sl=a(bR),sd=a(bT),se=a(cN),sf=a(a_),sg=a(cP),sh=a(Y),si=a(bL),sj=a("ObjectTypeProperty"),sn=a(av),so=a("ObjectTypeSpreadProperty"),sp=a(cN),sq=a(a_),sr=a(Y),ss=a(bL),st=a(af),su=a("ObjectTypeIndexer"),sv=a(a_),sw=a(Y),sx=a("ObjectTypeCallProperty"),sy=a("elementType"),sz=a("ArrayTypeAnnotation"),sA=a(af),sB=a("qualification"),sC=a("QualifiedTypeIdentifier"),sD=a(aK),sE=a(af),sF=a("GenericTypeAnnotation"),sG=a(dD),sH=a("UnionTypeAnnotation"),sI=a(dD),sJ=a("IntersectionTypeAnnotation"),sK=a(av),sL=a("TypeofTypeAnnotation"),sM=a(dD),sN=a("TupleTypeAnnotation"),sO=a(bx),sP=a(Y),sQ=a("StringLiteralTypeAnnotation"),sR=a(bx),sS=a(Y),sT=a("NumberLiteralTypeAnnotation"),sU=a(bx),sV=a(Y),sW=a("BooleanLiteralTypeAnnotation"),sX=a("ExistsTypeAnnotation"),sY=a(aZ),sZ=a("TypeAnnotation"),s0=a(bW),s1=a("TypeParameterDeclaration"),s2=a(cI),s3=a(cN),s4=a("bound"),s5=a(a8),s6=a("TypeParameter"),s7=a(bW),s8=a("TypeParameterInstantiation"),s9=a("children"),s_=a("closingElement"),s$=a("openingElement"),ta=a("JSXElement"),tb=a("selfClosing"),tc=a("attributes"),td=a(a8),te=a("JSXOpeningElement"),tf=a(a8),tg=a("JSXClosingElement"),th=a(Y),ti=a(a8),tj=a("JSXAttribute"),tk=a(av),tl=a("JSXSpreadAttribute"),to=a("JSXEmptyExpression"),tm=a(bS),tn=a("JSXExpressionContainer"),tp=a(bx),tq=a(Y),tr=a("JSXText"),ts=a(dE),tt=a(dV),tu=a("JSXMemberExpression"),tv=a(a8),tw=a("namespace"),tx=a("JSXNamespacedName"),ty=a(a8),tz=a("JSXIdentifier"),tA=a(gM),tB=a(cS),tC=a("ExportSpecifier"),tD=a(cS),tE=a("ImportDefaultSpecifier"),tF=a(cS),tG=a("ImportNamespaceSpecifier"),tH=a(bV),tM=a(bP),tI=a(f6),tJ=a(cS),tK=a("imported"),tL=a("ImportSpecifier"),tN=a("Block"),tP=a("Line"),tO=a(Y),tQ=a(Y),tR=a("DeclaredPredicate"),tS=a("InferredPredicate"),lW=a("message"),lX=a(gc),lT=a("range"),lU=a(gc),lV=a(bV),lP=a(gL),lQ=a("end"),lR=a("start"),lS=a(bM),lN=a("column"),lO=a("line"),v9=a(dK),v_=[0,0],v$=[0,0],wa=[0,2],wb=[0,2],wc=[0,1],wd=[0,1],we=[0,3],wf=[0,3],wg=a(dK),wh=[5,3,d3],wi=[5,3,d3],wj=a("\\"),wk=a(cG),wl=a(ge),wm=a("*/"),wn=a(ge),wo=a(p),wp=a(p),wq=a(p),wr=a(p),ws=a(cG),wt=a("iexcl"),At=a("aelig"),Cr=a("Nu"),Dr=a("Eacute"),DX=a("Atilde"),Eb=a("'int'"),Ec=a("AElig"),Ed=a("Aacute"),Ee=a("Acirc"),Ef=a("Agrave"),Eg=a("Alpha"),Eh=a("Aring"),Ei=[0,197],Ej=[0,913],Ek=[0,cM],El=[0,194],Em=[0,193],En=[0,198],Eo=[0,8747],DY=a("Auml"),DZ=a("Beta"),D0=a("Ccedil"),D1=a("Chi"),D2=a("Dagger"),D3=a("Delta"),D4=a("ETH"),D5=[0,208],D6=[0,916],D7=[0,8225],D8=[0,935],D9=[0,fo],D_=[0,914],D$=[0,196],Ea=[0,195],Ds=a("Icirc"),DI=a("Ecirc"),DJ=a("Egrave"),DK=a("Epsilon"),DL=a("Eta"),DM=a("Euml"),DN=a("Gamma"),DO=a("Iacute"),DP=[0,205],DQ=[0,915],DR=[0,203],DS=[0,919],DT=[0,917],DU=[0,200],DV=[0,202],Dt=a("Igrave"),Du=a("Iota"),Dv=a("Iuml"),Dw=a("Kappa"),Dx=a("Lambda"),Dy=a("Mu"),Dz=a("Ntilde"),DA=[0,209],DB=[0,924],DC=[0,923],DD=[0,922],DE=[0,207],DF=[0,921],DG=[0,204],DH=[0,206],DW=[0,201],Cs=a("Sigma"),CY=a("Otilde"),Dc=a("OElig"),Dd=a("Oacute"),De=a("Ocirc"),Df=a("Ograve"),Dg=a("Omega"),Dh=a("Omicron"),Di=a("Oslash"),Dj=[0,fq],Dk=[0,927],Dl=[0,937],Dm=[0,210],Dn=[0,212],Do=[0,211],Dp=[0,338],CZ=a("Ouml"),C0=a("Phi"),C1=a("Pi"),C2=a("Prime"),C3=a("Psi"),C4=a("Rho"),C5=a("Scaron"),C6=[0,352],C7=[0,929],C8=[0,936],C9=[0,8243],C_=[0,928],C$=[0,934],Da=[0,214],Db=[0,213],Ct=a("Uuml"),CJ=a("THORN"),CK=a("Tau"),CL=a("Theta"),CM=a("Uacute"),CN=a("Ucirc"),CO=a("Ugrave"),CP=a("Upsilon"),CQ=[0,933],CR=[0,217],CS=[0,219],CT=[0,gh],CU=[0,920],CV=[0,932],CW=[0,222],Cu=a("Xi"),Cv=a("Yacute"),Cw=a("Yuml"),Cx=a("Zeta"),Cy=a("aacute"),Cz=a("acirc"),CA=a("acute"),CB=[0,180],CC=[0,226],CD=[0,225],CE=[0,918],CF=[0,376],CG=[0,221],CH=[0,926],CI=[0,220],CX=[0,931],Dq=[0,925],Au=a("delta"),Bs=a("cap"),BY=a("aring"),Cc=a("agrave"),Cd=a("alefsym"),Ce=a("alpha"),Cf=a("amp"),Cg=a("and"),Ch=a("ang"),Ci=a("apos"),Cj=[0,39],Ck=[0,8736],Cl=[0,8743],Cm=[0,38],Cn=[0,945],Co=[0,8501],Cp=[0,cT],BZ=a("asymp"),B0=a("atilde"),B1=a("auml"),B2=a("bdquo"),B3=a("beta"),B4=a("brvbar"),B5=a("bull"),B6=[0,8226],B7=[0,166],B8=[0,946],B9=[0,8222],B_=[0,228],B$=[0,gG],Ca=[0,8776],Cb=[0,229],Bt=a("copy"),BJ=a("ccedil"),BK=a("cedil"),BL=a("cent"),BM=a("chi"),BN=a("circ"),BO=a("clubs"),BP=a("cong"),BQ=[0,8773],BR=[0,9827],BS=[0,710],BT=[0,967],BU=[0,162],BV=[0,184],BW=[0,231],Bu=a("crarr"),Bv=a("cup"),Bw=a("curren"),Bx=a("dArr"),By=a("dagger"),Bz=a("darr"),BA=a("deg"),BB=[0,176],BC=[0,8595],BD=[0,8224],BE=[0,8659],BF=[0,164],BG=[0,8746],BH=[0,8629],BI=[0,169],BX=[0,8745],Av=a("fnof"),AZ=a("ensp"),Bd=a("diams"),Be=a("divide"),Bf=a("eacute"),Bg=a("ecirc"),Bh=a("egrave"),Bi=a(fN),Bj=a("emsp"),Bk=[0,8195],Bl=[0,8709],Bm=[0,232],Bn=[0,234],Bo=[0,233],Bp=[0,247],Bq=[0,9830],A0=a("epsilon"),A1=a("equiv"),A2=a("eta"),A3=a("eth"),A4=a("euml"),A5=a("euro"),A6=a("exist"),A7=[0,8707],A8=[0,8364],A9=[0,235],A_=[0,cQ],A$=[0,951],Ba=[0,8801],Bb=[0,fQ],Bc=[0,8194],Aw=a("gt"),AK=a("forall"),AL=a("frac12"),AM=a("frac14"),AN=a("frac34"),AO=a("frasl"),AP=a("gamma"),AQ=a("ge"),AR=[0,8805],AS=[0,947],AT=[0,8260],AU=[0,190],AV=[0,188],AW=[0,189],AX=[0,8704],Ax=a("hArr"),Ay=a("harr"),Az=a("hearts"),AA=a("hellip"),AB=a("iacute"),AC=a("icirc"),AD=[0,238],AE=[0,237],AF=[0,8230],AG=[0,9829],AH=[0,8596],AI=[0,8660],AJ=[0,62],AY=[0,go],Br=[0,948],Cq=[0,230],wu=a("prime"),yu=a("ndash"),zu=a("le"),z0=a("kappa"),Ae=a("igrave"),Af=a("image"),Ag=a("infin"),Ah=a("iota"),Ai=a("iquest"),Aj=a("isin"),Ak=a("iuml"),Al=[0,239],Am=[0,8712],An=[0,gQ],Ao=[0,953],Ap=[0,8734],Aq=[0,8465],Ar=[0,236],z1=a("lArr"),z2=a("lambda"),z3=a("lang"),z4=a("laquo"),z5=a("larr"),z6=a("lceil"),z7=a("ldquo"),z8=[0,8220],z9=[0,8968],z_=[0,8592],z$=[0,171],Aa=[0,10216],Ab=[0,955],Ac=[0,8656],Ad=[0,954],zv=a("macr"),zL=a("lfloor"),zM=a("lowast"),zN=a("loz"),zO=a("lrm"),zP=a("lsaquo"),zQ=a("lsquo"),zR=a("lt"),zS=[0,60],zT=[0,8216],zU=[0,8249],zV=[0,8206],zW=[0,9674],zX=[0,8727],zY=[0,8970],zw=a("mdash"),zx=a("micro"),zy=a("middot"),zz=a(fF),zA=a("mu"),zB=a("nabla"),zC=a("nbsp"),zD=[0,160],zE=[0,8711],zF=[0,gN],zG=[0,8722],zH=[0,183],zI=[0,181],zJ=[0,8212],zK=[0,175],zZ=[0,8804],yv=a("or"),y1=a("oacute"),zf=a("ne"),zg=a("ni"),zh=a("not"),zi=a("notin"),zj=a("nsub"),zk=a("ntilde"),zl=a("nu"),zm=[0,957],zn=[0,241],zo=[0,8836],zp=[0,8713],zq=[0,172],zr=[0,8715],zs=[0,8800],y2=a("ocirc"),y3=a("oelig"),y4=a("ograve"),y5=a("oline"),y6=a("omega"),y7=a("omicron"),y8=a("oplus"),y9=[0,8853],y_=[0,959],y$=[0,969],za=[0,8254],zb=[0,242],zc=[0,339],zd=[0,244],ze=[0,243],yw=a("part"),yM=a("ordf"),yN=a("ordm"),yO=a("oslash"),yP=a("otilde"),yQ=a("otimes"),yR=a("ouml"),yS=a("para"),yT=[0,182],yU=[0,cV],yV=[0,8855],yW=[0,fE],yX=[0,W],yY=[0,186],yZ=[0,170],yx=a("permil"),yy=a("perp"),yz=a("phi"),yA=a("pi"),yB=a("piv"),yC=a("plusmn"),yD=a("pound"),yE=[0,163],yF=[0,177],yG=[0,982],yH=[0,960],yI=[0,966],yJ=[0,8869],yK=[0,8240],yL=[0,8706],y0=[0,8744],zt=[0,8211],wv=a("sup1"),xv=a("rlm"),x1=a("raquo"),yf=a("prod"),yg=a("prop"),yh=a("psi"),yi=a("quot"),yj=a("rArr"),yk=a("radic"),yl=a("rang"),ym=[0,10217],yn=[0,8730],yo=[0,8658],yp=[0,34],yq=[0,968],yr=[0,8733],ys=[0,8719],x2=a("rarr"),x3=a("rceil"),x4=a("rdquo"),x5=a("real"),x6=a("reg"),x7=a("rfloor"),x8=a("rho"),x9=[0,961],x_=[0,8971],x$=[0,174],ya=[0,8476],yb=[0,8221],yc=[0,8969],yd=[0,8594],ye=[0,187],xw=a("sigma"),xM=a("rsaquo"),xN=a("rsquo"),xO=a("sbquo"),xP=a("scaron"),xQ=a("sdot"),xR=a("sect"),xS=a("shy"),xT=[0,173],xU=[0,167],xV=[0,8901],xW=[0,353],xX=[0,8218],xY=[0,8217],xZ=[0,8250],xx=a("sigmaf"),xy=a("sim"),xz=a("spades"),xA=a("sub"),xB=a("sube"),xC=a("sum"),xD=a("sup"),xE=[0,8835],xF=[0,8721],xG=[0,8838],xH=[0,8834],xI=[0,9824],xJ=[0,8764],xK=[0,962],xL=[0,963],x0=[0,8207],ww=a("uarr"),w2=a("thetasym"),xg=a("sup2"),xh=a("sup3"),xi=a("supe"),xj=a("szlig"),xk=a("tau"),xl=a("there4"),xm=a("theta"),xn=[0,952],xo=[0,8756],xp=[0,964],xq=[0,223],xr=[0,8839],xs=[0,179],xt=[0,178],w3=a("thinsp"),w4=a("thorn"),w5=a("tilde"),w6=a("times"),w7=a("trade"),w8=a("uArr"),w9=a("uacute"),w_=[0,cj],w$=[0,8657],xa=[0,8482],xb=[0,215],xc=[0,732],xd=[0,d8],xe=[0,8201],xf=[0,977],wx=a("xi"),wN=a("ucirc"),wO=a("ugrave"),wP=a("uml"),wQ=a("upsih"),wR=a("upsilon"),wS=a("uuml"),wT=a("weierp"),wU=[0,8472],wV=[0,f$],wW=[0,965],wX=[0,978],wY=[0,168],wZ=[0,249],w0=[0,251],wy=a("yacute"),wz=a("yen"),wA=a("yuml"),wB=a("zeta"),wC=a("zwj"),wD=a("zwnj"),wG=[0,8204],wH=[0,8205],wI=[0,950],wJ=[0,K],wK=[0,165],wL=[0,253],wM=[0,958],w1=[0,8593],xu=[0,185],yt=[0,8242],As=[0,161],wE=a(";"),wF=a(gx),Ep=a("}"),Eq=[0,a(p),a(p),a(p)],Er=a("${"),Es=a(fp),v4=a(fZ),v3=a(p),v2=[0,a(d0),620,11],v1=[0,a(d0),614,11],vY=[0,0],v0=[0,a(d0),556,4],vW=a(p),vQ=[1,a("ILLEGAL")],vO=a(ci),vP=a(ci),tT=a("T_IDENTIFIER"),tU=a("T_LCURLY"),tV=a("T_RCURLY"),tW=a("T_LCURLYBAR"),tX=a("T_RCURLYBAR"),tY=a("T_LPAREN"),tZ=a("T_RPAREN"),t0=a("T_LBRACKET"),t1=a("T_RBRACKET"),t2=a("T_SEMICOLON"),t3=a("T_COMMA"),t4=a("T_PERIOD"),t5=a("T_ARROW"),t6=a("T_ELLIPSIS"),t7=a("T_AT"),t8=a("T_FUNCTION"),t9=a("T_IF"),t_=a("T_IN"),t$=a("T_INSTANCEOF"),ua=a("T_RETURN"),ub=a("T_SWITCH"),uc=a("T_THIS"),ud=a("T_THROW"),ue=a("T_TRY"),uf=a("T_VAR"),ug=a("T_WHILE"),uh=a("T_WITH"),ui=a("T_CONST"),uj=a("T_LET"),uk=a("T_NULL"),ul=a("T_FALSE"),um=a("T_TRUE"),un=a("T_BREAK"),uo=a("T_CASE"),up=a("T_CATCH"),uq=a("T_CONTINUE"),ur=a("T_DEFAULT"),us=a("T_DO"),ut=a("T_FINALLY"),uu=a("T_FOR"),uv=a("T_CLASS"),uw=a("T_EXTENDS"),ux=a("T_STATIC"),uy=a("T_ELSE"),uz=a("T_NEW"),uA=a("T_DELETE"),uB=a("T_TYPEOF"),uC=a("T_VOID"),uD=a("T_ENUM"),uE=a("T_EXPORT"),uF=a("T_IMPORT"),uG=a("T_SUPER"),uH=a("T_IMPLEMENTS"),uI=a("T_INTERFACE"),uJ=a("T_PACKAGE"),uK=a("T_PRIVATE"),uL=a("T_PROTECTED"),uM=a("T_PUBLIC"),uN=a("T_YIELD"),uO=a("T_DEBUGGER"),uP=a("T_DECLARE"),uQ=a("T_TYPE"),uR=a("T_OF"),uS=a("T_ASYNC"),uT=a("T_AWAIT"),uU=a("T_CHECKS"),uV=a("T_RSHIFT3_ASSIGN"),uW=a("T_RSHIFT_ASSIGN"),uX=a("T_LSHIFT_ASSIGN"),uY=a("T_BIT_XOR_ASSIGN"),uZ=a("T_BIT_OR_ASSIGN"),u0=a("T_BIT_AND_ASSIGN"),u1=a("T_MOD_ASSIGN"),u2=a("T_DIV_ASSIGN"),u3=a("T_MULT_ASSIGN"),u4=a("T_EXP_ASSIGN"),u5=a("T_MINUS_ASSIGN"),u6=a("T_PLUS_ASSIGN"),u7=a("T_ASSIGN"),u8=a("T_PLING"),u9=a("T_COLON"),u_=a("T_OR"),u$=a("T_AND"),va=a("T_BIT_OR"),vb=a("T_BIT_XOR"),vc=a("T_BIT_AND"),vd=a("T_EQUAL"),ve=a("T_NOT_EQUAL"),vf=a("T_STRICT_EQUAL"),vg=a("T_STRICT_NOT_EQUAL"),vh=a("T_LESS_THAN_EQUAL"),vi=a("T_GREATER_THAN_EQUAL"),vj=a("T_LESS_THAN"),vk=a("T_GREATER_THAN"),vl=a("T_LSHIFT"),vm=a("T_RSHIFT"),vn=a("T_RSHIFT3"),vo=a("T_PLUS"),vp=a("T_MINUS"),vq=a("T_DIV"),vr=a("T_MULT"),vs=a("T_EXP"),vt=a("T_MOD"),vu=a("T_NOT"),vv=a("T_BIT_NOT"),vw=a("T_INCR"),vx=a("T_DECR"),vy=a("T_ERROR"),vz=a("T_EOF"),vA=a("T_JSX_IDENTIFIER"),vB=a("T_ANY_TYPE"),vC=a("T_MIXED_TYPE"),vD=a("T_EMPTY_TYPE"),vE=a("T_BOOLEAN_TYPE"),vF=a("T_NUMBER_TYPE"),vG=a("T_STRING_TYPE"),vH=a("T_VOID_TYPE"),vI=a("T_NUMBER"),vJ=a("T_STRING"),vK=a("T_TEMPLATE_PART"),vL=a("T_REGEXP"),vM=a("T_JSX_TEXT"),vN=a("T_NUMBER_SINGLETON_TYPE"),vR=a("Lexer_flow.FloatOfString.No_good"),v5=ha([[0,a(dS),15],[0,a("if"),16],[0,a(gt),17],[0,a(gs),18],[0,a("return"),19],[0,a("switch"),20],[0,a("this"),21],[0,a("throw"),22],[0,a("try"),23],[0,a(f0),24],[0,a("while"),25],[0,a("with"),26],[0,a(gA),27],[0,a(gp),28],[0,a(dL),29],[0,a(dX),30],[0,a(dJ),31],[0,a("break"),32],[0,a("case"),33],[0,a("catch"),34],[0,a("continue"),35],[0,a(cI),36],[0,a("do"),37],[0,a("finally"),38],[0,a("for"),39],[0,a("class"),40],[0,a(dQ),41],[0,a(a_),42],[0,a("else"),43],[0,a(gl),44],[0,a(fH),45],[0,a(bP),46],[0,a(dU),47],[0,a(gu),48],[0,a("export"),49],[0,a("import"),50],[0,a("super"),51],[0,a(cW),52],[0,a(fw),53],[0,a(gX),54],[0,a(gU),55],[0,a(fB),56],[0,a(fx),57],[0,a(f3),58],[0,a("debugger"),59],[0,a("declare"),60],[0,a(bV),61],[0,a("of"),62],[0,a(cf),63],[0,a("await"),64]]),v6=ha([[0,a(a_),42],[0,a(bP),46],[0,a("any"),cK],[0,a("mixed"),111],[0,a(fN),gJ],[0,a("bool"),dM],[0,a("boolean"),dM],[0,a(dJ),31],[0,a(dX),30],[0,a("number"),fP],[0,a("string"),115],[0,a(dU),f8],[0,a(dL),29]]),EJ=a(fY),EI=a(fY),EG=a(dZ),EH=a("eval"),Ey=a(cW),Ez=a(fw),EA=a(gX),EB=a(gU),EC=a(fB),ED=a(fx),EE=a(a_),EF=a(f3),Ex=a(gu),Ew=[0,a("src/parser/parser_env.ml"),294,2],Ev=[0,0,0],Eu=a(gF),Et=a(gF),EK=a("Parser_env.Try.Rollback"),EO=[0,a("did not consume any tokens")],Fb=[0,1],Fc=[0,0,0],E8=[0,a(bU),496,6],Fa=a(a_),E9=a(bv),E_=a(bR),E$=a(bv),E7=[0,1],E6=[0,[0,0,0]],E5=[0,1],E4=[0,1],E3=[0,1],EW=[0,0],EX=[0,1],EY=[0,2],EZ=[0,7],E0=[0,5],E1=[0,6],E2=[0,3],EV=[0,4],EU=[0,a(bU),G,17],ET=[0,a(bU),87,17],ES=[0,a(bU),65,11],ER=[0,a(bU),69,11],EQ=[0,a(bU),47,14],Fe=[0,31],Fd=[0,31],F9=[0,1],F_=[0,29],F8=[0,a(gK),gg,13],F6=[0,a(gK),712,17],F7=[0,[0,a(p),a(p)],1],F5=a(dL),F4=a(fZ),F3=[0,31],F1=a(gl),F2=a("target"),F0=[0,1],FZ=[0,0],FY=[0,1],FX=[0,0],FP=[0,1],FQ=[0,0],FR=[0,2],FS=[0,3],FT=[0,7],FU=[0,6],FV=[0,4],FW=[0,5],Ft=[0,[0,17,[0,2]]],Fu=[0,[0,18,[0,3]]],Fv=[0,[0,19,[0,4]]],Fw=[0,[0,0,[0,5]]],Fx=[0,[0,1,[0,5]]],Fy=[0,[0,2,[0,5]]],Fz=[0,[0,3,[0,5]]],FA=[0,[0,5,[0,6]]],FB=[0,[0,7,[0,6]]],FC=[0,[0,4,[0,6]]],FD=[0,[0,6,[0,6]]],FE=[0,[0,8,[0,7]]],FF=[0,[0,9,[0,7]]],FG=[0,[0,10,[0,7]]],FH=[0,[0,11,[0,8]]],FI=[0,[0,12,[0,8]]],FJ=[0,[0,15,[0,9]]],FK=[0,[0,13,[0,9]]],FL=[0,[0,14,[1,10]]],FM=[0,[0,16,[0,9]]],FO=[0,[0,21,[0,6]]],FN=[0,[0,20,[0,6]]],Fg=[0,9],Fh=[0,8],Fi=[0,7],Fj=[0,11],Fk=[0,10],Fl=[0,12],Fm=[0,6],Fn=[0,5],Fo=[0,3],Fp=[0,4],Fq=[0,2],Fr=[0,1],Fs=[0,0],Ff=a(cf),Gc=a(dK),Gd=a(bO),Ga=a(p),Gb=[0,a(p)],Gg=a(dO),Gh=a(dO),Gi=[0,1],Gj=[0,1],Gk=[0,1],Gl=[0,1],Gm=a(bv),Gn=a(bR),Ge=a(bv),Gf=a(bR),GX=a(bV),GY=[0,0],G2=a(bP),G3=[0,1],GZ=a(aY),G0=a(aY),G1=a(aY),G5=a(ch),G4=a(aY),GW=a(ch),GT=a(aY),GU=a(aY),GS=a(ch),GV=[0,a(dN),1121,15],GL=a("other than an interface declaration!"),GM=a("Internal Flow Error! Parsed `export interface` into something "),GN=[0,1],GO=a("other than a type alias!"),GP=a("Internal Flow Error! Parsed `export type` into something "),GI=a(aY),GJ=a(aY),GR=a(cI),GK=a(ch),GQ=a("Internal Flow Error! Unexpected export statement declaration!"),GG=a(aY),GH=a(aY),GF=a(ch),GB=[0,1],GC=a(gW),GD=[0,1],GE=a(gW),GA=a("exports"),Gz=[0,1],Gy=[0,1],Gw=a(gS),Gx=a(gS),Gv=[0,1],Gu=[0,1],Gt=a("Label"),Gs=[0,27],Gr=[0,0,0],Gp=[0,a(dN),fo,20],Gq=[0,a(dN),fq,20],Go=a("Parser error: No such thing as an expression pattern!"),Hn=[0,1],Hl=a("use strict"),Hm=[0,0,0],Hj=a(fp),Hk=a("Nooo: "),G6=[0,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],G7=[0,a("src/parser/parser_flow.ml"),39,28],Ho=[0,[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]],HA=[0,0],Hz=a(" errors");function
L(a){if(typeof
a==="number")return 0;else
switch(a[0]){case
0:return[0,L(a[1])];case
1:return[1,L(a[1])];case
2:return[2,L(a[1])];case
3:return[3,L(a[1])];case
4:return[4,L(a[1])];case
5:return[5,L(a[1])];case
6:return[6,L(a[1])];case
7:return[7,L(a[1])];case
8:var
c=a[1];return[8,c,L(a[2])];case
9:var
b=a[1];return[9,b,b,L(a[3])];case
10:return[10,L(a[1])];case
11:return[11,L(a[1])];case
12:return[12,L(a[1])];case
13:return[13,L(a[1])];default:return[14,L(a[1])]}}function
ag(a,b){if(typeof
a==="number")return b;else
switch(a[0]){case
0:return[0,ag(a[1],b)];case
1:return[1,ag(a[1],b)];case
2:return[2,ag(a[1],b)];case
3:return[3,ag(a[1],b)];case
4:return[4,ag(a[1],b)];case
5:return[5,ag(a[1],b)];case
6:return[6,ag(a[1],b)];case
7:return[7,ag(a[1],b)];case
8:var
c=a[1];return[8,c,ag(a[2],b)];case
9:var
d=a[2],e=a[1];return[9,e,d,ag(a[3],b)];case
10:return[10,ag(a[1],b)];case
11:return[11,ag(a[1],b)];case
12:return[12,ag(a[1],b)];case
13:return[13,ag(a[1],b)];default:return[14,ag(a[1],b)]}}function
I(a,b){if(typeof
a==="number")return b;else
switch(a[0]){case
0:return[0,I(a[1],b)];case
1:return[1,I(a[1],b)];case
2:var
c=a[1];return[2,c,I(a[2],b)];case
3:var
d=a[1];return[3,d,I(a[2],b)];case
4:var
e=a[3],f=a[2],g=a[1];return[4,g,f,e,I(a[4],b)];case
5:var
h=a[3],i=a[2],j=a[1];return[5,j,i,h,I(a[4],b)];case
6:var
k=a[3],l=a[2],m=a[1];return[6,m,l,k,I(a[4],b)];case
7:var
n=a[3],o=a[2],p=a[1];return[7,p,o,n,I(a[4],b)];case
8:var
q=a[3],r=a[2],s=a[1];return[8,s,r,q,I(a[4],b)];case
9:return[9,I(a[1],b)];case
10:return[10,I(a[1],b)];case
11:var
t=a[1];return[11,t,I(a[2],b)];case
12:var
u=a[1];return[12,u,I(a[2],b)];case
13:var
v=a[2],w=a[1];return[13,w,v,I(a[3],b)];case
14:var
x=a[2],y=a[1];return[14,y,x,I(a[3],b)];case
15:return[15,I(a[1],b)];case
16:return[16,I(a[1],b)];case
17:var
z=a[1];return[17,z,I(a[2],b)];case
18:var
A=a[1];return[18,A,I(a[2],b)];case
19:return[19,I(a[1],b)];case
20:var
B=a[2],C=a[1];return[20,C,B,I(a[3],b)];case
21:var
D=a[1];return[21,D,I(a[2],b)];case
22:return[22,I(a[1],b)];case
23:var
E=a[1];return[23,E,I(a[2],b)];default:var
F=a[2],G=a[1];return[24,G,F,I(a[3],b)]}}function
ay(a){throw[0,c$,a]}function
az(a){throw[0,ef,a]}a0(0);function
da(b,a){return HR(b,a)?b:a}function
db(a){return 0<=a?a:-a|0}function
w(d,c){var
a=s(d),e=s(c),b=Z(a+e|0);aA(d,0,b,0,a);aA(c,0,b,a,e);return b}function
cr(a,b){if(a){var
c=a[1];return[0,c,cr(a[2],b)]}return b}Ii(0);hb(1);hb(2);function
hq(b){function
a(b){var
a=b;for(;;){if(a){var
c=a[2],d=a[1];try{Ih(d);}catch(a){}var
a=c;continue}return 0}}return a(Ij(0))}function
dc(c){var
b=0,a=c;for(;;){if(a){var
b=b+1|0,a=a[2];continue}return b}}function
bl(a){return a?a[1]:ay(hr)}function
b0(d,c){var
a=d,b=c;for(;;){if(a){var
e=[0,a[1],b],a=a[2],b=e;continue}return b}}function
m(a){return b0(a,0)}function
bm(c,a){if(a){var
d=a[2],e=b(c,a[1]);return[0,e,bm(c,d)]}return 0}function
M(d,c){var
a=c;for(;;){if(a){var
e=a[2];b(d,a[1]);var
a=e;continue}return 0}}function
aB(e,d,c){var
b=d,a=c;for(;;){if(a){var
g=a[2],b=f(e,b,a[1]),a=g;continue}return b}}function
eg(d,c){var
b=d,a=c;for(;;){if(0===b)return a;if(a){var
b=b-1|0,a=a[2];continue}throw[0,t,hs]}}function
ad(a){if(0<=a)if(!(K<a))return a;return az(ht)}function
eh(a){if(40<=a){if(92===a)return hu;var
c=B<=a?0:1;}else
if(32<=a){if(39<=a)return hv;var
c=1;}else
if(14<=a)var
c=0;else
switch(a){case
8:return hw;case
9:return hx;case
10:return hy;case
13:return hz;default:var
c=0;}if(c){var
d=Z(1);Q(d,0,a);return d}var
b=Z(4);Q(b,0,92);Q(b,1,48+(a/ae|0)|0);Q(b,2,48+((a/10|0)%10|0)|0);Q(b,3,48+(a%10|0)|0);return b}function
bn(a,c){var
b=Z(a);HN(b,0,a,c);return b}function
ei(a){var
b=s(a),c=Z(b);aA(a,0,c,0,b);return c}function
ej(c,b,a){if(0<=b)if(0<=a)if(!((s(c)-a|0)<b)){var
d=Z(a);aA(c,b,d,0,a);return d}return az(hA)}function
cs(c,b,a){return ej(c,b,a)}function
ek(e,c,d,b,a){if(0<=a)if(0<=c)if(!((s(e)-a|0)<c))if(0<=b)if(!((s(d)-a|0)<b))return aA(e,c,d,b,a);return az(hB)}function
aR(e,c,d,b,a){if(0<=a)if(0<=c)if(!((s(e)-a|0)<c))if(0<=b)if(!((s(d)-a|0)<b))return aA(e,c,d,b,a);return az(hC)}function
hD(e,d,c,b){var
a=c;for(;;){if(d<=a)throw ah;if(ax(e,a)===b)return a;var
a=a+1|0;continue}}function
hE(b,a,d){var
c=s(b);if(0<=a)if(!(c<a))try{hD(b,c,a,d);var
e=1;return e}catch(a){a=aj(a);if(a===ah)return 0;throw a}return az(hF)}function
hG(c,b){if(b){var
e=b[1],g=[0,0],f=[0,0],h=b[2];M(function(a){g[1]++;f[1]=f[1]+s(a)|0;return 0},b);var
d=Z(f[1]+co(s(c),g[1]-1|0)|0);aA(e,0,d,0,s(e));var
a=[0,s(e)];M(function(b){aA(c,0,d,a[1],s(c));a[1]=a[1]+s(c)|0;aA(b,0,d,a[1],s(b));a[1]=a[1]+s(b)|0;return 0},h);return d}return hH}function
el(g,d){var
c=s(d)-1|0,e=0;if(!(c<0)){var
a=e;for(;;){b(g,ax(d,a));var
f=a+1|0;if(c!==a){var
a=f;continue}break}}return 0}var
dd=x;function
hI(b,a){return hE(b,0,a)}var
de=Iv(0)[1],ct=It(0),df=Is(0),b1=(4*df|0)-1|0;a0(0);function
bB(a){if(a){var
d=0,c=a,g=a[2],h=a[1];for(;;){if(c){var
d=d+1|0,c=c[2];continue}var
f=bA(d,h),e=1,b=g;for(;;){if(b){var
i=b[2];f[e+1]=b[1];var
e=e+1|0,b=i;continue}return f}}}return[0]}a0(0);function
aC(e,d,a){var
c=Ie(e,d,a);if(0<=c){a[11]=a[12];var
b=a[12];a[12]=[0,b[1],b[2],b[3],a[4]+a[6]|0];}return c}function
em(e,d,a){var
c=Il(e,d,a);if(0<=c){a[11]=a[12];var
b=a[12];a[12]=[0,b[1],b[2],b[3],a[4]+a[6]|0];}return c}function
cu(a){return cs(a[2],a[5],a[6]-a[5]|0)}function
l(c,a,b){return cs(c[2],a,b-a|0)}function
A(b,a){return _(b[2],a)}function
aD(b){var
a=b[12];b[12]=[0,a[1],a[2]+1|0,a[4],a[4]];return 0}function
cv(h){function
n(a){return a?a[4]:0}function
c(b,e,a){var
c=b?b[4]:0,d=a?a[4]:0,f=d<=c?c+1|0:d+1|0;return[0,b,e,a,f]}function
e(b,f,a){var
g=b?b[4]:0,h=a?a[4]:0;if((h+2|0)<g){if(b){var
d=b[3],k=b[2],i=b[1],m=n(d);if(m<=n(i))return c(i,k,c(d,f,a));if(d){var
o=d[2],p=d[1],q=c(d[3],f,a);return c(c(i,k,p),o,q)}return az(hL)}return az(hM)}if((g+2|0)<h){if(a){var
j=a[3],l=a[2],e=a[1],r=n(e);if(r<=n(j))return c(c(b,f,e),l,j);if(e){var
s=e[2],t=e[1],u=c(e[3],l,j);return c(c(b,f,t),s,u)}return az(hN)}return az(hO)}var
v=h<=g?g+1|0:h+1|0;return[0,b,f,a,v]}function
a(c,b){if(b){var
d=b[3],g=b[2],i=b[1],j=f(h[1],c,g);if(0===j)return b;if(0<=j){var
k=a(c,d);return d===k?b:e(i,g,k)}var
l=a(c,i);return i===l?b:e(l,g,d)}return[0,0,c,0,1]}function
g(a){return[0,0,a,0,1]}function
x(b,a){if(a){var
c=a[3],d=a[2];return e(x(b,a[1]),d,c)}return g(b)}function
y(b,a){if(a){var
c=a[2],d=a[1];return e(d,c,y(b,a[3]))}return g(b)}function
d(b,f,a){if(b){if(a){var
g=a[4],h=b[4],i=a[3],j=a[2],k=a[1],l=b[3],m=b[2],n=b[1];return(g+2|0)<h?e(n,m,d(l,f,a)):(h+2|0)<g?e(d(b,f,k),j,i):c(b,f,a)}return y(f,b)}return x(f,a)}function
o(c){var
a=c;for(;;){if(a){var
b=a[1];if(b){var
a=b;continue}return a[2]}throw ah}}function
G(c){var
a=c;for(;;){if(a){var
b=a[3],d=a[2];if(b){var
a=b;continue}return d}throw ah}}function
r(a){if(a){var
b=a[1];if(b){var
c=a[3],d=a[2];return e(r(b),d,c)}return a[3]}return az(hP)}function
j(b,a){if(b){if(a){var
c=r(a);return d(b,o(a),c)}return b}return a}function
i(b,a){if(a){var
c=a[3],e=a[2],g=a[1],l=f(h[1],b,e);if(0===l)return[0,g,1,c];if(0<=l){var
j=i(b,c),m=j[3],n=j[2];return[0,d(g,e,j[1]),n,m]}var
k=i(b,g),o=k[2],p=k[1];return[0,p,o,d(k[3],e,c)]}return hQ}var
z=0;function
H(a){return a?0:1}function
I(e,d){var
a=d;for(;;){if(a){var
g=a[3],i=a[1],b=f(h[1],e,a[2]),c=0===b?1:0;if(c)return c;var
j=0<=b?g:i,a=j;continue}return 0}}function
s(d,b){if(b){var
a=b[3],g=b[2],c=b[1],i=f(h[1],d,g);if(0===i){if(c){if(a){var
l=r(a);return e(c,o(a),l)}return c}return a}if(0<=i){var
j=s(d,a);return a===j?b:e(c,g,j)}var
k=s(d,c);return c===k?b:e(k,g,a)}return 0}function
k(c,b){if(c){if(b){var
g=b[4],e=b[2],h=c[4],f=c[2],m=b[3],n=b[1],o=c[3],p=c[1];if(g<=h){if(1===g)return a(e,c);var
j=i(f,b),q=j[1],r=k(o,j[3]);return d(k(p,q),f,r)}if(1===h)return a(f,b);var
l=i(e,c),s=l[1],t=k(l[3],m);return d(k(s,n),e,t)}return c}return b}function
l(a,c){if(a){if(c){var
e=a[3],f=a[2],g=a[1],b=i(f,c),h=b[1];if(0===b[2]){var
k=l(e,b[3]);return j(l(g,h),k)}var
m=l(e,b[3]);return d(l(g,h),f,m)}return 0}return 0}function
m(a,c){if(a){if(c){var
e=a[3],f=a[2],g=a[1],b=i(f,c),h=b[1];if(0===b[2]){var
k=m(e,b[3]);return d(m(g,h),f,k)}var
l=m(e,b[3]);return j(m(g,h),l)}return a}return 0}function
p(d,c){var
a=d,b=c;for(;;){if(a){var
e=[0,a[2],a[3],b],a=a[1],b=e;continue}return b}}function
A(l,k){var
m=p(k,0),b=p(l,0),a=m;for(;;){if(b){if(a){var
d=a[3],e=a[2],g=b[3],i=b[2],c=f(h[1],b[1],a[1]);if(0===c){var
j=p(e,d),b=p(i,g),a=j;continue}return c}return 1}return a?-1:0}}function
J(b,a){return 0===A(b,a)?1:0}function
q(o,n){var
a=o,b=n;for(;;){if(a){if(b){var
g=b[3],i=b[1],c=a[3],d=a[2],e=a[1],j=f(h[1],d,b[2]);if(0===j){var
k=q(e,i);if(k){var
a=c,b=g;continue}return k}if(0<=j){var
l=q([0,0,d,c,0],g);if(l){var
a=e;continue}return l}var
m=q([0,e,d,0,0],i);if(m){var
a=c;continue}return m}return 0}return 1}}function
B(c,d){var
a=d;for(;;){if(a){var
e=a[3],f=a[2];B(c,a[1]);b(c,f);var
a=e;continue}return 0}}function
C(c,e,d){var
a=e,b=d;for(;;){if(a){var
g=a[3],h=a[2],i=f(c,h,C(c,a[1],b)),a=g,b=i;continue}return b}}function
D(c,g){var
a=g;for(;;){if(a){var
h=a[3],i=a[1],d=b(c,a[2]);if(d){var
e=D(c,i);if(e){var
a=h;continue}var
f=e;}else
var
f=d;return f}return 1}}function
E(c,g){var
a=g;for(;;){if(a){var
h=a[3],i=a[1],d=b(c,a[2]);if(d)var
e=d;else{var
f=E(c,i);if(!f){var
a=h;continue}var
e=f;}return e}return 0}}function
u(c,a){if(a){var
g=a[3],h=a[2],i=a[1],e=u(c,i),k=b(c,h),f=u(c,g);if(k){if(i===e)if(g===f)return a;return d(e,h,f)}return j(e,f)}return 0}function
v(c,a){if(a){var
e=a[2],m=a[3],f=v(c,a[1]),g=f[2],h=f[1],n=b(c,e),i=v(c,m),k=i[2],l=i[1];if(n){var
o=j(g,k);return[0,d(h,e,l),o]}var
p=d(g,e,k);return[0,j(h,l),p]}return hR}function
w(a){if(a){var
b=a[1],c=w(a[3]);return(w(b)+1|0)+c|0}return 0}function
F(d,c){var
b=d,a=c;for(;;){if(a){var
e=a[2],f=a[1],b=[0,e,F(b,a[3])],a=f;continue}return b}}function
K(a){return F(0,a)}function
L(e,d){var
a=d;for(;;){if(a){var
b=a[2],g=a[3],i=a[1],c=f(h[1],e,b);if(0===c)return b;var
j=0<=c?g:i,a=j;continue}throw ah}}return[0,z,H,I,a,g,s,k,l,m,A,J,q,B,C,D,E,u,v,w,K,o,G,o,i,L,function(d){if(d){var
k=d[2],e=d[1];if(k){var
l=k[2],i=k[1];if(l){var
n=l[2],o=l[1];if(n){var
p=n[2],r=n[1];if(p){if(p[2]){var
b=h[1],m=function(j,g){if(2===j){if(g){var
t=g[2];if(t){var
m=t[1],k=g[1],v=f(b,k,m);return 0===v?[0,k,0]:0<=v?[0,m,[0,k,0]]:[0,k,[0,m,0]]}}}else
if(3===j)if(g){var
o=g[2];if(o){var
w=o[2];if(w){var
c=w[1],a=o[1],d=g[1],x=f(b,d,a);if(0===x){var
y=f(b,a,c);return 0===y?[0,a,0]:0<=y?[0,c,[0,a,0]]:[0,a,[0,c,0]]}if(0<=x){var
z=f(b,d,c);if(0===z)return[0,a,[0,d,0]];if(0<=z){var
A=f(b,a,c);return 0===A?[0,a,[0,d,0]]:0<=A?[0,c,[0,a,[0,d,0]]]:[0,a,[0,c,[0,d,0]]]}return[0,a,[0,d,[0,c,0]]]}var
B=f(b,a,c);if(0===B)return[0,d,[0,a,0]];if(0<=B){var
C=f(b,d,c);return 0===C?[0,d,[0,a,0]]:0<=C?[0,c,[0,d,[0,a,0]]]:[0,d,[0,c,[0,a,0]]]}return[0,d,[0,a,[0,c,0]]]}}}var
n=j>>1,D=eg(n,g),E=u(n,g),i=E,h=u(j-n|0,D),e=0;for(;;){if(i){if(h){var
p=h[2],q=h[1],r=i[2],l=i[1],s=f(b,l,q);if(0===s){var
i=r,h=p,e=[0,l,e];continue}if(0<s){var
i=r,e=[0,l,e];continue}var
h=p,e=[0,q,e];continue}return b0(i,e)}return b0(h,e)}},u=function(j,g){if(2===j){if(g){var
u=g[2];if(u){var
n=u[1],k=g[1],v=f(b,k,n);return 0===v?[0,k,0]:0<v?[0,k,[0,n,0]]:[0,n,[0,k,0]]}}}else
if(3===j)if(g){var
p=g[2];if(p){var
w=p[2];if(w){var
c=w[1],a=p[1],d=g[1],x=f(b,d,a);if(0===x){var
y=f(b,a,c);return 0===y?[0,a,0]:0<y?[0,a,[0,c,0]]:[0,c,[0,a,0]]}if(0<x){var
z=f(b,a,c);if(0===z)return[0,d,[0,a,0]];if(0<z)return[0,d,[0,a,[0,c,0]]];var
A=f(b,d,c);return 0===A?[0,d,[0,a,0]]:0<A?[0,d,[0,c,[0,a,0]]]:[0,c,[0,d,[0,a,0]]]}var
B=f(b,d,c);if(0===B)return[0,a,[0,d,0]];if(0<B)return[0,a,[0,d,[0,c,0]]];var
C=f(b,a,c);return 0===C?[0,a,[0,d,0]]:0<C?[0,a,[0,c,[0,d,0]]]:[0,c,[0,a,[0,d,0]]]}}}var
o=j>>1,D=eg(o,g),E=m(o,g),i=E,h=m(j-o|0,D),e=0;for(;;){if(i){if(h){var
q=h[2],r=h[1],s=i[2],l=i[1],t=f(b,l,r);if(0===t){var
i=s,h=q,e=[0,l,e];continue}if(0<=t){var
h=q,e=[0,r,e];continue}var
i=s,e=[0,l,e];continue}return b0(i,e)}return b0(h,e)}},q=dc(d),s=2<=q?m(q,d):d,j=function(b,a){if(!(3<b>>>0))switch(b){case
0:return[0,0,a];case
1:if(a)return[0,[0,0,a[1],0,1],a[2]];break;case
2:if(a){var
e=a[2];if(e)return[0,[0,[0,0,a[1],0,1],e[1],0,2],e[2]]}break;default:if(a){var
f=a[2];if(f){var
g=f[2];if(g)return[0,[0,[0,0,a[1],0,1],f[1],[0,0,g[1],0,1],2],g[2]]}}}var
h=b/2|0,i=j(h,a),d=i[2],l=i[1];if(d){var
m=d[1],k=j((b-h|0)-1|0,d[2]),n=k[2];return[0,c(l,m,k[1]),n]}throw[0,t,hS]};return j(dc(s),s)[1]}var
v=p[1];return a(v,a(r,a(o,a(i,g(e)))))}return a(r,a(o,a(i,g(e))))}return a(o,a(i,g(e)))}return a(i,g(e))}return g(e)}return z}]}a0(0);var
hU=[W,hT,a0(0)];function
hV(a){throw hU}function
hW(a){var
d=a[1];a[1]=hV;try{var
c=b(d,0);a[1]=c;Im(a,cj);return c}catch(b){b=aj(b);a[1]=function(a){throw b};throw b}}function
C(a){var
b=1<=a?a:1,c=b1<b?b1:b,d=Z(c);return[0,d,0,c,d]}function
T(a){return cs(a[1],0,a[2])}function
eo(a,c){var
b=[0,a[3]];for(;;){if(b[1]<(a[2]+c|0)){b[1]=2*b[1]|0;continue}if(b1<b[1])if((a[2]+c|0)<=b1)b[1]=b1;else
ay(hX);var
d=Z(b[1]);ek(a[1],0,d,0,a[2]);a[1]=d;a[3]=b[1];return 0}}function
o(a,c){var
b=a[2];if(a[3]<=b)eo(a,1);Q(a[1],b,c);a[2]=b+1|0;return 0}function
y(a,c){var
b=s(c),d=a[2]+b|0;if(a[3]<d)eo(a,b);aR(c,0,a[1],a[2],b);a[2]=d;return 0}var
dg=-6;function
ep(a){return[0,0,Z(a)]}function
eq(a,g){var
b=s(a[2]),c=a[1]+g|0,d=b<c?1:0;if(d){var
e=Z(da(b*2|0,c));ek(a[2],0,e,0,b);a[2]=e;var
f=0;}else
var
f=d;return f}function
b2(a,b){eq(a,1);cp(a[2],a[1],b);a[1]=a[1]+1|0;return 0}function
$(a,c){var
b=s(c);eq(a,b);aR(c,0,a[2],a[1],b);a[1]=a[1]+b|0;return 0}function
er(a){return cs(a[2],0,a[1])}function
dh(b,c){var
a=c;for(;;)if(typeof
a==="number")return 0;else
switch(a[0]){case
0:var
d=a[1];$(b,h6);var
a=d;continue;case
1:var
e=a[1];$(b,h7);var
a=e;continue;case
2:var
f=a[1];$(b,h8);var
a=f;continue;case
3:var
g=a[1];$(b,h9);var
a=g;continue;case
4:var
h=a[1];$(b,h_);var
a=h;continue;case
5:var
i=a[1];$(b,h$);var
a=i;continue;case
6:var
j=a[1];$(b,ia);var
a=j;continue;case
7:var
k=a[1];$(b,ib);var
a=k;continue;case
8:var
l=a[2],m=a[1];$(b,ic);dh(b,m);$(b,id);var
a=l;continue;case
9:var
n=a[3],o=a[1];$(b,ie);dh(b,o);$(b,ig);var
a=n;continue;case
10:var
p=a[1];$(b,ih);var
a=p;continue;case
11:var
q=a[1];$(b,ii);var
a=q;continue;case
12:var
r=a[1];$(b,ij);var
a=r;continue;case
13:var
s=a[1];$(b,ik);var
a=s;continue;default:var
t=a[1];$(b,il);var
a=t;continue}}function
R(a){if(typeof
a==="number")return 0;else
switch(a[0]){case
0:return[0,R(a[1])];case
1:return[1,R(a[1])];case
2:return[2,R(a[1])];case
3:return[3,R(a[1])];case
4:return[4,R(a[1])];case
5:return[5,R(a[1])];case
6:return[6,R(a[1])];case
7:return[7,R(a[1])];case
8:var
b=a[1];return[8,b,R(a[2])];case
9:var
c=a[2],d=a[1];return[9,c,d,R(a[3])];case
10:return[10,R(a[1])];case
11:return[11,R(a[1])];case
12:return[12,R(a[1])];case
13:return[13,R(a[1])];default:return[14,R(a[1])]}}function
aa(a){if(typeof
a==="number"){var
s=function(a){return 0},t=function(a){return 0},u=function(a){return 0};return[0,function(a){return 0},u,t,s]}else
switch(a[0]){case
0:var
c=aa(a[1]),v=c[4],w=c[3],x=c[2],y=c[1],z=function(a){b(x,0);return 0};return[0,function(a){b(y,0);return 0},z,w,v];case
1:var
d=aa(a[1]),A=d[4],B=d[3],C=d[2],D=d[1],E=function(a){b(C,0);return 0};return[0,function(a){b(D,0);return 0},E,B,A];case
2:var
e=aa(a[1]),F=e[4],G=e[3],H=e[2],I=e[1],J=function(a){b(H,0);return 0};return[0,function(a){b(I,0);return 0},J,G,F];case
3:var
f=aa(a[1]),K=f[4],L=f[3],M=f[2],N=f[1],O=function(a){b(M,0);return 0};return[0,function(a){b(N,0);return 0},O,L,K];case
4:var
g=aa(a[1]),P=g[4],Q=g[3],S=g[2],T=g[1],V=function(a){b(S,0);return 0};return[0,function(a){b(T,0);return 0},V,Q,P];case
5:var
h=aa(a[1]),W=h[4],X=h[3],Y=h[2],Z=h[1],_=function(a){b(Y,0);return 0};return[0,function(a){b(Z,0);return 0},_,X,W];case
6:var
i=aa(a[1]),$=i[4],ab=i[3],ac=i[2],ad=i[1],ae=function(a){b(ac,0);return 0};return[0,function(a){b(ad,0);return 0},ae,ab,$];case
7:var
j=aa(a[1]),af=j[4],ag=j[3],ah=j[2],ai=j[1],aj=function(a){b(ah,0);return 0};return[0,function(a){b(ai,0);return 0},aj,ag,af];case
8:var
k=aa(a[2]),ak=k[4],al=k[3],am=k[2],an=k[1],ao=function(a){b(am,0);return 0};return[0,function(a){b(an,0);return 0},ao,al,ak];case
9:var
ap=a[2],aq=a[1],l=aa(a[3]),ar=l[4],as=l[3],at=l[2],au=l[1],m=aa(U(R(aq),ap)),av=m[4],aw=m[3],ax=m[2],ay=m[1],az=function(a){b(av,0);b(ar,0);return 0},aA=function(a){b(as,0);b(aw,0);return 0},aB=function(a){b(ax,0);b(at,0);return 0};return[0,function(a){b(au,0);b(ay,0);return 0},aB,aA,az];case
10:var
n=aa(a[1]),aC=n[4],aD=n[3],aE=n[2],aF=n[1],aG=function(a){b(aE,0);return 0};return[0,function(a){b(aF,0);return 0},aG,aD,aC];case
11:var
o=aa(a[1]),aH=o[4],aI=o[3],aJ=o[2],aK=o[1],aL=function(a){b(aJ,0);return 0};return[0,function(a){b(aK,0);return 0},aL,aI,aH];case
12:var
p=aa(a[1]),aM=p[4],aN=p[3],aO=p[2],aP=p[1],aQ=function(a){b(aO,0);return 0};return[0,function(a){b(aP,0);return 0},aQ,aN,aM];case
13:var
q=aa(a[1]),aR=q[4],aS=q[3],aT=q[2],aU=q[1],aV=function(a){b(aR,0);return 0},aW=function(a){b(aS,0);return 0},aX=function(a){b(aT,0);return 0};return[0,function(a){b(aU,0);return 0},aX,aW,aV];default:var
r=aa(a[1]),aY=r[4],aZ=r[3],a0=r[2],a1=r[1],a2=function(a){b(aY,0);return 0},a3=function(a){b(aZ,0);return 0},a4=function(a){b(a0,0);return 0};return[0,function(a){b(a1,0);return 0},a4,a3,a2]}}function
U(d,c){if(typeof
d==="number")if(typeof
c==="number")return 0;else
switch(c[0]){case
10:var
a=0;break;case
11:var
a=1;break;case
12:var
a=2;break;case
13:var
a=3;break;case
14:var
a=4;break;case
8:var
a=5;break;case
9:var
a=6;break;default:throw[0,t,im]}else
switch(d[0]){case
0:var
u=d[1];if(typeof
c==="number")var
e=1;else
switch(c[0]){case
0:return[0,U(u,c[1])];case
8:var
a=5,e=0;break;case
9:var
a=6,e=0;break;case
10:var
a=0,e=0;break;case
11:var
a=1,e=0;break;case
12:var
a=2,e=0;break;case
13:var
a=3,e=0;break;case
14:var
a=4,e=0;break;default:var
e=1;}if(e)var
a=7;break;case
1:var
v=d[1];if(typeof
c==="number")var
f=1;else
switch(c[0]){case
1:return[1,U(v,c[1])];case
8:var
a=5,f=0;break;case
9:var
a=6,f=0;break;case
10:var
a=0,f=0;break;case
11:var
a=1,f=0;break;case
12:var
a=2,f=0;break;case
13:var
a=3,f=0;break;case
14:var
a=4,f=0;break;default:var
f=1;}if(f)var
a=7;break;case
2:var
w=d[1];if(typeof
c==="number")var
g=1;else
switch(c[0]){case
2:return[2,U(w,c[1])];case
8:var
a=5,g=0;break;case
9:var
a=6,g=0;break;case
10:var
a=0,g=0;break;case
11:var
a=1,g=0;break;case
12:var
a=2,g=0;break;case
13:var
a=3,g=0;break;case
14:var
a=4,g=0;break;default:var
g=1;}if(g)var
a=7;break;case
3:var
x=d[1];if(typeof
c==="number")var
h=1;else
switch(c[0]){case
3:return[3,U(x,c[1])];case
8:var
a=5,h=0;break;case
9:var
a=6,h=0;break;case
10:var
a=0,h=0;break;case
11:var
a=1,h=0;break;case
12:var
a=2,h=0;break;case
13:var
a=3,h=0;break;case
14:var
a=4,h=0;break;default:var
h=1;}if(h)var
a=7;break;case
4:var
y=d[1];if(typeof
c==="number")var
i=1;else
switch(c[0]){case
4:return[4,U(y,c[1])];case
8:var
a=5,i=0;break;case
9:var
a=6,i=0;break;case
10:var
a=0,i=0;break;case
11:var
a=1,i=0;break;case
12:var
a=2,i=0;break;case
13:var
a=3,i=0;break;case
14:var
a=4,i=0;break;default:var
i=1;}if(i)var
a=7;break;case
5:var
z=d[1];if(typeof
c==="number")var
j=1;else
switch(c[0]){case
5:return[5,U(z,c[1])];case
8:var
a=5,j=0;break;case
9:var
a=6,j=0;break;case
10:var
a=0,j=0;break;case
11:var
a=1,j=0;break;case
12:var
a=2,j=0;break;case
13:var
a=3,j=0;break;case
14:var
a=4,j=0;break;default:var
j=1;}if(j)var
a=7;break;case
6:var
A=d[1];if(typeof
c==="number")var
k=1;else
switch(c[0]){case
6:return[6,U(A,c[1])];case
8:var
a=5,k=0;break;case
9:var
a=6,k=0;break;case
10:var
a=0,k=0;break;case
11:var
a=1,k=0;break;case
12:var
a=2,k=0;break;case
13:var
a=3,k=0;break;case
14:var
a=4,k=0;break;default:var
k=1;}if(k)var
a=7;break;case
7:var
B=d[1];if(typeof
c==="number")var
l=1;else
switch(c[0]){case
7:return[7,U(B,c[1])];case
8:var
a=5,l=0;break;case
9:var
a=6,l=0;break;case
10:var
a=0,l=0;break;case
11:var
a=1,l=0;break;case
12:var
a=2,l=0;break;case
13:var
a=3,l=0;break;case
14:var
a=4,l=0;break;default:var
l=1;}if(l)var
a=7;break;case
8:var
C=d[2],D=d[1];if(typeof
c==="number")var
n=1;else
switch(c[0]){case
8:var
E=c[1],F=U(C,c[2]);return[8,U(D,E),F];case
10:var
a=0,n=0;break;case
11:var
a=1,n=0;break;case
12:var
a=2,n=0;break;case
13:var
a=3,n=0;break;case
14:var
a=4,n=0;break;default:var
n=1;}if(n)throw[0,t,iw];break;case
9:var
G=d[3],H=d[2],I=d[1];if(typeof
c==="number")var
m=1;else
switch(c[0]){case
8:var
a=5,m=0;break;case
9:var
J=c[3],K=c[2],L=c[1],s=aa(U(R(H),L)),M=s[4];b(s[2],0);b(M,0);return[9,I,K,U(G,J)];case
10:var
a=0,m=0;break;case
11:var
a=1,m=0;break;case
12:var
a=2,m=0;break;case
13:var
a=3,m=0;break;case
14:var
a=4,m=0;break;default:var
m=1;}if(m)throw[0,t,ix];break;case
10:var
N=d[1];if(typeof
c!=="number"&&10===c[0])return[10,U(N,c[1])];throw[0,t,iy];case
11:var
O=d[1];if(typeof
c==="number")var
r=1;else
switch(c[0]){case
10:var
a=0,r=0;break;case
11:return[11,U(O,c[1])];default:var
r=1;}if(r)throw[0,t,iz];break;case
12:var
P=d[1];if(typeof
c==="number")var
q=1;else
switch(c[0]){case
10:var
a=0,q=0;break;case
11:var
a=1,q=0;break;case
12:return[12,U(P,c[1])];default:var
q=1;}if(q)throw[0,t,iA];break;case
13:var
Q=d[1];if(typeof
c==="number")var
p=1;else
switch(c[0]){case
10:var
a=0,p=0;break;case
11:var
a=1,p=0;break;case
12:var
a=2,p=0;break;case
13:return[13,U(Q,c[1])];default:var
p=1;}if(p)throw[0,t,iB];break;default:var
S=d[1];if(typeof
c==="number")var
o=1;else
switch(c[0]){case
10:var
a=0,o=0;break;case
11:var
a=1,o=0;break;case
12:var
a=2,o=0;break;case
13:var
a=3,o=0;break;case
14:return[14,U(S,c[1])];default:var
o=1;}if(o)throw[0,t,iC]}switch(a){case
0:throw[0,t,iq];case
1:throw[0,t,ir];case
2:throw[0,t,is];case
3:throw[0,t,it];case
4:throw[0,t,iu];case
5:throw[0,t,io];case
6:throw[0,t,ip];default:throw[0,t,iv]}}var
ab=[W,iD,a0(0)];function
di(b,a){if(typeof
b==="number")return[0,0,a];else{if(0===b[0])return[0,[0,b[1],b[2]],a];if(typeof
a!=="number"&&2===a[0])return[0,[1,b[1]],a[1]];throw ab}}function
b3(e,b,d){var
a=di(e,d);if(typeof
b==="number"){if(0===b)return[0,a[1],0,a[2]];var
c=a[2];if(typeof
c!=="number"&&2===c[0])return[0,a[1],1,c[1]];throw ab}return[0,a[1],[0,b[1]],a[2]]}function
D(b,a){if(typeof
b==="number")return[0,0,a];else
switch(b[0]){case
0:if(typeof
a!=="number"&&0===a[0]){var
r=D(b[1],a[1]);return[0,[0,r[1]],r[2]]}break;case
1:if(typeof
a!=="number"&&0===a[0]){var
s=D(b[1],a[1]);return[0,[1,s[1]],s[2]]}break;case
2:var
aa=b[2],t=di(b[1],a),e=t[2],ac=t[1];if(typeof
e!=="number"&&1===e[0]){var
u=D(aa,e[1]);return[0,[2,ac,u[1]],u[2]]}throw ab;case
3:var
ad=b[2],v=di(b[1],a),f=v[2],ae=v[1];if(typeof
f!=="number"&&1===f[0]){var
w=D(ad,f[1]);return[0,[3,ae,w[1]],w[2]]}throw ab;case
4:var
af=b[4],ag=b[1],g=b3(b[2],b[3],a),h=g[3],ah=g[2],ai=g[1];if(typeof
h!=="number"&&2===h[0]){var
x=D(af,h[1]);return[0,[4,ag,ai,ah,x[1]],x[2]]}throw ab;case
5:var
aj=b[4],al=b[1],i=b3(b[2],b[3],a),j=i[3],am=i[2],an=i[1];if(typeof
j!=="number"&&3===j[0]){var
y=D(aj,j[1]);return[0,[5,al,an,am,y[1]],y[2]]}throw ab;case
6:var
ao=b[4],aq=b[1],k=b3(b[2],b[3],a),l=k[3],ar=k[2],as=k[1];if(typeof
l!=="number"&&4===l[0]){var
z=D(ao,l[1]);return[0,[6,aq,as,ar,z[1]],z[2]]}throw ab;case
7:var
at=b[4],au=b[1],m=b3(b[2],b[3],a),n=m[3],av=m[2],aw=m[1];if(typeof
n!=="number"&&5===n[0]){var
A=D(at,n[1]);return[0,[7,au,aw,av,A[1]],A[2]]}throw ab;case
8:var
ax=b[4],ay=b[1],o=b3(b[2],b[3],a),p=o[3],az=o[2],aA=o[1];if(typeof
p!=="number"&&6===p[0]){var
B=D(ax,p[1]);return[0,[8,ay,aA,az,B[1]],B[2]]}throw ab;case
9:if(typeof
a!=="number"&&7===a[0]){var
C=D(b[1],a[1]);return[0,[9,C[1]],C[2]]}break;case
10:var
E=D(b[1],a);return[0,[10,E[1]],E[2]];case
11:var
aB=b[1],F=D(b[2],a);return[0,[11,aB,F[1]],F[2]];case
12:var
aC=b[1],G=D(b[2],a);return[0,[12,aC,G[1]],G[2]];case
13:if(typeof
a!=="number"&&8===a[0]){var
H=a[1],aD=a[2],aE=b[3],aF=b[1];if(bY([0,b[2]],[0,H]))throw ab;var
I=D(aE,aD);return[0,[13,aF,H,I[1]],I[2]]}break;case
14:if(typeof
a!=="number"&&9===a[0]){var
J=a[1],aG=a[3],aH=b[3],aI=b[2],aJ=b[1],aK=[0,L(J)];if(bY([0,L(aI)],aK))throw ab;var
K=D(aH,L(aG));return[0,[14,aJ,J,K[1]],K[2]]}break;case
15:if(typeof
a!=="number"&&10===a[0]){var
M=D(b[1],a[1]);return[0,[15,M[1]],M[2]]}break;case
16:if(typeof
a!=="number"&&11===a[0]){var
N=D(b[1],a[1]);return[0,[16,N[1]],N[2]]}break;case
17:var
aL=b[1],O=D(b[2],a);return[0,[17,aL,O[1]],O[2]];case
18:var
P=b[2],q=b[1];if(0===q[0]){var
T=q[1],aP=T[2],U=D(T[1],a),aQ=U[1],V=D(P,U[2]);return[0,[18,[0,[0,aQ,aP]],V[1]],V[2]]}var
W=q[1],aR=W[2],X=D(W[1],a),aS=X[1],Y=D(P,X[2]);return[0,[18,[1,[0,aS,aR]],Y[1]],Y[2]];case
19:if(typeof
a!=="number"&&13===a[0]){var
Q=D(b[1],a[1]);return[0,[19,Q[1]],Q[2]]}break;case
20:if(typeof
a!=="number"&&1===a[0]){var
aM=b[2],aN=b[1],R=D(b[3],a[1]);return[0,[20,aN,aM,R[1]],R[2]]}break;case
21:if(typeof
a!=="number"&&2===a[0]){var
aO=b[1],S=D(b[2],a[1]);return[0,[21,aO,S[1]],S[2]]}break;case
23:var
d=b[2],c=b[1];if(typeof
c==="number")switch(c){case
0:return ap(c,d,a);case
1:return ap(c,d,a);case
2:return ap(c,d,a);case
3:if(typeof
a!=="number"&&14===a[0]){var
Z=D(d,a[1]);return[0,[23,3,Z[1]],Z[2]]}throw ab;default:return ap(c,d,a)}else
switch(c[0]){case
0:return ap(c,d,a);case
1:return ap(c,d,a);case
2:return ap(c,d,a);case
3:return ap(c,d,a);case
4:return ap(c,d,a);case
5:return ap(c,d,a);case
6:return ap(c,d,a);case
7:return ap([7,c[1],c[2]],d,a);case
8:var
aT=c[1],_=ak(c[2],d,a),$=_[2];return[0,[23,[8,aT,_[1]],$[1]],$[2]];case
9:return ap(c,d,a);default:return ap(c,d,a)}}throw ab}function
ap(d,c,b){var
a=D(c,b);return[0,[23,d,a[1]],a[2]]}function
ak(c,d,a){if(typeof
c==="number")return[0,0,D(d,a)];else
switch(c[0]){case
0:if(typeof
a!=="number"&&0===a[0]){var
g=ak(c[1],d,a[1]);return[0,[0,g[1]],g[2]]}break;case
1:if(typeof
a!=="number"&&1===a[0]){var
h=ak(c[1],d,a[1]);return[0,[1,h[1]],h[2]]}break;case
2:if(typeof
a!=="number"&&2===a[0]){var
i=ak(c[1],d,a[1]);return[0,[2,i[1]],i[2]]}break;case
3:if(typeof
a!=="number"&&3===a[0]){var
j=ak(c[1],d,a[1]);return[0,[3,j[1]],j[2]]}break;case
4:if(typeof
a!=="number"&&4===a[0]){var
k=ak(c[1],d,a[1]);return[0,[4,k[1]],k[2]]}break;case
5:if(typeof
a!=="number"&&5===a[0]){var
l=ak(c[1],d,a[1]);return[0,[5,l[1]],l[2]]}break;case
6:if(typeof
a!=="number"&&6===a[0]){var
m=ak(c[1],d,a[1]);return[0,[6,m[1]],m[2]]}break;case
7:if(typeof
a!=="number"&&7===a[0]){var
n=ak(c[1],d,a[1]);return[0,[7,n[1]],n[2]]}break;case
8:if(typeof
a!=="number"&&8===a[0]){var
o=a[1],w=a[2],x=c[2];if(bY([0,c[1]],[0,o]))throw ab;var
p=ak(x,d,w);return[0,[8,o,p[1]],p[2]]}break;case
9:if(typeof
a!=="number"&&9===a[0]){var
e=a[2],f=a[1],y=a[3],z=c[3],A=c[2],B=c[1],C=[0,L(f)];if(bY([0,L(B)],C))throw ab;var
E=[0,L(e)];if(bY([0,L(A)],E))throw ab;var
q=aa(U(R(f),e)),F=q[4];b(q[2],0);b(F,0);var
r=ak(L(z),d,y),G=r[2];return[0,[9,f,e,R(r[1])],G]}break;case
10:if(typeof
a!=="number"&&10===a[0]){var
s=ak(c[1],d,a[1]);return[0,[10,s[1]],s[2]]}break;case
11:if(typeof
a!=="number"&&11===a[0]){var
t=ak(c[1],d,a[1]);return[0,[11,t[1]],t[2]]}break;case
13:if(typeof
a!=="number"&&13===a[0]){var
u=ak(c[1],d,a[1]);return[0,[13,u[1]],u[2]]}break;case
14:if(typeof
a!=="number"&&14===a[0]){var
v=ak(c[1],d,a[1]);return[0,[14,v[1]],v[2]]}break}throw ab}function
aq(k,i,a){var
b=s(a),j=0<=i?k:0,d=db(i);if(d<=b)return a;var
l=2===j?48:32,c=bn(d,l);switch(j){case
0:aR(a,0,c,0,b);break;case
1:aR(a,0,c,d-b|0,b);break;default:if(0<b){if(43===_(a,0))var
e=1;else
if(45===_(a,0))var
e=1;else
if(32===_(a,0))var
e=1;else
var
g=0,e=0;if(e){cp(c,0,_(a,0));aR(a,1,c,(d-b|0)+1|0,b-1|0);var
g=1;}}else
var
g=0;if(!g){if(1<b)if(48===_(a,0)){if(d4===_(a,1))var
h=1;else
if(88===_(a,1))var
h=1;else
var
f=0,h=0;if(h){cp(c,1,_(a,1));aR(a,2,c,(d-b|0)+2|0,b-2|0);var
f=1;}}else
var
f=0;else
var
f=0;if(!f)aR(a,0,c,d-b|0,b);}}return c}function
bC(j,b){var
c=db(j),a=s(b),d=_(b,0);if(58<=d)var
e=71<=d?5<(d+fz|0)>>>0?1:0:65<=d?0:1;else{if(32===d)var
f=1;else
if(43<=d)switch(d+f4|0){case
5:if(a<(c+2|0))if(1<a){var
k=d4===_(b,1)?0:88===_(b,1)?0:1;if(!k){var
h=bn(c+2|0,48);cp(h,1,_(b,1));aR(b,2,h,(c-a|0)+4|0,a-2|0);return h}}var
e=0,f=0;break;case
0:case
2:var
f=1;break;case
1:case
3:case
4:var
e=1,f=0;break;default:var
e=0,f=0;}else
var
e=1,f=0;if(f){if(a<(c+1|0)){var
g=bn(c+1|0,48);cp(g,0,d);aR(b,1,g,(c-a|0)+2|0,a-1|0);return g}var
e=1;}}if(!e)if(a<c){var
i=bn(c,48);aR(b,0,i,c-a|0,a);return i}return b}function
iE(d){var
j=0;for(;;){if(s(d)<=j)var
v=0;else{var
g=ax(d,j);if(32<=g){var
q=g+fs|0;if(58<q>>>0)if(93<=q)var
r=0,l=0;else
var
l=1;else
if(56<(q-1|0)>>>0)var
r=1,l=0;else
var
l=1;if(l){var
j=j+1|0;continue}}else
var
r=11<=g?13===g?1:0:8<=g?1:0;var
v=r?1:1;}if(v){var
a=[0,0],t=s(d)-1|0,y=0;if(!(t<0)){var
i=y;for(;;){var
f=ax(d,i);if(32<=f){var
o=f+fs|0;if(58<o>>>0)if(93<=o)var
m=0,n=0;else
var
n=1;else
if(56<(o-1|0)>>>0)var
m=1,n=0;else
var
n=1;if(n)var
p=1,m=2;}else
var
m=11<=f?13===f?1:0:8<=f?1:0;switch(m){case
0:var
p=4;break;case
1:var
p=2;break}a[1]=a[1]+p|0;var
C=i+1|0;if(t!==i){var
i=C;continue}break}}if(a[1]===s(d))var
k=ei(d);else{var
b=Z(a[1]);a[1]=0;var
u=s(d)-1|0,z=0;if(!(u<0)){var
h=z;for(;;){var
c=ax(d,h);if(35<=c)var
e=92===c?1:B<=c?0:2;else
if(32<=c)var
e=34<=c?1:2;else
if(14<=c)var
e=0;else
switch(c){case
8:Q(b,a[1],92);a[1]++;Q(b,a[1],98);var
e=3;break;case
9:Q(b,a[1],92);a[1]++;Q(b,a[1],f8);var
e=3;break;case
10:Q(b,a[1],92);a[1]++;Q(b,a[1],cK);var
e=3;break;case
13:Q(b,a[1],92);a[1]++;Q(b,a[1],fP);var
e=3;break;default:var
e=0;}switch(e){case
0:Q(b,a[1],92);a[1]++;Q(b,a[1],48+(c/ae|0)|0);a[1]++;Q(b,a[1],48+((c/10|0)%10|0)|0);a[1]++;Q(b,a[1],48+(c%10|0)|0);break;case
1:Q(b,a[1],92);a[1]++;Q(b,a[1],c);break;case
2:Q(b,a[1],c);break}a[1]++;var
A=h+1|0;if(u!==h){var
h=A;continue}break}}var
k=b;}}else
var
k=d;var
w=s(k),x=bn(w+2|0,34);aA(k,0,x,1,w);return x}}function
ju(c,b){switch(c){case
0:var
a=iF;break;case
1:var
a=iG;break;case
2:var
a=iH;break;case
3:var
a=iI;break;case
4:var
a=iJ;break;case
5:var
a=iK;break;case
6:var
a=iL;break;case
7:var
a=iM;break;case
8:var
a=iN;break;case
9:var
a=iO;break;case
10:var
a=iP;break;case
11:var
a=iQ;break;default:var
a=iR;}return c0(a,b)}function
jv(c,b){switch(c){case
0:var
a=i5;break;case
1:var
a=i6;break;case
2:var
a=i7;break;case
3:var
a=i8;break;case
4:var
a=i9;break;case
5:var
a=i_;break;case
6:var
a=i$;break;case
7:var
a=ja;break;case
8:var
a=jb;break;case
9:var
a=jc;break;case
10:var
a=jd;break;case
11:var
a=je;break;default:var
a=jf;}return c0(a,b)}function
jw(c,b){switch(c){case
0:var
a=jg;break;case
1:var
a=jh;break;case
2:var
a=ji;break;case
3:var
a=jj;break;case
4:var
a=jk;break;case
5:var
a=jl;break;case
6:var
a=jm;break;case
7:var
a=jn;break;case
8:var
a=jo;break;case
9:var
a=jp;break;case
10:var
a=jq;break;case
11:var
a=jr;break;default:var
a=js;}return c0(a,b)}function
jx(c,b){switch(c){case
0:var
a=iS;break;case
1:var
a=iT;break;case
2:var
a=iU;break;case
3:var
a=iV;break;case
4:var
a=iW;break;case
5:var
a=iX;break;case
6:var
a=iY;break;case
7:var
a=iZ;break;case
8:var
a=i0;break;case
9:var
a=i1;break;case
10:var
a=i2;break;case
11:var
a=i3;break;default:var
a=i4;}return H3(a,b)}function
a3(c,u,h){if(16<=c){if(17<=c)switch(c+gr|0){case
2:var
k=0;break;case
0:case
3:var
m=43,k=1;break;default:var
m=32,k=1;}else
var
k=0;if(!k)var
m=45;var
i=H0(h,u,m);if(19<=c){var
l=s(i);if(0===l)return i;var
q=Z(l),r=l-1|0,z=0;if(!(r<0)){var
e=z;for(;;){var
g=ax(i,e);if(97<=g)if(gE<g)var
o=0;else
var
t=g-32|0,o=1;else
var
o=0;if(!o)var
t=g;Q(q,e,t);var
A=e+1|0;if(r!==e){var
e=A;continue}break}}return q}return i}if(15===c)var
v=jt;else{var
B=db(u);switch(c){case
15:var
b=70;break;case
0:case
1:case
2:var
b=ce;break;case
3:case
4:case
5:var
b=fU;break;case
6:case
7:case
8:var
b=69;break;case
9:case
10:case
11:var
b=d5;break;case
12:case
13:case
14:var
b=71;break;case
16:case
17:case
18:var
b=cL;break;default:var
b=72;}var
d=ep(16);b2(d,37);switch(c){case
1:case
4:case
7:case
10:case
13:case
17:case
20:b2(d,43);break;case
2:case
5:case
8:case
11:case
14:case
18:case
21:b2(d,32);break}b2(d,46);$(d,a(p+B));b2(d,b);var
v=er(d);}var
f=HP(v,h);if(15===c){var
x=HL(h),C=s(f);if(3===x)return h<0?jy:jz;if(4<=x)return jA;var
j=0;for(;;){if(j===C)var
y=0;else{var
n=_(f,j)-46|0,D=23<n>>>0?55===n?1:0:21<(n-1|0)>>>0?1:0;if(!D){var
j=j+1|0;continue}var
y=1;}return y?f:w(f,jB)}}return f}function
v(x,e,w,u){var
d=x,c=w,a=u;for(;;)if(typeof
a==="number")return f(d,e,c);else
switch(a[0]){case
0:var
y=a[1];return function(a){return v(d,e,[5,c,a],y)};case
1:var
z=a[1];return function(g){var
a=eh(g),b=s(a),f=bn(b+2|0,39);aA(a,0,f,1,b);return v(d,e,[4,c,f],z)};case
2:var
A=a[2],B=a[1];return es(d,e,c,A,B,function(a){return a});case
3:return es(d,e,c,a[2],a[1],iE);case
4:return cw(d,e,c,a[4],a[2],a[3],ju,a[1]);case
5:return cw(d,e,c,a[4],a[2],a[3],jv,a[1]);case
6:return cw(d,e,c,a[4],a[2],a[3],jw,a[1]);case
7:return cw(d,e,c,a[4],a[2],a[3],jx,a[1]);case
8:var
h=a[4],i=a[3],k=a[2],j=a[1];if(typeof
k==="number"){if(typeof
i==="number")return 0===i?function(a){return v(d,e,[4,c,a3(j,dg,a)],h)}:function(b,a){return v(d,e,[4,c,a3(j,b,a)],h)};var
Z=i[1];return function(a){return v(d,e,[4,c,a3(j,Z,a)],h)}}else{if(0===k[0]){var
n=k[2],o=k[1];if(typeof
i==="number")return 0===i?function(a){return v(d,e,[4,c,aq(o,n,a3(j,dg,a))],h)}:function(b,a){return v(d,e,[4,c,aq(o,n,a3(j,b,a))],h)};var
_=i[1];return function(a){return v(d,e,[4,c,aq(o,n,a3(j,_,a))],h)}}var
p=k[1];if(typeof
i==="number")return 0===i?function(b,a){return v(d,e,[4,c,aq(p,b,a3(j,dg,a))],h)}:function(f,b,a){return v(d,e,[4,c,aq(p,f,a3(j,b,a))],h)};var
$=i[1];return function(b,a){return v(d,e,[4,c,aq(p,b,a3(j,$,a))],h)}}case
9:var
C=a[1];return function(a){var
b=a?ho:hp;return v(d,e,[4,c,b],C)};case
10:var
c=[7,c],a=a[1];continue;case
11:var
c=[2,c,a[1]],a=a[2];continue;case
12:var
c=[3,c,a[1]],a=a[2];continue;case
13:var
E=a[3],F=a[2],q=ep(16);dh(q,F);var
r=er(q);return function(a){return v(d,e,[4,c,r],E)};case
14:var
G=a[3],H=a[2];return function(b){var
f=b[1],a=D(f,L(R(H)));if(typeof
a[2]==="number")return v(d,e,c,I(a[1],G));throw ab};case
15:var
J=a[1];return function(b,a){return v(d,e,[6,c,function(c){return f(b,c,a)}],J)};case
16:var
K=a[1];return function(a){return v(d,e,[6,c,a],K)};case
17:var
c=[0,c,a[1]],a=a[2];continue;case
18:var
m=a[1];if(0===m[0]){var
M=a[2],N=m[1][1],O=0,d=function(c,d,e){return function(b,a){return v(d,b,[1,c,[0,a]],e)}}(c,d,M),c=O,a=N;continue}var
P=a[2],Q=m[1][1],S=0,d=function(c,d,e){return function(b,a){return v(d,b,[1,c,[1,a]],e)}}(c,d,P),c=S,a=Q;continue;case
19:throw[0,t,jC];case
20:var
T=a[3],U=[8,c,jD];return function(a){return v(d,e,U,T)};case
21:var
V=a[2];return function(a){return v(d,e,[4,c,c0(jE,a)],V)};case
22:var
W=a[1];return function(a){return v(d,e,[5,c,a],W)};case
23:var
g=a[2],l=a[1];if(typeof
l==="number")switch(l){case
0:return al(d,e,c,g);case
1:return al(d,e,c,g);case
2:return al(d,e,c,g);case
3:throw[0,t,jF];default:return al(d,e,c,g)}else
switch(l[0]){case
0:return al(d,e,c,g);case
1:return al(d,e,c,g);case
2:return al(d,e,c,g);case
3:return al(d,e,c,g);case
4:return al(d,e,c,g);case
5:return al(d,e,c,g);case
6:return al(d,e,c,g);case
7:return al(d,e,c,g);case
8:return ar(d,e,c,l[2],g);case
9:return al(d,e,c,g);default:return al(d,e,c,g)}default:var
X=a[3],Y=a[1];return et(d,e,c,X,Y,b(a[2],0))}}function
ar(e,d,c,a,b){if(typeof
a==="number")return al(e,d,c,b);else
switch(a[0]){case
0:var
f=a[1];return function(a){return ar(e,d,c,f,b)};case
1:var
g=a[1];return function(a){return ar(e,d,c,g,b)};case
2:var
h=a[1];return function(a){return ar(e,d,c,h,b)};case
3:var
i=a[1];return function(a){return ar(e,d,c,i,b)};case
4:var
j=a[1];return function(a){return ar(e,d,c,j,b)};case
5:var
k=a[1];return function(a){return ar(e,d,c,k,b)};case
6:var
l=a[1];return function(a){return ar(e,d,c,l,b)};case
7:var
m=a[1];return function(a){return ar(e,d,c,m,b)};case
8:var
n=a[2];return function(a){return ar(e,d,c,n,b)};case
9:var
o=a[3],p=a[2],q=U(R(a[1]),p);return function(a){return ar(e,d,c,ag(q,o),b)};case
10:var
r=a[1];return function(f,a){return ar(e,d,c,r,b)};case
11:var
s=a[1];return function(a){return ar(e,d,c,s,b)};case
12:var
u=a[1];return function(a){return ar(e,d,c,u,b)};case
13:throw[0,t,jG];default:throw[0,t,jH]}}function
al(d,c,b,a){return v(d,c,[8,b,jI],a)}function
es(g,f,e,d,a,c){if(typeof
a==="number")return function(a){return v(g,f,[4,e,b(c,a)],d)};else{if(0===a[0]){var
h=a[2],i=a[1];return function(a){return v(g,f,[4,e,aq(i,h,b(c,a))],d)}}var
j=a[1];return function(h,a){return v(g,f,[4,e,aq(j,h,b(c,a))],d)}}}function
cw(h,g,e,d,i,c,b,a){if(typeof
i==="number"){if(typeof
c==="number")return 0===c?function(c){return v(h,g,[4,e,f(b,a,c)],d)}:function(i,c){return v(h,g,[4,e,bC(i,f(b,a,c))],d)};var
m=c[1];return function(c){return v(h,g,[4,e,bC(m,f(b,a,c))],d)}}else{if(0===i[0]){var
j=i[2],k=i[1];if(typeof
c==="number")return 0===c?function(c){return v(h,g,[4,e,aq(k,j,f(b,a,c))],d)}:function(i,c){return v(h,g,[4,e,aq(k,j,bC(i,f(b,a,c)))],d)};var
n=c[1];return function(c){return v(h,g,[4,e,aq(k,j,bC(n,f(b,a,c)))],d)}}var
l=i[1];if(typeof
c==="number")return 0===c?function(i,c){return v(h,g,[4,e,aq(l,i,f(b,a,c))],d)}:function(j,i,c){return v(h,g,[4,e,aq(l,j,bC(i,f(b,a,c)))],d)};var
o=c[1];return function(i,c){return v(h,g,[4,e,aq(l,i,bC(o,f(b,a,c)))],d)}}}function
et(g,f,e,d,c,a){if(c){var
h=c[1];return function(c){return et(g,f,e,d,h,b(a,c))}}return v(g,f,[4,e,a],d)}function
ba(c,h){var
a=h;for(;;)if(typeof
a==="number")return 0;else
switch(a[0]){case
0:var
e=a[2],i=a[1];if(typeof
e==="number")switch(e){case
0:var
d=hY;break;case
1:var
d=hZ;break;case
2:var
d=h0;break;case
3:var
d=h1;break;case
4:var
d=h2;break;case
5:var
d=h3;break;default:var
d=h4;}else
switch(e[0]){case
0:var
d=e[1];break;case
1:var
d=e[1];break;default:var
d=w(h5,bn(1,e[1]));}ba(c,i);return y(c,d);case
1:var
f=a[2],g=a[1];if(0===f[0]){var
j=f[1];ba(c,g);y(c,jJ);var
a=j;continue}var
k=f[1];ba(c,g);y(c,jK);var
a=k;continue;case
6:var
n=a[2];ba(c,a[1]);return y(c,b(n,0));case
7:var
a=a[1];continue;case
8:var
p=a[2];ba(c,a[1]);return az(p);case
2:case
4:var
l=a[2];ba(c,a[1]);return y(c,l);default:var
m=a[2];ba(c,a[1]);return o(c,m)}}function
eu(b){var
a=b[1];return v(function(c,b){var
a=C(64);ba(a,b);return T(a)},0,0,a)}var
ev=[0,0];function
ew(a){ev[1]=[0,a,ev[1]];return 0}try{var
HG=c9(HF),ey=HG;}catch(a){a=aj(a);if(a!==ah)throw a;try{var
HE=c9(HD),ex=HE;}catch(a){a=aj(a);if(a!==ah)throw a;var
ex=jM;}var
ey=ex;}var
jN=hI(ey,82),cx=[cV,function(A){var
n=Ix(0),c=[0,bA(55,0),0],i=0===n.length-1?[0,0]:n,j=i.length-1,b=0;for(;;){k(c[1],b)[b+1]=b;var
z=b+1|0;if(54!==b){var
b=z;continue}var
g=[0,jL],l=54+da(55,j)|0,u=0;if(!(l<0)){var
d=u;for(;;){var
e=d%55|0,m=hc(d,j),v=k(i,m)[m+1],h=w(g[1],a(p+v));g[1]=Ig(h,0,s(h));var
f=g[1],o=_(f,3)<<24,q=_(f,2)<<16,r=_(f,1)<<8,t=((_(f,0)+r|0)+q|0)+o|0,x=(k(c[1],e)[e+1]^t)&cH;k(c[1],e)[e+1]=x;var
y=d+1|0;if(l!==d){var
d=y;continue}break}}c[2]=0;return c}}];function
ez(h,l){var
m=h?h[1]:jN,b=16;for(;;){if(!(l<=b))if(!(df<(b*2|0))){var
b=b*2|0;continue}if(m){var
i=hf(cx),a=cj===i?cx[1]:cV===i?hW(cx):cx;a[2]=(a[2]+1|0)%55|0;var
c=a[2],d=k(a[1],c)[c+1],e=(a[2]+24|0)%55|0,f=(k(a[1],e)[e+1]+(d^(d>>>25|0)&31)|0)&cH,g=a[2];k(a[1],g)[g+1]=f;var
j=f;}else
var
j=0;return[0,0,bA(b,0),j,b]}}function
dj(a,b){return 3<=a.length-1?HS(10,ae,a[3],b)&(a[2].length-1-1|0):hc(HZ(10,ae,b),a[2].length-1)}function
eA(a,m,q){var
c=dj(a,m),r=[0,m,q,k(a[2],c)[c+1]];k(a[2],c)[c+1]=r;a[1]=a[1]+1|0;var
n=a[2].length-1<<1<a[1]?1:0;if(n){var
e=a[2],f=e.length-1,g=f*2|0,h=g<df?1:0;if(h){var
d=bA(g,0);a[2]=d;var
i=function(b){if(b){var
e=b[1],f=b[2];i(b[3]);var
c=dj(a,e);return d[c+1]=[0,e,f,k(d,c)[c+1]]}return 0},j=f-1|0,o=0;if(!(j<0)){var
b=o;for(;;){i(k(e,b)[b+1]);var
p=b+1|0;if(j!==b){var
b=p;continue}break}}var
l=0;}else
var
l=h;return l}return n}function
eB(f,b){var
g=dj(f,b),c=k(f[2],g)[g+1];if(c){var
d=c[3],j=c[2];if(0===cn(b,c[1]))return j;if(d){var
e=d[3],l=d[2];if(0===cn(b,d[1]))return l;if(e){var
m=e[3],n=e[2];if(0===cn(b,e[1]))return n;var
a=m;for(;;){if(a){var
h=a[3],i=a[2];if(0===cn(b,a[1]))return i;var
a=h;continue}throw ah}}throw ah}throw ah}throw ah}var
aF=g1,aE=HH;function
jO(b,a){var
c=hf(a)===W?a:a[1];return Iq(b,c)}try{c9(HC);}catch(a){a=aj(a);if(a!==ah)throw a}try{c9(HB);}catch(a){a=aj(a);if(a!==ah)throw a}if(c(de,jP))if(c(de,jQ))if(c(de,jR))throw[0,t,jS];var
eC=aQ,eD=undefined,jT=null;function
b4(a){return a!==eD?1:0}var
jU=eC.Array,eE=[W,jV,a0(0)];jO(jW,[0,eE,{}]);(function(a){throw a});ew(function(a){return a[1]===eE?[0,bk(a[2].toString())]:0});ew(function(a){return a
instanceof
jU?0:[0,bk(a.toString())]});function
eF(c,b,a){var
d=a[4],e=da(0,a[4]-a[3]|0);return[0,c,[0,b[2],b[4]-b[3]|0,b[4]],[0,a[2],e,d]]}function
g(a,b){return[0,a[1],a[2],b[3]]}function
eG(a){return typeof
a==="number"?jX:a[1]}function
eH(a){if(typeof
a==="number")return 1;else
switch(a[0]){case
0:return 2;case
3:return 4;default:return 3}}function
eI(b,a){var
c=b[1]-a[1]|0;return 0===c?b[2]-a[2]|0:c}var
eJ=[W,jY,a0(0)],eK=f(aE,lg,lf),eL=f(aE,li,lh),eM=f(aE,lk,lj),eN=f(aE,lm,ll),eO=f(aE,lo,ln),eP=f(aE,lq,lp),eQ=f(aE,ls,lr),eR=f(aE,lu,lt),eS=f(aE,lw,lv),eT=f(aE,ly,lx),eU=f(aE,lA,lz);u(aF,lB,eK,eK);u(aF,lC,eL,eL);u(aF,lD,eM,eM);u(aF,lE,eN,eN);u(aF,lF,eO,eO);u(aF,lG,eP,eP);u(aF,lH,eQ,eQ);u(aF,lI,eR,eR);u(aF,lJ,eS,eS);u(aF,lK,eT,eT);u(aF,lL,eU,eU);function
lM(c){function
i(d,a){var
e=bB(bm(d,a));return b(c[4],e)}function
s(a){return b(c[5],a)}function
d(d,a){return a?b(d,a[1]):c[6]}function
H(a){var
d=[0,lN,s(a[2])],e=[0,[0,lO,s(a[1])],d];return b(c[3],e)}function
I(a){var
d=a[1];if(d)var
e=d[1],g=typeof
e==="number"?b(c[1],lP):b(c[1],e[1]),f=g;else
var
f=c[6];var
h=[0,lQ,H(a[3])],i=[0,[0,lS,f],[0,lR,H(a[2])],h];return b(c[3],i)}function
a(k,d,a){var
i=s(d[3][3]),j=[0,s(d[2][3]),i],l=[0,lT,b(c[4],j)],m=[0,lU,I(d)],e=[0,[0,lV,b(c[1],k)],m,l],g=e.length-1;if(0===g)var
f=a.length-1,h=0===f?[0]:g3(a,0,f);else
var
h=0===a.length-1?g3(e,0,g):HI(e,a);return b(c[3],h)}function
$(a){return i(function(g){var
d=g[2];if(typeof
d==="number"){var
e=d;if(34<=e)switch(e){case
34:var
a=kw;break;case
35:var
a=kx;break;case
36:var
a=ky;break;case
37:var
a=kz;break;case
38:var
a=kA;break;case
39:var
a=kB;break;case
40:var
a=kC;break;case
41:var
a=kD;break;case
42:var
a=kE;break;case
43:var
a=kF;break;case
44:var
a=kG;break;case
45:var
a=kH;break;case
46:var
a=w(kJ,kI);break;case
47:var
a=w(kL,kK);break;case
48:var
a=kM;break;case
49:var
a=kN;break;case
50:var
a=kO;break;case
51:var
a=kP;break;case
52:var
a=kQ;break;case
53:var
a=kR;break;case
54:var
a=kS;break;case
55:var
a=kT;break;case
56:var
a=kU;break;case
57:var
a=kV;break;case
58:var
a=kW;break;case
59:var
a=kX;break;case
60:var
a=kY;break;case
61:var
a=kZ;break;case
62:var
a=k0;break;case
63:var
a=k1;break;case
64:var
a=w(k3,k2);break;case
65:var
a=k4;break;default:var
a=k5;}else
switch(e){case
0:var
a=jZ;break;case
1:var
a=j0;break;case
2:var
a=j1;break;case
3:var
a=j2;break;case
4:var
a=j3;break;case
5:var
a=j4;break;case
6:var
a=j5;break;case
7:var
a=j6;break;case
8:var
a=j7;break;case
9:var
a=j8;break;case
10:var
a=j9;break;case
11:var
a=j_;break;case
12:var
a=j$;break;case
13:var
a=ka;break;case
14:var
a=kb;break;case
15:var
a=kc;break;case
16:var
a=kd;break;case
17:var
a=ke;break;case
18:var
a=kf;break;case
19:var
a=w(kh,kg);break;case
20:var
a=ki;break;case
21:var
a=kj;break;case
22:var
a=kk;break;case
23:var
a=kl;break;case
24:var
a=km;break;case
25:var
a=kn;break;case
26:var
a=ko;break;case
27:var
a=kp;break;case
28:var
a=kq;break;case
29:var
a=kr;break;case
30:var
a=ks;break;case
31:var
a=kt;break;case
32:var
a=ku;break;default:var
a=kv;}}else
switch(d[0]){case
0:var
a=w(k6,d[1]);break;case
1:var
a=w(k7,d[1]);break;case
2:var
h=d[2],i=d[1],a=f(eu(k8),i,h);break;case
3:var
a=w(k_,w(d[1],k9));break;case
4:var
a=w(la,w(d[1],k$));break;case
5:var
j=w(lc,w(d[2],lb)),a=w(d[1],j);break;case
6:var
a=w(ld,d[1]);break;default:var
k=d[1],a=b(eu(le),k);}var
l=[0,lW,b(c[1],a)],m=[0,[0,lX,I(g[1])],l];return b(c[3],m)},a)}function
aa(b){var
c=[0,lY,i(aq,b[3])],d=[0,[0,lZ,J(b[2])],c];return a(l0,b[1],d)}function
J(a){return i(l,a)}function
y(e){var
f=e[2];switch(f[2]){case
0:var
d=rE;break;case
1:var
d=rI;break;default:var
d=rJ;}var
g=[0,rF,b(c[1],d)],h=[0,[0,rG,i(ag,f[1])],g];return a(rH,e[1],h)}function
V(c){var
b=c[2],e=[0,qA,i(K,b[4])],f=[0,qB,F(b[3])],g=[0,qC,d(q,b[2])],j=[0,[0,qD,h(b[1])],g,f,e];return a(qE,c[1],j)}function
S(c){var
b=c[2],e=[0,pV,k(b[3])],f=[0,pW,d(q,b[2])],g=[0,[0,pX,h(b[1])],f,e];return a(pY,c[1],g)}function
Q(c){var
b=c[2],e=[0,pM,i(K,b[4])],f=[0,pN,F(b[3])],g=[0,pO,d(q,b[2])],j=[0,[0,pP,h(b[1])],g,f,e];return a(pQ,c[1],j)}function
P(c){var
b=c[2],e=g(b[1][1],b[2][1]),f=[0,pJ,d(A,b[3])],h=[0,[0,pK,B(e,[0,b[1],[0,b[2]],0])],f];return a(pL,c[1],h)}function
O(c){var
b=c[2],d=b[2],e=d?d[1][1]:b[1][1],f=g(b[1][1],e),h=[0,[0,pH,B(f,[0,b[1],b[2],0])]];return a(pI,c[1],h)}function
r(b){var
c=[0,[0,pF,J(b[2][1])]];return a(pG,b[1],c)}function
l(W){var
j=W[2],f=W[1];if(typeof
j==="number")return 0===j?a(l1,f,[0]):a(l2,f,[0]);else
switch(j[0]){case
0:return r([0,f,j[1]]);case
1:var
X=j[1],ak=[0,l3,d(c[1],X[2])];return a(l5,f,[0,[0,l4,e(X[1])],ak]);case
2:var
E=j[1],al=[0,l6,d(l,E[3])],am=[0,l7,l(E[2])];return a(l9,f,[0,[0,l8,e(E[1])],am,al]);case
3:var
Y=j[1],an=[0,l_,l(Y[2])];return a(ma,f,[0,[0,l$,h(Y[1])],an]);case
4:return a(mc,f,[0,[0,mb,d(h,j[1][1])]]);case
5:return a(me,f,[0,[0,md,d(h,j[1][1])]]);case
6:var
Z=j[1],ao=[0,mf,l(Z[2])];return a(mh,f,[0,[0,mg,e(Z[1])],ao]);case
7:return S([0,f,j[1]]);case
8:var
_=j[1],ap=[0,mi,i(ai,_[2])];return a(mk,f,[0,[0,mj,e(_[1])],ap]);case
9:return a(mm,f,[0,[0,ml,d(e,j[1][1])]]);case
10:return a(mo,f,[0,[0,mn,e(j[1][1])]]);case
11:var
F=j[1],aq=[0,mp,d(r,F[3])],ar=[0,mq,d(aj,F[2])];return a(ms,f,[0,[0,mr,r(F[1])],ar,aq]);case
12:var
$=j[1],as=[0,mt,l($[2])];return a(mv,f,[0,[0,mu,e($[1])],as]);case
13:var
aa=j[1],at=[0,mw,e(aa[2])];return a(my,f,[0,[0,mx,l(aa[1])],at]);case
14:var
w=j[1],au=function(a){return 0===a[0]?y(a[1]):e(a[1])},av=[0,mz,l(w[4])],aw=[0,mA,d(e,w[3])],ax=[0,mB,d(e,w[2])];return a(mD,f,[0,[0,mC,d(au,w[1])],ax,aw,av]);case
15:var
z=j[1],G=z[1],ay=0===G[0]?y(G[1]):e(G[1]),az=[0,mE,b(c[2],z[4])],aA=[0,mF,l(z[3])];return a(mI,f,[0,[0,mH,ay],[0,mG,e(z[2])],aA,az]);case
16:var
B=j[1],aB=B[4]?mJ:mN,H=B[1],aC=0===H[0]?y(H[1]):e(H[1]),aD=[0,mK,l(B[3])];return a(aB,f,[0,[0,mM,aC],[0,mL,e(B[2])],aD]);case
17:var
m=j[1],N=m[3],aV=0===N[0]?r(N[1]):e(N[1]),aW=[0,o9,d(q,m[9])],aX=[0,o_,d(p,m[8])],aY=[0,o$,b(c[2],m[7])],aZ=[0,pa,d(A,m[6])],a0=[0,pb,b(c[2],m[5])],a1=[0,pc,b(c[2],m[4])],a2=[0,pe,D(m[2])];return a(pg,f,[0,[0,pf,d(h,m[1])],a2,[0,pd,aV],a1,a0,aZ,aY,aX,aW]);case
18:return y([0,f,j[1]]);case
19:var
o=j[1],a3=[0,pZ,i(e,o[7])],a4=[0,p0,i(T,o[6])],a5=[0,p1,d(x,o[5])],a6=[0,p2,d(q,o[4])],a7=[0,p3,d(e,o[3])],a8=[0,p4,U(o[2])];return a(p6,f,[0,[0,p5,d(h,o[1])],a8,a7,a6,a5,a4,a3]);case
20:return V([0,f,j[1]]);case
21:return O([0,f,j[1]]);case
22:return P([0,f,j[1]]);case
23:return Q([0,f,j[1]]);case
24:var
I=j[1],J=I[1],aE=0===J[0]?h(J[1]):n(J[1]),aF=0===I[3][0]?b(c[1],mO):b(c[1],mT);return a(mS,f,[0,[0,mR,aE],[0,mQ,r(I[2])],[0,mP,aF]]);case
25:return a(mV,f,[0,[0,mU,p(j[1])]]);case
26:var
u=j[1],ab=u[3];if(ab){var
ac=ab[1];if(0!==ac[0])if(!ac[2])return a(m2,f,[0,[0,m1,d(n,u[4])]])}var
ad=u[2];if(ad){var
s=ad[1];switch(s[0]){case
0:var
v=O(s[1]);break;case
1:var
v=P(s[1]);break;case
2:var
v=Q(s[1]);break;case
3:var
v=k(s[1]);break;case
4:var
v=S(s[1]);break;default:var
v=V(s[1]);}var
ae=v;}else
var
ae=c[6];var
aG=[0,mW,d(n,u[4])],aH=[0,mX,R(u[3])];return a(m0,f,[0,[0,mZ,b(c[2],u[1])],[0,mY,ae],aH,aG]);case
27:var
t=j[1],af=t[2];if(af){var
ag=af[1];if(0!==ag[0])if(!ag[2]){var
aM=C(t[4]),aN=[0,m8,b(c[1],aM)];return a(m_,f,[0,[0,m9,d(n,t[3])],aN])}}var
aI=C(t[4]),aJ=[0,m3,b(c[1],aI)],aK=[0,m4,d(n,t[3])],aL=[0,m5,R(t[2])];return a(m7,f,[0,[0,m6,d(l,t[1])],aL,aK,aJ]);case
28:var
ah=j[1],K=ah[1],aO=0===K[0]?l(K[1]):e(K[1]),aP=C(ah[2]);return a(nb,f,[0,[0,na,aO],[0,m$,b(c[1],aP)]]);default:var
L=j[1],aQ=L[3],aR=bm(function(d){switch(d[0]){case
0:var
j=d[1],l=j[1],e=j[3],f=j[2],q=f?g(e[1],f[1][1]):e[1],r=f?f[1]:e;if(l)switch(l[1]){case
0:var
k=b(c[1],tH),i=1;break;case
1:var
k=b(c[1],tM),i=1;break;default:var
i=0;}else
var
i=0;if(!i)var
k=c[6];var
s=[0,tJ,h(r)];return a(tL,q,[0,[0,tK,h(e)],s,[0,tI,k]]);case
1:var
m=d[1],o=[0,[0,tD,h(m)]];return a(tE,m[1],o);default:var
n=d[1],p=[0,[0,tF,h(n[2])]];return a(tG,n[1],p)}},aQ);switch(L[1]){case
0:var
M=nc;break;case
1:var
M=nh;break;default:var
M=ni;}var
aS=[0,nd,b(c[1],M)],aT=[0,ne,n(L[2])],aU=bB(aR);return a(ng,f,[0,[0,nf,b(c[4],aU)],aT,aS])}}function
W(g){var
e=g[2],j=[0,s9,i(an,e[3])],k=[0,s_,d(am,e[2])],h=e[1],f=h[2],m=[0,tb,b(c[2],f[2])],n=[0,tc,i(al,f[3])],o=[0,[0,td,X(f[1])],n,m],l=[0,[0,s$,a(te,h[1],o)],k,j];return a(ta,g[1],l)}function
M(b){var
c=b[2],d=[0,rt,i(e,c[2])],f=[0,[0,ru,i(af,c[1])],d];return a(rv,b[1],f)}function
n(g){var
h=g[2],i=h[2],d=h[1],j=g[1];if(typeof
d==="number")var
e=c[6];else
switch(d[0]){case
0:var
e=b(c[1],d[1]);break;case
1:var
e=b(c[2],d[1]);break;case
2:var
e=b(c[5],d[1]);break;default:var
m=d[1],e=u(c[7],j,m[1],m[2]);}if(typeof
d==="number")var
f=0;else
if(3===d[0])var
l=d[1],n=[0,ro,b(c[1],l[2])],o=[0,[0,rp,b(c[1],l[1])],n],p=[0,rq,b(c[3],o)],k=[0,[0,rs,e],[0,rr,b(c[1],i)],p],f=1;else
var
f=0;if(!f)var
k=[0,[0,rm,e],[0,rl,b(c[1],i)]];return a(rn,j,k)}function
h(d){var
e=[0,pr,b(c[2],0)],f=[0,ps,c[6]],g=[0,[0,pt,b(c[1],d[2])],f,e];return a(pu,d[1],g)}function
v(i){var
f=i[2],g=f[3],j=0===g[0]?r(g[1]):e(g[1]),k=[0,ph,d(q,f[9])],l=[0,pi,d(p,f[8])],m=[0,pj,b(c[2],f[7])],n=[0,pk,d(A,f[6])],o=[0,pl,b(c[2],f[5])],s=[0,pm,b(c[2],f[4])],t=[0,po,D(f[2])],u=[0,[0,pp,d(h,f[1])],t,[0,pn,j],s,o,n,m,l,k];return a(pq,i[1],u)}function
e(H){var
f=H[2],g=H[1];if(typeof
f==="number")return 0===f?a(nj,g,[0]):a(nk,g,[0]);else
switch(f[0]){case
0:var
S=f[1][1];return a(nm,g,[0,[0,nl,i(function(a){return d(E,a)},S)]]);case
1:return a(no,g,[0,[0,nn,i(ad,f[1][1])]]);case
2:return v([0,g,f[1]]);case
3:var
l=f[1],u=l[3],V=0===u[0]?r(u[1]):e(u[1]),X=[0,np,d(q,l[9])],Y=[0,nq,d(p,l[8])],Z=[0,nr,b(c[2],l[7])],_=[0,ns,d(A,l[6])],$=[0,nt,b(c[2],l[5])],aa=[0,nu,b(c[2],l[4])],ab=[0,nw,D(l[2])];return a(ny,g,[0,[0,nx,d(h,l[1])],ab,[0,nv,V],aa,$,_,Z,Y,X]);case
4:return a(nA,g,[0,[0,nz,i(e,f[1][1])]]);case
5:var
t=f[1];if(7<=t[1])return a(nC,g,[0,[0,nB,e(t[3])]]);switch(t[1]){case
0:var
m=nD;break;case
1:var
m=nI;break;case
2:var
m=nJ;break;case
3:var
m=nK;break;case
4:var
m=nL;break;case
5:var
m=nM;break;case
6:var
m=nN;break;default:var
m=ay(nO);}var
ac=[0,nE,e(t[3])],ae=[0,nF,b(c[2],t[2])];return a(nH,g,[0,[0,nG,b(c[1],m)],ae,ac]);case
6:var
w=f[1];switch(w[1]){case
0:var
j=nP;break;case
1:var
j=nU;break;case
2:var
j=nV;break;case
3:var
j=nW;break;case
4:var
j=nX;break;case
5:var
j=nY;break;case
6:var
j=nZ;break;case
7:var
j=n0;break;case
8:var
j=n1;break;case
9:var
j=n2;break;case
10:var
j=n3;break;case
11:var
j=n4;break;case
12:var
j=n5;break;case
13:var
j=n6;break;case
14:var
j=n7;break;case
15:var
j=n8;break;case
16:var
j=n9;break;case
17:var
j=n_;break;case
18:var
j=n$;break;case
19:var
j=oa;break;case
20:var
j=ob;break;default:var
j=oc;}var
af=[0,nQ,e(w[3])],ag=[0,nR,e(w[2])];return a(nT,g,[0,[0,nS,b(c[1],j)],ag,af]);case
7:var
y=f[1];switch(y[1]){case
0:var
k=od;break;case
1:var
k=oi;break;case
2:var
k=oj;break;case
3:var
k=ok;break;case
4:var
k=ol;break;case
5:var
k=om;break;case
6:var
k=on;break;case
7:var
k=oo;break;case
8:var
k=op;break;case
9:var
k=oq;break;case
10:var
k=or;break;case
11:var
k=os;break;default:var
k=ot;}var
ah=[0,oe,e(y[3])],ai=[0,of,o(y[2])];return a(oh,g,[0,[0,og,b(c[1],k)],ai,ah]);case
8:var
z=f[1],aj=0===z[1]?ou:oz,ak=[0,ov,b(c[2],z[3])],al=[0,ow,e(z[2])];return a(oy,g,[0,[0,ox,b(c[1],aj)],al,ak]);case
9:var
B=f[1],am=0===B[1]?oA:oF,an=[0,oB,e(B[3])],ao=[0,oC,e(B[2])];return a(oE,g,[0,[0,oD,b(c[1],am)],ao,an]);case
10:var
C=f[1],ap=[0,oG,e(C[3])],aq=[0,oH,e(C[2])];return a(oJ,g,[0,[0,oI,e(C[1])],aq,ap]);case
11:var
I=f[1],ar=[0,oK,i(E,I[2])];return a(oM,g,[0,[0,oL,e(I[1])],ar]);case
12:var
J=f[1],as=[0,oN,i(E,J[2])];return a(oP,g,[0,[0,oO,e(J[1])],as]);case
13:var
F=f[1],G=F[2],at=0===G[0]?h(G[1]):e(G[1]),au=[0,oQ,b(c[2],F[3])];return a(oT,g,[0,[0,oS,e(F[1])],[0,oR,at],au]);case
14:var
K=f[1],av=[0,oU,b(c[2],K[2])];return a(oW,g,[0,[0,oV,d(e,K[1])],av]);case
15:var
N=f[1],aw=[0,oX,d(e,N[2])];return a(oZ,g,[0,[0,oY,i(L,N[1])],aw]);case
16:var
O=f[1],ax=[0,o0,d(e,O[2])];return a(o2,g,[0,[0,o1,i(L,O[1])],ax]);case
17:return h(f[1]);case
18:return n([0,g,f[1]]);case
19:return M([0,g,f[1]]);case
20:var
P=f[1],aH=[0,rB,M(P[2])];return a(rD,g,[0,[0,rC,e(P[1])],aH]);case
21:return W([0,g,f[1]]);case
22:var
s=f[1],aB=[0,p7,i(e,s[7])],aC=[0,p8,i(T,s[6])],aD=[0,p9,d(x,s[5])],aE=[0,p_,d(q,s[4])],aF=[0,p$,d(e,s[3])],aG=[0,qa,U(s[2])];return a(qc,g,[0,[0,qb,d(h,s[1])],aG,aF,aE,aD,aC,aB]);case
23:var
Q=f[1],az=[0,o3,p(Q[2])];return a(o5,g,[0,[0,o4,e(Q[1])],az]);default:var
R=f[1],aA=[0,o6,h(R[2])];return a(o8,g,[0,[0,o7,h(R[1])],aA])}}function
B(f,e){var
g=[0,pv,b(c[2],e[3])],h=[0,pw,d(p,e[2])];return a(py,f,[0,[0,px,b(c[1],e[1][2])],h,g])}function
ai(b){var
c=b[2],f=[0,pz,i(l,c[2])],g=[0,[0,pA,d(e,c[1])],f];return a(pB,b[1],g)}function
aj(b){var
c=b[2],d=[0,pC,r(c[2])],e=[0,[0,pD,o(c[1])],d];return a(pE,b[1],e)}function
C(a){return 0===a?pR:pS}function
R(e){if(e){var
d=e[1];if(0===d[0])return i(ap,d[1]);var
f=d[2];if(f){var
g=[0,[0,pT,h(f[1])]],j=[0,a(pU,d[1],g)];return b(c[4],j)}return b(c[4],[0])}return b(c[4],[0])}function
T(b){var
c=b[2],e=[0,qd,d(x,c[2])],f=[0,[0,qe,h(c[1])],e];return a(qf,b[1],f)}function
U(b){var
c=[0,[0,qg,i(ab,b[2][1])]];return a(qh,b[1],c)}function
ab(q){if(0===q[0]){var
r=q[1],f=r[2],j=f[2];switch(j[0]){case
0:var
k=[0,n(j[1]),0];break;case
1:var
k=[0,h(j[1]),0];break;default:var
k=[0,e(j[1]),1];}switch(f[1]){case
0:var
l=qi;break;case
1:var
l=qq;break;case
2:var
l=qr;break;default:var
l=qs;}var
u=[0,qj,i(e,f[5])],w=[0,qk,b(c[2],k[2])],x=[0,ql,b(c[2],f[4])],y=[0,qm,b(c[1],l)],z=[0,qn,v(f[3])];return a(qp,r[1],[0,[0,qo,k[1]],z,y,x,w,u])}var
s=q[1],g=s[2],m=g[1];switch(m[0]){case
0:var
o=[0,n(m[1]),0];break;case
1:var
o=[0,h(m[1]),0];break;default:var
o=[0,e(m[1]),1];}var
A=[0,qt,d(t,g[5])],B=[0,qu,b(c[2],g[4])],C=[0,qv,b(c[2],o[2])],D=[0,qw,d(p,g[3])],E=[0,qx,d(e,g[2])];return a(qz,s[1],[0,[0,qy,o[1]],E,D,C,B,A])}function
K(c){var
e=c[2],b=e[1],f=0===b[0]?h(b[1]):G(b[1]),g=[0,[0,qG,f],[0,qF,d(x,e[2])]];return a(qH,c[1],g)}function
o(f){var
b=f[2],c=f[1];switch(b[0]){case
0:var
g=b[1],k=[0,qI,d(p,g[2])];return a(qK,c,[0,[0,qJ,i(ae,g[1])],k]);case
1:var
h=b[1],l=[0,qL,d(p,h[2])],m=h[1];return a(qN,c,[0,[0,qM,i(function(a){return d(ac,a)},m)],l]);case
2:var
j=b[1],n=[0,qO,e(j[2])];return a(qQ,c,[0,[0,qP,o(j[1])],n]);case
3:return B(c,b[1]);default:return e(b[1])}}function
D(d){var
e=d[2],f=d[1];if(e){var
g=e[1],h=[0,[0,qR,o(g[2][1])]],j=a(qS,g[1],h),k=bB(m([0,j,m(bm(o,f))]));return b(c[4],k)}return i(o,f)}function
ac(b){if(0===b[0])return o(b[1]);var
c=b[1],d=[0,[0,qT,o(c[2][1])]];return a(qU,c[1],d)}function
ad(k){if(0===k[0]){var
l=k[1],d=l[2],f=d[1];switch(f[0]){case
0:var
g=[0,n(f[1]),0];break;case
1:var
g=[0,h(f[1]),0];break;default:var
g=[0,e(f[1]),1];}var
i=d[2];switch(i[0]){case
0:var
j=[0,e(i[1]),qV];break;case
1:var
j=[0,v(i[1]),q3];break;default:var
j=[0,v(i[1]),q4];}var
o=[0,qW,b(c[2],g[2])],p=[0,qX,b(c[2],d[4])],q=[0,qY,b(c[2],d[3])],r=[0,qZ,b(c[1],j[2])];return a(q2,l[1],[0,[0,q1,g[1]],[0,q0,j[1]],r,q,p,o])}var
m=k[1],s=[0,[0,q5,e(m[2][1])]];return a(q6,m[1],s)}function
ae(g){if(0===g[0]){var
j=g[1],i=j[2],d=i[1];switch(d[0]){case
0:var
f=[0,n(d[1]),0];break;case
1:var
f=[0,h(d[1]),0];break;default:var
f=[0,e(d[1]),1];}var
l=[0,q7,b(c[2],f[2])],m=[0,q8,b(c[2],i[3])],p=[0,q9,b(c[2],0)],q=[0,q$,b(c[1],q_)],r=[0,ra,o(i[2])];return a(rc,j[1],[0,[0,rb,f[1]],r,q,p,m,l])}var
k=g[1],s=[0,[0,rd,o(k[2][1])]];return a(re,k[1],s)}function
E(b){if(0===b[0])return e(b[1]);var
c=b[1],d=[0,[0,rf,e(c[2][1])]];return a(rg,c[1],d)}function
L(f){var
d=f[2],g=[0,rh,b(c[2],d[3])],h=[0,ri,e(d[2])],i=[0,[0,rj,o(d[1])],h,g];return a(rk,f[1],i)}function
af(e){var
d=e[2],f=[0,rw,b(c[1],d[1][2])],g=[0,[0,rx,b(c[1],d[1][1])],f],h=b(c[3],g),i=[0,[0,rz,h],[0,ry,b(c[2],d[2])]];return a(rA,e[1],i)}function
ag(b){var
c=b[2],f=[0,rK,d(e,c[2])],g=[0,[0,rL,o(c[1])],f];return a(rM,b[1],g)}function
t(a){return 0===a[2]?b(c[1],rN):b(c[1],rO)}function
F(f){var
g=f[2],i=g[2],e=aB(function(p,e){var
i=p[3],j=p[2],l=p[1];switch(e[0]){case
0:var
s=e[1],f=s[2],q=f[1];switch(q[0]){case
0:var
r=n(q[1]);break;case
1:var
r=h(q[1]);break;default:var
r=ay(sm);}var
m=f[2];switch(m[0]){case
0:var
o=[0,k(m[1]),sc];break;case
1:var
x=m[1],o=[0,z([0,x[1],x[2]]),sk];break;default:var
y=m[1],o=[0,z([0,y[1],y[2]]),sl];}var
B=[0,sd,b(c[1],o[2])],C=[0,se,d(t,f[6])],D=[0,sf,b(c[2],f[4])],E=[0,sg,b(c[2],f[3])];return[0,[0,a(sj,s[1],[0,[0,si,r],[0,sh,o[1]],E,D,C,B]),l],j,i];case
1:var
u=e[1],F=[0,[0,sn,k(u[2][1])]];return[0,[0,a(so,u[1],F),l],j,i];case
2:var
v=e[1],g=v[2],G=[0,sp,d(t,g[5])],H=[0,sq,b(c[2],g[4])],I=[0,sr,k(g[3])],J=[0,ss,k(g[2])],K=[0,[0,st,d(h,g[1])],J,I,H,G];return[0,l,[0,a(su,v[1],K),j],i];default:var
w=e[1],A=w[2],L=[0,sv,b(c[2],A[2])],M=[0,[0,sw,z(A[1])],L];return[0,l,j,[0,a(sx,w[1],M),i]]}},r8,i),j=bB(m(e[3])),l=[0,r9,b(c[4],j)],o=bB(m(e[2])),p=[0,r_,b(c[4],o)],q=bB(m(e[1])),r=[0,r$,b(c[4],q)],s=[0,[0,sa,b(c[2],g[1])],r,p,l];return a(sb,f[1],s)}function
z(c){var
b=c[2],e=b[1],f=[0,rZ,d(q,b[3])],g=[0,r0,d(ah,e[2])],h=[0,r1,k(b[2])],j=[0,[0,r2,i(N,e[1])],h,g,f];return a(r3,c[1],j)}function
k(j){var
f=j[2],e=j[1];if(typeof
f==="number")switch(f){case
0:return a(rP,e,[0]);case
1:return a(rQ,e,[0]);case
2:return a(rR,e,[0]);case
3:return a(rS,e,[0]);case
4:return a(rT,e,[0]);case
5:return a(rU,e,[0]);case
6:return a(rV,e,[0]);case
7:return a(rW,e,[0]);default:return a(sX,e,[0])}else
switch(f[0]){case
0:return a(rY,e,[0,[0,rX,k(f[1])]]);case
1:return z([0,e,f[1]]);case
2:return F([0,e,f[1]]);case
3:return a(sz,e,[0,[0,sy,k(f[1])]]);case
4:var
l=f[1],g=l[1],p=0===g[0]?h(g[1]):G(g[1]);return a(sF,e,[0,[0,sE,p],[0,sD,d(x,l[2])]]);case
5:return a(sH,e,[0,[0,sG,i(k,[0,f[1],[0,f[2],f[3]]])]]);case
6:return a(sJ,e,[0,[0,sI,i(k,[0,f[1],[0,f[2],f[3]]])]]);case
7:return a(sL,e,[0,[0,sK,k(f[1])]]);case
8:return a(sN,e,[0,[0,sM,i(k,f[1])]]);case
9:var
m=f[1],q=[0,sO,b(c[1],m[2])];return a(sQ,e,[0,[0,sP,b(c[1],m[1])],q]);case
10:var
n=f[1],r=[0,sR,b(c[1],n[2])];return a(sT,e,[0,[0,sS,b(c[5],n[1])],r]);default:var
o=f[1],s=[0,sU,b(c[1],o[2])];return a(sW,e,[0,[0,sV,b(c[2],o[1])],s])}}function
N(f){var
e=f[2],g=[0,r4,b(c[2],e[3])],i=[0,r5,k(e[2])],j=[0,[0,r6,d(h,e[1])],i,g];return a(r7,f[1],j)}function
ah(a){return N(a[2][1])}function
G(c){var
d=c[2],b=d[1],e=0===b[0]?h(b[1]):G(b[1]),f=[0,[0,sB,e],[0,sA,h(d[2])]];return a(sC,c[1],f)}function
p(b){var
c=[0,[0,sY,k(b[2])]];return a(sZ,b[1],c)}function
q(b){var
c=[0,[0,s0,i(ak,b[2][1])]];return a(s1,b[1],c)}function
ak(f){var
e=f[2],g=[0,s2,d(k,e[4])],h=[0,s3,d(t,e[3])],i=[0,s4,d(p,e[2])],j=[0,[0,s5,b(c[1],e[1])],i,h,g];return a(s6,f[1],j)}function
x(b){var
c=[0,[0,s7,i(k,b[2][1])]];return a(s8,b[1],c)}function
al(b){if(0===b[0]){var
f=b[1],h=f[2],c=h[1],i=0===c[0]?j(c[1]):_(c[1]),k=[0,[0,ti,i],[0,th,d(ao,h[2])]];return a(tj,f[1],k)}var
g=b[1],l=[0,[0,tk,e(g[2][1])]];return a(tl,g[1],l)}function
am(b){var
c=[0,[0,tf,X(b[2][1])]];return a(tg,b[1],c)}function
Y(c){var
b=c[2][1],d=0===b[0]?e(b[1]):a(to,b[1],[0]);return a(tn,c[1],[0,[0,tm,d]])}function
an(f){var
d=f[2],e=f[1];switch(d[0]){case
0:return W([0,e,d[1]]);case
1:return Y([0,e,d[1]]);default:var
g=d[1],h=[0,tp,b(c[1],g[2])];return a(tr,e,[0,[0,tq,b(c[1],g[1])],h])}}function
j(d){var
e=[0,[0,ty,b(c[1],d[2][1])]];return a(tz,d[1],e)}function
_(b){var
c=b[2],d=[0,tv,j(c[2])],e=[0,[0,tw,j(c[1])],d];return a(tx,b[1],e)}function
Z(c){var
d=c[2],b=d[1],e=0===b[0]?j(b[1]):Z(b[1]),f=[0,[0,tt,e],[0,ts,j(d[2])]];return a(tu,c[1],f)}function
X(a){switch(a[0]){case
0:return j(a[1]);case
1:return _(a[1]);default:return Z(a[1])}}function
ao(a){return 0===a[0]?n([0,a[1],a[2]]):Y([0,a[1],a[2]])}function
ap(c){var
b=c[2],d=b[2],e=d?h(d[1]):h(b[1]),f=[0,[0,tB,h(b[1])],[0,tA,e]];return a(tC,c[1],f)}function
aq(e){var
d=e[2],f=0===d[0]?[0,tN,d[1]]:[0,tP,d[1]],g=[0,[0,tO,b(c[1],f[2])]];return a(f[1],e[1],g)}function
A(b){var
c=b[2];if(c)var
f=tR,d=[0,[0,tQ,e(c[1])]];else
var
f=tS,d=[0];return a(f,b[1],d)}return[0,aa,e,$]}function
cy(c,a){a[6]=a[6]-c|0;var
b=a[12];a[12]=[0,b[1],b[2],b[3],b[4]-c|0];return 0}function
eV(b,a){return[0,a[1],b,a[3],a[4],a[5]]}function
cz(b,a){return b!==a[3]?[0,a[1],a[2],b,a[4],a[5]]:a}function
n(b,a){return eF(b[1],a[11],a[12])}function
bD(j){var
a=j[2],b=j[1],e=b[5],d=e!==dk?[0,b[1],b[2],b[3],b[4],dk]:b;if(typeof
a==="number")var
c=1;else
switch(a[0]){case
2:var
l=a[1],h=[0,l[1],l[2][3]],c=0;break;case
3:var
i=a[1],q=w(vO,i[3]),r=w(vP,w(i[2],q)),h=[0,i[1],r],c=0;break;case
1:case
4:var
k=a[1],g=k[1],f=k[3],c=2;break;default:var
c=1;}switch(c){case
0:var
g=h[1],f=h[2];break;case
1:var
o=cu(d[2]),g=n(d,d[2]),f=o;break}var
p=m(e[2]);return[0,d,[0,a,g,f,m(e[1]),p]]}function
aS(a,c,b){return[0,a[1],a[2],a[3],a[4],[0,[0,[0,c,b],a[5][1]],a[5][2]]]}function
eW(c,b,a){return aS(c,b,[1,a])}function
aN(b,a){return aS(b,a,vQ)}function
aT(b,a,d,c){var
e=n(b,a);cy(s(d),a);return[0,aN(b,e),c]}var
bE=[W,vR,a0(0)];function
bb(a){var
b=a[5];if(b)return[0,a[1],a[2],a[3],a[4],b[2]];throw bE}function
vS(b){var
a=[0,0];el(function(b){a[1]=[0,b,a[1]];return 0},b);return[0,0,0,0,0,m(a[1])]}function
vT(a){var
c=a[5];if(c){var
d=c[1]+f4|0;if(!(2<d>>>0))switch(d){case
0:return bb(a);case
1:break;default:var
b=bb(a);return[0,1,b[2],b[3],b[4],b[5]]}}return a}function
vU(b){var
a=b[5];if(a)if(48===a[1]){var
c=a[2];if(c){var
d=c[1],e=88===d?0:d4===d?0:1;if(!e)return bb(bb(b))}}throw bE}function
vV(a){var
b=hG(vW,bm(eh,a[5]));try{var
c=c4(b);}catch(a){a=aj(a);if(a[1]===c$)throw bE;throw a}return[0,a[1],a[2],c,a[4],0]}function
vX(l){var
a=l;for(;;){var
j=a[5];if(j){var
b=j[1];if(81<=b){if(95===b){var
a=bb(a);continue}var
k=gJ===b?1:0;}else{if(46===b){if(0===a[4]){var
c=bb(a),a=[0,c[1],c[2],c[3],vY,c[5]];continue}throw bE}var
k=80<=b?1:0;}if(k)return vV(bb(a));if(48<=b)if(57<b)var
g=0;else
var
d=48,g=1;else
var
g=0;if(!g){if(65<=b)if(70<b)var
h=0;else
var
d=55,h=1;else
var
h=0;if(!h){if(97<=b)if(ce<b)var
i=0;else
var
d=87,i=1;else
var
i=0;if(!i)throw bE}}var
e=a[4],m=b-d|0,n=e?[0,e[1]-4|0]:e,o=(a[2]<<4)+m|0,f=bb(a),a=[0,f[1],o,f[3],n,f[5]];continue}return a}}function
vZ(a){if(0===a[5]){var
b=a[2],c=a[4],d=c?a[3]+c[1]|0:a[3],e=0===d?b:Math.pow(b,d);return a[1]?-e:e}throw[0,t,v0]}function
eX(b){try{var
a=HO(b);return a}catch(a){a=aj(a);if(ct)try{var
c=vZ(vX(vU(vT(vS(b)))));return c}catch(b){b=aj(b);if(b===bE)throw a;throw b}throw a}}function
aG(a,f,e,d,c){var
h=g(f,e),b=T(d),i=c?[0,b]:[1,b];return[0,a[1],a[2],a[3],a[4],[0,a[5][1],[0,[0,h,i],a[5][2]]]]}function
bc(a){var
c=a[5],b=0,f=a[6];for(;;){if(c===f){var
d=a[12];a[12]=[0,d[1],d[2],a[12][3]+b|0,d[4]];return 0}var
e=P===(_(a[2],c)&cM)?b+1|0:b,c=c+1|0,b=e;continue}}function
bd(a){if(7<(a+gH|0)>>>0)throw[0,t,v1];return a-48|0}function
bF(a){if(65<=a){if(97<=a){if(!(d5<=a))return(a-97|0)+10|0}else
if(!(71<=a))return(a-65|0)+10|0}else
if(!(9<(a+gH|0)>>>0))return a-48|0;throw[0,t,v2]}function
aU(a){if(fI<=a){var
b=[0,ad(P|a&63),0],c=[0,ad(P|(a>>>6|0)&63),b],d=[0,ad(P|(a>>>12|0)&63),c];return[0,ad(cQ|a>>>18|0),d]}if(d2<=a){var
e=[0,ad(P|a&63),0],f=[0,ad(P|(a>>>6|0)&63),e];return[0,ad(cT|a>>>12|0),f]}if(P<=a){var
g=[0,ad(P|a&63),0];return[0,ad(cM|a>>>6|0),g]}return[0,ad(a),0]}function
aH(d,c,e){if(0===d)var
b=0;else
switch(d-1|0){case
0:var
a=c3(c2(w(v4,c))),b=1;break;case
2:var
a=eX(c),b=1;break;default:var
b=0;}if(!b)var
a=c3(c2(c));var
f=ai(e,v3)?a:-a;return[5,d,f]}var
eY=ez(0,53),eZ=ez(0,53);M(function(a){return eA(eY,a[1],a[2])},v5);M(function(a){return eA(eZ,a[1],a[2])},v6);function
aV(b,a){a[10]=bA(8,-1);return v7(b,a,0)}function
v7(a,d,H){var
q=H;for(;;){var
f=em(as,q,d);if(77<f>>>0){b(d[1],d);var
q=f;continue}var
p=f;if(39<=p)switch(p){case
39:return[0,a,90];case
40:return[0,a,91];case
41:return[0,a,86];case
42:return[0,a,87];case
43:return[0,a,cU];case
44:return[0,a,cl];case
45:return[0,a,68];case
46:return[0,a,94];case
47:return[0,a,67];case
48:return[0,a,66];case
49:return[0,a,96];case
50:return[0,a,95];case
51:return[0,a,77];case
52:return[0,a,76];case
53:return[0,a,74];case
54:return[0,a,75];case
55:return[0,a,72];case
56:return[0,a,71];case
57:return[0,a,70];case
58:return[0,a,69];case
59:return[0,a,92];case
60:return[0,a,93];case
61:return[0,a,97];case
62:return[0,a,98];case
63:return[0,a,ae];case
64:return[0,a,fU];case
65:return[0,a,ce];case
66:return[0,a,83];case
67:return[0,a,85];case
68:return[0,a,84];case
69:return[0,a,d5];case
70:return[0,a,cL];case
71:return[0,a,78];case
72:return[0,a,12];case
73:return[0,a,73];case
74:return[0,a,99];case
75:return[0,a,14];case
76:var
af=a[3]?aS(a,n(a,d),4):a;return[0,af,G];default:return[0,aN(a,n(a,d)),bQ]}switch(p){case
0:aD(d);return aV(a,d);case
1:return aV(aN(a,n(a,d)),d);case
2:bc(d);return aV(a,d);case
3:var
I=n(a,d),r=C(B),s=bo(a,r,d);return aV(aG(s[1],I,s[2],r,1),d);case
4:var
J=k(d[10],0)[1],K=l(d,d[5]+2|0,J),L=d[6],t=l(d,k(d[10],0)[1],L),M=l(d,d[5],d[6]);if(a[4]){var
N=a[3]?eW(a,n(a,d),M):a,u=cz(1,N);return c(t,v9)?aV(u,d):[0,u,80]}var
O=n(a,d),e=C(B);y(e,K);y(e,t);var
v=bo(a,e,d);return aV(aG(v[1],O,v[2],e,1),d);case
5:return a[3]?aV(cz(0,a),d):(cy(1,d),[0,a,ae]);case
6:var
P=n(a,d),w=C(B),x=bG(a,w,d);return aV(aG(x[1],P,x[2],w,0),d);case
7:return 0===d[5]?aV(bG(a,C(B),d)[1],d):[0,a,bQ];case
8:var
z=A(d,d[5]),Q=n(a,d),D=C(B),h=C(B);o(h,z);var
i=e0(a,z,D,h,0,d),R=i[3],S=T(h),U=T(D),V=[1,[0,g(Q,i[2]),U,S,R]];return[0,i[1],V];case
9:var
E=C(B),F=C(B),j=C(B);y(j,cu(d));var
m=e2(a,n(a,d),E,F,j,d),W=m[3],X=T(j),Y=T(F),Z=[0,T(E),Y,X];return[0,m[1],[2,[0,m[2],Z,W]]];case
10:var
_=d[6];return aT(a,d,l(d,k(d[10],0)[1],_),v_);case
11:return[0,a,v$];case
12:var
$=d[6];return aT(a,d,l(d,k(d[10],0)[1],$),wa);case
13:return[0,a,wb];case
14:var
aa=d[6];return aT(a,d,l(d,k(d[10],0)[1],aa),wc);case
15:return[0,a,wd];case
22:var
ac=l(d,d[5],d[6]);bc(d);try{var
ad=[0,a,eB(eY,ac)];return ad}catch(b){b=aj(b);if(b===ah)return[0,a,0];throw b}case
23:return[0,a,1];case
24:return[0,a,2];case
25:return[0,a,5];case
26:return[0,a,6];case
27:return[0,a,7];case
28:return[0,a,8];case
29:return[0,a,13];case
30:return[0,a,11];case
31:return[0,a,9];case
32:return[0,a,10];case
33:return[0,a,80];case
34:return[0,a,79];case
35:return[0,a,82];case
36:return[0,a,81];case
37:return[0,a,88];case
38:return[0,a,89];case
16:case
18:case
20:var
ab=d[6];return aT(a,d,l(d,k(d[10],0)[1],ab),we);default:return[0,a,wf]}}}function
be(b,a){a[10]=bA(26,-1);var
c=a[6];k(a[10],17)[18]=c;var
d=a[6];k(a[10],16)[17]=d;var
e=a[6];k(a[10],15)[16]=e;var
f=a[6];k(a[10],14)[15]=f;var
g=a[6];k(a[10],13)[14]=g;var
h=a[6];k(a[10],12)[13]=h;var
i=a[6];k(a[10],11)[12]=i;var
j=a[6];k(a[10],10)[11]=j;var
l=a[6];k(a[10],9)[10]=l;var
m=a[6];k(a[10],8)[9]=m;var
n=a[6];k(a[10],7)[8]=n;var
o=a[6];k(a[10],6)[7]=o;var
p=a[6];k(a[10],5)[6]=p;var
q=a[6];k(a[10],4)[5]=q;return v8(b,a,133)}function
v8(d,a,D){var
j=D;for(;;){var
f=em(as,j,a);if(51<f>>>0){b(a[1],a);var
j=f;continue}switch(f){case
0:aD(a);return be(d,a);case
1:bc(a);return be(d,a);case
2:var
E=n(d,a),m=C(B),p=bo(d,m,a);return be(aG(p[1],E,p[2],m,1),a);case
3:var
F=k(a[10],0)[1],H=l(a,a[5]+2|0,F),I=a[6],q=l(a,k(a[10],0)[1],I),J=l(a,a[5],a[6]);if(d[4]){var
K=d[3]?eW(d,n(d,a),J):d,r=cz(1,K);return c(q,wg)?be(r,a):[0,r,80]}var
L=n(d,a),e=C(B);y(e,H);y(e,q);var
s=bo(d,e,a);return be(aG(s[1],L,s[2],e,1),a);case
4:return d[3]?be(cz(0,d),a):(cy(1,a),[0,d,ae]);case
5:var
M=n(d,a),t=C(B),u=bG(d,t,a);return be(aG(u[1],M,u[2],t,0),a);case
6:var
v=A(a,a[5]),N=n(d,a),w=C(B),h=C(B);o(h,v);var
i=e0(d,v,w,h,0,a),O=i[3],P=T(h),Q=T(w),R=[1,[0,g(N,i[2]),Q,P,O]];return[0,i[1],R];case
7:var
S=k(a[10],0)[1],U=l(a,a[5],S),V=k(a[10],1)[2],W=l(a,k(a[10],0)[1],V),X=a[6],Y=l(a,k(a[10],1)[2],X);return aT(d,a,Y,aH(0,W,U));case
8:var
Z=k(a[10],0)[1],_=l(a,a[5],Z),$=a[6];return[0,d,aH(0,l(a,k(a[10],0)[1],$),_)];case
9:var
aa=k(a[10],0)[1],ab=l(a,a[5],aa),ac=k(a[10],1)[2],ad=l(a,k(a[10],0)[1],ac),af=a[6],ag=l(a,k(a[10],1)[2],af);return aT(d,a,ag,aH(2,ad,ab));case
10:var
ai=k(a[10],0)[1],ak=l(a,a[5],ai),al=a[6];return[0,d,aH(2,l(a,k(a[10],0)[1],al),ak)];case
11:var
am=k(a[10],0)[1],an=l(a,a[5],am),ao=k(a[10],1)[2],ap=l(a,k(a[10],0)[1],ao),aq=a[6],ar=l(a,k(a[10],1)[2],aq);return aT(d,a,ar,aH(1,ap,an));case
12:var
at=k(a[10],0)[1],au=l(a,a[5],at),av=a[6];return[0,d,aH(1,l(a,k(a[10],0)[1],av),au)];case
13:var
aw=k(a[10],0)[1],ax=l(a,a[5],aw),ay=k(a[10],1)[2],az=l(a,k(a[10],0)[1],ay),aA=a[6],aB=l(a,k(a[10],1)[2],aA);try{var
aC=aH(3,az,ax),z=d,x=aC;}catch(b){b=aj(b);if(!ct)throw b;var
z=aS(d,n(d,a),59),x=wh;}return aT(z,a,aB,x);case
14:var
aE=k(a[10],0)[1],aF=l(a,a[5],aE),aI=a[6],aJ=l(a,k(a[10],0)[1],aI);try{var
aK=[0,d,aH(3,aJ,aF)];return aK}catch(b){b=aj(b);if(ct)return[0,aS(d,n(d,a),59),wi];throw b}case
15:var
aL=k(a[10],0)[1],aM=l(a,a[5],aL),aN=k(a[10],1)[2],aO=l(a,k(a[10],0)[1],aN),aP=a[6],aQ=l(a,k(a[10],1)[2],aP);return aT(d,a,aQ,aH(3,aO,aM));case
16:var
aR=k(a[10],0)[1],aU=l(a,a[5],aR),aV=a[6];return[0,d,aH(3,l(a,k(a[10],0)[1],aV),aU)];case
17:var
aW=k(a[10],0)[1],aX=l(a,a[5],aW),aY=k(a[10],1)[2],aZ=l(a,k(a[10],0)[1],aY),a0=a[6],a1=l(a,k(a[10],1)[2],a0);return aT(d,a,a1,aH(3,aZ,aX));case
18:var
a2=k(a[10],0)[1],a3=l(a,k(a[10],1)[2],a2),a4=k(a[10],2)[3];return[0,d,aH(3,l(a,k(a[10],3)[4],a4),a3)];case
19:var
a5=l(a,a[5],a[6]);bc(a);try{var
a6=[0,d,eB(eZ,a5)];return a6}catch(a){a=aj(a);if(a===ah)return[0,d,0];throw a}case
20:return[0,d,65];case
23:return[0,d,1];case
24:return[0,d,2];case
25:return[0,d,3];case
26:return[0,d,4];case
27:return[0,d,5];case
28:return[0,d,6];case
29:return[0,d,13];case
30:return[0,d,11];case
31:return[0,d,9];case
32:return[0,d,10];case
37:return[0,d,92];case
38:return[0,d,93];case
41:return[0,d,ae];case
43:return[0,d,83];case
44:return[0,d,85];case
45:return[0,d,46];case
46:return[0,d,12];case
48:return[0,d,97];case
49:return[0,d,98];case
50:var
a7=d[3]?aS(d,n(d,a),4):d;return[0,a7,G];case
51:return[0,d,bQ];case
21:case
35:return[0,d,7];case
22:case
36:return[0,d,8];case
33:case
42:return[0,d,80];case
34:case
40:return[0,d,79];default:return[0,d,78]}}}function
e0(s,r,e,d,q,a){var
c=s,f=q;a:for(;;){var
i=bw;for(;;){var
g=aC(as,i,a);if(3<g>>>0){b(a[1],a);var
i=g;continue}switch(g){case
0:var
h=A(a,a[5]);o(d,h);if(r===h)return[0,c,n(c,a),f];o(e,h);continue a;case
1:o(d,A(a,a[5]));var
j=e1(c,e,a),t=j[2],u=t||f;y(d,cu(a));var
c=j[1],f=u;continue a;case
2:var
k=l(a,a[5],a[6]);y(d,k);var
m=aN(c,n(c,a));y(e,k);return[0,m,n(m,a),f];default:var
p=A(a,a[5]);o(d,p);o(e,p);continue a}}}}function
e1(c,d,a){var
f=261;for(;;){var
e=aC(as,f,a);if(17<e>>>0){b(a[1],a);var
f=e;continue}switch(e){case
0:return[0,c,0];case
1:y(d,wj);return[0,c,0];case
2:var
m=A(a,a[5]+1|0),p=bF(A(a,a[5]+2|0)),q=aU((bF(m)*16|0)+p|0);M(function(a){return o(d,a)},q);return[0,c,0];case
3:var
g=A(a,a[5]),h=A(a,a[5]+1|0),i=A(a,a[5]+2|0),r=bd(i),s=bd(h)<<3,j=((bd(g)<<6)+s|0)+r|0;if(bw<=j){var
t=bd(h),u=aU((bd(g)<<3)+t|0);M(function(a){return o(d,a)},u);o(d,i);}else{var
v=aU(j);M(function(a){return o(d,a)},v);}return[0,c,1];case
4:var
x=A(a,a[5]),z=bd(A(a,a[5]+1|0)),B=aU((bd(x)<<3)+z|0);M(function(a){return o(d,a)},B);return[0,c,1];case
5:o(d,ad(0));return[0,c,0];case
6:o(d,ad(8));return[0,c,0];case
7:o(d,ad(12));return[0,c,0];case
8:o(d,ad(10));return[0,c,0];case
9:o(d,ad(13));return[0,c,0];case
10:o(d,ad(9));return[0,c,0];case
11:o(d,ad(11));return[0,c,0];case
12:var
C=aU(bd(A(a,a[5])));M(function(a){return o(d,a)},C);return[0,c,1];case
13:var
D=A(a,a[5]+1|0),E=A(a,a[5]+2|0),F=A(a,a[5]+3|0),G=bF(A(a,a[5]+4|0)),H=bF(F)<<4,I=bF(E)<<8,J=aU((((bF(D)<<12)+I|0)+H|0)+G|0);M(function(a){return o(d,a)},J);return[0,c,0];case
14:var
k=c4(w(wk,l(a,a[5]+2|0,a[6]-1|0))),K=fA<k?aN(c,n(c,a)):c,L=aU(k);M(function(a){return o(d,a)},L);return[0,K,0];case
15:var
N=A(a,a[5]),O=aN(c,n(c,a));o(d,N);return[0,O,0];case
16:aD(a);return[0,c,0];default:o(d,A(a,a[5]));return[0,c,0]}}}function
bo(c,d,a){a:for(;;){var
f=288;for(;;){var
e=aC(as,f,a);if(4<e>>>0){b(a[1],a);var
f=e;continue}switch(e){case
0:var
g=aN(c,n(c,a));return[0,g,n(g,a)];case
1:aD(a);o(d,10);continue a;case
2:var
h=n(c,a),i=c[3]?aS(c,h,[2,wm,wl]):c;return[0,i,h];case
3:if(c[3])return[0,c,n(c,a)];y(d,wn);continue a;default:o(d,A(a,a[5]));continue a}}}}function
bG(c,h,a){a:for(;;){var
g=296;for(;;){var
d=aC(as,g,a);if(2<d>>>0){b(a[1],a);var
g=d;continue}switch(d){case
0:return[0,c,n(c,a)];case
1:var
e=n(c,a),f=e[3];aD(a);return[0,c,[0,e[1],e[2],[0,f[1],f[2]-1|0,f[3]-1|0]]];default:o(h,A(a,a[5]));continue a}}}}function
dl(ah,be,Z,ag,d){a:for(;;){var
aE=380;for(;;){var
aj=aC(as,aE,d);if(6<aj>>>0){b(d[1],d);var
aE=aj;continue}switch(aj){case
0:var
ai=A(d,d[5]);switch(be){case
0:var
aA=39===ai?1:0;break;case
1:var
aA=34===ai?1:0;break;default:if(60===ai)var
aB=1;else
if(123===ai)var
aB=1;else
var
aA=0,aB=0;if(aB){cy(d[12][4]-d[11][4]|0,d);return[0,ah,n(ah,d)]}}if(aA)return[0,ah,n(ah,d)];o(ag,ai);o(Z,ai);continue a;case
1:var
aF=aN(ah,n(ah,d));return[0,aF,n(aF,d)];case
2:var
aG=l(d,d[5],d[6]);y(ag,aG);y(Z,aG);aD(d);continue a;case
3:var
bf=l(d,d[5]+3|0,d[6]-1|0);y(ag,l(d,d[5],d[6]));var
bg=aU(c4(w(ws,bf)));M(function(a){return o(Z,a)},bg);continue a;case
4:var
bh=l(d,d[5]+2|0,d[6]-1|0);y(ag,l(d,d[5],d[6]));var
bi=aU(c4(bh));M(function(a){return o(Z,a)},bi);continue a;case
5:var
a=l(d,d[5]+1|0,d[6]-1|0);y(ag,l(d,d[5],d[6]));var
aH=x(a,wt);if(0<=aH)if(0<aH){var
aI=x(a,wu);if(0<=aI)if(0<aI){var
aJ=x(a,wv);if(0<=aJ)if(0<aJ){var
aK=x(a,ww);if(0<=aK)if(0<aK){var
aL=x(a,wx);if(0<=aL)if(0<aL)if(c(a,wy))if(c(a,wz))if(c(a,wA))if(c(a,wB))if(c(a,wC))if(c(a,wD))var
e=1,f=0,V=0,_=0,C=0;else
var
T=wG,C=1;else
var
T=wH,C=1;else
var
T=wI,C=1;else
var
T=wJ,C=1;else
var
T=wK,C=1;else
var
T=wL,C=1;else
var
T=wM,C=1;else
if(c(a,wN))if(c(a,wO))if(c(a,wP))if(c(a,wQ))if(c(a,wR))if(c(a,wS))if(c(a,wT))var
e=1,f=0,V=0,_=0,C=0;else
var
T=wU,C=1;else
var
T=wV,C=1;else
var
T=wW,C=1;else
var
T=wX,C=1;else
var
T=wY,C=1;else
var
T=wZ,C=1;else
var
T=w0,C=1;if(C)var
ak=T,_=1;}else
var
ak=w1,_=1;else{var
aO=x(a,w2);if(0<=aO)if(0<aO)if(c(a,w3))if(c(a,w4))if(c(a,w5))if(c(a,w6))if(c(a,w7))if(c(a,w8))if(c(a,w9))var
e=1,f=0,V=0,_=0,h=0;else
var
E=w_,h=1;else
var
E=w$,h=1;else
var
E=xa,h=1;else
var
E=xb,h=1;else
var
E=xc,h=1;else
var
E=xd,h=1;else
var
E=xe,h=1;else
var
E=xf,h=1;else
if(c(a,xg))if(c(a,xh))if(c(a,xi))if(c(a,xj))if(c(a,xk))if(c(a,xl))if(c(a,xm))var
e=1,f=0,V=0,_=0,h=0;else
var
E=xn,h=1;else
var
E=xo,h=1;else
var
E=xp,h=1;else
var
E=xq,h=1;else
var
E=xr,h=1;else
var
E=xs,h=1;else
var
E=xt,h=1;if(h)var
ak=E,_=1;}if(_)var
al=ak,V=1;}else
var
al=xu,V=1;else{var
aP=x(a,xv);if(0<=aP)if(0<aP){var
aQ=x(a,xw);if(0<=aQ)if(0<aQ)if(c(a,xx))if(c(a,xy))if(c(a,xz))if(c(a,xA))if(c(a,xB))if(c(a,xC))if(c(a,xD))var
e=1,f=0,V=0,$=0,i=0;else
var
F=xE,i=1;else
var
F=xF,i=1;else
var
F=xG,i=1;else
var
F=xH,i=1;else
var
F=xI,i=1;else
var
F=xJ,i=1;else
var
F=xK,i=1;else
var
F=xL,i=1;else
if(c(a,xM))if(c(a,xN))if(c(a,xO))if(c(a,xP))if(c(a,xQ))if(c(a,xR))if(c(a,xS))var
e=1,f=0,V=0,$=0,i=0;else
var
F=xT,i=1;else
var
F=xU,i=1;else
var
F=xV,i=1;else
var
F=xW,i=1;else
var
F=xX,i=1;else
var
F=xY,i=1;else
var
F=xZ,i=1;if(i)var
ao=F,$=1;}else
var
ao=x0,$=1;else{var
aR=x(a,x1);if(0<=aR)if(0<aR)if(c(a,x2))if(c(a,x3))if(c(a,x4))if(c(a,x5))if(c(a,x6))if(c(a,x7))if(c(a,x8))var
e=1,f=0,V=0,$=0,j=0;else
var
G=x9,j=1;else
var
G=x_,j=1;else
var
G=x$,j=1;else
var
G=ya,j=1;else
var
G=yb,j=1;else
var
G=yc,j=1;else
var
G=yd,j=1;else
var
G=ye,j=1;else
if(c(a,yf))if(c(a,yg))if(c(a,yh))if(c(a,yi))if(c(a,yj))if(c(a,yk))if(c(a,yl))var
e=1,f=0,V=0,$=0,j=0;else
var
G=ym,j=1;else
var
G=yn,j=1;else
var
G=yo,j=1;else
var
G=yp,j=1;else
var
G=yq,j=1;else
var
G=yr,j=1;else
var
G=ys,j=1;if(j)var
ao=G,$=1;}if($)var
al=ao,V=1;}if(V)var
am=al,f=1;}else
var
am=yt,f=1;else{var
aS=x(a,yu);if(0<=aS)if(0<aS){var
aT=x(a,yv);if(0<=aT)if(0<aT){var
aV=x(a,yw);if(0<=aV)if(0<aV)if(c(a,yx))if(c(a,yy))if(c(a,yz))if(c(a,yA))if(c(a,yB))if(c(a,yC))if(c(a,yD))var
e=1,f=0,W=0,aa=0,k=0;else
var
H=yE,k=1;else
var
H=yF,k=1;else
var
H=yG,k=1;else
var
H=yH,k=1;else
var
H=yI,k=1;else
var
H=yJ,k=1;else
var
H=yK,k=1;else
var
H=yL,k=1;else
if(c(a,yM))if(c(a,yN))if(c(a,yO))if(c(a,yP))if(c(a,yQ))if(c(a,yR))if(c(a,yS))var
e=1,f=0,W=0,aa=0,k=0;else
var
H=yT,k=1;else
var
H=yU,k=1;else
var
H=yV,k=1;else
var
H=yW,k=1;else
var
H=yX,k=1;else
var
H=yY,k=1;else
var
H=yZ,k=1;if(k)var
ap=H,aa=1;}else
var
ap=y0,aa=1;else{var
aW=x(a,y1);if(0<=aW)if(0<aW)if(c(a,y2))if(c(a,y3))if(c(a,y4))if(c(a,y5))if(c(a,y6))if(c(a,y7))if(c(a,y8))var
e=1,f=0,W=0,aa=0,m=0;else
var
I=y9,m=1;else
var
I=y_,m=1;else
var
I=y$,m=1;else
var
I=za,m=1;else
var
I=zb,m=1;else
var
I=zc,m=1;else
var
I=zd,m=1;else
var
I=ze,m=1;else
if(c(a,zf))if(c(a,zg))if(c(a,zh))if(c(a,zi))if(c(a,zj))if(c(a,zk))if(c(a,zl))var
e=1,f=0,W=0,aa=0,m=0;else
var
I=zm,m=1;else
var
I=zn,m=1;else
var
I=zo,m=1;else
var
I=zp,m=1;else
var
I=zq,m=1;else
var
I=zr,m=1;else
var
I=zs,m=1;if(m)var
ap=I,aa=1;}if(aa)var
aq=ap,W=1;}else
var
aq=zt,W=1;else{var
aX=x(a,zu);if(0<=aX)if(0<aX){var
aY=x(a,zv);if(0<=aY)if(0<aY)if(c(a,zw))if(c(a,zx))if(c(a,zy))if(c(a,zz))if(c(a,zA))if(c(a,zB))if(c(a,zC))var
e=1,f=0,W=0,ab=0,p=0;else
var
J=zD,p=1;else
var
J=zE,p=1;else
var
J=zF,p=1;else
var
J=zG,p=1;else
var
J=zH,p=1;else
var
J=zI,p=1;else
var
J=zJ,p=1;else
var
J=zK,p=1;else
if(c(a,zL))if(c(a,zM))if(c(a,zN))if(c(a,zO))if(c(a,zP))if(c(a,zQ))if(c(a,zR))var
e=1,f=0,W=0,ab=0,p=0;else
var
J=zS,p=1;else
var
J=zT,p=1;else
var
J=zU,p=1;else
var
J=zV,p=1;else
var
J=zW,p=1;else
var
J=zX,p=1;else
var
J=zY,p=1;if(p)var
ar=J,ab=1;}else
var
ar=zZ,ab=1;else{var
aZ=x(a,z0);if(0<=aZ)if(0<aZ)if(c(a,z1))if(c(a,z2))if(c(a,z3))if(c(a,z4))if(c(a,z5))if(c(a,z6))if(c(a,z7))var
e=1,f=0,W=0,ab=0,q=0;else
var
K=z8,q=1;else
var
K=z9,q=1;else
var
K=z_,q=1;else
var
K=z$,q=1;else
var
K=Aa,q=1;else
var
K=Ab,q=1;else
var
K=Ac,q=1;else
var
K=Ad,q=1;else
if(c(a,Ae))if(c(a,Af))if(c(a,Ag))if(c(a,Ah))if(c(a,Ai))if(c(a,Aj))if(c(a,Ak))var
e=1,f=0,W=0,ab=0,q=0;else
var
K=Al,q=1;else
var
K=Am,q=1;else
var
K=An,q=1;else
var
K=Ao,q=1;else
var
K=Ap,q=1;else
var
K=Aq,q=1;else
var
K=Ar,q=1;if(q)var
ar=K,ab=1;}if(ab)var
aq=ar,W=1;}if(W)var
am=aq,f=1;}if(f)var
an=am,e=0;}else
var
an=As,e=0;else{var
a0=x(a,At);if(0<=a0)if(0<a0){var
a1=x(a,Au);if(0<=a1)if(0<a1){var
a2=x(a,Av);if(0<=a2)if(0<a2){var
a3=x(a,Aw);if(0<=a3)if(0<a3)if(c(a,Ax))if(c(a,Ay))if(c(a,Az))if(c(a,AA))if(c(a,AB))if(c(a,AC))var
e=1,g=0,X=0,ac=0,D=0;else
var
U=AD,D=1;else
var
U=AE,D=1;else
var
U=AF,D=1;else
var
U=AG,D=1;else
var
U=AH,D=1;else
var
U=AI,D=1;else
var
U=AJ,D=1;else
if(c(a,AK))if(c(a,AL))if(c(a,AM))if(c(a,AN))if(c(a,AO))if(c(a,AP))if(c(a,AQ))var
e=1,g=0,X=0,ac=0,D=0;else
var
U=AR,D=1;else
var
U=AS,D=1;else
var
U=AT,D=1;else
var
U=AU,D=1;else
var
U=AV,D=1;else
var
U=AW,D=1;else
var
U=AX,D=1;if(D)var
at=U,ac=1;}else
var
at=AY,ac=1;else{var
a4=x(a,AZ);if(0<=a4)if(0<a4)if(c(a,A0))if(c(a,A1))if(c(a,A2))if(c(a,A3))if(c(a,A4))if(c(a,A5))if(c(a,A6))var
e=1,g=0,X=0,ac=0,r=0;else
var
L=A7,r=1;else
var
L=A8,r=1;else
var
L=A9,r=1;else
var
L=A_,r=1;else
var
L=A$,r=1;else
var
L=Ba,r=1;else
var
L=Bb,r=1;else
var
L=Bc,r=1;else
if(c(a,Bd))if(c(a,Be))if(c(a,Bf))if(c(a,Bg))if(c(a,Bh))if(c(a,Bi))if(c(a,Bj))var
e=1,g=0,X=0,ac=0,r=0;else
var
L=Bk,r=1;else
var
L=Bl,r=1;else
var
L=Bm,r=1;else
var
L=Bn,r=1;else
var
L=Bo,r=1;else
var
L=Bp,r=1;else
var
L=Bq,r=1;if(r)var
at=L,ac=1;}if(ac)var
au=at,X=1;}else
var
au=Br,X=1;else{var
a5=x(a,Bs);if(0<=a5)if(0<a5){var
a6=x(a,Bt);if(0<=a6)if(0<a6)if(c(a,Bu))if(c(a,Bv))if(c(a,Bw))if(c(a,Bx))if(c(a,By))if(c(a,Bz))if(c(a,BA))var
e=1,g=0,X=0,ad=0,s=0;else
var
N=BB,s=1;else
var
N=BC,s=1;else
var
N=BD,s=1;else
var
N=BE,s=1;else
var
N=BF,s=1;else
var
N=BG,s=1;else
var
N=BH,s=1;else
var
N=BI,s=1;else
if(c(a,BJ))if(c(a,BK))if(c(a,BL))if(c(a,BM))if(c(a,BN))if(c(a,BO))if(c(a,BP))var
e=1,g=0,X=0,ad=0,s=0;else
var
N=BQ,s=1;else
var
N=BR,s=1;else
var
N=BS,s=1;else
var
N=BT,s=1;else
var
N=BU,s=1;else
var
N=BV,s=1;else
var
N=BW,s=1;if(s)var
aw=N,ad=1;}else
var
aw=BX,ad=1;else{var
a7=x(a,BY);if(0<=a7)if(0<a7)if(c(a,BZ))if(c(a,B0))if(c(a,B1))if(c(a,B2))if(c(a,B3))if(c(a,B4))if(c(a,B5))var
e=1,g=0,X=0,ad=0,t=0;else
var
O=B6,t=1;else
var
O=B7,t=1;else
var
O=B8,t=1;else
var
O=B9,t=1;else
var
O=B_,t=1;else
var
O=B$,t=1;else
var
O=Ca,t=1;else
var
O=Cb,t=1;else
if(c(a,Cc))if(c(a,Cd))if(c(a,Ce))if(c(a,Cf))if(c(a,Cg))if(c(a,Ch))if(c(a,Ci))var
e=1,g=0,X=0,ad=0,t=0;else
var
O=Cj,t=1;else
var
O=Ck,t=1;else
var
O=Cl,t=1;else
var
O=Cm,t=1;else
var
O=Cn,t=1;else
var
O=Co,t=1;else
var
O=Cp,t=1;if(t)var
aw=O,ad=1;}if(ad)var
au=aw,X=1;}if(X)var
av=au,g=1;}else
var
av=Cq,g=1;else{var
a8=x(a,Cr);if(0<=a8)if(0<a8){var
a9=x(a,Cs);if(0<=a9)if(0<a9){var
a_=x(a,Ct);if(0<=a_)if(0<a_)if(c(a,Cu))if(c(a,Cv))if(c(a,Cw))if(c(a,Cx))if(c(a,Cy))if(c(a,Cz))if(c(a,CA))var
e=1,g=0,Y=0,ae=0,u=0;else
var
P=CB,u=1;else
var
P=CC,u=1;else
var
P=CD,u=1;else
var
P=CE,u=1;else
var
P=CF,u=1;else
var
P=CG,u=1;else
var
P=CH,u=1;else
var
P=CI,u=1;else
if(c(a,CJ))if(c(a,CK))if(c(a,CL))if(c(a,CM))if(c(a,CN))if(c(a,CO))if(c(a,CP))var
e=1,g=0,Y=0,ae=0,u=0;else
var
P=CQ,u=1;else
var
P=CR,u=1;else
var
P=CS,u=1;else
var
P=CT,u=1;else
var
P=CU,u=1;else
var
P=CV,u=1;else
var
P=CW,u=1;if(u)var
ax=P,ae=1;}else
var
ax=CX,ae=1;else{var
a$=x(a,CY);if(0<=a$)if(0<a$)if(c(a,CZ))if(c(a,C0))if(c(a,C1))if(c(a,C2))if(c(a,C3))if(c(a,C4))if(c(a,C5))var
e=1,g=0,Y=0,ae=0,v=0;else
var
Q=C6,v=1;else
var
Q=C7,v=1;else
var
Q=C8,v=1;else
var
Q=C9,v=1;else
var
Q=C_,v=1;else
var
Q=C$,v=1;else
var
Q=Da,v=1;else
var
Q=Db,v=1;else
if(c(a,Dc))if(c(a,Dd))if(c(a,De))if(c(a,Df))if(c(a,Dg))if(c(a,Dh))if(c(a,Di))var
e=1,g=0,Y=0,ae=0,v=0;else
var
Q=Dj,v=1;else
var
Q=Dk,v=1;else
var
Q=Dl,v=1;else
var
Q=Dm,v=1;else
var
Q=Dn,v=1;else
var
Q=Do,v=1;else
var
Q=Dp,v=1;if(v)var
ax=Q,ae=1;}if(ae)var
ay=ax,Y=1;}else
var
ay=Dq,Y=1;else{var
ba=x(a,Dr);if(0<=ba)if(0<ba){var
bb=x(a,Ds);if(0<=bb)if(0<bb)if(c(a,Dt))if(c(a,Du))if(c(a,Dv))if(c(a,Dw))if(c(a,Dx))if(c(a,Dy))if(c(a,Dz))var
e=1,g=0,Y=0,af=0,z=0;else
var
R=DA,z=1;else
var
R=DB,z=1;else
var
R=DC,z=1;else
var
R=DD,z=1;else
var
R=DE,z=1;else
var
R=DF,z=1;else
var
R=DG,z=1;else
var
R=DH,z=1;else
if(c(a,DI))if(c(a,DJ))if(c(a,DK))if(c(a,DL))if(c(a,DM))if(c(a,DN))if(c(a,DO))var
e=1,g=0,Y=0,af=0,z=0;else
var
R=DP,z=1;else
var
R=DQ,z=1;else
var
R=DR,z=1;else
var
R=DS,z=1;else
var
R=DT,z=1;else
var
R=DU,z=1;else
var
R=DV,z=1;if(z)var
az=R,af=1;}else
var
az=DW,af=1;else{var
bc=x(a,DX);if(0<=bc)if(0<bc)if(c(a,DY))if(c(a,DZ))if(c(a,D0))if(c(a,D1))if(c(a,D2))if(c(a,D3))if(c(a,D4))var
e=1,g=0,Y=0,af=0,B=0;else
var
S=D5,B=1;else
var
S=D6,B=1;else
var
S=D7,B=1;else
var
S=D8,B=1;else
var
S=D9,B=1;else
var
S=D_,B=1;else
var
S=D$,B=1;else
var
S=Ea,B=1;else
if(c(a,Eb))if(c(a,Ec))if(c(a,Ed))if(c(a,Ee))if(c(a,Ef))if(c(a,Eg))if(c(a,Eh))var
e=1,g=0,Y=0,af=0,B=0;else
var
S=Ei,B=1;else
var
S=Ej,B=1;else
var
S=Ek,B=1;else
var
S=El,B=1;else
var
S=Em,B=1;else
var
S=En,B=1;else
var
S=Eo,B=1;if(B)var
az=S,af=1;}if(af)var
ay=az,Y=1;}if(Y)var
av=ay,g=1;}if(g)var
an=av,e=0;}var
aM=e?0:an;if(aM){var
bj=aU(aM[1]);M(function(a){return o(Z,a)},bj);}else
y(Z,w(wF,w(a,wE)));continue a;default:var
bd=A(d,d[5]);o(ag,bd);o(Z,bd);continue a}}}}function
e2(s,h,f,e,d,a){var
c=s;a:for(;;){var
k=425;for(;;){var
i=aC(as,k,a);if(6<i>>>0){b(a[1],a);var
k=i;continue}switch(i){case
0:var
m=aN(c,n(c,a));return[0,m,g(h,n(m,a)),1];case
1:o(d,96);return[0,c,g(h,n(c,a)),1];case
2:y(d,Er);return[0,c,g(h,n(c,a)),0];case
3:o(e,92);o(d,92);var
t=e1(c,f,a),p=cu(a);y(e,p);y(d,p);var
c=t[1];continue a;case
4:var
q=l(a,a[5],a[5]+2|0);y(e,q);y(d,q);y(f,Es);aD(a);continue a;case
5:var
r=A(a,a[5]);o(e,r);o(d,r);o(f,10);aD(a);continue a;default:var
j=A(a,a[5]);o(e,j);o(d,j);o(f,j);continue a}}}}var
bH=cv([0,dd]);function
b5(a,d){var
b=a[2],c=b.slice();c[2]=b[2];return[0,[0],0,d,eV(c,a)]}function
dm(i,aE){var
aF=aE+1|0;if(i[1].length-1<aF){var
r=1;for(;;){if(!(aF<=r)){var
r=r*2|0;continue}var
ax=function(a){var
b=a<i[1].length-1?1:0,c=b?k(i[1],a)[a+1]:b;return c};if(0===r)var
O=[0];else
if(0<=r){var
Q=bA(r,ax(0)),R=r-1|0,aH=1;if(!(R<1)){var
x=aH;for(;;){Q[x+1]=ax(x);var
aI=x+1|0;if(R!==x){var
x=aI;continue}break}}var
O=Q;}else
var
O=az(hJ);i[1]=O;break}}for(;;){if(i[2]<=aE){var
e=i[4];switch(i[3]){case
0:var
s=bD(aV(e,e[2]));break;case
1:var
s=bD(be(e,e[2]));break;case
2:var
f=e[2],d=e;b:for(;;){var
ab=342;for(;;){var
H=aC(as,ab,f);if(14<H>>>0){b(f[1],f);var
ab=H;continue}switch(H){case
0:var
m=[0,d,G];break;case
1:aD(f);continue b;case
2:bc(f);continue b;case
3:var
aP=n(d,f),ac=C(B),ad=bG(d,ac,f),d=aG(ad[1],aP,ad[2],ac,0);continue b;case
4:var
aQ=n(d,f),ae=C(B),af=bo(d,ae,f),d=aG(af[1],aQ,af[2],ae,1);continue b;case
5:var
m=[0,d,92];break;case
6:var
m=[0,d,99];break;case
7:var
m=[0,d,93];break;case
8:var
m=[0,d,1];break;case
9:var
m=[0,d,80];break;case
10:var
m=[0,d,11];break;case
11:var
m=[0,d,78];break;case
12:bc(f);var
m=[0,d,fW];break;case
13:var
I=A(f,f[5]),aR=n(d,f),ag=C(B),z=C(B);o(z,I);var
aT=39===I?0:1,ah=dl(d,aT,ag,z,f);o(z,I);var
aU=T(ag),aW=T(z),aX=[4,[0,g(aR,ah[2]),aU,aW]],m=[0,ah[1],aX];break;default:var
m=[0,d,bQ];}var
s=bD(m);break}break}break;case
3:var
S=e[2][12],U=eF(e[1],S,S),u=C(B),v=C(B),j=e[2],ai=373;for(;;){var
J=aC(as,ai,j);if(4<J>>>0){b(j[1],j);var
ai=J;continue}switch(J){case
0:var
aj=l(j,j[5],j[6]);y(v,aj);y(u,aj);aD(j);var
ak=dl(e,2,u,v,j),aY=T(u),aZ=T(v),a0=[4,[0,g(U,ak[2]),aY,aZ]],w=[0,ak[1],a0];break;case
1:var
w=[0,e,G];break;case
2:var
w=[0,e,92];break;case
3:var
w=[0,e,1];break;default:var
al=A(j,j[5]);o(v,al);o(u,al);var
am=dl(e,2,u,v,j),a1=T(u),a2=T(v),a3=[4,[0,g(U,am[2]),a1,a2]],w=[0,am[1],a3];}var
s=bD([0,w[1],w[2]]);break}break;case
4:var
h=e[2],p=e;b:for(;;){var
an=go;for(;;){var
K=aC(as,an,h);if(5<K>>>0){b(h[1],h);var
an=K;continue}switch(K){case
0:aD(h);continue b;case
1:bc(h);continue b;case
2:var
a4=n(p,h),ao=C(B),ap=bG(p,ao,h),p=aG(ap[1],a4,ap[2],ao,0);continue b;case
3:var
a5=n(p,h),aq=C(B),ar=bo(p,aq,h),p=aG(ar[1],a5,ar[2],aq,1);continue b;case
4:var
a6=n(p,h),at=C(B),au=C(B),L=C(B);y(L,Ep);var
M=e2(p,a6,at,au,L,h),a7=M[3],a8=T(L),a9=T(au),a_=[0,T(at),a9,a8],aw=[0,M[1],[2,[0,M[2],a_,a7]]];break;default:var
av=aN(p,n(p,h)),aw=[0,av,[2,[0,n(av,h),Eq,1]]];}var
s=bD(aw);break}break}break;default:var
a=e[2],c=e;b:for(;;){var
V=300;for(;;){var
D=aC(as,V,a);if(6<D>>>0){b(a[1],a);var
V=D;continue}switch(D){case
0:var
N=[0,c,G];break;case
1:aD(a);continue b;case
2:bc(a);continue b;case
3:var
aJ=n(c,a),W=C(B),X=bG(c,W,a),c=aG(X[1],aJ,X[2],W,0);continue b;case
4:var
aK=n(c,a),Y=C(B),Z=bo(c,Y,a),c=aG(Z[1],aK,Z[2],Y,1);continue b;case
5:var
aL=n(c,a),q=C(B);c:for(;;){var
$=323;for(;;){var
E=aC(as,$,a);if(7<E>>>0){b(a[1],a);var
$=E;continue}switch(E){case
0:var
t=[0,aS(c,n(c,a),14),wo];break;case
1:var
t=[0,aS(c,n(c,a),14),wp];break;case
2:y(q,l(a,a[5],a[5]+2|0));continue c;case
3:var
t=[0,c,l(a,a[5]+1|0,a[6])];break;case
4:var
t=[0,c,wq];break;case
5:o(q,A(a,a[5]));d:for(;;){var
aa=335;for(;;){var
F=aC(as,aa,a);if(4<F>>>0){b(a[1],a);var
aa=F;continue}switch(F){case
0:break;case
3:o(q,A(a,a[5]));break;case
4:o(q,A(a,a[5]));continue d;default:y(q,l(a,a[5],a[5]+2|0));continue d}continue c}}case
6:var
t=[0,aS(c,n(c,a),14),wr];break;default:o(q,A(a,a[5]));continue c}var
_=t[1],aM=g(aL,n(_,a)),aO=t[2],N=[0,_,[3,[0,aM,T(q),aO]]];break}break}break;default:var
N=[0,aN(c,n(c,a)),bQ];}var
s=bD(N);break}break}}var
P=s[1],ay=P[2],aA=ay.slice();aA[2]=ay[2];var
a$=eV(aA,P);i[4]=P;var
aB=i[2],ba=[0,[0,a$,s[2]]];k(i[1],aB)[aB+1]=ba;i[2]=i[2]+1|0;continue}return 0}}function
b6(a){return bl(a[20][1])}function
at(a){return a[24][5]}function
q(a,c){var
d=c[2];a[1][1]=[0,[0,c[1],d],a[1][1]];var
b=a[19];return b?f(b[1],a,d):b}function
bI(a,c){var
b=c[2];if(f(bH[3],b,a[4][1]))return q(a,[0,c[1],[7,b]]);var
d=f(bH[4],b,a[4][1]);a[4][1]=d;return 0}function
b7(c,e){var
a=c?c[1]:0;if(a<2){var
d=e[22][1];dm(d,a);var
b=k(d[1],a)[a+1];return b?b[1][2]:ay(Et)}throw[0,t,Ew]}function
bf(c,b){var
a=b.slice();a[6]=c;return a}function
e3(c,b){var
a=b.slice();a[18]=c;return a}function
b8(c,b){var
a=b.slice();a[13]=c;return a}function
b9(c,b){var
a=b.slice();a[8]=c;return a}function
bp(c,b){var
a=b.slice();a[11]=c;return a}function
dp(c,b){var
a=b.slice();a[14]=c;return a}function
e4(c,b){var
a=b.slice();a[7]=c;return a}function
e5(c,b){var
a=b.slice();a[12]=c;return a}function
e6(c,b){var
a=b.slice();a[19]=[0,c];return a}function
e7(a){function
b(b){return q(a,b)}return function(a){return M(b,a)}}function
cA(a){return a[5][1]}function
e8(b){var
a=b.slice();a[19]=0;return a}function
e9(d,c,b){var
a=d.slice();a[3]=bH[1];a[8]=0;a[9]=0;a[10]=1;a[16]=b;a[17]=c;return a}function
cB(a){return c(a,Ex)?0:1}function
b_(a){if(c(a,Ey))if(c(a,Ez))if(c(a,EA))if(c(a,EB))if(c(a,EC))if(c(a,ED))if(c(a,EE))if(c(a,EF))return 0;return 1}function
bq(a){if(c(a,EG))if(c(a,EH))return 0;return 1}function
e(a,b){var
c=a?a[1]:0;return b7([0,c],b)[1]}function
E(a,b){var
c=a?a[1]:0;return b7([0,c],b)[3]}function
h(a,b){var
c=a?a[1]:0;return b7([0,c],b)[2]}function
e_(a,b){var
c=a?a[1]:0;return b7([0,c],b)[4]}function
bJ(b){var
a=cA(b);if(a)var
d=a[1][2][1],c=d<h(0,b)[2][1]?1:0;else
var
c=a;return c}function
b$(b){var
c=e(0,b);if(typeof
c==="number"){var
a=c-3|0;if(cL<a>>>0){if(!(cl<(a+1|0)>>>0))return 1}else{var
d=6!==a?1:0;if(!d)return d}}return bJ(b)}function
N(b,a){var
c=b?b[1]:0,d=9===e([0,c],a)?1:0,f=d?[0,h([0,c],a)]:d;return f}function
aI(d,c){var
f=d?d[1]:0,a=E([0,f],c),g=e([0,f],c);if(!b_(a))if(!bq(a))if(!cB(a)){if(typeof
g==="number"){var
b=g-1|0,h=58<b>>>0?64<=b?0:1:27===b?1:0;if(h)return 1}return 0}return 1}function
cC(c,a){var
b=c?c[1]:0,d=15===e([0,b],a)?1:0;if(d)var
f=d;else
var
g=63===e([0,b],a)?1:0,f=g?15===e([0,b+1|0],a)?1:0:g;return f}function
dq(b,c){var
d=b?b[1]:0,a=e([0,d],c);if(typeof
a==="number"){var
f=14===a?1:40===a?1:0;if(f)return 1}return 0}function
r(a,b){return q(a,[0,h(0,a),b])}function
e$(c){var
a=c[1];if(typeof
a==="number")switch(a){case
0:return 2;case
108:return 4}else
switch(a[0]){case
0:return 0;case
1:case
4:return 1}var
b=c[2];return cB(b)?3:b_(b)?40:[1,b]}function
ac(a){var
c=e_(0,a);b(e7(a),c);var
d=E(0,a);return r(a,e$([0,e(0,a),d]))}function
dr(a){function
b(b){return q(a,[0,b[1],57])}return function(a){return M(b,a)}}function
au(a,c){var
b=a[6];return b?r(a,c):b}function
aW(b,a){var
c=b[6];return c?q(b,[0,a[1],a[2]]):c}function
H(a){var
m=a[23][1];if(m){var
o=h(0,a),p=e(0,a),q=E(0,a),r=[0,o,p,b6(a),q];b(m[1],r);}var
l=a[22][1];dm(l,0);var
f=k(l[1],0)[1],s=f?f[1][1]:ay(Eu);a[21][1]=s;var
t=e_(0,a);b(e7(a),t);var
n=b7([0,0],a)[5];M(function(b){a[2][1]=[0,b,a[2][1]];return 0},n);var
u=[0,h(0,a)];a[5][1]=u;var
c=a[22][1];dm(c,0);if(1<c[2]){var
d=c[2]-1|0,g=c[1],i=c[1],v=0<=d?(i.length-1-d|0)<1?0:(g.length-1-d|0)<0?0:(HJ(i,1,g,0,d),1):0;if(!v)az(hK);}var
j=c[2]-1|0;k(c[1],j)[j+1]=0;c[2]=c[2]-1|0;return 0}function
aO(a,b){a[20][1]=[0,b,a[20][1]];var
c=b6(a),d=b5(a[21][1],c);a[22][1]=d;return 0}function
a4(a){var
b=a[20][1],c=b?b[2]:ay(EI);a[20][1]=c;var
d=b6(a),e=b5(a[21][1],d);a[22][1]=e;return 0}function
O(a){var
b=1-b$(a);return b?9===e(0,a)?H(a):ac(a):b}function
d(a,b){if(bY(e(0,a),b))ac(a);return H(a)}function
am(a,c){var
b=g4(e(0,a),c),d=b?(H(a),1):b;return d}function
aX(a,b){if(c(E(0,a),b))ac(a);return H(a)}var
ca=[W,EK,a0(0)];function
EL(b){var
c=b[23][1];if(c){var
a=[0,0,0,0],e=[0,function(d){var
b=[0,d,0],c=a[3];return c?(a[1]=a[1]+1|0,c[2]=b,a[3]=b,0):(a[1]=1,a[2]=b,a[3]=b,0)}];b[23][1]=e;var
d=[0,[0,c[1],a]];}else
var
d=c;return[0,b[1][1],b[2][1],b[5][1],b[20][1],b[21][1],d]}function
fa(d,i,c){if(c){var
e=c[1],f=e[1];i[23][1]=[0,f];if(d){var
a=e[2][2];for(;;){if(a){var
h=a[2];b(f,a[1]);var
a=h;continue}return 0}}var
g=d;}else
var
g=c;return g}function
EM(a,b){fa(0,a,b[6]);a[1][1]=b[1];a[2][1]=b[2];a[5][1]=b[3];a[20][1]=b[4];a[21][1]=b[5];var
c=b6(a),d=b5(a[21][1],c);a[22][1]=d;return 0}function
EN(c,b,a){fa(1,c,b[6]);return[0,a]}function
fb(a,d){var
c=EL(a);try{var
e=EN(a,c,b(d,a));return e}catch(b){b=aj(b);if(b===ca)return EM(a,c);throw b}}function
br(d,a){var
e=h(0,a),f=b(d,a),c=cA(a),i=c?c[1]:(r(a,EO),h(0,a));return[0,g(e,i),f]}function
EP(p){var
j=function
b(a){return b.fun(a)},x=function
b(a){return b.fun(a)},F=function
b(a){return b.fun(a)},y=function
b(a){return b.fun(a)},W=function
b(a){return b.fun(a)},z=function
c(a,b){return c.fun(a,b)},A=function
b(a){return b.fun(a)},C=function
c(a,b){return c.fun(a,b)},D=function
b(a){return b.fun(a)},I=function
c(a,b){return c.fun(a,b)},J=function
b(a){return b.fun(a)},X=function
b(a){return b.fun(a)},n=function
c(a,b){return c.fun(a,b)},K=function
b(a){return b.fun(a)},L=function
b(a){return b.fun(a)},Y=function
b(a){return b.fun(a)},l=function
c(a,b){return c.fun(a,b)},M=function
c(a,b){return c.fun(a,b)},k=function
b(a){return b.fun(a)},o=function
b(a){return b.fun(a)},Z=function
b(a){return b.fun(a)},_=function
b(a){return b.fun(a)},$=function
b(a){return b.fun(a)},aa=function
b(a){return b.fun(a)},s=function
e(a,b,c,d){return e.fun(a,b,c,d)},N=function
e(a,b,c,d){return e.fun(a,b,c,d)},v=function
c(a,b){return c.fun(a,b)},O=function
b(a){return b.fun(a)},P=function
b(a){return b.fun(a)},Q=function
c(a,b){return c.fun(a,b)},ab=function
c(a,b){return c.fun(a,b)},R=function
b(a){return b.fun(a)};i(j,function(a){return b(W,a)});i(x,function(a){if(1-at(a))r(a,7);var
e=h(0,a);d(a,80);var
f=b(j,a),c=cA(a);if(c)return[0,g(e,c[1]),f];throw[0,t,EQ]});i(F,function(a){var
c=h(0,a),b=e(0,a);if(typeof
b==="number"){if(97===b){H(a);return[0,[0,c,0]]}if(98===b){H(a);return[0,[0,c,1]]}}return 0});i(y,function(a){if(a){var
c=a[1][1],b=m(a);if(b)return[0,g(b[1][1],c),b];throw[0,t,ER]}throw[0,t,ES]});i(W,function(a){am(a,83);return f(z,a,b(A,a))});i(z,function(a,j){if(83===e(0,a)){var
c=[0,j,0];for(;;){var
h=e(0,a);if(typeof
h==="number")if(83===h){d(a,83);var
c=[0,b(A,a),c];continue}var
i=b(y,c),f=i[2];if(f){var
g=f[2];if(g)return[0,i[1],[5,f[1],g[1],g[2]]]}throw[0,t,ET]}}return j});i(A,function(a){am(a,85);return f(C,a,b(D,a))});i(C,function(a,j){if(85===e(0,a)){var
c=[0,j,0];for(;;){var
h=e(0,a);if(typeof
h==="number")if(85===h){d(a,85);var
c=[0,b(D,a),c];continue}var
i=b(y,c),f=i[2];if(f){var
g=f[2];if(g)return[0,i[1],[6,f[1],g[1],g[2]]]}throw[0,t,EU]}}return j});i(D,function(a){return f(I,a,b(J,a))});i(I,function(a,b){var
c=e(0,a);if(typeof
c==="number")if(12===c)if(!a[14]){var
d=f(l,a,b);return bs(s,a,d[1],0,[0,[0,d,0],0])}return b});i(J,function(a){var
c=e(0,a);if(typeof
c==="number")if(79===c){var
i=h(0,a);d(a,79);var
f=b(J,a);return[0,g(i,f[1]),[0,f]]}return b(X,a)});i(X,function(a){return f(n,a,b(K,a))});i(n,function(a,b){if(!bJ(a))if(am(a,7)){var
c=h(0,a);d(a,8);return f(n,a,[0,g(b[1],c),[3,b]])}return b});i(K,function(a){var
f=h(0,a),c=e(0,a);if(typeof
c==="number")switch(c){case
0:var
j=b(P,a);return[0,j[1],[4,j[2]]];case
5:return b($,a);case
7:return b(Y,a);case
46:var
u=h(0,a);d(a,46);var
m=b(K,a);return[0,g(u,m[1]),[7,m]];case
92:return b(aa,a);case
100:d(a,ae);return[0,f,8];case
1:case
3:var
k=bs(N,0,1,1,a);return[0,k[1],[2,k[2]]];case
30:case
31:var
t=E(0,a);d(a,c);return[0,f,[11,[0,31===c?1:0,t]]]}else
switch(c[0]){case
1:var
i=c[1],n=i[4],o=i[3],p=i[2],q=i[1];if(n)au(a,32);d(a,[1,[0,q,p,o,n]]);return[0,q,[9,[0,p,o]]];case
5:var
r=c[2],s=c[1],v=E(0,a);d(a,[5,s,r]);if(1===s)au(a,32);return[0,f,[10,[0,r,v]]]}var
l=b(L,c);return l?(d(a,c),[0,f,l[1]]):(ac(a),[0,f,0])});i(L,function(a){if(typeof
a==="number"){if(29===a)return EV;if(cK<=a)switch(a-110|0){case
0:return EW;case
1:return EX;case
2:return EY;case
3:return EZ;case
4:return E0;case
5:return E1;default:return E2}}return 0});i(Y,function(a){var
l=h(0,a);d(a,7);var
c=0;for(;;){var
f=e(0,a);if(typeof
f==="number"){var
o=8===f?1:G===f?1:0;if(o){var
i=m(c),n=h(0,a);d(a,8);return[0,g(l,n),[8,i]]}}var
k=[0,b(j,a),c];if(8!==e(0,a))d(a,10);var
c=k;continue}});i(l,function(b,a){return[0,a[1],[0,0,a,0]]});i(M,function(a,c){if(1-at(a))r(a,7);var
f=am(a,79);d(a,80);var
e=b(j,a);return[0,g(c[1],e[1]),[0,[0,c],e,f]]});function
ad(a){var
c=e(E3,a);if(typeof
c==="number")if(!(1<(c+dR|0)>>>0))return f(M,a,b(p[14],a)[1]);return f(l,a,b(j,a))}i(k,function(a){return function(o){var
b=o;for(;;){var
c=e(0,a);if(typeof
c==="number"){var
f=c-6|0,p=7<f>>>0?ce===f?1:0:5<(f-1|0)>>>0?1:0;if(p){var
i=13===c?1:0;if(i){var
l=h(0,a);d(a,13);var
j=ad(a),k=[0,[0,g(l,j[1]),[0,j]]];}else
var
k=i;return[0,m(b),k]}}var
n=[0,ad(a),b];if(6!==e(0,a))d(a,10);var
b=n;continue}}});i(o,function(a){d(a,5);var
b=f(k,a,0);d(a,6);return b});i(Z,function(a){d(a,5);var
g=dp(0,a),h=e(0,g);if(typeof
h==="number")if(13<=h){if(G===h)var
q=1;else
if(14<=h)var
i=0,q=0;else
var
q=1;if(q)var
c=[0,f(k,g,0)],i=1;}else
if(6===h)var
c=E6,i=1;else
if(0===h)var
c=b(_,g),i=1;else
var
i=0;else
var
i=0;if(!i){if(b(L,h)){var
u=e(E5,g);if(typeof
u==="number")if(1<(u+dR|0)>>>0)var
r=0;else
var
v=[0,f(k,g,0)],r=1;else
var
r=0;if(!r)var
v=[1,b(j,g)];var
w=v;}else
var
w=[1,b(j,g)];var
c=w;}if(0===c[0])var
s=c;else{var
o=c[1];if(a[14])var
t=c;else{var
p=e(0,a);if(typeof
p==="number")if(6===p)if(12===e(E4,a))var
n=[0,f(k,a,[0,f(l,a,o),0])],m=1;else
var
n=[1,o],m=1;else
if(10===p){d(a,10);var
n=[0,f(k,a,[0,f(l,a,o),0])],m=1;}else
var
m=0;else
var
m=0;if(!m)var
n=c;var
t=n;}var
s=t;}d(a,6);return s});i(_,function(a){var
b=f(p[13],0,a),c=e(0,a);if(typeof
c==="number")if(!(1<(c+dR|0)>>>0)){var
d=f(M,a,b);am(a,10);return[0,f(k,a,[0,d,0])]}return[1,f(z,a,f(C,a,f(I,a,f(n,a,f(ab,a,b)))))]});i($,function(a){var
d=h(0,a),c=b(Z,a);return 0===c[0]?bs(s,a,d,0,c[1]):c[1]});i(aa,function(a){var
c=h(0,a),d=f(v,0,a);return bs(s,a,c,d,b(o,a))});i(s,function(a,h,f,e){d(a,12);var
c=b(j,a);return[0,g(h,c[1]),[1,[0,e,c,f]]]});function
S(a,f,e){var
h=b(o,a);d(a,80);var
c=b(j,a);return[0,g(f,c[1]),[0,h,c,e]]}function
T(a,g,e,d){var
b=S(a,g,f(v,0,a)),c=[0,b[1],[1,b[2]]];return[0,[0,c[1],[0,d,[0,c],0,e,1,0]]]}function
U(a,i,h,f,e){if(1-at(a))r(a,7);var
k=am(a,79);d(a,80);var
c=b(j,a);return[0,[0,g(i,c[1]),[0,e,[0,c],k,h,0,f]]]}function
B(c,a){var
b=e(0,a);if(typeof
b==="number")if(!(11<=b))switch(b){case
2:if(!c)return 0;break;case
4:if(c)return 0;break;case
9:case
10:return H(a)}return ac(a)}function
w(b,a){return a?q(b,[0,a[1][1],5]):a}i(N,function(M,aq,ap,a){var
n=aq?3===e(0,a)?1:0:aq,aC=h(0,a),aD=n?3:1;d(a,aD);var
k=0;for(;;){if(M)if(ap)throw[0,t,E8];var
i=h(0,a),r=M?am(a,42):M,l=b(F,a),s=e(0,a);if(typeof
s==="number"){if(92===s)var
u=1;else{if(G===s)var
N=m(k),o=1;else
if(14<=s)var
u=0,o=0;else
switch(s){case
2:if(n)var
u=0,o=0;else
var
N=m(k),o=1;break;case
4:if(n)var
N=m(k),o=1;else
var
u=0,o=0;break;case
7:d(a,7);var
Z=80===e(E7,a)?1:0;if(Z){var
ay=b(p[14],a);d(a,80);var
_=[0,ay[1]];}else
var
_=Z;var
az=b(j,a);d(a,8);d(a,80);var
$=b(j,a),aA=[2,[0,g(i,$[1]),[0,_,az,$,r,l]]];B(n,a);var
k=[0,aA,k];continue;case
13:if(ap){w(a,l);H(a);var
ao=b(j,a),aB=[1,[0,g(i,ao[1]),[0,ao]]];B(n,a);var
k=[0,aB,k];continue}var
u=0,o=0;break;case
5:var
u=1,o=0;break;default:var
u=0,o=0;}if(o){var
aE=h(0,a),aF=n?4:2;d(a,aF);return[0,g(aC,aE),[0,n,N]]}}if(u){w(a,l);var
ar=f(v,0,a),X=S(a,h(0,a),ar),as=[3,[0,g(i,X[1]),[0,X,r]]];B(n,a);var
k=[0,as,k];continue}}if(0===r)var
y=0;else
if(l)var
y=0;else
if(typeof
s==="number")if(80===s){aW(a,[0,i,40]);var
ak=[1,[0,i,Fa]],L=e(0,a),al=0;if(typeof
L==="number"){if(5===L)var
P=1;else
if(92===L)var
P=1;else
var
O=0,P=0;if(P){w(a,l);var
an=T(a,i,al,ak),O=1;}}else
var
O=0;if(!O)var
an=U(a,i,al,l,ak);var
ad=an,y=1;}else
var
y=0;else
var
y=0;if(!y){var
aa=function(a){aO(a,0);var
c=b(p[21],a);a4(a);return c},x=aa(a)[2];if(1===x[0]){var
J=x[1][2];if(c(J,E9))if(c(J,E_))var
Q=0,R=0;else
var
R=1;else
var
R=1;if(R){var
ae=e(0,a);if(typeof
ae==="number"){var
K=ae-6|0;if(85<K>>>0)if(87<(K+1|0)>>>0)var
C=0,D=0;else{w(a,l);var
aj=T(a,i,r,x),D=1;}else
if(1<(K-73|0)>>>0)var
C=0,D=0;else
var
aj=U(a,i,r,l,x),D=1;if(D)var
ah=aj,C=1;}else
var
C=0;if(!C){var
af=aa(a),ag=ai(J,E$);w(a,l);var
z=S(a,i,0),A=z[2][1],E=af[1];if(0===ag){var
Y=A[1];if(A[2])q(a,[0,E,63]);else{var
aG=Y?Y[2]?0:1:0;if(!aG)q(a,[0,E,63]);}}else{var
aH=A[1]?0:A[2]?0:1;if(!aH)q(a,[0,E,62]);}var
at=0,au=0,av=0,aw=ag?[1,z]:[2,z],ax=[0,af[2],aw,av,r,au,at],ah=[0,[0,g(i,z[1]),ax]];}var
ac=ah,Q=1;}}else
var
Q=0;if(!Q){var
I=e(0,a);if(typeof
I==="number"){if(5===I)var
W=1;else
if(92===I)var
W=1;else
var
V=0,W=0;if(W){w(a,l);var
ab=T(a,i,r,x),V=1;}}else
var
V=0;if(!V)var
ab=U(a,i,r,l,x);var
ac=ab;}var
ad=ac;}B(n,a);var
k=[0,ad,k];continue}});i(v,function(D,a){var
E=h(0,a),z=92===e(0,a)?1:0;if(z){if(1-at(a))r(a,7);d(a,92);var
c=0,t=0;for(;;){var
C=b(F,a),v=u(p[15],a,0,29),w=v[2],x=v[1],y=e(0,a);if(0===D)var
i=0,f=0;else{if(typeof
y==="number")if(78===y){H(a);var
i=[0,b(j,a)],f=1,n=1;}else
var
n=0;else
var
n=0;if(!n){if(c)q(a,[0,x,58]);var
i=0,f=c;}}var
k=[0,[0,x,[0,w[1][2],w[2],C,i]],t],l=e(0,a);if(typeof
l==="number"){if(93===l)var
s=1;else
if(G===l)var
s=1;else
var
o=0,s=0;if(s)var
A=m(k),o=1;}else
var
o=0;if(!o){d(a,10);if(93!==e(0,a)){var
c=f,t=k;continue}var
A=m(k);}var
I=g(E,h(0,a));d(a,93);var
B=[0,[0,I,[0,A]]];break}}else
var
B=z;return B});i(O,function(a){var
q=h(0,a),l=92===e(0,a)?1:0;if(l){d(a,92);var
c=0;for(;;){var
f=e(0,a);if(typeof
f==="number"){if(93===f)var
k=1;else
if(G===f)var
k=1;else
var
i=0,k=0;if(k){var
o=m(c),r=g(q,h(0,a));d(a,93);var
n=[0,[0,r,[0,o]]],i=1;}}else
var
i=0;if(!i){var
p=[0,b(j,a),c];if(93!==e(0,a))d(a,10);var
c=p;continue}break}}else
var
n=l;return n});i(P,function(a){return f(Q,a,f(p[13],0,a))});i(Q,function(a,m){var
c=[0,m[1],[0,m]];for(;;){var
j=c[2],h=c[1];if(11===e(0,a)){d(a,11);var
k=f(p[13],0,a),l=g(h,k[1]),c=[0,l,[1,[0,l,[0,j,k]]]];continue}var
i=b(O,a),n=i?g(h,i[1][1]):h;return[0,n,[0,j,i]]}});i(ab,function(c,b){var
a=f(Q,c,b);return[0,a[1],[4,a[2]]]});i(R,function(a){var
c=e(0,a);if(typeof
c==="number")if(80===c)return[0,b(x,a)];return 0});function
V(l){var
a=dp(0,l),f=e(0,a);if(typeof
f==="number")if(65===f){var
c=h(0,a);d(a,65);if(5===e(0,a)){d(a,5);aO(a,0);var
j=b(p[8],a);a4(a);var
k=h(0,a);d(a,6);var
i=[0,g(c,k),[0,j]];}else
var
i=[0,c,0];return[0,i]}return 0}function
af(a){var
c=e(0,a),f=e(Fb,a);if(typeof
c==="number")if(80===c){if(typeof
f==="number")if(65===f){d(a,80);return[0,0,V(a)]}var
g=b(R,a);return[0,g,V(a)]}return Fc}function
a(d,c){var
a=bf(1,c);aO(a,1);var
e=b(d,a);a4(a);return e}function
ag(b){return a(j,b)}var
ah=b(v,1);function
aj(b){return a(ah,b)}var
ak=b(v,0);function
al(b){return a(ak,b)}function
an(b){return a(O,b)}function
ao(c,b){return a(u(N,c,0,0),b)}function
ap(b){return a(o,b)}function
aq(b){return a(x,b)}function
ar(b){return a(R,b)}function
as(b){return a(V,b)}function
av(b){return a(af,b)}return[0,ag,al,aj,an,function(b){return a(P,b)},ao,ap,aq,ar,as,av]}var
ds=cv([0,dd]);function
F$(t){function
u(a){aO(a,0);var
c=h(0,a);d(a,1);d(a,13);var
e=b(t[9],a),f=h(0,a);d(a,2);a4(a);return[0,g(c,f),[0,e]]}function
l(a){aO(a,0);var
c=h(0,a);d(a,1);if(2===e(0,a))var
i=h(0,a)[2],f=[1,[0,c[1],c[3],i]];else
var
f=[0,b(t[7],a)];var
j=h(0,a);d(a,2);a4(a);return[0,g(c,j),[0,f]]}function
j(a){var
b=h(0,a),c=E(0,a);d(a,fW);return[0,b,[0,c]]}function
n(a){var
b=j(a),f=e(0,a);if(typeof
f==="number"){if(11===f){d(a,11);var
k=j(a),c=[0,g(b[1],k[1]),[0,[0,b],k]];for(;;){var
h=e(0,a);if(typeof
h==="number")if(11===h){d(a,11);var
i=j(a),c=[0,g(c[1],i[1]),[0,[1,c],i]];continue}return[2,c]}}if(80===f){d(a,80);var
l=j(a);return[1,[0,g(b[1],l[1]),[0,b,l]]]}}return[0,b]}function
v(a){var
z=h(0,a),c=j(a);if(80===e(0,a)){d(a,80);var
p=j(a),s=g(c[1],p[1]),u=s,t=[1,[0,s,[0,c,p]]];}else
var
u=c[1],t=[0,c];if(78===e(0,a)){d(a,78);var
b=e(0,a);if(typeof
b==="number")if(1===b){var
w=l(a),x=w[2],m=w[1];if(0!==x[1][0])q(a,[0,m,41]);var
n=[0,m,[0,[1,m,x]]],f=0;}else
var
f=1;else
if(4===b[0]){var
o=b[1],y=o[1];d(a,b);var
n=[0,y,[0,[0,y,[0,[0,o[2]],o[3]]]]],f=0;}else
var
f=1;if(f){r(a,42);var
v=h(0,a),k=v,i=[0,[0,v,[0,Gb,Ga]]];}else
var
k=n[1],i=n[2];}else
var
k=u,i=0;return[0,g(z,k),[0,t,i]]}function
y(a,k){var
c=0,l=n(a);for(;;){var
b=e(0,a);if(typeof
b==="number"){if(94<=b)var
i=99===b?1:G===b?1:0;else{if(1===b){var
c=[0,[1,u(a)],c];continue}var
i=93<=b?1:0;}if(i){var
j=m(c),f=99===e(0,a)?1:0;if(f)d(a,99);var
o=h(0,a);d(a,93);a4(a);return[0,g(k,o),[0,l,f,j]]}}var
c=[0,[0,v(a)],c];continue}}function
z(a,k){d(a,99);var
l=n(a),m=h(0,a);d(a,93);var
c=a[20][1];if(c){var
e=c[2];if(e)var
f=e[2],b=1;else
var
b=0;}else
var
b=0;if(!b)var
f=ay(EJ);a[20][1]=f;var
i=b6(a),j=b5(a[21][1],i);a[22][1]=j;return[0,g(k,m),[0,l]]}var
o=function
b(a){return b.fun(a)},k=function
c(a,b){return c.fun(a,b)},p=function
b(a){return b.fun(a)};i(o,function(c){var
a=e(0,c);if(typeof
a==="number"){if(1===a){var
h=l(c);return[0,h[1],[1,h[2]]]}}else
if(4===a[0]){var
f=a[1];d(c,a);return[0,f[1],[2,[0,f[2],f[3]]]]}var
g=b(p,c);return[0,g[1],[0,g[2]]]});function
s(a){switch(a[0]){case
0:return a[1][2][1];case
1:var
c=a[1][2],e=w(Gc,c[2][2][1]);return w(c[1][2][1],e);default:var
d=a[1][2],b=d[1],f=0===b[0]?b[1][2][1]:s([2,b[1]]);return w(f,w(Gd,d[2][2][1]))}}i(k,function(a,I){var
j=y(a,I);if(j[2][2])var
C=0,n=0;else{aO(a,3);var
i=0;for(;;){var
q=e(0,a);if(typeof
q==="number"){if(92===q){aO(a,2);var
A=h(0,a);d(a,92);var
p=e(0,a);if(typeof
p==="number"){if(99===p)var
x=1;else
if(G===p)var
x=1;else
var
w=0,x=0;if(x)var
l=[0,z(a,A)],w=1;}else
var
w=0;if(!w)var
l=[1,f(k,a,A)];if(0!==l[0]){var
B=l[1],i=[0,[0,B[1],[0,B[2]]],i];continue}var
H=[0,l[1]],t=[0,m(i),H],v=1;}else
if(G===q){ac(a);var
t=[0,m(i),0],v=1;}else
var
u=0,v=0;if(v)var
C=t[1],n=t[2],u=1;}else
var
u=0;if(!u){var
i=[0,b(o,a),i];continue}break}}if(n){var
D=n[1],E=s(j[2][1]);if(c(s(D[2][1]),E))r(a,[6,E]);var
F=D[1];}else
var
F=j[1];return[0,g(j[1],F),[0,j,n,C]]});i(p,function(a){var
b=h(0,a);aO(a,2);d(a,92);return f(k,a,b)});return[0,u,l,j,n,v,y,z,o,k,p]}var
dt=cv([0,dd]),du=cv([0,function(l,k){var
c=k[1],d=l[1],b=c[1],i=d[1];if(i)if(b){var
f=b[1],g=i[1],m=eH(f),h=eH(g)-m|0;if(0===h)var
n=eG(f),a=x(eG(g),n);else
var
a=h;}else
var
a=-1;else
var
a=b?1:0;if(0===a)var
j=eI(d[2],c[2]),e=0===j?eI(d[3],c[3]):j;else
var
e=a;return 0===e?cn(l[2],k[2]):e}]),j=f(aE,G7,G6),z=EP(j),F=function(p){function
a(a,j){var
c=j;for(;;){var
b=c[2];switch(b[0]){case
0:return aB(y,a,b[1][1]);case
1:return aB(z,a,b[1][1]);case
2:var
c=b[1][1];continue;case
3:var
d=b[1][1],e=d[2],g=a[2],h=a[1];if(f(ds[3],e,g))q(h,[0,d[1],30]);var
i=k([0,h,g],d),l=f(ds[4],e,i[2]);return[0,i[1],l];default:q(a[1],[0,c[1],19]);return a}}}function
y(c,b){if(0===b[0]){var
d=b[1][2],e=d[1],f=1===e[0]?k(c,e[1]):c;return a(f,d[2])}return a(c,b[1][2][1])}function
z(b,d){if(d){var
c=d[1];return 0===c[0]?a(b,c[1]):a(b,c[1][2][1])}return b}function
k(d,c){var
a=c[2],e=c[1],b=d[1];if(bq(a))aW(b,[0,e,29]);var
f=cB(a),g=f||b_(a);if(g)aW(b,[0,e,40]);return[0,b,d[2]]}function
s(b,h,m,g,f){var
i=h||1-m;if(i){var
c=f[2],d=h?bf(1-b[6],b):b;if(g){var
j=g[1],e=j[2],k=j[1];if(bq(e))aW(d,[0,k,31]);var
n=cB(e),o=n||b_(e);if(o)aW(d,[0,k,40]);}var
p=aB(a,[0,d,ds[1]],f[1]),q=c?(a(p,c[1][2][1]),0):c,l=q;}else
var
l=i;return l}function
t(a){d(a,5);var
i=0;for(;;){var
k=e(0,a);if(typeof
k==="number"){var
l=k-6|0,v=7<l>>>0?ce===l?1:0:5<(l-1|0)>>>0?1:0;if(v){var
o=13===k?1:0;if(o){var
t=h(0,a);d(a,13);var
p=f(j[19],a,29),q=[0,[0,g(t,p[1]),[0,p]]];}else
var
q=o;if(6!==e(0,a))r(a,48);var
u=[0,m(i),q];d(a,6);return u}}var
c=f(j[19],a,29);if(78===e(0,a)){d(a,78);var
n=b(j[9],a),s=[0,g(c[1],n[1]),[2,[0,c,n]]];}else
var
s=c;if(6!==e(0,a))d(a,10);var
i=[0,s,i];continue}}function
l(f,e,d){var
g=e9(f,e,d),a=b(j[17],g),c=a[1];return[0,c,[0,[0,c,a[2]]],a[3]]}function
A(i,d,c){var
a=i.slice();a[10]=1;var
f=e(0,a);if(typeof
f==="number")if(1===f){var
g=l(a,d,c);return[0,g[2],g[3]]}var
h=e9(a,d,c),k=b(j[9],h);return[0,[1,k],h[6]]}function
B(a,i,g){var
f=h(0,a),d=e(0,a);if(typeof
d==="number")if(97===d){H(a);var
b=[0,[0,f,0]],c=1;}else
if(98===d){H(a);var
b=[0,[0,f,1]],c=1;}else
var
c=0;else
var
c=0;if(!c)var
b=0;if(b){var
j=i?0:g?0:1;if(!j){q(a,[0,b[1][1],5]);return 0}}return b}function
u(a){return am(a,ae)}function
v(a){return am(a,63)}function
w(c){var
d=0===c[2]?1:0;if(d){var
a=c[1];for(;;){if(a){var
e=a[2],b=3===a[1][2][0]?1:0;if(b){var
a=e;continue}return b}return 1}}return d}function
C(a){var
A=h(0,a),q=v(a);d(a,15);var
r=u(a),B=a[7],m=e(0,a);if(0===B)var
c=0;else
if(typeof
m==="number")if(5===m)var
n=0,i=0,c=1;else
if(92===m)var
F=b(p[2],a),G=5===e(0,a)?0:[0,f(j[13],Fe,a)],n=F,i=G,c=1;else
var
c=0;else
var
c=0;if(!c)var
C=[0,f(j[13],Fd,a)],n=b(p[2],a),i=C;var
o=t(a),x=b(p[11],a),y=l(a,q,r),k=y[2],D=w(o);s(a,y[3],D,i,o);var
z=0===k[0]?[0,k[1][1],0]:[0,k[1][1],1],E=[17,[0,i,o,k,q,r,x[2],z[2],x[1],n]];return[0,g(A,z[1]),E]}function
n(a){var
n=0,l=0;for(;;){var
c=f(j[19],a,28);if(78===e(0,a)){d(a,78);var
h=[0,b(j[9],a)],k=0;}else
if(3===c[2][0])var
h=fc[1],k=fc[2];else
var
h=0,k=[0,[0,c[1],44],0];var
p=h?h[1][1]:c[1],i=[0,[0,g(c[1],p),[0,c,h]],n],o=cr(k,l);if(10===e(0,a)){d(a,10);var
n=i,l=o;continue}var
q=bl(i),r=m(i),s=bl(i),t=m(o);return[0,g(s[1],q[1]),r,t]}}function
c(e,c,a){var
f=h(0,a);d(a,e);var
b=n(a),i=b[3],j=[0,b[2],c];return[0,[0,g(f,b[1]),j],i]}var
D=0,E=24;function
i(a){return c(E,D,a)}function
o(e){var
a=c(27,2,b8(1,e)),b=a[1],d=b[2],f=d[1],g=a[2],h=m(aB(function(b,a){return a[2][2]?b:[0,[0,a[1],43],b]},g,f));return[0,[0,b[1],d],h]}function
x(a){return c(28,1,b8(1,a))}return[0,v,u,B,t,l,w,s,A,function(a){var
m=h(0,a),j=e(0,a);if(typeof
j==="number"){var
k=j+gv|0;if(4<k>>>0)var
b=0;else{switch(k){case
0:var
f=i(a),c=1;break;case
3:var
f=o(a),c=1;break;case
4:var
f=x(a),c=1;break;default:var
b=0,c=0;}if(c)var
d=f,b=1;}}else
var
b=0;if(!b){ac(a);var
d=i(a);}var
l=d[1],n=d[2],p=[18,l[2]];return[0,[0,g(m,l[1]),p],n]},n,x,o,i,C]}(z),a5=function(l){var
k=function
b(a){return b.fun(a)},W=function
b(a){return b.fun(a)},D=function
b(a){return b.fun(a)},F=function
b(a){return b.fun(a)},X=function
b(a){return b.fun(a)},I=function
b(a){return b.fun(a)},Y=function
b(a){return b.fun(a)},p=function
b(a){return b.fun(a)},J=function
b(a){return b.fun(a)},v=function
b(a){return b.fun(a)},Z=function
b(a){return b.fun(a)},K=function
b(a){return b.fun(a)},n=function
d(a,b,c){return d.fun(a,b,c)},L=function
b(a){return b.fun(a)},M=function
b(a){return b.fun(a)},x=function
d(a,b,c){return d.fun(a,b,c)},P=function
b(a){return b.fun(a)},Q=function
c(a,b){return c.fun(a,b)},R=function
b(a){return b.fun(a)},_=function
b(a){return b.fun(a)},S=function
c(a,b){return c.fun(a,b)},y=function
e(a,b,c,d){return e.fun(a,b,c,d)},$=function
b(a){return b.fun(a)},U=function
b(a){return b.fun(a)},aa=function
b(a){return b.fun(a)},ab=function
b(a){return b.fun(a)},A=function
c(a,b){return c.fun(a,b)},B=function
b(a){return b.fun(a)};function
V(a){var
c=b(I,a),e=b(X,a);if(e){if(1-b(F,c))q(a,[0,c[1],15]);var
d=c[2],m=typeof
d==="number"?0:17===d[0]?bq(d[1][2])?(aW(a,[0,c[1],37]),1):0:0,h=f(j[20],a,c),i=b(k,a),l=g(h[1],i[1]);return[0,l,[7,[0,e[1],h,i]]]}return c}function
ah(b,a){throw ca}function
ak(g){var
a=e6(ah,g),b=V(a),d=e(0,a);if(typeof
d==="number"){var
h=12===d?1:80===d?1:0;if(h)throw ca}if(aI(0,a)){var
f=b[2];if(typeof
f!=="number"&&17===f[0])if(!c(f[1][2],Ff))if(!bJ(a))throw ca;return b}return b}i(k,function(a){var
f=e(0,a),i=aI(0,a);if(typeof
f==="number"){var
d=f-6|0;if(85<d>>>0)var
c=87<(d+1|0)>>>0?0:1;else
if(52===d){if(a[16])return b(W,a);var
c=0;}else
var
c=0;}else
var
c=0;if(!c)if(0===i)return V(a);var
g=fb(a,ak);if(g)return g[1];var
h=fb(a,ab);return h?h[1]:V(a)});i(W,function(a){var
f=h(0,a);d(a,58);if(1-a[16])r(a,25);var
i=am(a,ae),n=9===e(0,a)?1:0,o=n||b$(a),p=1-o,j=i||p,c=j?[0,b(k,a)]:j;if(c)var
l=c[1][1];else{var
m=N(0,a),q=m?m[1]:f;O(a);var
l=q;}return[0,g(f,l),[14,[0,c,i]]]});i(D,function(b){var
a=b[2];if(typeof
a!=="number")switch(a[0]){case
13:case
17:case
24:return 1}return 0});i(F,function(b){var
a=b[2];if(typeof
a!=="number")switch(a[0]){case
0:case
1:case
13:case
17:case
24:return 1}return 0});i(X,function(d){var
f=e(0,d);if(typeof
f==="number"){var
g=f+fJ|0;if(12<g>>>0)var
c=0;else{switch(g){case
0:var
a=Fg;break;case
1:var
a=Fh;break;case
2:var
a=Fi;break;case
3:var
a=Fj;break;case
4:var
a=Fk;break;case
5:var
a=Fl;break;case
6:var
a=Fm;break;case
7:var
a=Fn;break;case
8:var
a=Fo;break;case
9:var
a=Fp;break;case
10:var
a=Fq;break;case
11:var
a=Fr;break;default:var
a=Fs;}var
b=a,c=1;}}else
var
c=0;if(!c)var
b=0;if(0!==b)H(d);return b});i(I,function(a){var
i=h(0,a),c=b(Y,a);if(79===e(0,a)){d(a,79);var
j=b(k,bp(0,a));d(a,80);var
f=br(k,a),l=g(i,f[1]);return[0,l,[10,[0,c,j,f[2]]]]}return c});function
ad(d,c,b,a){return[0,a,[9,[0,b,d,c]]]}function
af(a,k,j){var
c=k,b=j;for(;;){var
f=e(0,a);if(typeof
f==="number")if(82===f){d(a,82);var
h=br(p,a),i=g(b,h[1]),c=ad(c,h[2],1,i),b=i;continue}return[0,b,c]}}i(Y,function(a){var
k=br(p,a),l=af(a,k[2],k[1]),b=l[2],c=l[1];for(;;){var
f=e(0,a);if(typeof
f==="number")if(81===f){d(a,81);var
h=br(p,a),i=af(a,h[2],h[1]),j=g(c,i[1]),b=ad(b,i[2],0,j),c=j;continue}return b}});function
ag(d,c,b,a){return[0,a,[6,[0,b,d,c]]]}i(p,function(d){var
y=0;a:for(;;){var
Q=h(0,d),G=0!==b(J,d)?1:0,l=b(v,bp(0,d)),I=cA(d),R=I?I[1]:l[1],z=g(Q,R);if(92===e(0,d))var
K=l[2],T=typeof
K==="number"?0:21===K[0]?(r(d,47),1):0;var
A=e(0,d);if(typeof
A==="number"){var
i=A+gr|0;if(1<i>>>0)if(66<=i)switch(i+fJ|0){case
0:var
c=Ft,a=1;break;case
1:var
c=Fu,a=1;break;case
2:var
c=Fv,a=1;break;case
3:var
c=Fw,a=1;break;case
4:var
c=Fx,a=1;break;case
5:var
c=Fy,a=1;break;case
6:var
c=Fz,a=1;break;case
7:var
c=FA,a=1;break;case
8:var
c=FB,a=1;break;case
9:var
c=FC,a=1;break;case
10:var
c=FD,a=1;break;case
11:var
c=FE,a=1;break;case
12:var
c=FF,a=1;break;case
13:var
c=FG,a=1;break;case
14:var
c=FH,a=1;break;case
15:var
c=FI,a=1;break;case
16:var
c=FJ,a=1;break;case
17:var
c=FK,a=1;break;case
18:var
c=FL,a=1;break;case
19:var
c=FM,a=1;break;default:var
m=0,a=0;}else
var
m=0,a=0;else
if(0===i)if(d[11])var
c=0,a=1;else
var
c=FN,a=1;else
var
c=FO,a=1;if(a)var
j=c,m=1;}else
var
m=0;if(!m)var
j=0;if(0!==j)H(d);if(j){var
L=j[1],M=L[1],S=G?14===M?1:0:G;if(S)q(d,[0,z,16]);var
p=l,o=[0,M,L[2]],n=z,f=y;for(;;){var
s=o[2],B=o[1];if(f){var
t=f[1],C=t[2],u=C[2],N=0===u[0]?u[1]:u[1]-1|0;if(s[1]<=N){var
D=g(t[3],n),O=ag(t[1],p,C[1],D),p=O,o=[0,B,s],n=D,f=f[2];continue}}var
y=[0,[0,p,[0,B,s],n],f];continue a}}var
w=l,E=z,k=y;for(;;){if(k){var
x=k[1],F=g(x[3],E),P=k[2],w=ag(x[1],w,x[2][1],F),E=F,k=P;continue}return w}}});i(J,function(b){var
a=e(0,b);if(typeof
a==="number")if(48<=a){if(97<=a){if(!(cU<=a))switch(a+fz|0){case
0:return FP;case
1:return FQ;case
6:return FR;case
7:return FS}}else
if(64===a)if(b[17])return FT}else
if(45<=a)switch(a-45|0){case
0:return FU;case
1:return FV;default:return FW}return 0});i(v,function(a){var
l=h(0,a),m=b(J,a);if(m){var
n=m[1];H(a);var
i=b(v,a),o=g(l,i[1]);if(6===n)var
p=i[2],s=typeof
p==="number"?0:17===p[0]?(aW(a,[0,o,33]),1):0;else
var
s=0;return[0,o,[5,[0,n,1,i]]]}var
j=e(0,a);if(typeof
j==="number")if(cU===j)var
d=FX,f=1;else
if(cl===j)var
d=FY,f=1;else
var
f=0;else
var
f=0;if(!f)var
d=0;if(d){H(a);var
c=b(v,a);if(1-b(D,c))q(a,[0,c[1],15]);var
k=c[2],t=typeof
k==="number"?0:17===k[0]?bq(k[1][2])?(au(a,39),1):0:0,r=[8,[0,d[1],c,1]];return[0,g(l,c[1]),r]}return b(Z,a)});i(Z,function(a){var
c=b(K,a);if(bJ(a))return c;var
i=e(0,a);if(typeof
i==="number")if(cU===i)var
d=FZ,f=1;else
if(cl===i)var
d=F0,f=1;else
var
f=0;else
var
f=0;if(!f)var
d=0;if(d){if(1-b(D,c))q(a,[0,c[1],15]);var
j=c[2],m=typeof
j==="number"?0:17===j[0]?bq(j[1][2])?(au(a,38),1):0:0,k=h(0,a);H(a);var
l=[8,[0,d[1],c,0]];return[0,g(c[1],k),l]}return c});i(K,function(g){var
c=h(0,g),a=g.slice(),l=1-g[15];a[15]=0;var
j=e(0,a);if(typeof
j==="number")if(44===j)if(l)var
k=b(L,a),f=1;else
var
f=0;else
var
f=0;else
var
f=0;if(!f)var
k=cC(0,a)?b(P,a):b(R,a);var
i=u(x,a,c,k),d=e(0,a);if(typeof
d==="number"){if(5===d)return u(n,a,c,i)}else
if(2===d[0])return u(x,a,c,bs(y,a,c,i,d[1]));return i});i(n,function(a,c,f){var
i=e(0,a);if(typeof
i==="number")switch(i){case
5:if(!a[12]){var
k=b(M,a),m=g(c,k[1]);return u(n,a,c,[0,m,[12,[0,f,k[2]]]])}break;case
7:d(a,7);var
o=b(j[7],a),p=g(c,h(0,a));d(a,8);return u(n,a,c,[0,p,[13,[0,f,[1,o],1]]]);case
11:d(a,11);var
l=b(B,a)[1];return u(n,a,c,[0,g(c,l[1]),[13,[0,f,[0,l],0]]])}else
if(2===i[0])return bs(y,a,c,f,i[1]);return f});i(L,function(a){var
c=h(0,a);d(a,44);if(a[10])if(11===e(0,a)){d(a,11);var
o=[0,c,F1];if(ai(E(0,a),F2)){var
p=f(j[13],0,a);return[0,g(c,p[1]),[24,[0,o,p]]]}ac(a);H(a);return[0,c,[17,o]]}var
q=h(0,a),r=e(0,a);if(typeof
r==="number")if(44===r)var
s=b(L,a),l=1;else
var
l=0;else
var
l=0;if(!l)var
s=cC(0,a)?b(P,a):b(R,a);var
t=u(x,e5(1,a),q,s),i=e(0,a);if(typeof
i==="number")var
m=0;else
if(2===i[0])var
k=bs(y,a,q,t,i[1]),m=1;else
var
m=0;if(!m)var
k=t;var
v=e(0,a);if(typeof
v==="number")if(5===v)var
w=b(M,a),A=w[1],z=w[2],n=1;else
var
n=0;else
var
n=0;if(!n)var
A=k[1],z=0;return[0,g(c,A),[11,[0,k,z]]]});i(M,function(a){var
r=h(0,a);d(a,5);var
c=0;for(;;){var
f=e(0,a);if(typeof
f==="number"){var
t=6===f?1:G===f?1:0;if(t){var
p=m(c),s=h(0,a);d(a,6);return[0,g(r,s),p]}}var
j=e(0,a);if(typeof
j==="number")if(13===j){var
o=h(0,a);d(a,13);var
l=b(k,a),n=[1,[0,g(o,l[1]),[0,l]]],i=1;}else
var
i=0;else
var
i=0;if(!i)var
n=[0,b(k,a)];var
q=[0,n,c];if(6!==e(0,a))d(a,10);var
c=q;continue}});i(x,function(a,c,f){var
i=e(0,a);if(typeof
i==="number"){if(7===i){d(a,7);var
l=e5(0,a),m=b(j[7],l),o=h(0,a);d(a,8);return u(n,a,c,[0,g(c,o),[13,[0,f,[1,m],1]]])}if(11===i){d(a,11);var
k=b(B,a)[1];return u(n,a,c,[0,g(c,k[1]),[13,[0,f,[0,k],0]]])}}return f});i(P,function(a){var
w=h(0,a),n=b(l[1],a);d(a,15);var
o=b(l[2],a);if(5===e(0,a))var
c=0,p=0;else{var
s=e(0,a);if(typeof
s==="number"){var
t=92!==s?1:0;if(t)var
m=0;else
var
v=t,m=1;}else
var
m=0;if(!m)var
v=[0,f(j[13],F3,a)];var
c=v,p=b(z[2],a);}var
i=b(l[4],a),q=b(z[11],a),k=u(l[5],a,n,o),r=k[2],x=b(l[6],i);cc(l[7],a,k[3],x,c,i);var
y=0===r[0]?0:1,A=[2,[0,c,i,r,n,o,q[2],y,q[1],p]];return[0,g(w,k[1]),A]});i(Q,function(b,e){var
f=E(0,b);if(0===e)var
a=0;else
switch(e-1|0){case
0:au(b,32);var
c=c3(c2(w(F4,f))),a=1;break;case
2:var
g=1;try{var
h=eX(f);}catch(d){g=0;d=aj(d);if(!ct)throw d;r(b,59);var
c=d3,a=1;}if(g)var
c=h,a=1;break;default:var
a=0;}if(!a)var
c=c3(c2(f));d(b,[0,e]);return c});i(R,function(a){var
g=h(0,a),c=e(0,a);if(typeof
c==="number")switch(c){case
1:return b(_,a);case
5:return b($,a);case
7:var
l=b(U,a);return[0,l[1],[0,l[2]]];case
21:d(a,21);return[0,g,0];case
29:var
s=E(0,a);d(a,29);return[0,g,[18,[0,0,s]]];case
40:return b(j[23],a);case
51:var
u=h(0,a);d(a,51);return[0,u,1];case
92:var
m=b(j[18],a);return[0,m[1],[21,m[2]]];case
30:case
31:var
t=E(0,a);d(a,c);return[0,g,[18,[0,[1,31===c?1:0],t]]];case
73:case
99:return b(aa,a)}else
switch(c[0]){case
0:var
v=E(0,a);return[0,g,[18,[0,[2,f(Q,a,c[1])],v]]];case
1:var
i=c[1],n=i[4],o=i[3],p=i[2],q=i[1];if(n)au(a,32);d(a,[1,[0,q,p,o,n]]);return[0,q,[18,[0,[0,p],o]]];case
2:var
r=f(S,a,c[1]);return[0,r[1],[19,r[2]]]}if(aI(0,a)){var
k=f(j[13],0,a);return[0,k[1],[17,k]]}ac(a);if(bQ===c)H(a);return[0,g,[18,[0,0,F5]]]});i(_,function(c){var
a=b(j[11],c);return[0,a[1],[1,a[2]]]});i(S,function(a,c){var
y=c[3],z=c[2],o=c[1];d(a,[2,c]);var
A=[0,o,[0,[0,z[2],z[1]],y]];if(y)var
D=o,C=[0,A,0],B=0;else{var
h=[0,A,0],r=0;for(;;){var
i=b(j[7],a),k=[0,i,r],s=e(0,a);if(typeof
s==="number")if(2===s){aO(a,4);var
l=e(0,a);if(typeof
l==="number")var
q=1;else
if(2===l[0]){var
n=l[1],u=n[3],v=n[2];H(a);var
w=n[1],E=[0,[0,v[2],v[1]],u];a4(a);var
x=[0,[0,w,E],h];if(!u){var
h=x,r=k;continue}var
F=m(k),f=[0,w,m(x),F],p=1,q=0;}else
var
q=1;if(q)throw[0,t,F6]}else
var
p=0;else
var
p=0;if(!p){ac(a);var
G=[0,i[1],F7],I=m(k),J=m([0,G,h]),f=[0,i[1],J,I];}var
D=f[1],C=f[2],B=f[3];break}}return[0,g(o,D),[0,C,B]]});i(y,function(e,d,c,b){var
a=f(S,e,b);return[0,g(d,a[1]),[20,[0,c,a]]]});i($,function(a){d(a,5);var
c=b(k,a),i=e(0,a);if(typeof
i==="number")if(10===i)var
j=f(A,a,[0,c,0]),h=1;else
if(80===i)var
l=b(z[8],a),j=[0,g(c[1],l[1]),[23,[0,c,l]]],h=1;else
var
h=0;else
var
h=0;if(!h)var
j=c;d(a,6);return j});i(U,function(a){var
q=h(0,a);d(a,7);var
c=0;for(;;){var
f=e(0,a);if(typeof
f==="number"){if(14<=f)var
i=G===f?1:0;else
if(8<=f)switch(f-8|0){case
2:d(a,10);var
c=[0,0,c];continue;case
5:var
o=h(0,a);d(a,13);var
j=b(k,a),p=[1,[0,g(o,j[1]),[0,j]]];if(8!==e(0,a))d(a,10);var
c=[0,[0,p],c];continue;case
0:var
i=1;break;default:var
i=0;}else
var
i=0;if(i){var
l=m(c),r=h(0,a);d(a,8);return[0,g(q,r),[0,l]]}}var
n=[0,b(k,a)];if(8!==e(0,a))d(a,10);var
c=[0,[0,n],c];continue}});i(aa,function(a){aO(a,5);var
j=h(0,a),d=e(0,a);if(typeof
d!=="number"&&3===d[0]){var
f=d[1],k=E(0,a);H(a);var
b=f[3],l=f[2];a4(a);var
g=C(s(b));el(function(a){var
b=a-103|0;if(!(18<b>>>0))switch(b){case
0:case
2:case
6:case
14:case
18:return o(g,a)}return 0},b);var
i=T(g);if(c(i,b))r(a,[3,b]);return[0,j,[18,[0,[3,[0,l,i]],k]]]}throw[0,t,F8]});function
al(d,b){if(typeof
b==="number"){var
a=b-29|0,c=16<a>>>0?19===a?1:0:14<(a-1|0)>>>0?1:0;if(c)return 0}throw ca}i(ab,function(D){var
a=e6(al,D),E=h(0,a),n=12!==e(F9,a)?1:0,o=n?b(l[1],a):n,p=b(z[2],a);if(aI(0,a))if(0===p)var
q=f(j[13],F_,a),s=q[1],c=[0,[0,[0,s,[3,[0,[0,s,q[2]],0,0]]],0],0],v=0,t=0,k=1;else
var
k=0;else
var
k=0;if(!k)var
J=b(l[4],a),K=dp(1,a),C=b(z[11],K),c=J,v=C[1],t=C[2];if(c[2])var
m=0;else
if(c[1])var
i=a,m=1;else
var
m=0;if(!m)var
i=e8(a);var
w=bJ(i),F=w?12===e(0,i)?1:0:w;if(F)r(i,45);d(i,12);var
x=e8(i),G=l[8],y=br(function(a){return u(G,a,o,0)},x),A=y[2],B=A[1],H=b(l[6],c);cc(l[7],x,A[2],H,0,c);var
I=0===B[0]?0:1;return[0,g(E,y[1]),[3,[0,0,c,B,o,0,t,I,v,p]]]});i(A,function(a,c){var
h=e(0,a);if(typeof
h==="number")if(10===h){d(a,10);return f(A,a,[0,b(k,a),c])}var
j=bl(c),i=m(c),l=bl(i);return[0,g(l[1],j[1]),[4,[0,i]]]});i(B,function(c){var
a=e(0,c),g=E(0,c),i=h(0,c);if(typeof
a==="number"){var
l=60<=a?64<=a?0:1:0===a?1:0;if(l)return[0,f(j[13],0,c),0]}if(typeof
a==="number"){if(65<=a)if(cK===a)var
b=1;else
if(dM<=a)var
b=1;else
var
d=0,b=0;else
if(60<=a)if(64<=a)var
b=1;else
var
d=0,b=0;else
if(15<=a)var
b=1;else
var
d=0,b=0;if(b)var
k=[0,[0,i,e$([0,a,g])]],d=1;}else
var
d=0;if(!d){ac(c);var
k=0;}H(c);return[0,[0,i,g],k]});return[0,U,k,I,B,F,K,Q,A]}(F),bK=function(k){function
o(a){var
f=a[24][3];if(f){var
c=0;for(;;){var
d=e(0,a);if(typeof
d==="number")if(14===d){H(a);var
c=[0,b(k[6],a),c];continue}return m(c)}}return f}function
p(a){var
c=e(0,a);if(typeof
c==="number"){if(7===c){var
r=h(0,a);d(a,7);var
s=bp(0,a),t=b(j[9],s),u=h(0,a);d(a,8);return[0,g(r,u),[2,t]]}}else
switch(c[0]){case
0:var
v=E(0,a),n=h(0,a);return[0,n,[0,[0,n,[0,[2,f(k[7],a,c[1])],v]]]];case
1:var
i=c[1],o=i[4],p=i[3],q=i[2],l=i[1];if(o)au(a,32);d(a,[1,[0,l,q,p,o]]);return[0,l,[0,[0,l,[0,[0,q],p]]]]}var
m=b(k[4],a)[1];return[0,m[1],[1,m]]}function
s(a,n){var
i=b(F[2],a),j=p(a),e=j[1],o=h(0,a),c=b(F[4],a),f=0,r=0;if(0===n){var
k=c[1];if(c[2])q(a,[0,e,63]);else{var
w=k?k[2]?0:1:0;if(!w)q(a,[0,e,63]);}}else{var
x=c[1]?0:c[2]?0:1;if(!x)q(a,[0,e,62]);}var
s=b(z[9],a),l=u(F[5],a,f,i),d=l[2],t=b(F[6],c);cc(F[7],a,l[3],t,0,c);var
m=0===d[0]?[0,d[1][1],0]:[0,d[1][1],1],v=g(o,m[1]);return[0,j[2],[0,v,[0,0,c,d,f,i,0,m[2],s,r]]]}function
v(a,y,c,s,r){var
k=e(0,a);if(typeof
k==="number"){if(92===k)var
i=1;else
if(11<=k)var
f=0,i=0;else
switch(k){case
5:var
i=1;break;case
2:case
10:var
G=0,H=1;switch(c[0]){case
0:var
w=c[1],q=[0,w[1],[18,w[2]]];break;case
1:var
x=c[1],q=[0,x[1],[17,x]];break;default:var
q=c[1];}var
m=q,p=H,o=G,f=1,i=0;break;default:var
f=0,i=0;}if(i){var
A=h(0,a),B=b(z[2],a),n=b(F[4],a),C=b(z[9],a),t=u(F[5],a,s,r),l=t[2],D=b(F[6],n);cc(F[7],a,t[3],D,0,n);var
v=0===l[0]?[0,l[1][1],0]:[0,l[1][1],1],E=g(A,v[1]),m=[0,E,[2,[0,0,n,l,s,r,0,v[2],C,B]]],p=0,o=1,f=1;}}else
var
f=0;if(!f){d(a,80);var
m=b(j[9],a),p=0,o=0;}return[0,g(y,m[1]),[0,c,[0,m],o,p]]}var
l=function
b(a){return b.fun(a)},n=function
c(a,b){return c.fun(a,b)},x=function
b(a){return b.fun(a)},y=function
b(a){return b.fun(a)};function
a(a){var
aa=h(0,a);d(a,1);var
w=0;for(;;){var
x=e(0,a);if(typeof
x==="number"){var
ac=2===x?1:G===x?1:0;if(ac){var
$=m(w),ab=h(0,a);d(a,2);return[0,g(aa,ab),[0,$]]}}var
f=h(0,a);if(13===e(0,a)){d(a,13);var
H=b(j[9],a),Y=[1,[0,g(f,H[1]),[0,H]]];}else{var
B=fd?fd[1]:0,C=aI([0,B],a);if(C)var
D=C,y=0;else{var
E=e([0,B],a);if(typeof
E==="number")var
z=1;else
if(1<E[0])var
z=1;else
var
D=1,y=0,z=0;if(z)var
u=0,y=1;}if(!y)var
u=D;var
I=u?b(F[1],a):u,J=b(F[2],a),K=p(a);if(0===I)if(0===J){var
q=K[2];if(1===q[0]){var
M=q[1][2];if(c(M,Ge))if(c(M,Gf))var
i=0,A=0;else{var
N=e(0,a);if(typeof
N==="number"){var
r=N+fX|0;if(12<r>>>0)if(dH<=r)var
k=0,l=0;else
switch(r+80|0){case
2:case
5:case
10:var
l=1;break;default:var
k=0,l=0;}else
if(10<(r-1|0)>>>0)var
l=1;else
var
k=0,l=0;if(l)var
O=v(a,f,q,0,0),k=1;}else
var
k=0;if(!k)var
V=s(a,0),W=V[2],X=W[1],_=[0,V[1],[2,[0,X,W[2]]],0,0],O=[0,g(f,X),_];var
P=O,A=1;}else{var
Q=e(0,a);if(typeof
Q==="number"){var
t=Q+fX|0;if(12<t>>>0)if(dH<=t)var
n=0,o=0;else
switch(t+80|0){case
2:case
5:case
10:var
o=1;break;default:var
n=0,o=0;}else
if(10<(t-1|0)>>>0)var
o=1;else
var
n=0,o=0;if(o)var
R=v(a,f,q,0,0),n=1;}else
var
n=0;if(!n)var
S=s(a,1),T=S[2],U=T[1],Z=[0,S[1],[1,[0,U,T[2]]],0,0],R=[0,g(f,U),Z];var
P=R,A=1;}if(A)var
L=P,i=1;}else
var
i=0;}else
var
i=0;else
var
i=0;if(!i)var
L=v(a,f,K[2],I,J);var
Y=[0,L];}if(2!==e(0,a))d(a,10);var
w=[0,Y,w];continue}}i(l,function(a){if(41===e(0,a)){d(a,41);var
c=a.slice();c[16]=0;var
l=b(k[6],c),h=[0,l],g=b(z[4],a);}else
var
h=0,g=0;var
i=52===e(0,a)?1:0;if(i){if(1-at(a))r(a,11);d(a,52);var
j=f(n,a,0);}else
var
j=i;return[0,b(x,a),h,g,j]});i(n,function(a,l){var
c=f(j[13],0,a),h=b(z[4],a),o=h?g(c[1],h[1][1]):c[1],i=[0,[0,o,[0,c,h]],l],k=e(0,a);if(typeof
k==="number")if(10===k){d(a,10);return f(n,a,i)}return m(i)});i(x,function(a){var
k=h(0,a);d(a,1);var
c=0;for(;;){var
i=e(0,a);if(typeof
i==="number"){var
f=i-3|0;if(cL<f>>>0){if(!(cl<(f+1|0)>>>0)){var
j=m(c),l=h(0,a);d(a,2);return[0,g(k,l),[0,j]]}}else
if(6===f){d(a,9);continue}}var
c=[0,b(y,a),c];continue}});function
t(b,a){return a?q(b,[0,a[1][1],5]):a}function
w(a,x,M,l,p,o,f,w){for(;;){var
y=e(0,a);if(typeof
y==="number"){var
q=y-78|0;if(2<q>>>0)var
L=dH===q?0:1;else{if(1===q){ac(a);H(a);continue}var
L=0;}if(!L)if(!p)if(!o){var
T=b(z[9],a),E=a[24],G=78===e(0,a)?1:0;if(G){var
I=f?E[2]:f;if(I)var
v=I;else
var
K=1-f,v=K?E[1]:K;var
J=v?(d(a,78),[0,b(j[7],a)]):v;}else
var
J=G;var
U=h(0,a);if(!am(a,9)){var
V=7===e(0,a)?1:0,W=V||(5===e(0,a)?1:0);if(W)ac(a);}return[1,[0,g(x,U),[0,l,J,T,f,w]]]}}t(a,w);var
N=h(0,a),O=b(z[2],a),r=b(F[4],a),P=b(z[9],a),A=u(F[5],a,p,o),m=A[2],Q=b(F[6],r);cc(F[7],a,A[3],Q,0,r);var
B=0===m[0]?[0,m[1][1],0]:[0,m[1][1],1],C=B[1],R=g(N,C),S=[0,R,[0,0,r,m,p,o,0,B[2],P,O]];if(0===f){switch(l[0]){case
0:var
s=l[1][2][1];if(typeof
s==="number")var
n=1;else
if(0===s[0])if(c(s[1],Gg))var
i=0,k=0,n=0;else
var
k=1,n=0;else
var
n=1;if(n)var
i=0,k=0;break;case
1:if(c(l[1][2],Gh))var
i=0,k=0;else
var
k=1;break;default:var
i=0,k=0;}if(k)var
D=0,i=1;}else
var
i=0;if(!i)var
D=1;return[0,[0,g(x,C),[0,D,l,S,f,M]]]}}i(y,function(a){var
l=h(0,a),m=o(a),B=5!==e(Gi,a)?1:0;if(B)var
C=92!==e(Gj,a)?1:0,i=C?am(a,42):C;else
var
i=B;var
D=5!==e(Gk,a)?1:0;if(D)var
E=80!==e(Gl,a)?1:0,j=E?b(F[1],a):E;else
var
j=D;var
r=b(F[2],a),k=u(F[3],a,j,r);if(0===r)if(k)var
n=b(F[2],a),v=1;else
var
v=0;else
var
v=0;if(!v)var
n=r;var
G=p(a);if(0===j)if(0===n){var
q=G[2];if(1===q[0]){var
H=q[1][2];if(!c(H,Gm)){var
f=e(0,a);if(typeof
f==="number"){var
L=78<=f?81<=f?92===f?1:0:79===f?0:1:5===f?1:9===f?1:0;if(L)return w(a,l,m,q,j,n,i,k)}t(a,k);var
x=s(a,1),y=x[2],I=[0,2,x[1],y,i,m];return[0,[0,g(l,y[1]),I]]}if(!c(H,Gn)){var
d=e(0,a);if(typeof
d==="number"){var
K=78<=d?81<=d?92===d?1:0:79===d?0:1:5===d?1:9===d?1:0;if(K)return w(a,l,m,q,j,n,i,k)}t(a,k);var
z=s(a,0),A=z[2],J=[0,3,z[1],A,i,m];return[0,[0,g(l,A[1]),J]]}}}return w(a,l,m,G[2],j,n,i,k)});function
A(q,p){var
a=bf(1,q),r=h(0,a),s=cr(p,o(a));d(a,40);var
i=b8(1,a),t=a[7],u=aI(0,i);if(0===t)var
e=0;else{var
n=0!==u?1:0;if(n)var
e=0;else
var
k=n,e=1;}if(!e)var
k=[0,f(j[13],0,i)];var
v=b(z[3],a),c=b(l,a),m=c[1],w=g(r,m[1]);return[0,w,[19,[0,k,m,c[2],v,c[3],c[4],s]]]}return[0,p,a,A,function(a){var
s=h(0,a),t=o(a);d(a,40);var
n=e(0,a);if(typeof
n==="number"){var
m=n-1|0;if(40<m>>>0)if(91===m)var
k=1;else
var
i=0,k=0;else
if(38<(m-1|0)>>>0)var
k=1;else
var
i=0,k=0;if(k)var
q=0,p=0,i=1;}else
var
i=0;if(!i)var
v=[0,f(j[13],0,a)],q=v,p=b(z[3],a);var
c=b(l,a),r=c[1],u=g(s,r[1]);return[0,u,[22,[0,q,r,c[2],p,c[3],c[4],t]]]},o]}(a5),J=function(aC){var
P=function
b(a){return b.fun(a)},Q=function
b(a){return b.fun(a)},R=function
b(a){return b.fun(a)},S=function
b(a){return b.fun(a)},T=function
b(a){return b.fun(a)},U=function
b(a){return b.fun(a)},V=function
b(a){return b.fun(a)},W=function
b(a){return b.fun(a)},X=function
b(a){return b.fun(a)},Y=function
b(a){return b.fun(a)},Z=function
b(a){return b.fun(a)},_=function
b(a){return b.fun(a)},$=function
b(a){return b.fun(a)},aa=function
b(a){return b.fun(a)},ab=function
b(a){return b.fun(a)},ad=function
b(a){return b.fun(a)},af=function
b(a){return b.fun(a)},a=function
b(a){return b.fun(a)},A=function
b(a){return b.fun(a)},p=function
b(a){return b.fun(a)},B=function
b(a){return b.fun(a)},v=function
b(a){return b.fun(a)},o=function
c(a,b){return c.fun(a,b)},ag=function
c(a,b){return c.fun(a,b)},x=function
c(a,b){return c.fun(a,b)},C=function
c(a,b){return c.fun(a,b)},D=function
c(a,b){return c.fun(a,b)},I=function
c(a,b){return c.fun(a,b)},ah=function
c(a,b){return c.fun(a,b)},aj=function
c(a,b){return c.fun(a,b)},J=function
c(a,b){return c.fun(a,b)},n=function
b(a){return b.fun(a)},l=function
b(a){return b.fun(a)},y=function
d(a,b,c){return d.fun(a,b,c)},ak=function
c(a,b){return c.fun(a,b)},K=function
c(a,b){return c.fun(a,b)},k=function
b(a){return b.fun(a)};function
L(b,d){var
c=d;for(;;){var
a=c[2];switch(a[0]){case
0:var
e=a[1][1];return aB(function(b,a){var
c=0===a[0]?a[1][2][2]:a[1][2][1];return L(b,c)},b,e);case
1:var
f=a[1][1];return aB(function(c,b){if(b){var
a=b[1],d=0===a[0]?a[1]:a[1][2][1];return L(c,d)}return c},b,f);case
2:var
c=a[1][1];continue;case
3:return[0,a[1][1],b];default:return ay(Go)}}}i(P,function(a){var
b=h(0,a);d(a,9);return[0,b,0]});i(Q,function(a){var
i=h(0,a);d(a,32);if(9===e(0,a))var
c=0;else
if(b$(a))var
c=0;else{var
o=f(j[13],0,a),p=o[2];if(1-f(dt[3],p,a[3]))r(a,[4,p]);var
b=[0,o],c=1;}if(!c)var
b=0;var
k=N(0,a),s=k?k[1]:b?b[1][1]:i,l=g(i,s),m=0===b?1:0;if(m)var
t=a[8],u=t||a[9],n=1-u;else
var
n=m;if(n)q(a,[0,l,23]);O(a);return[0,l,[4,[0,b]]]});i(R,function(a){var
i=h(0,a);d(a,35);if(9===e(0,a))var
c=0;else
if(b$(a))var
c=0;else{var
m=f(j[13],0,a),n=m[2];if(1-f(dt[3],n,a[3]))r(a,[4,n]);var
b=[0,m],c=1;}if(!c)var
b=0;var
k=N(0,a),o=k?k[1]:b?b[1][1]:i,l=g(i,o);if(1-a[8])q(a,[0,l,22]);O(a);return[0,l,[5,[0,b]]]});i(S,function(a){var
b=h(0,a);d(a,59);var
c=N(0,a),e=c?c[1]:b;O(a);return[0,g(b,e),1]});i(T,function(a){var
f=h(0,a);d(a,37);var
i=b9(1,a),k=b(j[2],i);d(a,25);d(a,5);var
l=b(j[7],a),m=h(0,a);d(a,6);var
c=N(0,a),n=c?c[1]:m;if(9===e(0,a))O(a);return[0,g(f,n),[13,[0,k,l]]]});function
al(c,a,f){if(f){var
d=f[1];if(0===d[0]){var
g=d[1],e=g[2][1];if(e)if(!e[1][2][2]){var
h=e[2];if(!h)return h}return q(c,[0,g[1],a])}var
i=d[1],k=i[1],l=1-b(j[24],[0,k,i[2]]);return l?q(c,[0,k,a]):l}return r(c,a)}i(U,function(a){var
m=h(0,a);d(a,39);var
v=a[17],w=v?am(a,64):v;d(a,5);var
i=e(0,a);if(typeof
i==="number")if(24<=i)if(29<=i)var
f=0;else{switch(i+gv|0){case
0:var
T=bp(1,a),H=b(F[13],T),k=[0,[0,[0,H[1]]],H[2]],l=1;break;case
3:var
U=bp(1,a),I=b(F[12],U),k=[0,[0,[0,I[1]]],I[2]],l=1;break;case
4:var
V=bp(1,a),J=b(F[11],V),k=[0,[0,[0,J[1]]],J[2]],l=1;break;default:var
f=0,l=0;}if(l)var
c=k[1],n=k[2],f=1;}else
if(9===i)var
c=0,n=0,f=1;else
var
f=0;else
var
f=0;if(!f)var
K=b8(1,bp(1,a)),c=[0,[1,b(j[7],K)]],n=0;var
o=e(0,a);if(62!==o)if(!w){if(typeof
o==="number")if(17===o){al(a,17,c);if(c){var
r=c[1],P=0===r[0]?[0,r[1]]:[1,r[1]];d(a,17);var
Q=b(j[7],a);d(a,6);var
R=b9(1,a),y=b(j[2],R);return[0,g(m,y[1]),[15,[0,P,Q,y,0]]]}throw[0,t,Gq]}M(function(b){return q(a,b)},n);d(a,9);var
z=e(0,a);if(typeof
z==="number"){var
A=9!==z?1:0;if(A)var
s=0;else
var
B=A,s=1;}else
var
s=0;if(!s)var
B=[0,b(j[7],a)];d(a,9);var
C=e(0,a);if(typeof
C==="number"){var
D=6!==C?1:0;if(D)var
u=0;else
var
E=D,u=1;}else
var
u=0;if(!u)var
E=[0,b(j[7],a)];d(a,6);var
S=b9(1,a),G=b(j[2],S);return[0,g(m,G[1]),[14,[0,c,B,E,G]]]}al(a,18,c);if(c){var
p=c[1],L=0===p[0]?[0,p[1]]:[1,p[1]];d(a,62);var
N=b(j[9],a);d(a,6);var
O=b9(1,a),x=b(j[2],O);return[0,g(m,x[1]),[16,[0,L,N,x,w]]]}throw[0,t,Gp]});i(V,function(a){var
k=h(0,a);d(a,16);d(a,5);var
l=b(j[7],a);d(a,6);e(0,a);var
f=cC(0,a)?(au(a,46),b(F[14],a)):b(j[2],a),i=43===e(0,a)?1:0,c=i?(d(a,43),[0,b(j[2],a)]):i,m=c?c[1][1]:f[1];return[0,g(k,m),[2,[0,l,f,c]]]});i(W,function(a){if(1-a[10])r(a,24);var
i=h(0,a);d(a,19);if(9===e(0,a))var
f=0;else
if(b$(a))var
f=0;else
var
c=[0,b(j[7],a)],f=1;if(!f)var
c=0;var
k=N(0,a),l=k?k[1]:c?c[1][1]:i;O(a);return[0,g(i,l),[9,[0,c]]]});i(X,function(a){var
A=h(0,a);d(a,20);d(a,5);var
B=b(j[7],a);d(a,6);d(a,1);var
c=Gr;for(;;){var
o=c[2],p=c[1],i=e(0,a);if(typeof
i==="number"){var
D=2===i?1:G===i?1:0;if(D){var
u=m(o),C=h(0,a);d(a,2);return[0,g(A,C),[8,[0,B,u]]]}}var
v=h(0,a),q=e(0,a);if(typeof
q==="number")if(36===q){if(p)r(a,20);d(a,36);var
k=0,l=1;}else
var
l=0;else
var
l=0;if(!l){d(a,33);var
k=[0,b(j[7],a)];}var
w=p||(0===k?1:0),x=h(0,a);d(a,80);var
y=function(b){if(typeof
b==="number"){var
a=b-2|0,c=31<a>>>0?34===a?1:0:29<(a-1|0)>>>0?1:0;if(c)return 1}return 0},n=a.slice();n[9]=1;var
s=f(j[4],y,n),t=m(s),z=t?t[1][1]:x,c=[0,w,[0,[0,g(v,z),[0,k,s]],o]];continue}});i(Y,function(a){var
c=h(0,a);d(a,22);if(bJ(a))q(a,[0,c,12]);var
e=b(j[7],a),f=N(0,a),i=f?f[1]:e[1];O(a);return[0,g(c,i),[10,[0,e]]]});i(Z,function(a){var
s=h(0,a);d(a,23);var
k=b(j[16],a),n=e(0,a);if(typeof
n==="number")if(34===n){var
t=h(0,a);d(a,34);d(a,5);var
o=f(j[13],Gs,a),u=[0,o[1],[3,[0,o,0,0]]];d(a,6);var
p=b(j[16],a),c=[0,[0,g(t,p[1]),[0,u,p]]],l=1;}else
var
l=0;else
var
l=0;if(!l)var
c=0;var
r=e(0,a);if(typeof
r==="number")if(38===r){d(a,38);var
i=[0,b(j[16],a)],m=1;}else
var
m=0;else
var
m=0;if(!m)var
i=0;var
v=i?i[1][1]:c?c[1][1]:(q(a,[0,k[1],21]),k[1]);return[0,g(s,v),[11,[0,k,c,i]]]});i(_,function(a){var
c=b(F[9],a),d=c[1],e=d[1],f=N(0,a),h=f?f[1]:e;O(a);var
i=c[2];M(function(b){return q(a,b)},i);var
j=d[2];return[0,g(e,h),j]});i($,function(a){var
f=h(0,a);d(a,28);var
i=b8(1,a),c=b(F[10],i),j=[18,[0,c[2],1]],e=N(0,a),k=e?e[1]:c[1];O(a);var
l=c[3];M(function(b){return q(a,b)},l);return[0,g(f,k),j]});i(aa,function(a){var
e=h(0,a);d(a,25);d(a,5);var
f=b(j[7],a);d(a,6);var
i=b9(1,a),c=b(j[2],i);return[0,g(e,c[1]),[12,[0,f,c]]]});i(ab,function(a){var
f=h(0,a);d(a,26);d(a,5);var
i=b(j[7],a);d(a,6);var
c=b(j[2],a),e=g(f,c[1]);aW(a,[0,e,26]);return[0,e,[6,[0,i,c]]]});i(ad,function(c){var
a=b(j[16],c);return[0,a[1],[0,a[2]]]});i(af,function(a){var
c=b(j[7],a),l=e(0,a),h=c[2],m=c[1];if(typeof
h!=="number"&&17===h[0])if(typeof
l==="number")if(80===l){var
o=h[1],i=o[2];d(a,80);if(f(dt[3],i,a[3]))q(a,[0,m,[5,Gt,i]]);var
k=a.slice();k[3]=f(bH[4],i,a[3]);var
p=b(j[2],k);return[0,g(m,p[1]),[3,[0,o,p]]]}var
n=N(0,a),r=n?n[1]:c[1];O(a);return[0,g(c[1],r),[1,[0,c,0]]]});i(a,function(a){var
e=br(j[7],a),f=e[2],h=e[1],i=N(0,a),q=i?g(h,i[1]):h;O(a);var
k=a[18];if(k){var
c=f[2];if(typeof
c==="number")var
b=0;else
if(18===c[0]){var
n=c[1],o=n[1];if(typeof
o==="number")var
d=1;else
if(0===o[0])var
p=n[2],l=[0,ej(p,1,s(p)-2|0)],b=1,d=0;else
var
d=1;if(d)var
b=0;}else
var
b=0;if(!b)var
l=0;var
m=l;}else
var
m=k;return[0,q,[1,[0,f,m]]]});i(A,function(a){var
i=h(0,a);if(1-at(a))r(a,6);d(a,61);aO(a,1);var
k=f(j[13],0,a),l=b(z[3],a);d(a,78);var
c=b(z[1],a),e=N(0,a),m=e?e[1]:c[1];O(a);a4(a);return[0,g(i,m),[0,k,l,c]]});i(p,function(a){if(aI(Gu,a)){var
c=b(A,a);return[0,c[1],[7,c[2]]]}return b(j[2],a)});i(B,function(a){var
p=h(0,a);if(1-at(a))r(a,11);d(a,53);var
q=f(j[13],0,a),s=b(z[3],a),l=41===e(0,a)?1:0;if(l){d(a,41);var
c=0;for(;;){var
i=[0,b(z[5],a),c],k=e(0,a);if(typeof
k==="number")if(10===k){d(a,10);var
c=i;continue}var
n=m(i);break}}else
var
n=l;var
o=f(z[6],1,a);return[0,g(p,o[1]),[0,q,s,o,n,0]]});i(v,function(c){if(aI(Gv,c)){var
d=b(B,c);return[0,d[1],[20,d[2]]]}return b(a,c)});function
an(a,h){var
c=h;for(;;){var
f=[0,b(z[5],a),c],g=e(0,a);if(typeof
g==="number")if(10===g){d(a,10);var
c=f;continue}return m(f)}}i(o,function(l,k){var
a=bf(1,l);d(a,40);var
m=f(j[13],0,a),n=b(z[3],a),c=41===e(0,a)?1:0,o=c?(d(a,41),an(a,0)):c,h=ai(E(0,a),Gw),p=h?(aX(a,Gx),an(a,0)):h,i=f(z[6],1,a);return[0,g(k,i[1]),[0,m,n,i,o,p]]});i(ag,function(c,b){var
a=f(o,c,b);return[0,a[1],[23,a[2]]]});i(x,function(a,m){d(a,15);var
e=f(j[13],0,a),n=h(0,a),o=b(z[2],a),p=b(z[7],a);d(a,80);var
i=b(z[1],a),c=i[1],q=b(z[10],a),k=[0,g(n,c),[1,[0,p,i,o]]],r=[0,k[1],k],s=e[2],t=[0,g(e[1],c),s],l=N(0,a),u=l?l[1]:c;O(a);return[0,g(m,u),[0,t,r,q]]});i(C,function(c,b){var
a=f(x,c,b);return[0,a[1],[22,a[2]]]});i(D,function(a,f){d(a,24);var
b=u(j[15],a,Gy,28),c=b[2],e=N(0,a),h=e?e[1]:b[1],i=g(f,h);O(a);return[0,i,[0,c[1],c[2]]]});i(I,function(c,b){var
a=f(D,c,b);return[0,a[1],[21,a[2]]]});i(ah,function(a,H){var
q=e(0,a);if(typeof
q==="number")var
s=0;else
if(1===q[0]){var
l=q[1],B=l[4],C=l[3],D=l[2],E=l[1];if(B)au(a,32);d(a,[1,[0,E,D,C,B]]);var
y=[1,[0,E,[0,[0,D],C]]],s=1;}else
var
s=0;if(!s)var
y=[0,f(j[13],0,a)];var
I=h(0,a);d(a,1);var
c=0,n=0;for(;;){var
o=e(0,a);if(typeof
o==="number"){var
L=2===o?1:G===o?1:0;if(L){var
F=m(n);d(a,2);var
z=[0,g(I,h(0,a)),[0,F]],A=g(H,z[1]),K=c?c[1]:[0,A];return[0,A,[24,[0,y,z,K]]]}}var
p=f(J,Gz,a),i=p[2],u=p[1];if(c)if(0===c[1][0])if(typeof
i==="number")var
b=0;else
switch(i[0]){case
25:r(a,60);var
k=c,b=1;break;case
26:var
v=i[1][2],M=v?3<v[1][0]?1:0:0;if(!M)r(a,61);var
k=c,b=1;break;default:var
b=0;}else
if(typeof
i==="number")var
b=0;else
if(25===i[0]){r(a,61);var
k=c,b=1;}else
var
b=0;else
if(typeof
i==="number")var
b=0;else
switch(i[0]){case
25:var
k=[0,[0,u]],b=1;break;case
26:var
w=i[1][2];if(w)if(3<w[1][0])var
x=c,t=1;else
var
t=0;else
var
t=0;if(!t)var
x=[0,[1,u]];var
k=x,b=1;break;default:var
b=0;}if(!b)var
k=c;var
c=k,n=[0,p,n];continue}});i(aj,function(a,f){d(a,11);aX(a,GA);var
c=b(z[8],a),e=N(0,a),h=e?e[1]:c[1];O(a);return[0,g(f,h),[25,c]]});i(J,function(l,a){var
i=l?l[1]:l;if(1-at(a))r(a,8);var
g=h(0,a),c=e(GB,a);if(typeof
c==="number")if(24<=c){if(40<=c){if(!(64<=c))switch(c-40|0){case
0:d(a,60);return f(ag,a,g);case
6:if(50===e(0,a))return b(k,a);break;case
9:if(i)return f(K,[0,i],a);break;case
13:d(a,60);return b(v,a);case
21:var
n=e(0,a);if(typeof
n==="number")if(50===n)if(i)return b(k,a);d(a,60);return b(p,a);case
23:d(a,60);r(a,49);d(a,63);return f(C,a,g)}}else
if(!(25<=c)){d(a,60);return f(I,a,g)}}else{if(15===c){d(a,60);return f(C,a,g)}if(0===c)if(ai(E(GD,a),GC)){d(a,60);aX(a,GE);if(!i)if(11!==e(0,a))return f(ah,a,g);return f(aj,a,g)}}if(i){var
m=e(0,a);if(typeof
m==="number")if(50===m){r(a,64);return b(j[2],a)}d(a,60);return f(I,a,g)}return b(j[2],a)});i(n,function(a){aX(a,GF);var
c=e(0,a);if(typeof
c!=="number"&&1===c[0]){var
b=c[1],g=b[4],i=b[3],j=b[2],k=b[1];if(g)au(a,32);d(a,[1,[0,k,j,i,g]]);return[0,k,[0,[0,j],i]]}var
f=E(0,a),l=[0,h(0,a),[0,[0,f],f]];ac(a);return l});i(l,function(a){return a[2]});i(y,function(a,n,h){var
i=e(0,a);if(typeof
i==="number"){var
x=2===i?1:G===i?1:0;if(x){var
s=m(h);return[0,m(n),s]}}var
o=b(j[14],a),c=o[1];if(ai(E(0,a),GG)){aX(a,GH);var
f=b(j[14],a)[1],t=b(l,f);bI(a,[0,f[1],t]);var
q=[0,f],k=0,p=f[1];}else{var
r=c[1];bI(a,[0,r,b(l,c)]);var
q=0,k=o[2],p=r;}var
v=[0,g(c[1],p),[0,c,q]];if(10===e(0,a))d(a,10);var
w=k?[0,k[1],h]:h;return u(y,a,[0,v,n],w)});i(ak,function(ak,S){var
a=e4(1,bf(1,ak)),c=h(0,a);d(a,49);var
m=e(0,a);if(typeof
m==="number"){if(53<=m){if(ae===m){var
al=h(0,a);d(a,ae);var
am=a[24][4],T=ai(E(0,a),GI),an=T?(aX(a,GJ),am?[0,f(j[13],0,a)]:(r(a,8),0)):T,U=b(n,a),V=N(0,a),ao=[0,[1,al,an]],ap=V?V[1]:U[1];O(a);return[0,g(c,ap),[27,[0,0,ao,[0,U],1]]]}if(64<=m)var
i=0;else
switch(m+f1|0){case
0:if(1-at(a))r(a,10);var
t=b(v,a),B=t[2];if(typeof
B==="number")var
J=0;else
if(20===B[0]){var
av=b(l,B[1][1]);bI(a,[0,t[1],av]);var
J=1;}else
var
J=0;if(!J)ay(w(GM,GL));return[0,g(c,t[1]),[27,[0,[0,t],0,0,0]]];case
8:if(1!==e(GN,a)){if(1-at(a))r(a,10);var
x=b(p,a),C=x[2];if(typeof
C==="number")var
K=0;else
if(7===C[0]){var
aw=b(l,C[1][1]);bI(a,[0,x[1],aw]);var
K=1;}else
var
K=0;if(!K)ay(w(GP,GO));return[0,g(c,x[1]),[27,[0,[0,x],0,0,0]]]}var
i=0;break;case
10:var
i=1;break;default:var
i=0;}}else{var
ac=m-14|0;if(26<ac>>>0)var
i=0;else
switch(ac){case
22:d(a,36);bI(a,[0,g(c,h(0,a)),GR]);var
ad=e(0,a);if(typeof
ad==="number")if(15===ad)var
af=b(F[14],a),I=af[1],G=[0,af],P=1;else
var
P=0;else
var
P=0;if(!P)if(dq(0,a))var
ag=f(aC[3],a,S),I=ag[1],G=[0,ag];else{var
ah=b(j[9],a),aj=N(0,a),aA=aj?aj[1]:ah[1];O(a);var
I=aA,G=[1,ah];}return[0,g(c,I),[28,[0,G,1]]];case
0:case
1:case
10:case
13:case
14:case
26:var
i=1;break;default:var
i=0;}}if(i){var
z=f(j[3],[0,S],a),o=z[2],D=z[1];if(typeof
o==="number")var
k=0;else
switch(o[0]){case
17:var
$=o[1][1];if($)var
aa=$[1],k=2;else{q(a,[0,D,56]);var
A=0,k=1;}break;case
18:var
ax=o[1][1],az=0,A=aB(function(b,a){return aB(L,b,[0,a[2][1],0])},az,ax),k=1;break;case
19:var
ab=o[1][1];if(ab)var
aa=ab[1],k=2;else{q(a,[0,D,55]);var
A=0,k=1;}break;default:var
k=0;}switch(k){case
0:var
A=ay(GQ),Q=0;break;case
1:var
Q=0;break;default:var
_=[0,[0,D,b(l,aa)],0],Q=1;}if(!Q)var
_=A;M(function(b){return bI(a,b)},_);return[0,g(c,z[1]),[27,[0,[0,z],0,0,1]]]}}var
W=e(0,a);if(typeof
W==="number")if(61===W){H(a);var
X=0,R=1;}else
var
R=0;else
var
R=0;if(!R)var
X=1;d(a,1);var
Y=u(y,a,0,0),aq=[0,[0,Y[1]]],ar=h(0,a);d(a,2);if(ai(E(0,a),GK))var
s=[0,b(n,a)];else{var
au=Y[2];M(function(b){return q(a,b)},au);var
s=0;}var
Z=N(0,a),as=Z?Z[1]:s?s[1][1]:ar;O(a);return[0,g(c,as),[27,[0,0,aq,s,X]]]});i(K,function(v,l){var
K=v?v[1]:v;if(1-at(l))r(l,8);var
c=h(0,l);d(l,60);var
a=e4(1,bf(1,l));d(a,49);var
k=e(0,a);if(typeof
k==="number")if(54<=k){if(61===k){if(K){var
L=b(A,a),P=L[1],ac=g(c,P);return[0,ac,[26,[0,0,[0,[4,[0,P,L[2]]]],0,0]]]}}else
if(ae===k){var
aj=h(0,a);d(a,ae);var
ak=a[24][4],S=ai(E(0,a),GT),al=S?(aX(a,GU),ak?[0,f(j[13],0,a)]:(r(a,8),0)):S,T=b(n,a),U=N(0,a),am=[0,[1,aj,al]],an=U?U[1]:T[1];O(a);return[0,g(c,an),[26,[0,0,0,am,[0,T]]]]}}else
if(41<=k){if(53<=k)if(K){var
V=b(B,a),W=V[1],ao=g(c,W);return[0,ao,[26,[0,0,[0,[5,[0,W,V[2]]]],0,0]]]}}else
if(15<=k)switch(k-15|0){case
21:d(a,36);var
G=e(0,a);if(typeof
G==="number")if(15===G)var
_=f(x,a,c),I=_[1],H=[0,[1,_]],s=1;else
if(40===G)var
$=f(o,a,c),I=$[1],H=[0,[2,$]],s=1;else
var
s=0;else
var
s=0;if(!s){var
aa=b(z[1],a),ab=N(0,a),ap=ab?ab[1]:aa[1];O(a);var
I=ap,H=[0,[3,aa]];}return[0,g(c,I),[26,[0,1,H,0,0]]];case
0:case
9:case
12:case
13:case
25:var
i=e(0,a);if(typeof
i==="number"){if(25<=i)if(29<=i)if(40===i)var
X=f(o,a,c),F=X[1],C=[0,[2,X]],m=2;else
var
m=0;else
var
m=27<=i?1:0;else
if(15===i)var
Z=f(x,a,c),F=Z[1],C=[0,[1,Z]],m=2;else
var
m=24<=i?1:0;switch(m){case
0:var
J=0;break;case
1:var
aq=typeof
i==="number"?27===i?(r(a,51),1):28===i?(r(a,50),1):0:0,Y=f(D,a,c),F=Y[1],C=[0,[0,Y]],J=1;break;default:var
J=1;}if(J)return[0,g(c,F),[26,[0,0,C,0,0]]]}throw[0,t,GV]}var
w=e(0,a),ar=typeof
w==="number"?53===w?(r(a,53),1):61===w?(r(a,52),1):0:0;d(a,1);var
Q=u(y,a,0,0),ad=[0,[0,Q[1]]],af=h(0,a);d(a,2);if(ai(E(0,a),GS))var
p=[0,b(n,a)];else{var
ah=Q[2];M(function(b){return q(a,b)},ah);var
p=0;}var
R=N(0,a),ag=R?R[1]:p?p[1][1]:af;O(a);return[0,g(c,ag),[26,[0,0,0,ad,p]]]});function
ao(a){aX(a,GW);var
c=e(0,a);if(typeof
c!=="number"&&1===c[0]){var
b=c[1],g=b[4],i=b[3],j=b[2],k=b[1];if(g)au(a,32);d(a,[1,[0,k,j,i,g]]);return[0,k,[0,[0,j],i]]}var
f=E(0,a),l=[0,h(0,a),[0,[0,f],f]];ac(a);return l}function
ap(a,A){var
J=h(0,a),B=e(0,a);if(typeof
B==="number")if(ae===B){d(a,ae);aX(a,G4);var
C=f(j[13],0,a);return[0,[2,[0,g(J,C[1]),C]],0]}d(a,1);var
n=0,l=0;for(;;){var
D=n?n[1]:1,o=e(0,a);if(typeof
o==="number"){var
K=2===o?1:G===o?1:0;if(K){var
F=m(l);d(a,2);return F}}if(1-D)q(a,[0,h(0,a),66]);var
t=b(j[14],a),u=t[2],c=t[1],v=c[2];if(ai(v,GX))var
k=1,i=GY;else
if(ai(v,G2))var
k=1,i=G3;else
var
k=0,i=0;if(ai(E(0,a),GZ)){var
H=f(j[13],0,a);if(k)if(aI(0,a))var
r=0;else{if(A)q(a,[0,c[1],65]);var
w=[0,[0,i,0,H]],r=1;}else
var
r=0;if(!r)var
w=[0,[0,0,[0,f(j[13],0,a)],c]];var
p=w;}else{if(k)if(aI(0,a)){if(A)q(a,[0,c[1],65]);var
x=b(j[14],a),y=x[2];if(y)q(a,y[1]);var
z=ai(E(0,a),G0),I=z?(aX(a,G1),[0,f(j[13],0,a)]):z,p=[0,[0,i,I,x[1]]],s=1;}else
var
s=0;else
var
s=0;if(!s){if(u)q(a,u[1]);var
p=[0,[0,0,0,c]];}}var
n=[0,am(a,10)],l=[0,p,l];continue}}i(k,function(K){var
a=bf(1,K),p=h(0,a);d(a,50);var
q=e(0,a);if(typeof
q==="number")if(46===q){if(1-at(a))r(a,9);d(a,46);var
b=1,k=0,n=1;}else
if(61===q){if(1-at(a))r(a,9);var
b=0,k=[0,f(j[13],0,a)],n=1;}else
var
n=0;else
var
n=0;if(!n)var
b=2,k=0;var
w=2!==b?1:0,l=e(0,a),L=aI(0,a);if(typeof
l==="number")var
u=10===l?1:0;else
if(1===l[0]){if(2===b){var
m=l[1],G=m[4],H=m[3],I=m[2],t=m[1];if(G)au(a,32);d(a,[1,[0,t,I,H,G]]);var
J=N(0,a),T=[0,t,[0,[0,I],H]],U=J?J[1]:t;O(a);return[0,g(p,U),[29,[0,b,T,0]]]}var
u=0;}else
var
u=0;if(!u)if(0===L){var
M=ap(a,w),x=ao(a),y=N(0,a),P=y?y[1]:x[1];O(a);return[0,g(p,P),[29,[0,b,x,M]]]}var
s=e(0,a),Q=E(0,a);if(k)if(typeof
s==="number"){var
R=k[1];if(10===s)var
o=1;else
if(0===s)if(c(Q,G5))var
i=0,o=0;else
var
o=1;else
var
i=0,o=0;if(o)var
A=2,z=[1,R],i=1;}else
var
i=0;else
var
i=0;if(!i)var
A=b,z=[1,f(j[13],0,a)];var
B=e(0,a);if(typeof
B==="number")if(10===B){d(a,10);var
C=ap(a,w),v=1;}else
var
v=0;else
var
v=0;if(!v)var
C=0;var
D=ao(a),F=N(0,a),S=F?F[1]:D[1];O(a);return[0,g(p,S),[29,[0,A,D,[0,z,C]]]]});return[0,U,V,$,Z,aa,ab,ad,Q,R,S,J,K,T,P,ak,a,k,v,af,W,X,Y,p,_]}(bK),fe=function(F){function
k(g,a){var
b=a[2][1],c=[0,[0,bm(function(h){if(0===h[0]){var
i=h[1],b=i[2],c=b[2],a=b[1];switch(a[0]){case
0:var
d=[0,a[1]];break;case
1:var
d=[1,a[1]];break;default:var
d=[2,a[1]];}if(0===c[0])var
k=f(j[20],g,c[1]);else{var
l=c[1],e=l[1];q(g,[0,e,2]);var
k=[0,e,[4,[0,e,[2,l[2]]]]];}return[0,[0,i[1],[0,d,k,b[4]]]]}var
m=h[1],n=[0,f(j[20],g,m[2][1])];return[1,[0,m[1],n]]},b),0]];return[0,a[1],c]}function
l(e,a){var
b=a[2][1],c=[1,[0,bm(function(b){if(b){var
a=b[1];if(0===a[0]){var
c=a[1];return[0,[0,f(j[20],e,[0,c[1],c[2]])]]}var
d=a[1],g=[0,f(j[20],e,d[2][1])];return[0,[1,[0,d[1],g]]]}return b},b),0]];return[0,a[1],c]}function
a(e,d){var
a=d[2],b=d[1];if(typeof
a!=="number")switch(a[0]){case
0:return l(e,[0,b,a[1]]);case
1:return k(e,[0,b,a[1]]);case
7:var
c=a[1];if(0===c[1])return[0,b,[2,[0,c[2],c[3]]]];break;case
17:return[0,b,[3,[0,a[1],0,0]]]}return[0,b,[4,[0,b,a]]]}function
n(t){return function(a){var
J=h(0,a);d(a,1);var
o=0;for(;;){var
p=e(0,a);if(typeof
p==="number"){var
L=2===p?1:G===p?1:0;if(L){var
I=m(o),K=h(0,a);d(a,2);if(80===e(0,a))var
C=b(F[8],a),E=C[1],D=[0,C];else
var
E=K,D=0;return[0,g(J,E),[0,[0,I,D]]]}}var
u=h(0,a);if(am(a,13))var
v=i(a,t),q=[0,[1,[0,g(u,v[1]),[0,v]]]];else{var
k=b(j[21],a)[2];switch(k[0]){case
0:var
c=[0,k[1]];break;case
1:var
c=[1,k[1]];break;default:var
c=[2,k[1]];}var
w=e(0,a);if(typeof
w==="number")if(80===w){d(a,80);var
f=[0,[0,i(a,t),0]],r=1;}else
var
r=0;else
var
r=0;if(!r)if(1===c[0])var
B=c[1],f=[0,[0,[0,B[1],[3,[0,B,0,0]]],1]];else{ac(a);var
f=0;}if(f){var
x=f[1],l=x[1],y=e(0,a);if(typeof
y==="number")if(78===y){d(a,78);var
z=b(j[9],a),n=[0,g(l[1],z[1]),[2,[0,l,z]]],s=1;}else
var
s=0;else
var
s=0;if(!s)var
n=l;var
H=g(u,n[1]),A=[0,[0,[0,H,[0,c,n,x[2]]]]];}else
var
A=f;var
q=A;}if(q){if(2!==e(0,a))d(a,10);var
o=[0,q[1],o];continue}continue}}}function
o(o){return function(a){var
z=h(0,a);d(a,7);var
c=0;for(;;){var
f=e(0,a);if(typeof
f==="number"){if(14<=f)var
k=G===f?1:0;else
if(8<=f)switch(f-8|0){case
2:d(a,10);var
c=[0,0,c];continue;case
5:var
y=h(0,a);d(a,13);var
s=i(a,o),c=[0,[0,[1,[0,g(y,s[1]),[0,s]]]],c];continue;case
0:var
k=1;break;default:var
k=0;}else
var
k=0;if(k){var
w=m(c),A=h(0,a);d(a,8);if(80===e(0,a))var
t=b(F[8],a),v=t[1],u=[0,t];else
var
v=A,u=0;return[0,g(z,v),[1,[0,w,u]]]}}var
l=i(a,o),p=e(0,a);if(typeof
p==="number")if(78===p){d(a,78);var
q=b(j[7],a),r=[0,g(l[1],q[1]),[2,[0,l,q]]],n=1;}else
var
n=0;else
var
n=0;if(!n)var
r=l;var
x=[0,r];if(8!==e(0,a))d(a,10);var
c=[0,[0,x],c];continue}}}function
i(a,c){var
d=e(0,a);if(typeof
d==="number"){if(1===d)return b(n(c),a);if(7===d)return b(o(c),a)}var
f=u(j[15],a,0,c);return[0,f[1],[3,f[2]]]}return[0,k,l,a,n,o,i]}(z),ff=function
b(a){return b.fun(a)},dv=function
d(a,b,c){return d.fun(a,b,c)},dw=function
b(a){return b.fun(a)},fg=function
c(a,b){return c.fun(a,b)},dx=function
c(a,b){return c.fun(a,b)},dy=function
c(a,b){return c.fun(a,b)},cD=function
c(a,b){return c.fun(a,b)},cb=function
c(a,b){return c.fun(a,b)},cE=function
b(a){return b.fun(a)},fh=function
b(a){return b.fun(a)},dz=function
c(a,b){return c.fun(a,b)},fi=function
d(a,b,c){return d.fun(a,b,c)},fj=function
b(a){return b.fun(a)},fk=function
b(a){return b.fun(a)},G8=F$(j),fl=bK[3],G9=a5[3],G_=a5[2],G$=a5[6],Ha=bK[2],Hb=bK[1],Hc=bK[4],Hd=a5[1],He=a5[5],Hf=a5[4],Hg=G8[10],Hh=fe[6],Hi=fe[3];i(ff,function(a){var
b=f(fg,a,function(a){return 0}),e=h(0,a);d(a,G);if(b)var
i=bl(m(b))[1],c=g(bl(b)[1],i);else
var
c=e;return[0,c,b,m(a[2][1])]});i(dv,function(u,t,s){var
a=e3(1,u),h=Hm;for(;;){var
f=h[2],c=h[1],d=e(0,a);if(typeof
d==="number")if(G===d)var
g=[0,a,c,f],j=1;else
var
j=0;else
var
j=0;if(!j)if(b(t,d))var
g=[0,a,c,f];else{if(typeof
d==="number")var
k=0;else
if(1===d[0]){var
l=b(s,a),n=[0,l,f],i=l[2];if(typeof
i!=="number"&&1===i[0]){var
o=i[1][2];if(o){var
q=a[6],r=q||ai(o[1],Hl),a=bf(r,a),h=[0,[0,d,c],n];continue}}var
g=[0,a,c,n],k=1;}else
var
k=0;if(!k)var
g=[0,a,c,f];}var
p=e3(0,a),v=m(c);M(function(b){if(typeof
b!=="number"&&1===b[0]){var
d=b[1],e=d[4];return e?aW(p,[0,d[1],32]):e}if(typeof
b==="number"){var
c=b;if(59<=c)switch(c){case
59:var
a=uO;break;case
60:var
a=uP;break;case
61:var
a=uQ;break;case
62:var
a=uR;break;case
63:var
a=uS;break;case
64:var
a=uT;break;case
65:var
a=uU;break;case
66:var
a=uV;break;case
67:var
a=uW;break;case
68:var
a=uX;break;case
69:var
a=uY;break;case
70:var
a=uZ;break;case
71:var
a=u0;break;case
72:var
a=u1;break;case
73:var
a=u2;break;case
74:var
a=u3;break;case
75:var
a=u4;break;case
76:var
a=u5;break;case
77:var
a=u6;break;case
78:var
a=u7;break;case
79:var
a=u8;break;case
80:var
a=u9;break;case
81:var
a=u_;break;case
82:var
a=u$;break;case
83:var
a=va;break;case
84:var
a=vb;break;case
85:var
a=vc;break;case
86:var
a=vd;break;case
87:var
a=ve;break;case
88:var
a=vf;break;case
89:var
a=vg;break;case
90:var
a=vh;break;case
91:var
a=vi;break;case
92:var
a=vj;break;case
93:var
a=vk;break;case
94:var
a=vl;break;case
95:var
a=vm;break;case
96:var
a=vn;break;case
97:var
a=vo;break;case
98:var
a=vp;break;case
99:var
a=vq;break;case
100:var
a=vr;break;case
101:var
a=vs;break;case
102:var
a=vt;break;case
103:var
a=vu;break;case
104:var
a=vv;break;case
105:var
a=vw;break;case
106:var
a=vx;break;case
107:var
a=vy;break;case
108:var
a=vz;break;case
109:var
a=vA;break;case
110:var
a=vB;break;case
111:var
a=vC;break;case
112:var
a=vD;break;case
113:var
a=vE;break;case
114:var
a=vF;break;case
115:var
a=vG;break;default:var
a=vH;}else
switch(c){case
0:var
a=tT;break;case
1:var
a=tU;break;case
2:var
a=tV;break;case
3:var
a=tW;break;case
4:var
a=tX;break;case
5:var
a=tY;break;case
6:var
a=tZ;break;case
7:var
a=t0;break;case
8:var
a=t1;break;case
9:var
a=t2;break;case
10:var
a=t3;break;case
11:var
a=t4;break;case
12:var
a=t5;break;case
13:var
a=t6;break;case
14:var
a=t7;break;case
15:var
a=t8;break;case
16:var
a=t9;break;case
17:var
a=t_;break;case
18:var
a=t$;break;case
19:var
a=ua;break;case
20:var
a=ub;break;case
21:var
a=uc;break;case
22:var
a=ud;break;case
23:var
a=ue;break;case
24:var
a=uf;break;case
25:var
a=ug;break;case
26:var
a=uh;break;case
27:var
a=ui;break;case
28:var
a=uj;break;case
29:var
a=uk;break;case
30:var
a=ul;break;case
31:var
a=um;break;case
32:var
a=un;break;case
33:var
a=uo;break;case
34:var
a=up;break;case
35:var
a=uq;break;case
36:var
a=ur;break;case
37:var
a=us;break;case
38:var
a=ut;break;case
39:var
a=uu;break;case
40:var
a=uv;break;case
41:var
a=uw;break;case
42:var
a=ux;break;case
43:var
a=uy;break;case
44:var
a=uz;break;case
45:var
a=uA;break;case
46:var
a=uB;break;case
47:var
a=uC;break;case
48:var
a=uD;break;case
49:var
a=uE;break;case
50:var
a=uF;break;case
51:var
a=uG;break;case
52:var
a=uH;break;case
53:var
a=uI;break;case
54:var
a=uJ;break;case
55:var
a=uK;break;case
56:var
a=uL;break;case
57:var
a=uM;break;default:var
a=uN;}}else
switch(b[0]){case
0:var
a=vI;break;case
1:var
a=vJ;break;case
2:var
a=vK;break;case
3:var
a=vL;break;case
4:var
a=vM;break;default:var
a=vN;}return ay(w(Hk,w(a,Hj)))},v);return[0,p,g[3]]}});i(dw,function(a){var
c=b(bK[5],a),d=e(0,a);if(typeof
d==="number"){var
g=d-49|0;if(!(11<g>>>0))switch(g){case
0:return f(J[15],a,c);case
1:b(dr(a),c);return b(J[17],a);case
11:if(49===e(Hn,a)){b(dr(a),c);return f(J[12],0,a)}break}}return f(cb,[0,c],a)});i(fg,function(c,a){var
b=u(dv,c,a,dw),d=f(dx,a,b[1]),e=b[2];return aB(function(b,a){return[0,a,b]},d,e)});i(dx,function(f,d){var
a=0;for(;;){var
c=e(0,d);if(typeof
c==="number")if(G===c)return m(a);if(b(f,c))return m(a);var
a=[0,b(dw,d),a];continue}});i(dy,function(a,d){var
b=u(dv,d,a,function(a){return f(cb,0,a)}),c=b[1],e=f(cD,a,c),g=b[2],h=aB(function(b,a){return[0,a,b]},e,g);return[0,h,c[6]]});i(cD,function(g,d){var
a=0;for(;;){var
c=e(0,d);if(typeof
c==="number")if(G===c)return m(a);if(b(g,c))return m(a);var
a=[0,f(cb,0,d),a];continue}});i(cb,function(d,a){var
g=d?d[1]:d;if(1-dq(0,a))b(dr(a),g);var
c=e(0,a);if(typeof
c==="number"){if(27===c)return b(J[24],a);if(28===c)return b(J[3],a)}if(cC(0,a))return b(F[14],a);if(dq(0,a))return f(fl,a,g);if(typeof
c==="number"){var
h=c+f1|0;if(!(8<h>>>0))switch(h){case
0:return b(J[18],a);case
7:return f(J[11],0,a);case
8:return b(J[23],a)}}return b(cE,a)});i(cE,function(a){var
c=e(0,a);if(typeof
c==="number"){if(G===c){ac(a);return[0,h(0,a),0]}if(!(60<=c))switch(c){case
1:return b(J[7],a);case
9:return b(J[14],a);case
16:return b(J[2],a);case
19:return b(J[20],a);case
20:return b(J[21],a);case
22:return b(J[22],a);case
23:return b(J[4],a);case
24:return b(J[24],a);case
25:return b(J[5],a);case
26:return b(J[6],a);case
32:return b(J[8],a);case
35:return b(J[9],a);case
37:return b(J[13],a);case
39:return b(J[1],a);case
59:return b(J[10],a)}}if(aI(0,a))return b(J[19],a);if(typeof
c==="number"){if(80===c)var
d=1;else
if(51<=c)var
d=0;else
switch(c){case
43:return b(J[2],a);case
2:case
6:case
8:case
10:case
11:case
12:case
13:case
17:case
18:case
33:case
34:case
36:case
38:case
41:case
42:case
49:case
50:var
d=1;break;default:var
d=0;}if(d){ac(a);H(a);return b(cE,a)}}return b(J[16],a)});i(fh,function(a){var
c=b(a5[2],a),d=e(0,a);if(typeof
d==="number")if(10===d)return f(a5[8],a,[0,c,0]);return c});i(dz,function(g,a){var
i=h(0,a),c=E(0,a),b=e(0,a);if(typeof
b==="number")if(28===b){if(a[6])au(a,40);else
if(a[13])r(a,[1,c]);H(a);var
f=1;}else
var
f=0;else
var
f=0;if(!f)if(b_(c)){au(a,40);H(a);}else{var
j=typeof
b==="number"?4<(b-60|0)>>>0?0:(d(a,b),1):0;if(!j)d(a,0);}var
k=g?bq(c)?(aW(a,[0,i,g[1]]),1):0:0;return[0,i,c]});i(fi,function(c,a,k){var
l=a?a[1]:a;return br(function(a){var
c=1-l,i=f(dz,[0,k],a),g=c?79===e(0,a)?1:0:c;if(g){if(1-at(a))r(a,7);d(a,79);}var
h=80===e(0,a)?1:0,j=h?[0,b(z[8],a)]:h;return[0,i,j,g]},c)});i(fj,function(a){var
b=h(0,a);d(a,1);var
c=f(cD,function(a){return 2===a?1:0},a),e=h(0,a);d(a,2);return[0,g(b,e),[0,c]]});i(fk,function(a){var
c=h(0,a);d(a,1);var
b=f(dy,function(a){return 2===a?1:0},a),e=h(0,a);d(a,2);var
i=b[2],j=[0,b[1]];return[0,g(c,e),j,i]});u(aF,Ho,j,[0,ff,cE,cb,cD,dy,dx,fh,G9,G_,G$,Ha,Hd,dz,Hf,fi,fj,fk,Hg,Hh,Hi,Hb,fl,Hc,He]);var
cF=[0,0];function
Hp(r,g,e,q){var
t=r?r[1]:1,M=g?g[1]:g,N=e?e[1]:e,h=[0,N],i=[0,M],u=0,L=i?i[1]:i,o=h?h[1]:h,p=[0,o],d=[0,L],F=d?d[1]:d,l=p?o:p,w=[0],x=1,y=0,z=0,A=0,B=0,C=0,D=s(q),v=ei(q),E=[0,function(a){a[9]=1;return 0},v,D,C,B,A,z,y,x,w,en,en],a=l?l[1]:dn,k=[0,u,E,0,a[5],dk],G=[0,b5(k,0)],n=[0,[0,0],[0,0],bH[1],[0,bH[1]],[0,0],a[6],0,0,0,0,0,0,0,0,0,1,0,0,0,[0,Ev],[0,k],G,[0,F],a,u],J=b(j[1],n),H=m(n[1][1]),I=[0,du[1],0],c=m(aB(function(c,a){var
d=c[2],b=c[1];return f(du[3],a,b)?[0,b,d]:[0,f(du[4],a,b),[0,a,d]]},I,H)[2]),K=t?0!==c?1:0:t;if(K)throw[0,eJ,c];return[0,J,c]}var
Hq=Ic,Hr=Ib,Hs=Id,Ht=Ia;function
Hu(a){return a}function
Hv(d,c,a){try{var
e=new
RegExp(c.toString(),a.toString()),b=e;}catch(c){cF[1]=[0,[0,d,13],cF[1]];var
b=new
RegExp(p,a.toString());}return b}function
Hw(b){var
a=new
Function(cX,"throw e;");return a.call(a,b)}function
Hx(a){var
f=a.esproposal_decorators;if(b4(f)){var
g=dn.slice();g[3]=f|0;var
b=g;}else
var
b=dn;var
h=a.esproposal_class_instance_fields;if(b4(h)){var
i=b.slice();i[1]=h|0;var
c=i;}else
var
c=b;var
j=a.esproposal_class_static_fields;if(b4(j)){var
k=c.slice();k[2]=j|0;var
d=k;}else
var
d=c;var
l=a.esproposal_export_star_as;if(b4(l)){var
m=d.slice();m[4]=l|0;var
e=m;}else
var
e=d;var
n=a.types;if(b4(n)){var
o=e.slice();o[5]=n|0;return o}return e}function
Hy(h,c){var
i=g4(c,eD)?{}:c,j=bk(h),k=[0,Hx(i)];try{var
e=Hp(HA,0,[0,k],j);cF[1]=0;var
f=lM([0,Hq,Hr,Hs,Ht,Hu,jT,Hv]),g=b(f[1],e[1]),l=cr(e[2],cF[1]);g.errors=b(f[3],l);return g}catch(b){b=aj(b);if(b[1]===eJ){var
d=new
Error(w(a(p+dc(b[2])),Hz).toString());d.name="Parse Error";Hw(d);return{}}throw b}}var fm;

var
fm=exports;fm.parse=Hy;hq(0);return}(function(){return this}()));
});

var index$34 = createCommonjsModule(function (module, exports) {
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/* eslint max-len: 0 */

// This is a trick taken from Esprima. It turns out that, on
// non-Chrome browsers, to check whether a string is in a set, a
// predicate containing a big ugly `switch` statement is faster than
// a regular expression, and on Chrome the two are about on par.
// This function uses `eval` (non-lexical) to produce such a
// predicate from a space-separated string of words.
//
// It starts by sorting the words by length.

function makePredicate(words) {
  words = words.split(" ");
  return function (str) {
    return words.indexOf(str) >= 0;
  };
}

// Reserved word lists for various dialects of the language

var reservedWords = {
  6: makePredicate("enum await"),
  strict: makePredicate("implements interface let package private protected public static yield"),
  strictBind: makePredicate("eval arguments")
};

// And the keywords

var isKeyword = makePredicate("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this let const class extends export import yield super");

// ## Character categories

// Big ugly regular expressions that match characters in the
// whitespace, identifier, and identifier-start categories. These
// are only applied when a character is found to actually have a
// code point above 128.
// Generated by `bin/generate-identifier-regex.js`.

var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D4-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0D01-\u0D03\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF5\u1DFB-\u1DFF\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA900-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F";

var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");

nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;

// These are a run-length and offset encoded representation of the
// >0xffff code points that are a valid part of identifiers. The
// offset starts at 0x10000, and each pair of numbers represents an
// offset to the next range, and then a size of the range. They were
// generated by `bin/generate-identifier-regex.js`.
// eslint-disable-next-line comma-spacing
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 17, 26, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 26, 45, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 785, 52, 76, 44, 33, 24, 27, 35, 42, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 25, 391, 63, 32, 0, 449, 56, 264, 8, 2, 36, 18, 0, 50, 29, 881, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 881, 68, 12, 0, 67, 12, 65, 0, 32, 6124, 20, 754, 9486, 1, 3071, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 10591, 541];
// eslint-disable-next-line comma-spacing
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 1306, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 52, 0, 13, 2, 49, 13, 10, 2, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 57, 0, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 87, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 423, 9, 838, 7, 2, 7, 17, 9, 57, 21, 2, 13, 19882, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];

// This has a complexity linear to the value of the code. The
// assumption is that looking up astral identifier characters is
// rare.
function isInAstralSet(code, set) {
  var pos = 0x10000;
  for (var i = 0; i < set.length; i += 2) {
    pos += set[i];
    if (pos > code) return false;

    pos += set[i + 1];
    if (pos >= code) return true;
  }
}

// Test whether a given character code starts an identifier.

function isIdentifierStart(code) {
  if (code < 65) return code === 36;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes);
}

// Test whether a given character is part of an identifier.

function isIdentifierChar(code) {
  if (code < 48) return code === 36;
  if (code < 58) return true;
  if (code < 65) return false;
  if (code < 91) return true;
  if (code < 97) return code === 95;
  if (code < 123) return true;
  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}

// A second optional argument can be given to further configure
var defaultOptions = {
  // Source type ("script" or "module") for different semantics
  sourceType: "script",
  // Source filename.
  sourceFilename: undefined,
  // Line from which to start counting source. Useful for
  // integration with other tools.
  startLine: 1,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program.
  allowImportExportEverywhere: false,
  // TODO
  allowSuperOutsideMethod: false,
  // An array of plugins to enable
  plugins: [],
  // TODO
  strictMode: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false
};

// Interpret and default an options object

function getOptions(opts) {
  var options = {};
  for (var key in defaultOptions) {
    options[key] = opts && key in opts ? opts[key] : defaultOptions[key];
  }
  return options;
}

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};











var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};











var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

// ## Token types

// The assignment of fine-grained, information-carrying type objects
// allows the tokenizer to store the information it has about a
// token in a way that is very cheap for the parser to look up.

// All token type variables start with an underscore, to make them
// easy to recognize.

// The `beforeExpr` property is used to disambiguate between regular
// expressions and divisions. It is set on all token types that can
// be followed by an expression (thus, a slash after them would be a
// regular expression).
//
// `isLoop` marks a keyword as starting a loop, which is important
// to know when parsing a label, in order to allow or disallow
// continue jumps to that label.

var beforeExpr = true;
var startsExpr = true;
var isLoop = true;
var isAssign = true;
var prefix = true;
var postfix = true;

var TokenType = function TokenType(label) {
  var conf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  classCallCheck(this, TokenType);

  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.rightAssociative = !!conf.rightAssociative;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};

var KeywordTokenType = function (_TokenType) {
  inherits(KeywordTokenType, _TokenType);

  function KeywordTokenType(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    classCallCheck(this, KeywordTokenType);

    options.keyword = name;

    return possibleConstructorReturn(this, _TokenType.call(this, name, options));
  }

  return KeywordTokenType;
}(TokenType);

var BinopTokenType = function (_TokenType2) {
  inherits(BinopTokenType, _TokenType2);

  function BinopTokenType(name, prec) {
    classCallCheck(this, BinopTokenType);
    return possibleConstructorReturn(this, _TokenType2.call(this, name, { beforeExpr: beforeExpr, binop: prec }));
  }

  return BinopTokenType;
}(TokenType);

var types = {
  num: new TokenType("num", { startsExpr: startsExpr }),
  regexp: new TokenType("regexp", { startsExpr: startsExpr }),
  string: new TokenType("string", { startsExpr: startsExpr }),
  name: new TokenType("name", { startsExpr: startsExpr }),
  eof: new TokenType("eof"),

  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceBarL: new TokenType("{|", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  braceR: new TokenType("}"),
  braceBarR: new TokenType("|}"),
  parenL: new TokenType("(", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", { beforeExpr: beforeExpr }),
  semi: new TokenType(";", { beforeExpr: beforeExpr }),
  colon: new TokenType(":", { beforeExpr: beforeExpr }),
  doubleColon: new TokenType("::", { beforeExpr: beforeExpr }),
  dot: new TokenType("."),
  question: new TokenType("?", { beforeExpr: beforeExpr }),
  arrow: new TokenType("=>", { beforeExpr: beforeExpr }),
  template: new TokenType("template"),
  ellipsis: new TokenType("...", { beforeExpr: beforeExpr }),
  backQuote: new TokenType("`", { startsExpr: startsExpr }),
  dollarBraceL: new TokenType("${", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  at: new TokenType("@"),

  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.

  eq: new TokenType("=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  assign: new TokenType("_=", { beforeExpr: beforeExpr, isAssign: isAssign }),
  incDec: new TokenType("++/--", { prefix: prefix, postfix: postfix, startsExpr: startsExpr }),
  prefix: new TokenType("prefix", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  logicalOR: new BinopTokenType("||", 1),
  logicalAND: new BinopTokenType("&&", 2),
  bitwiseOR: new BinopTokenType("|", 3),
  bitwiseXOR: new BinopTokenType("^", 4),
  bitwiseAND: new BinopTokenType("&", 5),
  equality: new BinopTokenType("==/!=", 6),
  relational: new BinopTokenType("</>", 7),
  bitShift: new BinopTokenType("<</>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: beforeExpr, binop: 9, prefix: prefix, startsExpr: startsExpr }),
  modulo: new BinopTokenType("%", 10),
  star: new BinopTokenType("*", 10),
  slash: new BinopTokenType("/", 10),
  exponent: new TokenType("**", { beforeExpr: beforeExpr, binop: 11, rightAssociative: true })
};

var keywords = {
  "break": new KeywordTokenType("break"),
  "case": new KeywordTokenType("case", { beforeExpr: beforeExpr }),
  "catch": new KeywordTokenType("catch"),
  "continue": new KeywordTokenType("continue"),
  "debugger": new KeywordTokenType("debugger"),
  "default": new KeywordTokenType("default", { beforeExpr: beforeExpr }),
  "do": new KeywordTokenType("do", { isLoop: isLoop, beforeExpr: beforeExpr }),
  "else": new KeywordTokenType("else", { beforeExpr: beforeExpr }),
  "finally": new KeywordTokenType("finally"),
  "for": new KeywordTokenType("for", { isLoop: isLoop }),
  "function": new KeywordTokenType("function", { startsExpr: startsExpr }),
  "if": new KeywordTokenType("if"),
  "return": new KeywordTokenType("return", { beforeExpr: beforeExpr }),
  "switch": new KeywordTokenType("switch"),
  "throw": new KeywordTokenType("throw", { beforeExpr: beforeExpr }),
  "try": new KeywordTokenType("try"),
  "var": new KeywordTokenType("var"),
  "let": new KeywordTokenType("let"),
  "const": new KeywordTokenType("const"),
  "while": new KeywordTokenType("while", { isLoop: isLoop }),
  "with": new KeywordTokenType("with"),
  "new": new KeywordTokenType("new", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "this": new KeywordTokenType("this", { startsExpr: startsExpr }),
  "super": new KeywordTokenType("super", { startsExpr: startsExpr }),
  "class": new KeywordTokenType("class"),
  "extends": new KeywordTokenType("extends", { beforeExpr: beforeExpr }),
  "export": new KeywordTokenType("export"),
  "import": new KeywordTokenType("import", { startsExpr: startsExpr }),
  "yield": new KeywordTokenType("yield", { beforeExpr: beforeExpr, startsExpr: startsExpr }),
  "null": new KeywordTokenType("null", { startsExpr: startsExpr }),
  "true": new KeywordTokenType("true", { startsExpr: startsExpr }),
  "false": new KeywordTokenType("false", { startsExpr: startsExpr }),
  "in": new KeywordTokenType("in", { beforeExpr: beforeExpr, binop: 7 }),
  "instanceof": new KeywordTokenType("instanceof", { beforeExpr: beforeExpr, binop: 7 }),
  "typeof": new KeywordTokenType("typeof", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "void": new KeywordTokenType("void", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr }),
  "delete": new KeywordTokenType("delete", { beforeExpr: beforeExpr, prefix: prefix, startsExpr: startsExpr })
};

// Map keyword names to token types.
Object.keys(keywords).forEach(function (name) {
  types["_" + name] = keywords[name];
});

// Matches a whole line break (where CRLF is considered a single
// line break). Used to count lines.

var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");

function isNewLine(code) {
  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029;
}

var nonASCIIwhitespace = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/;

// The algorithm used to determine whether a regexp can appear at a
// given point in the program is loosely based on sweet.js' approach.
// See https://github.com/mozilla/sweet.js/wiki/design

var TokContext = function TokContext(token, isExpr, preserveSpace, override) {
  classCallCheck(this, TokContext);

  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
};

var types$1 = {
  braceStatement: new TokContext("{", false),
  braceExpression: new TokContext("{", true),
  templateQuasi: new TokContext("${", true),
  parenStatement: new TokContext("(", false),
  parenExpression: new TokContext("(", true),
  template: new TokContext("`", true, true, function (p) {
    return p.readTmplToken();
  }),
  functionExpression: new TokContext("function", true)
};

// Token-specific context update code

types.parenR.updateContext = types.braceR.updateContext = function () {
  if (this.state.context.length === 1) {
    this.state.exprAllowed = true;
    return;
  }

  var out = this.state.context.pop();
  if (out === types$1.braceStatement && this.curContext() === types$1.functionExpression) {
    this.state.context.pop();
    this.state.exprAllowed = false;
  } else if (out === types$1.templateQuasi) {
    this.state.exprAllowed = true;
  } else {
    this.state.exprAllowed = !out.isExpr;
  }
};

types.name.updateContext = function (prevType) {
  this.state.exprAllowed = false;

  if (prevType === types._let || prevType === types._const || prevType === types._var) {
    if (lineBreak.test(this.input.slice(this.state.end))) {
      this.state.exprAllowed = true;
    }
  }
};

types.braceL.updateContext = function (prevType) {
  this.state.context.push(this.braceIsBlock(prevType) ? types$1.braceStatement : types$1.braceExpression);
  this.state.exprAllowed = true;
};

types.dollarBraceL.updateContext = function () {
  this.state.context.push(types$1.templateQuasi);
  this.state.exprAllowed = true;
};

types.parenL.updateContext = function (prevType) {
  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;
  this.state.context.push(statementParens ? types$1.parenStatement : types$1.parenExpression);
  this.state.exprAllowed = true;
};

types.incDec.updateContext = function () {
  // tokExprAllowed stays unchanged
};

types._function.updateContext = function () {
  if (this.curContext() !== types$1.braceStatement) {
    this.state.context.push(types$1.functionExpression);
  }

  this.state.exprAllowed = false;
};

types.backQuote.updateContext = function () {
  if (this.curContext() === types$1.template) {
    this.state.context.pop();
  } else {
    this.state.context.push(types$1.template);
  }
  this.state.exprAllowed = false;
};

// These are used when `options.locations` is on, for the
// `startLoc` and `endLoc` properties.

var Position = function Position(line, col) {
  classCallCheck(this, Position);

  this.line = line;
  this.column = col;
};

var SourceLocation = function SourceLocation(start, end) {
  classCallCheck(this, SourceLocation);

  this.start = start;
  this.end = end;
};

// The `getLineInfo` function is mostly useful when the
// `locations` option is off (for performance reasons) and you
// want to find the line/column position for a given character
// offset. `input` should be the code string that the offset refers
// into.

function getLineInfo(input, offset) {
  for (var line = 1, cur = 0;;) {
    lineBreakG.lastIndex = cur;
    var match = lineBreakG.exec(input);
    if (match && match.index < offset) {
      ++line;
      cur = match.index + match[0].length;
    } else {
      return new Position(line, offset - cur);
    }
  }
}

var State = function () {
  function State() {
    classCallCheck(this, State);
  }

  State.prototype.init = function init(options, input) {
    this.strict = options.strictMode === false ? false : options.sourceType === "module";

    this.input = input;

    this.potentialArrowAt = -1;

    this.inMethod = this.inFunction = this.inGenerator = this.inAsync = this.inPropertyName = this.inType = this.noAnonFunctionType = false;

    this.labels = [];

    this.decorators = [];

    this.tokens = [];

    this.comments = [];

    this.trailingComments = [];
    this.leadingComments = [];
    this.commentStack = [];

    this.pos = this.lineStart = 0;
    this.curLine = options.startLine;

    this.type = types.eof;
    this.value = null;
    this.start = this.end = this.pos;
    this.startLoc = this.endLoc = this.curPosition();

    this.lastTokEndLoc = this.lastTokStartLoc = null;
    this.lastTokStart = this.lastTokEnd = this.pos;

    this.context = [types$1.braceStatement];
    this.exprAllowed = true;

    this.containsEsc = this.containsOctal = false;
    this.octalPosition = null;

    this.invalidTemplateEscapePosition = null;

    this.exportedIdentifiers = [];

    return this;
  };

  // TODO


  // TODO


  // Used to signify the start of a potential arrow function


  // Flags to track whether we are in a function, a generator.


  // Labels in scope.


  // Leading decorators.


  // Token store.


  // Comment store.


  // Comment attachment store


  // The current position of the tokenizer in the input.


  // Properties of the current token:
  // Its type


  // For tokens that include more information than their type, the value


  // Its start and end offset


  // And, if locations are used, the {line, column} object
  // corresponding to those offsets


  // Position information for the previous token


  // The context stack is used to superficially track syntactic
  // context to predict whether a regular expression is allowed in a
  // given position.


  // Used to signal to callers of `readWord1` whether the word
  // contained any escape sequences. This is needed because words with
  // escape sequences must not be interpreted as keywords.


  // TODO


  // Names of exports store. `default` is stored as a name for both
  // `export default foo;` and `export { foo as default };`.


  State.prototype.curPosition = function curPosition() {
    return new Position(this.curLine, this.pos - this.lineStart);
  };

  State.prototype.clone = function clone(skipArrays) {
    var state = new State();
    for (var key in this) {
      var val = this[key];

      if ((!skipArrays || key === "context") && Array.isArray(val)) {
        val = val.slice();
      }

      state[key] = val;
    }
    return state;
  };

  return State;
}();

// Object type used to represent tokens. Note that normally, tokens
// simply exist as properties on the parser object. This is only
// used for the onToken callback and the external tokenizer.

var Token = function Token(state) {
  classCallCheck(this, Token);

  this.type = state.type;
  this.value = state.value;
  this.start = state.start;
  this.end = state.end;
  this.loc = new SourceLocation(state.startLoc, state.endLoc);
};

// ## Tokenizer

function codePointToString(code) {
  // UTF-16 Decoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  } else {
    return String.fromCharCode((code - 0x10000 >> 10) + 0xD800, (code - 0x10000 & 1023) + 0xDC00);
  }
}

var Tokenizer = function () {
  function Tokenizer(options, input) {
    classCallCheck(this, Tokenizer);

    this.state = new State();
    this.state.init(options, input);
  }

  // Move to the next token

  Tokenizer.prototype.next = function next() {
    if (!this.isLookahead) {
      this.state.tokens.push(new Token(this.state));
    }

    this.state.lastTokEnd = this.state.end;
    this.state.lastTokStart = this.state.start;
    this.state.lastTokEndLoc = this.state.endLoc;
    this.state.lastTokStartLoc = this.state.startLoc;
    this.nextToken();
  };

  // TODO

  Tokenizer.prototype.eat = function eat(type) {
    if (this.match(type)) {
      this.next();
      return true;
    } else {
      return false;
    }
  };

  // TODO

  Tokenizer.prototype.match = function match(type) {
    return this.state.type === type;
  };

  // TODO

  Tokenizer.prototype.isKeyword = function isKeyword$$1(word) {
    return isKeyword(word);
  };

  // TODO

  Tokenizer.prototype.lookahead = function lookahead() {
    var old = this.state;
    this.state = old.clone(true);

    this.isLookahead = true;
    this.next();
    this.isLookahead = false;

    var curr = this.state.clone(true);
    this.state = old;
    return curr;
  };

  // Toggle strict mode. Re-reads the next number or string to please
  // pedantic tests (`"use strict"; 010;` should fail).

  Tokenizer.prototype.setStrict = function setStrict(strict) {
    this.state.strict = strict;
    if (!this.match(types.num) && !this.match(types.string)) return;
    this.state.pos = this.state.start;
    while (this.state.pos < this.state.lineStart) {
      this.state.lineStart = this.input.lastIndexOf("\n", this.state.lineStart - 2) + 1;
      --this.state.curLine;
    }
    this.nextToken();
  };

  Tokenizer.prototype.curContext = function curContext() {
    return this.state.context[this.state.context.length - 1];
  };

  // Read a single token, updating the parser object's token-related
  // properties.

  Tokenizer.prototype.nextToken = function nextToken() {
    var curContext = this.curContext();
    if (!curContext || !curContext.preserveSpace) this.skipSpace();

    this.state.containsOctal = false;
    this.state.octalPosition = null;
    this.state.start = this.state.pos;
    this.state.startLoc = this.state.curPosition();
    if (this.state.pos >= this.input.length) return this.finishToken(types.eof);

    if (curContext.override) {
      return curContext.override(this);
    } else {
      return this.readToken(this.fullCharCodeAtPos());
    }
  };

  Tokenizer.prototype.readToken = function readToken(code) {
    // Identifier or keyword. '\uXXXX' sequences are allowed in
    // identifiers, so '\' also dispatches to that.
    if (isIdentifierStart(code) || code === 92 /* '\' */) {
        return this.readWord();
      } else {
      return this.getTokenFromCode(code);
    }
  };

  Tokenizer.prototype.fullCharCodeAtPos = function fullCharCodeAtPos() {
    var code = this.input.charCodeAt(this.state.pos);
    if (code <= 0xd7ff || code >= 0xe000) return code;

    var next = this.input.charCodeAt(this.state.pos + 1);
    return (code << 10) + next - 0x35fdc00;
  };

  Tokenizer.prototype.pushComment = function pushComment(block, text, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "CommentBlock" : "CommentLine",
      value: text,
      start: start,
      end: end,
      loc: new SourceLocation(startLoc, endLoc)
    };

    if (!this.isLookahead) {
      this.state.tokens.push(comment);
      this.state.comments.push(comment);
      this.addComment(comment);
    }
  };

  Tokenizer.prototype.skipBlockComment = function skipBlockComment() {
    var startLoc = this.state.curPosition();
    var start = this.state.pos;
    var end = this.input.indexOf("*/", this.state.pos += 2);
    if (end === -1) this.raise(this.state.pos - 2, "Unterminated comment");

    this.state.pos = end + 2;
    lineBreakG.lastIndex = start;
    var match = void 0;
    while ((match = lineBreakG.exec(this.input)) && match.index < this.state.pos) {
      ++this.state.curLine;
      this.state.lineStart = match.index + match[0].length;
    }

    this.pushComment(true, this.input.slice(start + 2, end), start, this.state.pos, startLoc, this.state.curPosition());
  };

  Tokenizer.prototype.skipLineComment = function skipLineComment(startSkip) {
    var start = this.state.pos;
    var startLoc = this.state.curPosition();
    var ch = this.input.charCodeAt(this.state.pos += startSkip);
    while (this.state.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {
      ++this.state.pos;
      ch = this.input.charCodeAt(this.state.pos);
    }

    this.pushComment(false, this.input.slice(start + startSkip, this.state.pos), start, this.state.pos, startLoc, this.state.curPosition());
  };

  // Called at the start of the parse and after every token. Skips
  // whitespace and comments, and.

  Tokenizer.prototype.skipSpace = function skipSpace() {
    loop: while (this.state.pos < this.input.length) {
      var ch = this.input.charCodeAt(this.state.pos);
      switch (ch) {
        case 32:case 160:
          // ' '
          ++this.state.pos;
          break;

        case 13:
          if (this.input.charCodeAt(this.state.pos + 1) === 10) {
            ++this.state.pos;
          }

        case 10:case 8232:case 8233:
          ++this.state.pos;
          ++this.state.curLine;
          this.state.lineStart = this.state.pos;
          break;

        case 47:
          // '/'
          switch (this.input.charCodeAt(this.state.pos + 1)) {
            case 42:
              // '*'
              this.skipBlockComment();
              break;

            case 47:
              this.skipLineComment(2);
              break;

            default:
              break loop;
          }
          break;

        default:
          if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
            ++this.state.pos;
          } else {
            break loop;
          }
      }
    }
  };

  // Called at the end of every token. Sets `end`, `val`, and
  // maintains `context` and `exprAllowed`, and skips the space after
  // the token, so that the next one's `start` will point at the
  // right position.

  Tokenizer.prototype.finishToken = function finishToken(type, val) {
    this.state.end = this.state.pos;
    this.state.endLoc = this.state.curPosition();
    var prevType = this.state.type;
    this.state.type = type;
    this.state.value = val;

    this.updateContext(prevType);
  };

  // ### Token reading

  // This is the function that is called to fetch the next token. It
  // is somewhat obscure, because it works in character codes rather
  // than characters, and because operator parsing has been inlined
  // into it.
  //
  // All in the name of speed.
  //


  Tokenizer.prototype.readToken_dot = function readToken_dot() {
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next >= 48 && next <= 57) {
      return this.readNumber(true);
    }

    var next2 = this.input.charCodeAt(this.state.pos + 2);
    if (next === 46 && next2 === 46) {
      // 46 = dot '.'
      this.state.pos += 3;
      return this.finishToken(types.ellipsis);
    } else {
      ++this.state.pos;
      return this.finishToken(types.dot);
    }
  };

  Tokenizer.prototype.readToken_slash = function readToken_slash() {
    // '/'
    if (this.state.exprAllowed) {
      ++this.state.pos;
      return this.readRegexp();
    }

    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.slash, 1);
    }
  };

  Tokenizer.prototype.readToken_mult_modulo = function readToken_mult_modulo(code) {
    // '%*'
    var type = code === 42 ? types.star : types.modulo;
    var width = 1;
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === 42) {
      // '*'
      width++;
      next = this.input.charCodeAt(this.state.pos + 2);
      type = types.exponent;
    }

    if (next === 61) {
      width++;
      type = types.assign;
    }

    return this.finishOp(type, width);
  };

  Tokenizer.prototype.readToken_pipe_amp = function readToken_pipe_amp(code) {
    // '|&'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === code) return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);
    if (next === 61) return this.finishOp(types.assign, 2);
    if (code === 124 && next === 125 && this.hasPlugin("flow")) return this.finishOp(types.braceBarR, 2);
    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);
  };

  Tokenizer.prototype.readToken_caret = function readToken_caret() {
    // '^'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.bitwiseXOR, 1);
    }
  };

  Tokenizer.prototype.readToken_plus_min = function readToken_plus_min(code) {
    // '+-'
    var next = this.input.charCodeAt(this.state.pos + 1);

    if (next === code) {
      if (next === 45 && this.input.charCodeAt(this.state.pos + 2) === 62 && lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.pos))) {
        // A `-->` line comment
        this.skipLineComment(3);
        this.skipSpace();
        return this.nextToken();
      }
      return this.finishOp(types.incDec, 2);
    }

    if (next === 61) {
      return this.finishOp(types.assign, 2);
    } else {
      return this.finishOp(types.plusMin, 1);
    }
  };

  Tokenizer.prototype.readToken_lt_gt = function readToken_lt_gt(code) {
    // '<>'
    var next = this.input.charCodeAt(this.state.pos + 1);
    var size = 1;

    if (next === code) {
      size = code === 62 && this.input.charCodeAt(this.state.pos + 2) === 62 ? 3 : 2;
      if (this.input.charCodeAt(this.state.pos + size) === 61) return this.finishOp(types.assign, size + 1);
      return this.finishOp(types.bitShift, size);
    }

    if (next === 33 && code === 60 && this.input.charCodeAt(this.state.pos + 2) === 45 && this.input.charCodeAt(this.state.pos + 3) === 45) {
      if (this.inModule) this.unexpected();
      // `<!--`, an XML-style comment that should be interpreted as a line comment
      this.skipLineComment(4);
      this.skipSpace();
      return this.nextToken();
    }

    if (next === 61) {
      // <= | >=
      size = 2;
    }

    return this.finishOp(types.relational, size);
  };

  Tokenizer.prototype.readToken_eq_excl = function readToken_eq_excl(code) {
    // '=!'
    var next = this.input.charCodeAt(this.state.pos + 1);
    if (next === 61) return this.finishOp(types.equality, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
    if (code === 61 && next === 62) {
      // '=>'
      this.state.pos += 2;
      return this.finishToken(types.arrow);
    }
    return this.finishOp(code === 61 ? types.eq : types.prefix, 1);
  };

  Tokenizer.prototype.getTokenFromCode = function getTokenFromCode(code) {
    switch (code) {
      // The interpretation of a dot depends on whether it is followed
      // by a digit or another two dots.
      case 46:
        // '.'
        return this.readToken_dot();

      // Punctuation tokens.
      case 40:
        ++this.state.pos;return this.finishToken(types.parenL);
      case 41:
        ++this.state.pos;return this.finishToken(types.parenR);
      case 59:
        ++this.state.pos;return this.finishToken(types.semi);
      case 44:
        ++this.state.pos;return this.finishToken(types.comma);
      case 91:
        ++this.state.pos;return this.finishToken(types.bracketL);
      case 93:
        ++this.state.pos;return this.finishToken(types.bracketR);

      case 123:
        if (this.hasPlugin("flow") && this.input.charCodeAt(this.state.pos + 1) === 124) {
          return this.finishOp(types.braceBarL, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.braceL);
        }

      case 125:
        ++this.state.pos;return this.finishToken(types.braceR);

      case 58:
        if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
          return this.finishOp(types.doubleColon, 2);
        } else {
          ++this.state.pos;
          return this.finishToken(types.colon);
        }

      case 63:
        ++this.state.pos;return this.finishToken(types.question);
      case 64:
        ++this.state.pos;return this.finishToken(types.at);

      case 96:
        // '`'
        ++this.state.pos;
        return this.finishToken(types.backQuote);

      case 48:
        // '0'
        var next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 120 || next === 88) return this.readRadixNumber(16); // '0x', '0X' - hex number
        if (next === 111 || next === 79) return this.readRadixNumber(8); // '0o', '0O' - octal number
        if (next === 98 || next === 66) return this.readRadixNumber(2); // '0b', '0B' - binary number
      // Anything else beginning with a digit is an integer, octal
      // number, or float.
      case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
        // 1-9
        return this.readNumber(false);

      // Quotes produce strings.
      case 34:case 39:
        // '"', "'"
        return this.readString(code);

      // Operators are parsed inline in tiny state machines. '=' (61) is
      // often referred to. `finishOp` simply skips the amount of
      // characters it is given as second argument, and returns a token
      // of the type given by its first argument.

      case 47:
        // '/'
        return this.readToken_slash();

      case 37:case 42:
        // '%*'
        return this.readToken_mult_modulo(code);

      case 124:case 38:
        // '|&'
        return this.readToken_pipe_amp(code);

      case 94:
        // '^'
        return this.readToken_caret();

      case 43:case 45:
        // '+-'
        return this.readToken_plus_min(code);

      case 60:case 62:
        // '<>'
        return this.readToken_lt_gt(code);

      case 61:case 33:
        // '=!'
        return this.readToken_eq_excl(code);

      case 126:
        // '~'
        return this.finishOp(types.prefix, 1);
    }

    this.raise(this.state.pos, "Unexpected character '" + codePointToString(code) + "'");
  };

  Tokenizer.prototype.finishOp = function finishOp(type, size) {
    var str = this.input.slice(this.state.pos, this.state.pos + size);
    this.state.pos += size;
    return this.finishToken(type, str);
  };

  Tokenizer.prototype.readRegexp = function readRegexp() {
    var start = this.state.pos;
    var escaped = void 0,
        inClass = void 0;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(start, "Unterminated regular expression");
      var ch = this.input.charAt(this.state.pos);
      if (lineBreak.test(ch)) {
        this.raise(start, "Unterminated regular expression");
      }
      if (escaped) {
        escaped = false;
      } else {
        if (ch === "[") {
          inClass = true;
        } else if (ch === "]" && inClass) {
          inClass = false;
        } else if (ch === "/" && !inClass) {
          break;
        }
        escaped = ch === "\\";
      }
      ++this.state.pos;
    }
    var content = this.input.slice(start, this.state.pos);
    ++this.state.pos;
    // Need to use `readWord1` because '\uXXXX' sequences are allowed
    // here (don't ask).
    var mods = this.readWord1();
    if (mods) {
      var validFlags = /^[gmsiyu]*$/;
      if (!validFlags.test(mods)) this.raise(start, "Invalid regular expression flag");
    }
    return this.finishToken(types.regexp, {
      pattern: content,
      flags: mods
    });
  };

  // Read an integer in the given radix. Return null if zero digits
  // were read, the integer value otherwise. When `len` is given, this
  // will return `null` unless the integer has exactly `len` digits.

  Tokenizer.prototype.readInt = function readInt(radix, len) {
    var start = this.state.pos;
    var total = 0;

    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {
      var code = this.input.charCodeAt(this.state.pos);
      var val = void 0;
      if (code >= 97) {
        val = code - 97 + 10; // a
      } else if (code >= 65) {
        val = code - 65 + 10; // A
      } else if (code >= 48 && code <= 57) {
        val = code - 48; // 0-9
      } else {
        val = Infinity;
      }
      if (val >= radix) break;
      ++this.state.pos;
      total = total * radix + val;
    }
    if (this.state.pos === start || len != null && this.state.pos - start !== len) return null;

    return total;
  };

  Tokenizer.prototype.readRadixNumber = function readRadixNumber(radix) {
    this.state.pos += 2; // 0x
    var val = this.readInt(radix);
    if (val == null) this.raise(this.state.start + 2, "Expected number in radix " + radix);
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");
    return this.finishToken(types.num, val);
  };

  // Read an integer, octal integer, or floating-point number.

  Tokenizer.prototype.readNumber = function readNumber(startsWithDot) {
    var start = this.state.pos;
    var firstIsZero = this.input.charCodeAt(start) === 48; // '0'
    var isFloat = false;

    if (!startsWithDot && this.readInt(10) === null) this.raise(start, "Invalid number");
    var next = this.input.charCodeAt(this.state.pos);
    if (next === 46) {
      // '.'
      ++this.state.pos;
      this.readInt(10);
      isFloat = true;
      next = this.input.charCodeAt(this.state.pos);
    }
    if (next === 69 || next === 101) {
      // 'eE'
      next = this.input.charCodeAt(++this.state.pos);
      if (next === 43 || next === 45) ++this.state.pos; // '+-'
      if (this.readInt(10) === null) this.raise(start, "Invalid number");
      isFloat = true;
    }
    if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.state.pos, "Identifier directly after number");

    var str = this.input.slice(start, this.state.pos);
    var val = void 0;
    if (isFloat) {
      val = parseFloat(str);
    } else if (!firstIsZero || str.length === 1) {
      val = parseInt(str, 10);
    } else if (this.state.strict) {
      this.raise(start, "Invalid number");
    } else if (/[89]/.test(str)) {
      val = parseInt(str, 10);
    } else {
      val = parseInt(str, 8);
    }
    return this.finishToken(types.num, val);
  };

  // Read a string value, interpreting backslash-escapes.

  Tokenizer.prototype.readCodePoint = function readCodePoint(throwOnInvalid) {
    var ch = this.input.charCodeAt(this.state.pos);
    var code = void 0;

    if (ch === 123) {
      // '{'
      var codePos = ++this.state.pos;
      code = this.readHexChar(this.input.indexOf("}", this.state.pos) - this.state.pos, throwOnInvalid);
      ++this.state.pos;
      if (code === null) {
        --this.state.invalidTemplateEscapePosition; // to point to the '\'' instead of the 'u'
      } else if (code > 0x10FFFF) {
        if (throwOnInvalid) {
          this.raise(codePos, "Code point out of bounds");
        } else {
          this.state.invalidTemplateEscapePosition = codePos - 2;
          return null;
        }
      }
    } else {
      code = this.readHexChar(4, throwOnInvalid);
    }
    return code;
  };

  Tokenizer.prototype.readString = function readString(quote) {
    var out = "",
        chunkStart = ++this.state.pos;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated string constant");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === quote) break;
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.readEscapedChar(false);
        chunkStart = this.state.pos;
      } else {
        if (isNewLine(ch)) this.raise(this.state.start, "Unterminated string constant");
        ++this.state.pos;
      }
    }
    out += this.input.slice(chunkStart, this.state.pos++);
    return this.finishToken(types.string, out);
  };

  // Reads template string tokens.

  Tokenizer.prototype.readTmplToken = function readTmplToken() {
    var out = "",
        chunkStart = this.state.pos,
        containsInvalid = false;
    for (;;) {
      if (this.state.pos >= this.input.length) this.raise(this.state.start, "Unterminated template");
      var ch = this.input.charCodeAt(this.state.pos);
      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.state.pos + 1) === 123) {
        // '`', '${'
        if (this.state.pos === this.state.start && this.match(types.template)) {
          if (ch === 36) {
            this.state.pos += 2;
            return this.finishToken(types.dollarBraceL);
          } else {
            ++this.state.pos;
            return this.finishToken(types.backQuote);
          }
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.template, containsInvalid ? null : out);
      }
      if (ch === 92) {
        // '\'
        out += this.input.slice(chunkStart, this.state.pos);
        var escaped = this.readEscapedChar(true);
        if (escaped === null) {
          containsInvalid = true;
        } else {
          out += escaped;
        }
        chunkStart = this.state.pos;
      } else if (isNewLine(ch)) {
        out += this.input.slice(chunkStart, this.state.pos);
        ++this.state.pos;
        switch (ch) {
          case 13:
            if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos;
          case 10:
            out += "\n";
            break;
          default:
            out += String.fromCharCode(ch);
            break;
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        chunkStart = this.state.pos;
      } else {
        ++this.state.pos;
      }
    }
  };

  // Used to read escaped characters

  Tokenizer.prototype.readEscapedChar = function readEscapedChar(inTemplate) {
    var throwOnInvalid = !inTemplate;
    var ch = this.input.charCodeAt(++this.state.pos);
    ++this.state.pos;
    switch (ch) {
      case 110:
        return "\n"; // 'n' -> '\n'
      case 114:
        return "\r"; // 'r' -> '\r'
      case 120:
        {
          // 'x'
          var code = this.readHexChar(2, throwOnInvalid);
          return code === null ? null : String.fromCharCode(code);
        }
      case 117:
        {
          // 'u'
          var _code = this.readCodePoint(throwOnInvalid);
          return _code === null ? null : codePointToString(_code);
        }
      case 116:
        return "\t"; // 't' -> '\t'
      case 98:
        return "\b"; // 'b' -> '\b'
      case 118:
        return "\x0B"; // 'v' -> '\u000b'
      case 102:
        return "\f"; // 'f' -> '\f'
      case 13:
        if (this.input.charCodeAt(this.state.pos) === 10) ++this.state.pos; // '\r\n'
      case 10:
        // ' \n'
        this.state.lineStart = this.state.pos;
        ++this.state.curLine;
        return "";
      default:
        if (ch >= 48 && ch <= 55) {
          var codePos = this.state.pos - 1;
          var octalStr = this.input.substr(this.state.pos - 1, 3).match(/^[0-7]+/)[0];
          var octal = parseInt(octalStr, 8);
          if (octal > 255) {
            octalStr = octalStr.slice(0, -1);
            octal = parseInt(octalStr, 8);
          }
          if (octal > 0) {
            if (inTemplate) {
              this.state.invalidTemplateEscapePosition = codePos;
              return null;
            } else if (this.state.strict) {
              this.raise(codePos, "Octal literal in strict mode");
            } else if (!this.state.containsOctal) {
              // These properties are only used to throw an error for an octal which occurs
              // in a directive which occurs prior to a "use strict" directive.
              this.state.containsOctal = true;
              this.state.octalPosition = codePos;
            }
          }
          this.state.pos += octalStr.length - 1;
          return String.fromCharCode(octal);
        }
        return String.fromCharCode(ch);
    }
  };

  // Used to read character escape sequences ('\x', '\u').

  Tokenizer.prototype.readHexChar = function readHexChar(len, throwOnInvalid) {
    var codePos = this.state.pos;
    var n = this.readInt(16, len);
    if (n === null) {
      if (throwOnInvalid) {
        this.raise(codePos, "Bad character escape sequence");
      } else {
        this.state.pos = codePos - 1;
        this.state.invalidTemplateEscapePosition = codePos - 1;
      }
    }
    return n;
  };

  // Read an identifier, and return it as a string. Sets `this.state.containsEsc`
  // to whether the word contained a '\u' escape.
  //
  // Incrementally adds only escaped chars, adding other chunks as-is
  // as a micro-optimization.

  Tokenizer.prototype.readWord1 = function readWord1() {
    this.state.containsEsc = false;
    var word = "",
        first = true,
        chunkStart = this.state.pos;
    while (this.state.pos < this.input.length) {
      var ch = this.fullCharCodeAtPos();
      if (isIdentifierChar(ch)) {
        this.state.pos += ch <= 0xffff ? 1 : 2;
      } else if (ch === 92) {
        // "\"
        this.state.containsEsc = true;

        word += this.input.slice(chunkStart, this.state.pos);
        var escStart = this.state.pos;

        if (this.input.charCodeAt(++this.state.pos) !== 117) {
          // "u"
          this.raise(this.state.pos, "Expecting Unicode escape sequence \\uXXXX");
        }

        ++this.state.pos;
        var esc = this.readCodePoint(true);
        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, true)) {
          this.raise(escStart, "Invalid Unicode escape");
        }

        word += codePointToString(esc);
        chunkStart = this.state.pos;
      } else {
        break;
      }
      first = false;
    }
    return word + this.input.slice(chunkStart, this.state.pos);
  };

  // Read an identifier or keyword token. Will check for reserved
  // words when necessary.

  Tokenizer.prototype.readWord = function readWord() {
    var word = this.readWord1();
    var type = types.name;
    if (!this.state.containsEsc && this.isKeyword(word)) {
      type = keywords[word];
    }
    return this.finishToken(type, word);
  };

  Tokenizer.prototype.braceIsBlock = function braceIsBlock(prevType) {
    if (prevType === types.colon) {
      var parent = this.curContext();
      if (parent === types$1.braceStatement || parent === types$1.braceExpression) {
        return !parent.isExpr;
      }
    }

    if (prevType === types._return) {
      return lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
    }

    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR) {
      return true;
    }

    if (prevType === types.braceL) {
      return this.curContext() === types$1.braceStatement;
    }

    return !this.state.exprAllowed;
  };

  Tokenizer.prototype.updateContext = function updateContext(prevType) {
    var type = this.state.type;
    var update = void 0;

    if (type.keyword && prevType === types.dot) {
      this.state.exprAllowed = false;
    } else if (update = type.updateContext) {
      update.call(this, prevType);
    } else {
      this.state.exprAllowed = type.beforeExpr;
    }
  };

  return Tokenizer;
}();

var plugins = {};

var Parser = function (_Tokenizer) {
  inherits(Parser, _Tokenizer);

  function Parser(options, input) {
    classCallCheck(this, Parser);

    options = getOptions(options);

    var _this = possibleConstructorReturn(this, _Tokenizer.call(this, options, input));

    _this.options = options;
    _this.inModule = _this.options.sourceType === "module";
    _this.input = input;
    _this.plugins = _this.loadPlugins(_this.options.plugins);
    _this.filename = options.sourceFilename;

    // If enabled, skip leading hashbang line.
    if (_this.state.pos === 0 && _this.input[0] === "#" && _this.input[1] === "!") {
      _this.skipLineComment(2);
    }
    return _this;
  }

  Parser.prototype.isReservedWord = function isReservedWord(word) {
    if (word === "await") {
      return this.inModule;
    } else {
      return reservedWords[6](word);
    }
  };

  Parser.prototype.hasPlugin = function hasPlugin(name) {
    return !!this.plugins[name];
  };

  Parser.prototype.extend = function extend(name, f) {
    this[name] = f(this[name]);
  };

  Parser.prototype.loadPlugins = function loadPlugins(pluginList) {
    var pluginMap = {};

    if (pluginList.indexOf("flow") >= 0) {
      // ensure flow plugin loads last
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "flow";
      });
      pluginList.push("flow");
    }

    if (pluginList.indexOf("estree") >= 0) {
      // ensure estree plugin loads first
      pluginList = pluginList.filter(function (plugin) {
        return plugin !== "estree";
      });
      pluginList.unshift("estree");
    }

    for (var _iterator = pluginList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var name = _ref;

      if (!pluginMap[name]) {
        pluginMap[name] = true;

        var plugin = plugins[name];
        if (plugin) plugin(this);
      }
    }

    return pluginMap;
  };

  Parser.prototype.parse = function parse() {
    var file = this.startNode();
    var program = this.startNode();
    this.nextToken();
    return this.parseTopLevel(file, program);
  };

  return Parser;
}(Tokenizer);

var pp = Parser.prototype;

// ## Parser utilities

// TODO

pp.addExtra = function (node, key, val) {
  if (!node) return;

  var extra = node.extra = node.extra || {};
  extra[key] = val;
};

// TODO

pp.isRelational = function (op) {
  return this.match(types.relational) && this.state.value === op;
};

// TODO

pp.expectRelational = function (op) {
  if (this.isRelational(op)) {
    this.next();
  } else {
    this.unexpected(null, types.relational);
  }
};

// Tests whether parsed token is a contextual keyword.

pp.isContextual = function (name) {
  return this.match(types.name) && this.state.value === name;
};

// Consumes contextual keyword if possible.

pp.eatContextual = function (name) {
  return this.state.value === name && this.eat(types.name);
};

// Asserts that following token is given contextual keyword.

pp.expectContextual = function (name, message) {
  if (!this.eatContextual(name)) this.unexpected(null, message);
};

// Test whether a semicolon can be inserted at the current position.

pp.canInsertSemicolon = function () {
  return this.match(types.eof) || this.match(types.braceR) || lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start));
};

// TODO

pp.isLineTerminator = function () {
  return this.eat(types.semi) || this.canInsertSemicolon();
};

// Consume a semicolon, or, failing that, see if we are allowed to
// pretend that there is a semicolon at this position.

pp.semicolon = function () {
  if (!this.isLineTerminator()) this.unexpected(null, types.semi);
};

// Expect a token of a given type. If found, consume it, otherwise,
// raise an unexpected token error at given pos.

pp.expect = function (type, pos) {
  return this.eat(type) || this.unexpected(pos, type);
};

// Raise an unexpected token error. Can take the expected token type
// instead of a message string.

pp.unexpected = function (pos) {
  var messageOrType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "Unexpected token";

  if (messageOrType && (typeof messageOrType === "undefined" ? "undefined" : _typeof(messageOrType)) === "object" && messageOrType.label) {
    messageOrType = "Unexpected token, expected " + messageOrType.label;
  }
  this.raise(pos != null ? pos : this.state.start, messageOrType);
};

/* eslint max-len: 0 */

var pp$1 = Parser.prototype;

// ### Statement parsing

// Parse a program. Initializes the parser, reads any number of
// statements, and wraps them in a Program node.  Optionally takes a
// `program` argument.  If present, the statements will be appended
// to its body instead of creating a new node.

pp$1.parseTopLevel = function (file, program) {
  program.sourceType = this.options.sourceType;

  this.parseBlockBody(program, true, true, types.eof);

  file.program = this.finishNode(program, "Program");
  file.comments = this.state.comments;
  file.tokens = this.state.tokens;

  return this.finishNode(file, "File");
};

var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };

// TODO

pp$1.stmtToDirective = function (stmt) {
  var expr = stmt.expression;

  var directiveLiteral = this.startNodeAt(expr.start, expr.loc.start);
  var directive = this.startNodeAt(stmt.start, stmt.loc.start);

  var raw = this.input.slice(expr.start, expr.end);
  var val = directiveLiteral.value = raw.slice(1, -1); // remove quotes

  this.addExtra(directiveLiteral, "raw", raw);
  this.addExtra(directiveLiteral, "rawValue", val);

  directive.value = this.finishNodeAt(directiveLiteral, "DirectiveLiteral", expr.end, expr.loc.end);

  return this.finishNodeAt(directive, "Directive", stmt.end, stmt.loc.end);
};

// Parse a single statement.
//
// If expecting a statement and finding a slash operator, parse a
// regular expression literal. This is to handle cases like
// `if (foo) /blah/.exec(foo)`, where looking at the previous token
// does not help.

pp$1.parseStatement = function (declaration, topLevel) {
  if (this.match(types.at)) {
    this.parseDecorators(true);
  }

  var starttype = this.state.type;
  var node = this.startNode();

  // Most types of statements are recognized by the keyword they
  // start with. Many are trivial to parse, some require a bit of
  // complexity.

  switch (starttype) {
    case types._break:case types._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types._debugger:
      return this.parseDebuggerStatement(node);
    case types._do:
      return this.parseDoStatement(node);
    case types._for:
      return this.parseForStatement(node);
    case types._function:
      if (!declaration) this.unexpected();
      return this.parseFunctionStatement(node);

    case types._class:
      if (!declaration) this.unexpected();
      return this.parseClass(node, true);

    case types._if:
      return this.parseIfStatement(node);
    case types._return:
      return this.parseReturnStatement(node);
    case types._switch:
      return this.parseSwitchStatement(node);
    case types._throw:
      return this.parseThrowStatement(node);
    case types._try:
      return this.parseTryStatement(node);

    case types._let:
    case types._const:
      if (!declaration) this.unexpected(); // NOTE: falls through to _var

    case types._var:
      return this.parseVarStatement(node, starttype);

    case types._while:
      return this.parseWhileStatement(node);
    case types._with:
      return this.parseWithStatement(node);
    case types.braceL:
      return this.parseBlock();
    case types.semi:
      return this.parseEmptyStatement(node);
    case types._export:
    case types._import:
      if (this.hasPlugin("dynamicImport") && this.lookahead().type === types.parenL) break;

      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.state.start, "'import' and 'export' may only appear at the top level");
        }

        if (!this.inModule) {
          this.raise(this.state.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types._import ? this.parseImport(node) : this.parseExport(node);

    case types.name:
      if (this.state.value === "async") {
        // peek ahead and see if next token is a function
        var state = this.state.clone();
        this.next();
        if (this.match(types._function) && !this.canInsertSemicolon()) {
          this.expect(types._function);
          return this.parseFunction(node, true, false, true);
        } else {
          this.state = state;
        }
      }
  }

  // If the statement does not start with a statement keyword or a
  // brace, it's an ExpressionStatement or LabeledStatement. We
  // simply start parsing an expression, and afterwards, if the
  // next token is a colon and the expression was a simple
  // Identifier node, we switch to interpreting it as a label.
  var maybeName = this.state.value;
  var expr = this.parseExpression();

  if (starttype === types.name && expr.type === "Identifier" && this.eat(types.colon)) {
    return this.parseLabeledStatement(node, maybeName, expr);
  } else {
    return this.parseExpressionStatement(node, expr);
  }
};

pp$1.takeDecorators = function (node) {
  if (this.state.decorators.length) {
    node.decorators = this.state.decorators;
    this.state.decorators = [];
  }
};

pp$1.parseDecorators = function (allowExport) {
  while (this.match(types.at)) {
    var decorator = this.parseDecorator();
    this.state.decorators.push(decorator);
  }

  if (allowExport && this.match(types._export)) {
    return;
  }

  if (!this.match(types._class)) {
    this.raise(this.state.start, "Leading decorators must be attached to a class declaration");
  }
};

pp$1.parseDecorator = function () {
  if (!this.hasPlugin("decorators")) {
    this.unexpected();
  }
  var node = this.startNode();
  this.next();
  node.expression = this.parseMaybeAssign();
  return this.finishNode(node, "Decorator");
};

pp$1.parseBreakContinueStatement = function (node, keyword) {
  var isBreak = keyword === "break";
  this.next();

  if (this.isLineTerminator()) {
    node.label = null;
  } else if (!this.match(types.name)) {
    this.unexpected();
  } else {
    node.label = this.parseIdentifier();
    this.semicolon();
  }

  // Verify that there is an actual destination to break or
  // continue to.
  var i = void 0;
  for (i = 0; i < this.state.labels.length; ++i) {
    var lab = this.state.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) break;
      if (node.label && isBreak) break;
    }
  }
  if (i === this.state.labels.length) this.raise(node.start, "Unsyntactic " + keyword);
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};

pp$1.parseDebuggerStatement = function (node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};

pp$1.parseDoStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  this.expect(types._while);
  node.test = this.parseParenExpression();
  this.eat(types.semi);
  return this.finishNode(node, "DoWhileStatement");
};

// Disambiguating between a `for` and a `for`/`in` or `for`/`of`
// loop is non-trivial. Basically, we have to parse the init `var`
// statement or expression, disallowing the `in` operator (see
// the second parameter to `parseExpression`), and then check
// whether the next token is `in` or `of`. When there is no init
// part (semicolon immediately after the opening parenthesis), it
// is a regular `for` loop.

pp$1.parseForStatement = function (node) {
  this.next();
  this.state.labels.push(loopLabel);

  var forAwait = false;
  if (this.hasPlugin("asyncGenerators") && this.state.inAsync && this.isContextual("await")) {
    forAwait = true;
    this.next();
  }
  this.expect(types.parenL);

  if (this.match(types.semi)) {
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, null);
  }

  if (this.match(types._var) || this.match(types._let) || this.match(types._const)) {
    var _init = this.startNode();
    var varKind = this.state.type;
    this.next();
    this.parseVar(_init, true, varKind);
    this.finishNode(_init, "VariableDeclaration");

    if (this.match(types._in) || this.isContextual("of")) {
      if (_init.declarations.length === 1 && !_init.declarations[0].init) {
        return this.parseForIn(node, _init, forAwait);
      }
    }
    if (forAwait) {
      this.unexpected();
    }
    return this.parseFor(node, _init);
  }

  var refShorthandDefaultPos = { start: 0 };
  var init = this.parseExpression(true, refShorthandDefaultPos);
  if (this.match(types._in) || this.isContextual("of")) {
    var description = this.isContextual("of") ? "for-of statement" : "for-in statement";
    this.toAssignable(init, undefined, description);
    this.checkLVal(init, undefined, undefined, description);
    return this.parseForIn(node, init, forAwait);
  } else if (refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }
  if (forAwait) {
    this.unexpected();
  }
  return this.parseFor(node, init);
};

pp$1.parseFunctionStatement = function (node) {
  this.next();
  return this.parseFunction(node, true);
};

pp$1.parseIfStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement(false);
  node.alternate = this.eat(types._else) ? this.parseStatement(false) : null;
  return this.finishNode(node, "IfStatement");
};

pp$1.parseReturnStatement = function (node) {
  if (!this.state.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.state.start, "'return' outside of function");
  }

  this.next();

  // In `return` (and `break`/`continue`), the keywords with
  // optional arguments, we eagerly look for a semicolon or the
  // possibility to insert one.

  if (this.isLineTerminator()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }

  return this.finishNode(node, "ReturnStatement");
};

pp$1.parseSwitchStatement = function (node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types.braceL);
  this.state.labels.push(switchLabel);

  // Statements under must be grouped (by label) in SwitchCase
  // nodes. `cur` is used to keep the node that we are currently
  // adding statements to.

  var cur = void 0;
  for (var sawDefault; !this.match(types.braceR);) {
    if (this.match(types._case) || this.match(types._default)) {
      var isCase = this.match(types._case);
      if (cur) this.finishNode(cur, "SwitchCase");
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) this.raise(this.state.lastTokStart, "Multiple default clauses");
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types.colon);
    } else {
      if (cur) {
        cur.consequent.push(this.parseStatement(true));
      } else {
        this.unexpected();
      }
    }
  }
  if (cur) this.finishNode(cur, "SwitchCase");
  this.next(); // Closing brace
  this.state.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};

pp$1.parseThrowStatement = function (node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.state.lastTokEnd, this.state.start))) this.raise(this.state.lastTokEnd, "Illegal newline after throw");
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};

// Reused empty array added for node fields that are always empty.

var empty = [];

pp$1.parseTryStatement = function (node) {
  this.next();

  node.block = this.parseBlock();
  node.handler = null;

  if (this.match(types._catch)) {
    var clause = this.startNode();
    this.next();

    this.expect(types.parenL);
    clause.param = this.parseBindingAtom();
    this.checkLVal(clause.param, true, Object.create(null), "catch clause");
    this.expect(types.parenR);

    clause.body = this.parseBlock();
    node.handler = this.finishNode(clause, "CatchClause");
  }

  node.guardedHandlers = empty;
  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;

  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }

  return this.finishNode(node, "TryStatement");
};

pp$1.parseVarStatement = function (node, kind) {
  this.next();
  this.parseVar(node, false, kind);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};

pp$1.parseWhileStatement = function (node) {
  this.next();
  node.test = this.parseParenExpression();
  this.state.labels.push(loopLabel);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "WhileStatement");
};

pp$1.parseWithStatement = function (node) {
  if (this.state.strict) this.raise(this.state.start, "'with' in strict mode");
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement(false);
  return this.finishNode(node, "WithStatement");
};

pp$1.parseEmptyStatement = function (node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};

pp$1.parseLabeledStatement = function (node, maybeName, expr) {
  for (var _iterator = this.state.labels, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var _label = _ref;

    if (_label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }

  var kind = this.state.type.isLoop ? "loop" : this.match(types._switch) ? "switch" : null;
  for (var i = this.state.labels.length - 1; i >= 0; i--) {
    var label = this.state.labels[i];
    if (label.statementStart === node.start) {
      label.statementStart = this.state.start;
      label.kind = kind;
    } else {
      break;
    }
  }

  this.state.labels.push({ name: maybeName, kind: kind, statementStart: this.state.start });
  node.body = this.parseStatement(true);
  this.state.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};

pp$1.parseExpressionStatement = function (node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};

// Parse a semicolon-enclosed block of statements, handling `"use
// strict"` declarations when `allowStrict` is true (used for
// function bodies).

pp$1.parseBlock = function (allowDirectives) {
  var node = this.startNode();
  this.expect(types.braceL);
  this.parseBlockBody(node, allowDirectives, false, types.braceR);
  return this.finishNode(node, "BlockStatement");
};

pp$1.isValidDirective = function (stmt) {
  return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
};

pp$1.parseBlockBody = function (node, allowDirectives, topLevel, end) {
  node.body = [];
  node.directives = [];

  var parsedNonDirective = false;
  var oldStrict = void 0;
  var octalPosition = void 0;

  while (!this.eat(end)) {
    if (!parsedNonDirective && this.state.containsOctal && !octalPosition) {
      octalPosition = this.state.octalPosition;
    }

    var stmt = this.parseStatement(true, topLevel);

    if (allowDirectives && !parsedNonDirective && this.isValidDirective(stmt)) {
      var directive = this.stmtToDirective(stmt);
      node.directives.push(directive);

      if (oldStrict === undefined && directive.value.value === "use strict") {
        oldStrict = this.state.strict;
        this.setStrict(true);

        if (octalPosition) {
          this.raise(octalPosition, "Octal literal in strict mode");
        }
      }

      continue;
    }

    parsedNonDirective = true;
    node.body.push(stmt);
  }

  if (oldStrict === false) {
    this.setStrict(false);
  }
};

// Parse a regular `for` loop. The disambiguation code in
// `parseStatement` will already have parsed the init statement or
// expression.

pp$1.parseFor = function (node, init) {
  node.init = init;
  this.expect(types.semi);
  node.test = this.match(types.semi) ? null : this.parseExpression();
  this.expect(types.semi);
  node.update = this.match(types.parenR) ? null : this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, "ForStatement");
};

// Parse a `for`/`in` and `for`/`of` loop, which are almost
// same from parser's perspective.

pp$1.parseForIn = function (node, init, forAwait) {
  var type = this.match(types._in) ? "ForInStatement" : "ForOfStatement";
  if (forAwait) {
    this.eatContextual("of");
  } else {
    this.next();
  }
  node.await = !!forAwait;
  node.left = init;
  node.right = this.parseExpression();
  this.expect(types.parenR);
  node.body = this.parseStatement(false);
  this.state.labels.pop();
  return this.finishNode(node, type);
};

// Parse a list of variable declarations.

pp$1.parseVar = function (node, isFor, kind) {
  node.declarations = [];
  node.kind = kind.keyword;
  for (;;) {
    var decl = this.startNode();
    this.parseVarHead(decl);
    if (this.eat(types.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (kind === types._const && !(this.match(types._in) || this.isContextual("of"))) {
      this.unexpected();
    } else if (decl.id.type !== "Identifier" && !(isFor && (this.match(types._in) || this.isContextual("of")))) {
      this.raise(this.state.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types.comma)) break;
  }
  return node;
};

pp$1.parseVarHead = function (decl) {
  decl.id = this.parseBindingAtom();
  this.checkLVal(decl.id, true, undefined, "variable declaration");
};

// Parse a function declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync, optionalId) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = false;

  this.initFunction(node, isAsync);

  if (this.match(types.star)) {
    if (node.async && !this.hasPlugin("asyncGenerators")) {
      this.unexpected();
    } else {
      node.generator = true;
      this.next();
    }
  }

  if (isStatement && !optionalId && !this.match(types.name) && !this.match(types._yield)) {
    this.unexpected();
  }

  if (this.match(types.name) || this.match(types._yield)) {
    node.id = this.parseBindingIdentifier();
  }

  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody);

  this.state.inMethod = oldInMethod;

  return this.finishNode(node, isStatement ? "FunctionDeclaration" : "FunctionExpression");
};

pp$1.parseFunctionParams = function (node) {
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
};

// Parse a class declaration or literal (depending on the
// `isStatement` parameter).

pp$1.parseClass = function (node, isStatement, optionalId) {
  this.next();
  this.takeDecorators(node);
  this.parseClassId(node, isStatement, optionalId);
  this.parseClassSuper(node);
  this.parseClassBody(node);
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};

pp$1.isClassProperty = function () {
  return this.match(types.eq) || this.match(types.semi) || this.match(types.braceR);
};

pp$1.isClassMethod = function () {
  return this.match(types.parenL);
};

pp$1.isNonstaticConstructor = function (method) {
  return !method.computed && !method.static && (method.key.name === "constructor" || // Identifier
  method.key.value === "constructor" // Literal
  );
};

pp$1.parseClassBody = function (node) {
  // class bodies are implicitly strict
  var oldStrict = this.state.strict;
  this.state.strict = true;

  var hadConstructor = false;
  var decorators = [];
  var classBody = this.startNode();

  classBody.body = [];

  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (this.eat(types.semi)) {
      if (decorators.length > 0) {
        this.raise(this.state.lastTokEnd, "Decorators must not be followed by a semicolon");
      }
      continue;
    }

    if (this.match(types.at)) {
      decorators.push(this.parseDecorator());
      continue;
    }

    var method = this.startNode();

    // steal the decorators if there are any
    if (decorators.length) {
      method.decorators = decorators;
      decorators = [];
    }

    method.static = false;
    if (this.match(types.name) && this.state.value === "static") {
      var key = this.parseIdentifier(true); // eats 'static'
      if (this.isClassMethod()) {
        // a method named 'static'
        method.kind = "method";
        method.computed = false;
        method.key = key;
        this.parseClassMethod(classBody, method, false, false);
        continue;
      } else if (this.isClassProperty()) {
        // a property named 'static'
        method.computed = false;
        method.key = key;
        classBody.body.push(this.parseClassProperty(method));
        continue;
      }
      // otherwise something static
      method.static = true;
    }

    if (this.eat(types.star)) {
      // a generator
      method.kind = "method";
      this.parsePropertyName(method);
      if (this.isNonstaticConstructor(method)) {
        this.raise(method.key.start, "Constructor can't be a generator");
      }
      if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
        this.raise(method.key.start, "Classes may not have static property named prototype");
      }
      this.parseClassMethod(classBody, method, true, false);
    } else {
      var isSimple = this.match(types.name);
      var _key = this.parsePropertyName(method);
      if (!method.computed && method.static && (method.key.name === "prototype" || method.key.value === "prototype")) {
        this.raise(method.key.start, "Classes may not have static property named prototype");
      }
      if (this.isClassMethod()) {
        // a normal method
        if (this.isNonstaticConstructor(method)) {
          if (hadConstructor) {
            this.raise(_key.start, "Duplicate constructor in the same class");
          } else if (method.decorators) {
            this.raise(method.start, "You can't attach decorators to a class constructor");
          }
          hadConstructor = true;
          method.kind = "constructor";
        } else {
          method.kind = "method";
        }
        this.parseClassMethod(classBody, method, false, false);
      } else if (this.isClassProperty()) {
        // a normal property
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
        }
        classBody.body.push(this.parseClassProperty(method));
      } else if (isSimple && _key.name === "async" && !this.isLineTerminator()) {
        // an async method
        var isGenerator = this.hasPlugin("asyncGenerators") && this.eat(types.star);
        method.kind = "method";
        this.parsePropertyName(method);
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Constructor can't be an async function");
        }
        this.parseClassMethod(classBody, method, isGenerator, true);
      } else if (isSimple && (_key.name === "get" || _key.name === "set") && !(this.isLineTerminator() && this.match(types.star))) {
        // `get\n*` is an uninitialized property named 'get' followed by a generator.
        // a getter or setter
        method.kind = _key.name;
        this.parsePropertyName(method);
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Constructor can't have get/set modifier");
        }
        this.parseClassMethod(classBody, method, false, false);
        this.checkGetterSetterParamCount(method);
      } else if (this.isLineTerminator()) {
        // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)
        if (this.isNonstaticConstructor(method)) {
          this.raise(method.key.start, "Classes may not have a non-static field named 'constructor'");
        }
        classBody.body.push(this.parseClassProperty(method));
      } else {
        this.unexpected();
      }
    }
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no method");
  }

  node.body = this.finishNode(classBody, "ClassBody");

  this.state.strict = oldStrict;
};

pp$1.parseClassProperty = function (node) {
  var noPluginMsg = "You can only use Class Properties when the 'classProperties' plugin is enabled.";
  if (!node.typeAnnotation && !this.hasPlugin("classProperties")) {
    this.raise(node.start, noPluginMsg);
  }

  if (this.match(types.eq)) {
    if (!this.hasPlugin("classProperties")) this.raise(this.state.start, noPluginMsg);
    this.next();
    node.value = this.parseMaybeAssign();
  } else {
    node.value = null;
  }
  this.semicolon();
  return this.finishNode(node, "ClassProperty");
};

pp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {
  this.parseMethod(method, isGenerator, isAsync);
  classBody.body.push(this.finishNode(method, "ClassMethod"));
};

pp$1.parseClassId = function (node, isStatement, optionalId) {
  if (this.match(types.name)) {
    node.id = this.parseIdentifier();
  } else {
    if (optionalId || !isStatement) {
      node.id = null;
    } else {
      this.unexpected();
    }
  }
};

pp$1.parseClassSuper = function (node) {
  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;
};

// Parses module export declaration.

pp$1.parseExport = function (node) {
  this.next();
  // export * from '...'
  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    if (this.hasPlugin("exportExtensions") && this.eatContextual("as")) {
      specifier.exported = this.parseIdentifier();
      node.specifiers = [this.finishNode(specifier, "ExportNamespaceSpecifier")];
      this.parseExportSpecifiersMaybe(node);
      this.parseExportFrom(node, true);
    } else {
      this.parseExportFrom(node, true);
      return this.finishNode(node, "ExportAllDeclaration");
    }
  } else if (this.hasPlugin("exportExtensions") && this.isExportDefaultSpecifier()) {
    var _specifier = this.startNode();
    _specifier.exported = this.parseIdentifier(true);
    node.specifiers = [this.finishNode(_specifier, "ExportDefaultSpecifier")];
    if (this.match(types.comma) && this.lookahead().type === types.star) {
      this.expect(types.comma);
      var _specifier2 = this.startNode();
      this.expect(types.star);
      this.expectContextual("as");
      _specifier2.exported = this.parseIdentifier();
      node.specifiers.push(this.finishNode(_specifier2, "ExportNamespaceSpecifier"));
    } else {
      this.parseExportSpecifiersMaybe(node);
    }
    this.parseExportFrom(node, true);
  } else if (this.eat(types._default)) {
    // export default ...
    var expr = this.startNode();
    var needsSemi = false;
    if (this.eat(types._function)) {
      expr = this.parseFunction(expr, true, false, false, true);
    } else if (this.isContextual("async") && this.lookahead().type === types._function) {
      // async function declaration
      this.eatContextual("async");
      this.eat(types._function);
      expr = this.parseFunction(expr, true, false, true, true);
    } else if (this.match(types._class)) {
      expr = this.parseClass(expr, true, true);
    } else {
      needsSemi = true;
      expr = this.parseMaybeAssign();
    }
    node.declaration = expr;
    if (needsSemi) this.semicolon();
    this.checkExport(node, true, true);
    return this.finishNode(node, "ExportDefaultDeclaration");
  } else if (this.shouldParseExportDeclaration()) {
    node.specifiers = [];
    node.source = null;
    node.declaration = this.parseExportDeclaration(node);
  } else {
    // export { x, y as z } [from '...']
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers();
    this.parseExportFrom(node);
  }
  this.checkExport(node, true);
  return this.finishNode(node, "ExportNamedDeclaration");
};

pp$1.parseExportDeclaration = function () {
  return this.parseStatement(true);
};

pp$1.isExportDefaultSpecifier = function () {
  if (this.match(types.name)) {
    return this.state.value !== "type" && this.state.value !== "async" && this.state.value !== "interface";
  }

  if (!this.match(types._default)) {
    return false;
  }

  var lookahead = this.lookahead();
  return lookahead.type === types.comma || lookahead.type === types.name && lookahead.value === "from";
};

pp$1.parseExportSpecifiersMaybe = function (node) {
  if (this.eat(types.comma)) {
    node.specifiers = node.specifiers.concat(this.parseExportSpecifiers());
  }
};

pp$1.parseExportFrom = function (node, expect) {
  if (this.eatContextual("from")) {
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
    this.checkExport(node);
  } else {
    if (expect) {
      this.unexpected();
    } else {
      node.source = null;
    }
  }

  this.semicolon();
};

pp$1.shouldParseExportDeclaration = function () {
  return this.state.type.keyword === "var" || this.state.type.keyword === "const" || this.state.type.keyword === "let" || this.state.type.keyword === "function" || this.state.type.keyword === "class" || this.isContextual("async");
};

pp$1.checkExport = function (node, checkNames, isDefault) {
  if (checkNames) {
    // Check for duplicate exports
    if (isDefault) {
      // Default exports
      this.checkDuplicateExports(node, "default");
    } else if (node.specifiers && node.specifiers.length) {
      // Named exports
      for (var _iterator2 = node.specifiers, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var specifier = _ref2;

        this.checkDuplicateExports(specifier, specifier.exported.name);
      }
    } else if (node.declaration) {
      // Exported declarations
      if (node.declaration.type === "FunctionDeclaration" || node.declaration.type === "ClassDeclaration") {
        this.checkDuplicateExports(node, node.declaration.id.name);
      } else if (node.declaration.type === "VariableDeclaration") {
        for (var _iterator3 = node.declaration.declarations, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray3) {
            if (_i3 >= _iterator3.length) break;
            _ref3 = _iterator3[_i3++];
          } else {
            _i3 = _iterator3.next();
            if (_i3.done) break;
            _ref3 = _i3.value;
          }

          var declaration = _ref3;

          this.checkDeclaration(declaration.id);
        }
      }
    }
  }

  if (this.state.decorators.length) {
    var isClass = node.declaration && (node.declaration.type === "ClassDeclaration" || node.declaration.type === "ClassExpression");
    if (!node.declaration || !isClass) {
      this.raise(node.start, "You can only use decorators on an export when exporting a class");
    }
    this.takeDecorators(node.declaration);
  }
};

pp$1.checkDeclaration = function (node) {
  if (node.type === "ObjectPattern") {
    for (var _iterator4 = node.properties, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
      var _ref4;

      if (_isArray4) {
        if (_i4 >= _iterator4.length) break;
        _ref4 = _iterator4[_i4++];
      } else {
        _i4 = _iterator4.next();
        if (_i4.done) break;
        _ref4 = _i4.value;
      }

      var prop = _ref4;

      this.checkDeclaration(prop);
    }
  } else if (node.type === "ArrayPattern") {
    for (var _iterator5 = node.elements, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
      var _ref5;

      if (_isArray5) {
        if (_i5 >= _iterator5.length) break;
        _ref5 = _iterator5[_i5++];
      } else {
        _i5 = _iterator5.next();
        if (_i5.done) break;
        _ref5 = _i5.value;
      }

      var elem = _ref5;

      if (elem) {
        this.checkDeclaration(elem);
      }
    }
  } else if (node.type === "ObjectProperty") {
    this.checkDeclaration(node.value);
  } else if (node.type === "RestElement") {
    this.checkDeclaration(node.argument);
  } else if (node.type === "Identifier") {
    this.checkDuplicateExports(node, node.name);
  }
};

pp$1.checkDuplicateExports = function (node, name) {
  if (this.state.exportedIdentifiers.indexOf(name) > -1) {
    this.raiseDuplicateExportError(node, name);
  }
  this.state.exportedIdentifiers.push(name);
};

pp$1.raiseDuplicateExportError = function (node, name) {
  this.raise(node.start, name === "default" ? "Only one default export allowed per module." : "`" + name + "` has already been exported. Exported identifiers must be unique.");
};

// Parses a comma-separated list of module exports.

pp$1.parseExportSpecifiers = function () {
  var nodes = [];
  var first = true;
  var needsFrom = void 0;

  // export { x, y as z } [from '...']
  this.expect(types.braceL);

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    var isDefault = this.match(types._default);
    if (isDefault && !needsFrom) needsFrom = true;

    var node = this.startNode();
    node.local = this.parseIdentifier(isDefault);
    node.exported = this.eatContextual("as") ? this.parseIdentifier(true) : node.local.__clone();
    nodes.push(this.finishNode(node, "ExportSpecifier"));
  }

  // https://github.com/ember-cli/ember-cli/pull/3739
  if (needsFrom && !this.isContextual("from")) {
    this.unexpected();
  }

  return nodes;
};

// Parses import declaration.

pp$1.parseImport = function (node) {
  this.eat(types._import);

  // import '...'
  if (this.match(types.string)) {
    node.specifiers = [];
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = [];
    this.parseImportSpecifiers(node);
    this.expectContextual("from");
    node.source = this.match(types.string) ? this.parseExprAtom() : this.unexpected();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};

// Parses a comma-separated list of module imports.

pp$1.parseImportSpecifiers = function (node) {
  var first = true;
  if (this.match(types.name)) {
    // import defaultObj, { x, y as z } from '...'
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node.specifiers.push(this.parseImportSpecifierDefault(this.parseIdentifier(), startPos, startLoc));
    if (!this.eat(types.comma)) return;
  }

  if (this.match(types.star)) {
    var specifier = this.startNode();
    this.next();
    this.expectContextual("as");
    specifier.local = this.parseIdentifier();
    this.checkLVal(specifier.local, true, undefined, "import namespace specifier");
    node.specifiers.push(this.finishNode(specifier, "ImportNamespaceSpecifier"));
    return;
  }

  this.expect(types.braceL);
  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      // Detect an attempt to deep destructure
      if (this.eat(types.colon)) {
        this.unexpected(null, "ES2015 named imports do not destructure. Use another statement for destructuring after the import.");
      }

      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    this.parseImportSpecifier(node);
  }
};

pp$1.parseImportSpecifier = function (node) {
  var specifier = this.startNode();
  specifier.imported = this.parseIdentifier(true);
  if (this.eatContextual("as")) {
    specifier.local = this.parseIdentifier();
  } else {
    this.checkReservedWord(specifier.imported.name, specifier.start, true, true);
    specifier.local = specifier.imported.__clone();
  }
  this.checkLVal(specifier.local, true, undefined, "import specifier");
  node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
};

pp$1.parseImportSpecifierDefault = function (id, startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.local = id;
  this.checkLVal(node.local, true, undefined, "default import specifier");
  return this.finishNode(node, "ImportDefaultSpecifier");
};

var pp$2 = Parser.prototype;

// Convert existing expression atom to assignable pattern
// if possible.

pp$2.toAssignable = function (node, isBinding, contextDescription) {
  if (node) {
    switch (node.type) {
      case "Identifier":
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
        break;

      case "ObjectExpression":
        node.type = "ObjectPattern";
        for (var _iterator = node.properties, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref = _i.value;
          }

          var prop = _ref;

          if (prop.type === "ObjectMethod") {
            if (prop.kind === "get" || prop.kind === "set") {
              this.raise(prop.key.start, "Object pattern can't contain getter or setter");
            } else {
              this.raise(prop.key.start, "Object pattern can't contain methods");
            }
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }
        break;

      case "ObjectProperty":
        this.toAssignable(node.value, isBinding, contextDescription);
        break;

      case "SpreadElement":
        node.type = "RestElement";
        break;

      case "ArrayExpression":
        node.type = "ArrayPattern";
        this.toAssignableList(node.elements, isBinding, contextDescription);
        break;

      case "AssignmentExpression":
        if (node.operator === "=") {
          node.type = "AssignmentPattern";
          delete node.operator;
        } else {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        break;

      case "MemberExpression":
        if (!isBinding) break;

      default:
        {
          var message = "Invalid left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
          this.raise(node.start, message);
        }
    }
  }
  return node;
};

// Convert list of expression atoms to binding list.

pp$2.toAssignableList = function (exprList, isBinding, contextDescription) {
  var end = exprList.length;
  if (end) {
    var last = exprList[end - 1];
    if (last && last.type === "RestElement") {
      --end;
    } else if (last && last.type === "SpreadElement") {
      last.type = "RestElement";
      var arg = last.argument;
      this.toAssignable(arg, isBinding, contextDescription);
      if (arg.type !== "Identifier" && arg.type !== "MemberExpression" && arg.type !== "ArrayPattern") {
        this.unexpected(arg.start);
      }
      --end;
    }
  }
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt && elt.type === "SpreadElement") this.raise(elt.start, "The rest element has to be the last element when destructuring");
    if (elt) this.toAssignable(elt, isBinding, contextDescription);
  }
  return exprList;
};

// Convert list of expression atoms to a list of

pp$2.toReferencedList = function (exprList) {
  return exprList;
};

// Parses spread element.

pp$2.parseSpread = function (refShorthandDefaultPos) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refShorthandDefaultPos);
  return this.finishNode(node, "SpreadElement");
};

pp$2.parseRest = function () {
  var node = this.startNode();
  this.next();
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};

pp$2.shouldAllowYieldIdentifier = function () {
  return this.match(types._yield) && !this.state.strict && !this.state.inGenerator;
};

pp$2.parseBindingIdentifier = function () {
  return this.parseIdentifier(this.shouldAllowYieldIdentifier());
};

// Parses lvalue (assignable) atom.
pp$2.parseBindingAtom = function () {
  switch (this.state.type) {
    case types._yield:
    case types.name:
      return this.parseBindingIdentifier();

    case types.bracketL:
      var node = this.startNode();
      this.next();
      node.elements = this.parseBindingList(types.bracketR, true);
      return this.finishNode(node, "ArrayPattern");

    case types.braceL:
      return this.parseObj(true);

    default:
      this.unexpected();
  }
};

pp$2.parseBindingList = function (close, allowEmpty) {
  var elts = [];
  var first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
    }
    if (allowEmpty && this.match(types.comma)) {
      elts.push(null);
    } else if (this.eat(close)) {
      break;
    } else if (this.match(types.ellipsis)) {
      elts.push(this.parseAssignableListItemTypes(this.parseRest()));
      this.expect(close);
      break;
    } else {
      var decorators = [];
      while (this.match(types.at)) {
        decorators.push(this.parseDecorator());
      }
      var left = this.parseMaybeDefault();
      if (decorators.length) {
        left.decorators = decorators;
      }
      this.parseAssignableListItemTypes(left);
      elts.push(this.parseMaybeDefault(left.start, left.loc.start, left));
    }
  }
  return elts;
};

pp$2.parseAssignableListItemTypes = function (param) {
  return param;
};

// Parses assignment pattern around given atom if possible.

pp$2.parseMaybeDefault = function (startPos, startLoc, left) {
  startLoc = startLoc || this.state.startLoc;
  startPos = startPos || this.state.start;
  left = left || this.parseBindingAtom();
  if (!this.eat(types.eq)) return left;

  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};

// Verify that a node is an lval  something that can be assigned
// to.

pp$2.checkLVal = function (expr, isBinding, checkClashes, contextDescription) {
  switch (expr.type) {
    case "Identifier":
      this.checkReservedWord(expr.name, expr.start, false, true);

      if (checkClashes) {
        // we need to prefix this with an underscore for the cases where we have a key of
        // `__proto__`. there's a bug in old V8 where the following wouldn't work:
        //
        //   > var obj = Object.create(null);
        //   undefined
        //   > obj.__proto__
        //   null
        //   > obj.__proto__ = true;
        //   true
        //   > obj.__proto__
        //   null
        var key = "_" + expr.name;

        if (checkClashes[key]) {
          this.raise(expr.start, "Argument name clash in strict mode");
        } else {
          checkClashes[key] = true;
        }
      }
      break;

    case "MemberExpression":
      if (isBinding) this.raise(expr.start, (isBinding ? "Binding" : "Assigning to") + " member expression");
      break;

    case "ObjectPattern":
      for (var _iterator2 = expr.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var prop = _ref2;

        if (prop.type === "ObjectProperty") prop = prop.value;
        this.checkLVal(prop, isBinding, checkClashes, "object destructuring pattern");
      }
      break;

    case "ArrayPattern":
      for (var _iterator3 = expr.elements, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var elem = _ref3;

        if (elem) this.checkLVal(elem, isBinding, checkClashes, "array destructuring pattern");
      }
      break;

    case "AssignmentPattern":
      this.checkLVal(expr.left, isBinding, checkClashes, "assignment pattern");
      break;

    case "RestElement":
      this.checkLVal(expr.argument, isBinding, checkClashes, "rest element");
      break;

    default:
      {
        var message = (isBinding ? /* istanbul ignore next */"Binding invalid" : "Invalid") + " left-hand side" + (contextDescription ? " in " + contextDescription : /* istanbul ignore next */"expression");
        this.raise(expr.start, message);
      }
  }
};

/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts  that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

var pp$3 = Parser.prototype;

// Check if property name clashes with already added.
// Object/class getters and setters are not allowed to clash 
// either with each other or with an init property  and in
// strict mode, init properties are also not allowed to be repeated.

pp$3.checkPropClash = function (prop, propHash) {
  if (prop.computed || prop.kind) return;

  var key = prop.key;
  // It is either an Identifier or a String/NumericLiteral
  var name = key.type === "Identifier" ? key.name : String(key.value);

  if (name === "__proto__") {
    if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
    propHash.proto = true;
  }
};

// Convenience method to parse an Expression only
pp$3.getExpression = function () {
  this.nextToken();
  var expr = this.parseExpression();
  if (!this.match(types.eof)) {
    this.unexpected();
  }
  return expr;
};

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.

// Parse a full expression. The optional arguments are used to
// forbid the `in` operator (in for loops initialization expressions)
// and provide reference for storing '=' operator inside shorthand
// property assignment in contexts where both object expression
// and object pattern might appear (so it's possible to raise
// delayed syntax error at correct position).

pp$3.parseExpression = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeAssign(noIn, refShorthandDefaultPos);
  if (this.match(types.comma)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types.comma)) {
      node.expressions.push(this.parseMaybeAssign(noIn, refShorthandDefaultPos));
    }
    this.toReferencedList(node.expressions);
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};

// Parse an assignment expression. This includes applications of
// operators like `+=`.

pp$3.parseMaybeAssign = function (noIn, refShorthandDefaultPos, afterLeftParse, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;

  if (this.match(types._yield) && this.state.inGenerator) {
    var _left = this.parseYield();
    if (afterLeftParse) _left = afterLeftParse.call(this, _left, startPos, startLoc);
    return _left;
  }

  var failOnShorthandAssign = void 0;
  if (refShorthandDefaultPos) {
    failOnShorthandAssign = false;
  } else {
    refShorthandDefaultPos = { start: 0 };
    failOnShorthandAssign = true;
  }

  if (this.match(types.parenL) || this.match(types.name)) {
    this.state.potentialArrowAt = this.state.start;
  }

  var left = this.parseMaybeConditional(noIn, refShorthandDefaultPos, refNeedsArrowPos);
  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc);
  if (this.state.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.state.value;
    node.left = this.match(types.eq) ? this.toAssignable(left, undefined, "assignment expression") : left;
    refShorthandDefaultPos.start = 0; // reset because shorthand default was used correctly

    this.checkLVal(left, undefined, undefined, "assignment expression");

    if (left.extra && left.extra.parenthesized) {
      var errorMsg = void 0;
      if (left.type === "ObjectPattern") {
        errorMsg = "`({a}) = 0` use `({a} = 0)`";
      } else if (left.type === "ArrayPattern") {
        errorMsg = "`([a]) = 0` use `([a] = 0)`";
      }
      if (errorMsg) {
        this.raise(left.start, "You're trying to assign to a parenthesized expression, eg. instead of " + errorMsg);
      }
    }

    this.next();
    node.right = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "AssignmentExpression");
  } else if (failOnShorthandAssign && refShorthandDefaultPos.start) {
    this.unexpected(refShorthandDefaultPos.start);
  }

  return left;
};

// Parse a ternary conditional (`?:`) operator.

pp$3.parseMaybeConditional = function (noIn, refShorthandDefaultPos, refNeedsArrowPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprOps(noIn, refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;

  return this.parseConditional(expr, noIn, startPos, startLoc, refNeedsArrowPos);
};

pp$3.parseConditional = function (expr, noIn, startPos, startLoc) {
  if (this.eat(types.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types.colon);
    node.alternate = this.parseMaybeAssign(noIn);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};

// Start the precedence parser.

pp$3.parseExprOps = function (noIn, refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseMaybeUnary(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  } else {
    return this.parseExprOp(expr, startPos, startLoc, -1, noIn);
  }
};

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.

pp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {
  var prec = this.state.type.binop;
  if (prec != null && (!noIn || !this.match(types._in))) {
    if (prec > minPrec) {
      var node = this.startNodeAt(leftStartPos, leftStartLoc);
      node.left = left;
      node.operator = this.state.value;

      if (node.operator === "**" && left.type === "UnaryExpression" && left.extra && !left.extra.parenthesizedArgument && !left.extra.parenthesized) {
        this.raise(left.argument.start, "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.");
      }

      var op = this.state.type;
      this.next();

      var startPos = this.state.start;
      var startLoc = this.state.startLoc;
      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, op.rightAssociative ? prec - 1 : prec, noIn);

      this.finishNode(node, op === types.logicalOR || op === types.logicalAND ? "LogicalExpression" : "BinaryExpression");
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);
    }
  }
  return left;
};

// Parse unary operators, both prefix and postfix.

pp$3.parseMaybeUnary = function (refShorthandDefaultPos) {
  if (this.state.type.prefix) {
    var node = this.startNode();
    var update = this.match(types.incDec);
    node.operator = this.state.value;
    node.prefix = true;
    this.next();

    var argType = this.state.type;
    node.argument = this.parseMaybeUnary();

    this.addExtra(node, "parenthesizedArgument", argType === types.parenL && (!node.argument.extra || !node.argument.extra.parenthesized));

    if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
      this.unexpected(refShorthandDefaultPos.start);
    }

    if (update) {
      this.checkLVal(node.argument, undefined, undefined, "prefix operation");
    } else if (this.state.strict && node.operator === "delete" && node.argument.type === "Identifier") {
      this.raise(node.start, "Deleting local variable in strict mode");
    }

    return this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  }

  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var expr = this.parseExprSubscripts(refShorthandDefaultPos);
  if (refShorthandDefaultPos && refShorthandDefaultPos.start) return expr;
  while (this.state.type.postfix && !this.canInsertSemicolon()) {
    var _node = this.startNodeAt(startPos, startLoc);
    _node.operator = this.state.value;
    _node.prefix = false;
    _node.argument = expr;
    this.checkLVal(expr, undefined, undefined, "postfix operation");
    this.next();
    expr = this.finishNode(_node, "UpdateExpression");
  }
  return expr;
};

// Parse call, dot, and `[]`-subscript expressions.

pp$3.parseExprSubscripts = function (refShorthandDefaultPos) {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var potentialArrowAt = this.state.potentialArrowAt;
  var expr = this.parseExprAtom(refShorthandDefaultPos);

  if (expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt) {
    return expr;
  }

  if (refShorthandDefaultPos && refShorthandDefaultPos.start) {
    return expr;
  }

  return this.parseSubscripts(expr, startPos, startLoc);
};

pp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {
  for (;;) {
    if (!noCalls && this.eat(types.doubleColon)) {
      var node = this.startNodeAt(startPos, startLoc);
      node.object = base;
      node.callee = this.parseNoCallExpr();
      return this.parseSubscripts(this.finishNode(node, "BindExpression"), startPos, startLoc, noCalls);
    } else if (this.eat(types.dot)) {
      var _node2 = this.startNodeAt(startPos, startLoc);
      _node2.object = base;
      _node2.property = this.parseIdentifier(true);
      _node2.computed = false;
      base = this.finishNode(_node2, "MemberExpression");
    } else if (this.eat(types.bracketL)) {
      var _node3 = this.startNodeAt(startPos, startLoc);
      _node3.object = base;
      _node3.property = this.parseExpression();
      _node3.computed = true;
      this.expect(types.bracketR);
      base = this.finishNode(_node3, "MemberExpression");
    } else if (!noCalls && this.match(types.parenL)) {
      var possibleAsync = this.state.potentialArrowAt === base.start && base.type === "Identifier" && base.name === "async" && !this.canInsertSemicolon();
      this.next();

      var _node4 = this.startNodeAt(startPos, startLoc);
      _node4.callee = base;
      _node4.arguments = this.parseCallExpressionArguments(types.parenR, possibleAsync);
      if (_node4.callee.type === "Import" && _node4.arguments.length !== 1) {
        this.raise(_node4.start, "import() requires exactly one argument");
      }
      base = this.finishNode(_node4, "CallExpression");

      if (possibleAsync && this.shouldParseAsyncArrow()) {
        return this.parseAsyncArrowFromCallExpression(this.startNodeAt(startPos, startLoc), _node4);
      } else {
        this.toReferencedList(_node4.arguments);
      }
    } else if (this.match(types.backQuote)) {
      var _node5 = this.startNodeAt(startPos, startLoc);
      _node5.tag = base;
      _node5.quasi = this.parseTemplate(true);
      base = this.finishNode(_node5, "TaggedTemplateExpression");
    } else {
      return base;
    }
  }
};

pp$3.parseCallExpressionArguments = function (close, possibleAsyncArrow) {
  var elts = [];
  var innerParenStart = void 0;
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    // we need to make sure that if this is an async arrow functions, that we don't allow inner parens inside the params
    if (this.match(types.parenL) && !innerParenStart) {
      innerParenStart = this.state.start;
    }

    elts.push(this.parseExprListItem(false, possibleAsyncArrow ? { start: 0 } : undefined, possibleAsyncArrow ? { start: 0 } : undefined));
  }

  // we found an async arrow function so let's not allow any inner parens
  if (possibleAsyncArrow && innerParenStart && this.shouldParseAsyncArrow()) {
    this.unexpected();
  }

  return elts;
};

pp$3.shouldParseAsyncArrow = function () {
  return this.match(types.arrow);
};

pp$3.parseAsyncArrowFromCallExpression = function (node, call) {
  this.expect(types.arrow);
  return this.parseArrowExpression(node, call.arguments, true);
};

// Parse a no-call expression (like argument of `new` or `::` operators).

pp$3.parseNoCallExpr = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  return this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);
};

// Parse an atomic expression  either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.

pp$3.parseExprAtom = function (refShorthandDefaultPos) {
  var canBeArrow = this.state.potentialArrowAt === this.state.start;
  var node = void 0;

  switch (this.state.type) {
    case types._super:
      if (!this.state.inMethod && !this.options.allowSuperOutsideMethod) {
        this.raise(this.state.start, "'super' outside of function or class");
      }

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL) && !this.match(types.bracketL) && !this.match(types.dot)) {
        this.unexpected();
      }
      if (this.match(types.parenL) && this.state.inMethod !== "constructor" && !this.options.allowSuperOutsideMethod) {
        this.raise(node.start, "super() is only valid inside a class constructor. Make sure the method name is spelled exactly as 'constructor'.");
      }
      return this.finishNode(node, "Super");

    case types._import:
      if (!this.hasPlugin("dynamicImport")) this.unexpected();

      node = this.startNode();
      this.next();
      if (!this.match(types.parenL)) {
        this.unexpected(null, types.parenL);
      }
      return this.finishNode(node, "Import");

    case types._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");

    case types._yield:
      if (this.state.inGenerator) this.unexpected();

    case types.name:
      node = this.startNode();
      var allowAwait = this.state.value === "await" && this.state.inAsync;
      var allowYield = this.shouldAllowYieldIdentifier();
      var id = this.parseIdentifier(allowAwait || allowYield);

      if (id.name === "await") {
        if (this.state.inAsync || this.inModule) {
          return this.parseAwait(node);
        }
      } else if (id.name === "async" && this.match(types._function) && !this.canInsertSemicolon()) {
        this.next();
        return this.parseFunction(node, false, false, true);
      } else if (canBeArrow && id.name === "async" && this.match(types.name)) {
        var params = [this.parseIdentifier()];
        this.expect(types.arrow);
        // let foo = bar => {};
        return this.parseArrowExpression(node, params, true);
      }

      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {
        return this.parseArrowExpression(node, [id]);
      }

      return id;

    case types._do:
      if (this.hasPlugin("doExpressions")) {
        var _node6 = this.startNode();
        this.next();
        var oldInFunction = this.state.inFunction;
        var oldLabels = this.state.labels;
        this.state.labels = [];
        this.state.inFunction = false;
        _node6.body = this.parseBlock(false, true);
        this.state.inFunction = oldInFunction;
        this.state.labels = oldLabels;
        return this.finishNode(_node6, "DoExpression");
      }

    case types.regexp:
      var value = this.state.value;
      node = this.parseLiteral(value.value, "RegExpLiteral");
      node.pattern = value.pattern;
      node.flags = value.flags;
      return node;

    case types.num:
      return this.parseLiteral(this.state.value, "NumericLiteral");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteral");

    case types._null:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "NullLiteral");

    case types._true:case types._false:
      node = this.startNode();
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteral");

    case types.parenL:
      return this.parseParenAndDistinguishExpression(null, null, canBeArrow);

    case types.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types.bracketR, true, refShorthandDefaultPos);
      this.toReferencedList(node.elements);
      return this.finishNode(node, "ArrayExpression");

    case types.braceL:
      return this.parseObj(false, refShorthandDefaultPos);

    case types._function:
      return this.parseFunctionExpression();

    case types.at:
      this.parseDecorators();

    case types._class:
      node = this.startNode();
      this.takeDecorators(node);
      return this.parseClass(node, false);

    case types._new:
      return this.parseNew();

    case types.backQuote:
      return this.parseTemplate(false);

    case types.doubleColon:
      node = this.startNode();
      this.next();
      node.object = null;
      var callee = node.callee = this.parseNoCallExpr();
      if (callee.type === "MemberExpression") {
        return this.finishNode(node, "BindExpression");
      } else {
        this.raise(callee.start, "Binding should be performed on object property.");
      }

    default:
      this.unexpected();
  }
};

pp$3.parseFunctionExpression = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);
  if (this.state.inGenerator && this.eat(types.dot) && this.hasPlugin("functionSent")) {
    return this.parseMetaProperty(node, meta, "sent");
  } else {
    return this.parseFunction(node, false);
  }
};

pp$3.parseMetaProperty = function (node, meta, propertyName) {
  node.meta = meta;
  node.property = this.parseIdentifier(true);

  if (node.property.name !== propertyName) {
    this.raise(node.property.start, "The only valid meta property for new is " + meta.name + "." + propertyName);
  }

  return this.finishNode(node, "MetaProperty");
};

pp$3.parseLiteral = function (value, type, startPos, startLoc) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var node = this.startNodeAt(startPos, startLoc);
  this.addExtra(node, "rawValue", value);
  this.addExtra(node, "raw", this.input.slice(startPos, this.state.end));
  node.value = value;
  this.next();
  return this.finishNode(node, type);
};

pp$3.parseParenExpression = function () {
  this.expect(types.parenL);
  var val = this.parseExpression();
  this.expect(types.parenR);
  return val;
};

pp$3.parseParenAndDistinguishExpression = function (startPos, startLoc, canBeArrow) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;

  var val = void 0;
  this.expect(types.parenL);

  var innerStartPos = this.state.start;
  var innerStartLoc = this.state.startLoc;
  var exprList = [];
  var refShorthandDefaultPos = { start: 0 };
  var refNeedsArrowPos = { start: 0 };
  var first = true;
  var spreadStart = void 0;
  var optionalCommaStart = void 0;

  while (!this.match(types.parenR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma, refNeedsArrowPos.start || null);
      if (this.match(types.parenR)) {
        optionalCommaStart = this.state.start;
        break;
      }
    }

    if (this.match(types.ellipsis)) {
      var spreadNodeStartPos = this.state.start;
      var spreadNodeStartLoc = this.state.startLoc;
      spreadStart = this.state.start;
      exprList.push(this.parseParenItem(this.parseRest(), spreadNodeStartPos, spreadNodeStartLoc));
      break;
    } else {
      exprList.push(this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos));
    }
  }

  var innerEndPos = this.state.start;
  var innerEndLoc = this.state.startLoc;
  this.expect(types.parenR);

  var arrowNode = this.startNodeAt(startPos, startLoc);
  if (canBeArrow && this.shouldParseArrow() && (arrowNode = this.parseArrow(arrowNode))) {
    for (var _iterator = exprList, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var param = _ref;

      if (param.extra && param.extra.parenthesized) this.unexpected(param.extra.parenStart);
    }

    return this.parseArrowExpression(arrowNode, exprList);
  }

  if (!exprList.length) {
    this.unexpected(this.state.lastTokStart);
  }
  if (optionalCommaStart) this.unexpected(optionalCommaStart);
  if (spreadStart) this.unexpected(spreadStart);
  if (refShorthandDefaultPos.start) this.unexpected(refShorthandDefaultPos.start);
  if (refNeedsArrowPos.start) this.unexpected(refNeedsArrowPos.start);

  if (exprList.length > 1) {
    val = this.startNodeAt(innerStartPos, innerStartLoc);
    val.expressions = exprList;
    this.toReferencedList(val.expressions);
    this.finishNodeAt(val, "SequenceExpression", innerEndPos, innerEndLoc);
  } else {
    val = exprList[0];
  }

  this.addExtra(val, "parenthesized", true);
  this.addExtra(val, "parenStart", startPos);

  return val;
};

pp$3.shouldParseArrow = function () {
  return !this.canInsertSemicolon();
};

pp$3.parseArrow = function (node) {
  if (this.eat(types.arrow)) {
    return node;
  }
};

pp$3.parseParenItem = function (node) {
  return node;
};

// New's precedence is slightly tricky. It must allow its argument
// to be a `[]` or dot subscript expression, but not a call  at
// least, not without wrapping it in parentheses. Thus, it uses the

pp$3.parseNew = function () {
  var node = this.startNode();
  var meta = this.parseIdentifier(true);

  if (this.eat(types.dot)) {
    var metaProp = this.parseMetaProperty(node, meta, "target");

    if (!this.state.inFunction) {
      this.raise(metaProp.property.start, "new.target can only be used in functions");
    }

    return metaProp;
  }

  node.callee = this.parseNoCallExpr();

  if (this.eat(types.parenL)) {
    node.arguments = this.parseExprList(types.parenR);
    this.toReferencedList(node.arguments);
  } else {
    node.arguments = [];
  }

  return this.finishNode(node, "NewExpression");
};

// Parse template expression.

pp$3.parseTemplateElement = function (isTagged) {
  var elem = this.startNode();
  if (this.state.value === null) {
    if (!isTagged) {
      this.raise(this.state.invalidTemplateEscapePosition, "Invalid escape sequence in template");
    } else {
      this.state.invalidTemplateEscapePosition = null;
    }
  }
  elem.value = {
    raw: this.input.slice(this.state.start, this.state.end).replace(/\r\n?/g, "\n"),
    cooked: this.state.value
  };
  this.next();
  elem.tail = this.match(types.backQuote);
  return this.finishNode(elem, "TemplateElement");
};

pp$3.parseTemplate = function (isTagged) {
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement(isTagged);
  node.quasis = [curElt];
  while (!curElt.tail) {
    this.expect(types.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types.braceR);
    node.quasis.push(curElt = this.parseTemplateElement(isTagged));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};

// Parse an object literal or binding pattern.

pp$3.parseObj = function (isPattern, refShorthandDefaultPos) {
  var decorators = [];
  var propHash = Object.create(null);
  var first = true;
  var node = this.startNode();

  node.properties = [];
  this.next();

  var firstRestLocation = null;

  while (!this.eat(types.braceR)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(types.braceR)) break;
    }

    while (this.match(types.at)) {
      decorators.push(this.parseDecorator());
    }

    var prop = this.startNode(),
        isGenerator = false,
        isAsync = false,
        startPos = void 0,
        startLoc = void 0;
    if (decorators.length) {
      prop.decorators = decorators;
      decorators = [];
    }

    if (this.hasPlugin("objectRestSpread") && this.match(types.ellipsis)) {
      prop = this.parseSpread(isPattern ? { start: 0 } : undefined);
      prop.type = isPattern ? "RestElement" : "SpreadElement";
      if (isPattern) this.toAssignable(prop.argument, true, "object pattern");
      node.properties.push(prop);
      if (isPattern) {
        var position = this.state.start;
        if (firstRestLocation !== null) {
          this.unexpected(firstRestLocation, "Cannot have multiple rest elements when destructuring");
        } else if (this.eat(types.braceR)) {
          break;
        } else if (this.match(types.comma) && this.lookahead().type === types.braceR) {
          this.unexpected(position, "A trailing comma is not permitted after the rest element");
        } else {
          firstRestLocation = position;
          continue;
        }
      } else {
        continue;
      }
    }

    prop.method = false;
    prop.shorthand = false;

    if (isPattern || refShorthandDefaultPos) {
      startPos = this.state.start;
      startLoc = this.state.startLoc;
    }

    if (!isPattern) {
      isGenerator = this.eat(types.star);
    }

    if (!isPattern && this.isContextual("async")) {
      if (isGenerator) this.unexpected();

      var asyncId = this.parseIdentifier();
      if (this.match(types.colon) || this.match(types.parenL) || this.match(types.braceR) || this.match(types.eq) || this.match(types.comma)) {
        prop.key = asyncId;
        prop.computed = false;
      } else {
        isAsync = true;
        if (this.hasPlugin("asyncGenerators")) isGenerator = this.eat(types.star);
        this.parsePropertyName(prop);
      }
    } else {
      this.parsePropertyName(prop);
    }

    this.parseObjPropValue(prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos);
    this.checkPropClash(prop, propHash);

    if (prop.shorthand) {
      this.addExtra(prop, "shorthand", true);
    }

    node.properties.push(prop);
  }

  if (firstRestLocation !== null) {
    this.unexpected(firstRestLocation, "The rest element has to be the last element when destructuring");
  }

  if (decorators.length) {
    this.raise(this.state.start, "You have trailing decorators with no property");
  }

  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};

pp$3.isGetterOrSetterMethod = function (prop, isPattern) {
  return !isPattern && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.match(types.string) || // get "string"() {}
  this.match(types.num) || // get 1() {}
  this.match(types.bracketL) || // get ["string"]() {}
  this.match(types.name) || // get foo() {}
  this.state.type.keyword // get debugger() {}
  );
};

// get methods aren't allowed to have any parameters
// set methods must have exactly 1 parameter
pp$3.checkGetterSetterParamCount = function (method) {
  var paramCount = method.kind === "get" ? 0 : 1;
  if (method.params.length !== paramCount) {
    var start = method.start;
    if (method.kind === "get") {
      this.raise(start, "getter should have no params");
    } else {
      this.raise(start, "setter should have exactly one param");
    }
  }
};

pp$3.parseObjectMethod = function (prop, isGenerator, isAsync, isPattern) {
  if (isAsync || isGenerator || this.match(types.parenL)) {
    if (isPattern) this.unexpected();
    prop.kind = "method";
    prop.method = true;
    this.parseMethod(prop, isGenerator, isAsync);

    return this.finishNode(prop, "ObjectMethod");
  }

  if (this.isGetterOrSetterMethod(prop, isPattern)) {
    if (isGenerator || isAsync) this.unexpected();
    prop.kind = prop.key.name;
    this.parsePropertyName(prop);
    this.parseMethod(prop);
    this.checkGetterSetterParamCount(prop);

    return this.finishNode(prop, "ObjectMethod");
  }
};

pp$3.parseObjectProperty = function (prop, startPos, startLoc, isPattern, refShorthandDefaultPos) {
  if (this.eat(types.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.state.start, this.state.startLoc) : this.parseMaybeAssign(false, refShorthandDefaultPos);

    return this.finishNode(prop, "ObjectProperty");
  }

  if (!prop.computed && prop.key.type === "Identifier") {
    if (isPattern) {
      this.checkReservedWord(prop.key.name, prop.key.start, true, true);
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else if (this.match(types.eq) && refShorthandDefaultPos) {
      if (!refShorthandDefaultPos.start) {
        refShorthandDefaultPos.start = this.state.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key.__clone());
    } else {
      prop.value = prop.key.__clone();
    }
    prop.shorthand = true;

    return this.finishNode(prop, "ObjectProperty");
  }
};

pp$3.parseObjPropValue = function (prop, startPos, startLoc, isGenerator, isAsync, isPattern, refShorthandDefaultPos) {
  var node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern) || this.parseObjectProperty(prop, startPos, startLoc, isPattern, refShorthandDefaultPos);

  if (!node) this.unexpected();

  return node;
};

pp$3.parsePropertyName = function (prop) {
  if (this.eat(types.bracketL)) {
    prop.computed = true;
    prop.key = this.parseMaybeAssign();
    this.expect(types.bracketR);
  } else {
    prop.computed = false;
    var oldInPropertyName = this.state.inPropertyName;
    this.state.inPropertyName = true;
    prop.key = this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
    this.state.inPropertyName = oldInPropertyName;
  }
  return prop.key;
};

// Initialize empty function node.

pp$3.initFunction = function (node, isAsync) {
  node.id = null;
  node.generator = false;
  node.expression = false;
  node.async = !!isAsync;
};

// Parse object or class method.

pp$3.parseMethod = function (node, isGenerator, isAsync) {
  var oldInMethod = this.state.inMethod;
  this.state.inMethod = node.kind || true;
  this.initFunction(node, isAsync);
  this.expect(types.parenL);
  node.params = this.parseBindingList(types.parenR);
  node.generator = !!isGenerator;
  this.parseFunctionBody(node);
  this.state.inMethod = oldInMethod;
  return node;
};

// Parse arrow function expression with given parameters.

pp$3.parseArrowExpression = function (node, params, isAsync) {
  this.initFunction(node, isAsync);
  node.params = this.toAssignableList(params, true, "arrow function parameters");
  this.parseFunctionBody(node, true);
  return this.finishNode(node, "ArrowFunctionExpression");
};

pp$3.isStrictBody = function (node, isExpression) {
  if (!isExpression && node.body.directives.length) {
    for (var _iterator2 = node.body.directives, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
      var _ref2;

      if (_isArray2) {
        if (_i2 >= _iterator2.length) break;
        _ref2 = _iterator2[_i2++];
      } else {
        _i2 = _iterator2.next();
        if (_i2.done) break;
        _ref2 = _i2.value;
      }

      var directive = _ref2;

      if (directive.value.value === "use strict") {
        return true;
      }
    }
  }

  return false;
};

// Parse function body and check parameters.
pp$3.parseFunctionBody = function (node, allowExpression) {
  var isExpression = allowExpression && !this.match(types.braceL);

  var oldInAsync = this.state.inAsync;
  this.state.inAsync = node.async;
  if (isExpression) {
    node.body = this.parseMaybeAssign();
    node.expression = true;
  } else {
    // Start a new scope with regard to labels and the `inFunction`
    // flag (restore them to their old value afterwards).
    var oldInFunc = this.state.inFunction;
    var oldInGen = this.state.inGenerator;
    var oldLabels = this.state.labels;
    this.state.inFunction = true;this.state.inGenerator = node.generator;this.state.labels = [];
    node.body = this.parseBlock(true);
    node.expression = false;
    this.state.inFunction = oldInFunc;this.state.inGenerator = oldInGen;this.state.labels = oldLabels;
  }
  this.state.inAsync = oldInAsync;

  // If this is a strict mode function, verify that argument names
  // are not repeated, and it does not try to bind the words `eval`
  // or `arguments`.
  var isStrict = this.isStrictBody(node, isExpression);
  // Also check when allowExpression === true for arrow functions
  var checkLVal = this.state.strict || allowExpression || isStrict;

  if (isStrict && node.id && node.id.type === "Identifier" && node.id.name === "yield") {
    this.raise(node.id.start, "Binding yield in strict mode");
  }

  if (checkLVal) {
    var nameHash = Object.create(null);
    var oldStrict = this.state.strict;
    if (isStrict) this.state.strict = true;
    if (node.id) {
      this.checkLVal(node.id, true, undefined, "function name");
    }
    for (var _iterator3 = node.params, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var param = _ref3;

      if (isStrict && param.type !== "Identifier") {
        this.raise(param.start, "Non-simple parameter in strict mode");
      }
      this.checkLVal(param, true, nameHash, "function parameter list");
    }
    this.state.strict = oldStrict;
  }
};

// Parses a comma-separated list of expressions, and returns them as
// an array. `close` is the token type that ends the list, and
// `allowEmpty` can be turned on to allow subsequent commas with
// nothing in between them to be parsed as `null` (which is needed
// for array literals).

pp$3.parseExprList = function (close, allowEmpty, refShorthandDefaultPos) {
  var elts = [];
  var first = true;

  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types.comma);
      if (this.eat(close)) break;
    }

    elts.push(this.parseExprListItem(allowEmpty, refShorthandDefaultPos));
  }
  return elts;
};

pp$3.parseExprListItem = function (allowEmpty, refShorthandDefaultPos, refNeedsArrowPos) {
  var elt = void 0;
  if (allowEmpty && this.match(types.comma)) {
    elt = null;
  } else if (this.match(types.ellipsis)) {
    elt = this.parseSpread(refShorthandDefaultPos);
  } else {
    elt = this.parseMaybeAssign(false, refShorthandDefaultPos, this.parseParenItem, refNeedsArrowPos);
  }
  return elt;
};

// Parse the next token as an identifier. If `liberal` is true (used
// when parsing properties), it will also convert keywords into
// identifiers.

pp$3.parseIdentifier = function (liberal) {
  var node = this.startNode();
  if (!liberal) {
    this.checkReservedWord(this.state.value, this.state.start, !!this.state.type.keyword, false);
  }

  if (this.match(types.name)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }

  if (!liberal && node.name === "await" && this.state.inAsync) {
    this.raise(node.start, "invalid use of await inside of an async function");
  }

  node.loc.identifierName = node.name;

  this.next();
  return this.finishNode(node, "Identifier");
};

pp$3.checkReservedWord = function (word, startLoc, checkKeywords, isBinding) {
  if (this.isReservedWord(word) || checkKeywords && this.isKeyword(word)) {
    this.raise(startLoc, word + " is a reserved word");
  }

  if (this.state.strict && (reservedWords.strict(word) || isBinding && reservedWords.strictBind(word))) {
    this.raise(startLoc, word + " is a reserved word in strict mode");
  }
};

// Parses await expression inside async function.

pp$3.parseAwait = function (node) {
  // istanbul ignore next: this condition is checked at the call site so won't be hit here
  if (!this.state.inAsync) {
    this.unexpected();
  }
  if (this.match(types.star)) {
    this.raise(node.start, "await* has been removed from the async functions proposal. Use Promise.all() instead.");
  }
  node.argument = this.parseMaybeUnary();
  return this.finishNode(node, "AwaitExpression");
};

// Parses yield expression inside generator.

pp$3.parseYield = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.semi) || this.canInsertSemicolon() || !this.match(types.star) && !this.state.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types.star);
    node.argument = this.parseMaybeAssign();
  }
  return this.finishNode(node, "YieldExpression");
};

// Start an AST node, attaching a start offset.

var pp$4 = Parser.prototype;
var commentKeys = ["leadingComments", "trailingComments", "innerComments"];

var Node = function () {
  function Node(parser, pos, loc) {
    classCallCheck(this, Node);

    this.type = "";
    this.start = pos;
    this.end = 0;
    this.loc = new SourceLocation(loc);
    if (parser && parser.options.ranges) this.range = [pos, 0];
    if (parser && parser.filename) this.loc.filename = parser.filename;
  }

  Node.prototype.__clone = function __clone() {
    var node2 = new Node();
    for (var key in this) {
      // Do not clone comments that are already attached to the node
      if (commentKeys.indexOf(key) < 0) {
        node2[key] = this[key];
      }
    }

    return node2;
  };

  return Node;
}();

pp$4.startNode = function () {
  return new Node(this, this.state.start, this.state.startLoc);
};

pp$4.startNodeAt = function (pos, loc) {
  return new Node(this, pos, loc);
};

function finishNodeAt(node, type, pos, loc) {
  node.type = type;
  node.end = pos;
  node.loc.end = loc;
  if (this.options.ranges) node.range[1] = pos;
  this.processComment(node);
  return node;
}

// Finish an AST node, adding `type` and `end` properties.

pp$4.finishNode = function (node, type) {
  return finishNodeAt.call(this, node, type, this.state.lastTokEnd, this.state.lastTokEndLoc);
};

// Finish node at given position

pp$4.finishNodeAt = function (node, type, pos, loc) {
  return finishNodeAt.call(this, node, type, pos, loc);
};

/**
 * Reset the start location of node to the start location of locationNode
 */
pp$4.resetStartLocationFromNode = function (node, locationNode) {
  node.start = locationNode.start;
  node.loc.start = locationNode.loc.start;
  if (this.options.ranges) node.range[0] = locationNode.range[0];

  return node;
};

var pp$5 = Parser.prototype;

// This function is used to raise exceptions on parse errors. It
// takes an offset integer (into the current `input`) to indicate
// the location of the error, attaches the position to the end
// of the error message, and then raises a `SyntaxError` with that
// message.

pp$5.raise = function (pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  var err = new SyntaxError(message);
  err.pos = pos;
  err.loc = loc;
  throw err;
};

/* eslint max-len: 0 */

/**
 * Based on the comment attachment algorithm used in espree and estraverse.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in the
 *   documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

function last(stack) {
  return stack[stack.length - 1];
}

var pp$6 = Parser.prototype;

pp$6.addComment = function (comment) {
  if (this.filename) comment.loc.filename = this.filename;
  this.state.trailingComments.push(comment);
  this.state.leadingComments.push(comment);
};

pp$6.processComment = function (node) {
  if (node.type === "Program" && node.body.length > 0) return;

  var stack = this.state.commentStack;

  var lastChild = void 0,
      trailingComments = void 0,
      i = void 0,
      j = void 0;

  if (this.state.trailingComments.length > 0) {
    // If the first comment in trailingComments comes after the
    // current node, then we're good - all comments in the array will
    // come after the node and so it's safe to add them as official
    // trailingComments.
    if (this.state.trailingComments[0].start >= node.end) {
      trailingComments = this.state.trailingComments;
      this.state.trailingComments = [];
    } else {
      // Otherwise, if the first comment doesn't come after the
      // current node, that means we have a mix of leading and trailing
      // comments in the array and that leadingComments contains the
      // same items as trailingComments. Reset trailingComments to
      // zero items and we'll handle this by evaluating leadingComments
      // later.
      this.state.trailingComments.length = 0;
    }
  } else {
    var lastInStack = last(stack);
    if (stack.length > 0 && lastInStack.trailingComments && lastInStack.trailingComments[0].start >= node.end) {
      trailingComments = lastInStack.trailingComments;
      lastInStack.trailingComments = null;
    }
  }

  // Eating the stack.
  while (stack.length > 0 && last(stack).start >= node.start) {
    lastChild = stack.pop();
  }

  if (lastChild) {
    if (lastChild.leadingComments) {
      if (lastChild !== node && last(lastChild.leadingComments).end <= node.start) {
        node.leadingComments = lastChild.leadingComments;
        lastChild.leadingComments = null;
      } else {
        // A leading comment for an anonymous class had been stolen by its first ClassMethod,
        // so this takes back the leading comment.
        // See also: https://github.com/eslint/espree/issues/158
        for (i = lastChild.leadingComments.length - 2; i >= 0; --i) {
          if (lastChild.leadingComments[i].end <= node.start) {
            node.leadingComments = lastChild.leadingComments.splice(0, i + 1);
            break;
          }
        }
      }
    }
  } else if (this.state.leadingComments.length > 0) {
    if (last(this.state.leadingComments).end <= node.start) {
      if (this.state.commentPreviousNode) {
        for (j = 0; j < this.state.leadingComments.length; j++) {
          if (this.state.leadingComments[j].end < this.state.commentPreviousNode.end) {
            this.state.leadingComments.splice(j, 1);
            j--;
          }
        }
      }
      if (this.state.leadingComments.length > 0) {
        node.leadingComments = this.state.leadingComments;
        this.state.leadingComments = [];
      }
    } else {
      // https://github.com/eslint/espree/issues/2
      //
      // In special cases, such as return (without a value) and
      // debugger, all comments will end up as leadingComments and
      // will otherwise be eliminated. This step runs when the
      // commentStack is empty and there are comments left
      // in leadingComments.
      //
      // This loop figures out the stopping point between the actual
      // leading and trailing comments by finding the location of the
      // first comment that comes after the given node.
      for (i = 0; i < this.state.leadingComments.length; i++) {
        if (this.state.leadingComments[i].end > node.start) {
          break;
        }
      }

      // Split the array based on the location of the first comment
      // that comes after the node. Keep in mind that this could
      // result in an empty array, and if so, the array must be
      // deleted.
      node.leadingComments = this.state.leadingComments.slice(0, i);
      if (node.leadingComments.length === 0) {
        node.leadingComments = null;
      }

      // Similarly, trailing comments are attached later. The variable
      // must be reset to null if there are no trailing comments.
      trailingComments = this.state.leadingComments.slice(i);
      if (trailingComments.length === 0) {
        trailingComments = null;
      }
    }
  }

  this.state.commentPreviousNode = node;

  if (trailingComments) {
    if (trailingComments.length && trailingComments[0].start >= node.start && last(trailingComments).end <= node.end) {
      node.innerComments = trailingComments;
    } else {
      node.trailingComments = trailingComments;
    }
  }

  stack.push(node);
};

var pp$7 = Parser.prototype;

pp$7.estreeParseRegExpLiteral = function (_ref) {
  var pattern = _ref.pattern,
      flags = _ref.flags;

  var regex = null;
  try {
    regex = new RegExp(pattern, flags);
  } catch (e) {
    // In environments that don't support these flags value will
    // be null as the regex can't be represented natively.
  }
  var node = this.estreeParseLiteral(regex);
  node.regex = { pattern: pattern, flags: flags };

  return node;
};

pp$7.estreeParseLiteral = function (value) {
  return this.parseLiteral(value, "Literal");
};

pp$7.directiveToStmt = function (directive) {
  var directiveLiteral = directive.value;

  var stmt = this.startNodeAt(directive.start, directive.loc.start);
  var expression = this.startNodeAt(directiveLiteral.start, directiveLiteral.loc.start);

  expression.value = directiveLiteral.value;
  expression.raw = directiveLiteral.extra.raw;

  stmt.expression = this.finishNodeAt(expression, "Literal", directiveLiteral.end, directiveLiteral.loc.end);
  stmt.directive = directiveLiteral.extra.raw.slice(1, -1);

  return this.finishNodeAt(stmt, "ExpressionStatement", directive.end, directive.loc.end);
};

function isSimpleProperty(node) {
  return node && node.type === "Property" && node.kind === "init" && node.method === false;
}

var estreePlugin = function (instance) {
  instance.extend("checkDeclaration", function (inner) {
    return function (node) {
      if (isSimpleProperty(node)) {
        this.checkDeclaration(node.value);
      } else {
        inner.call(this, node);
      }
    };
  });

  instance.extend("checkGetterSetterParamCount", function () {
    return function (prop) {
      var paramCount = prop.kind === "get" ? 0 : 1;
      if (prop.value.params.length !== paramCount) {
        var start = prop.start;
        if (prop.kind === "get") {
          this.raise(start, "getter should have no params");
        } else {
          this.raise(start, "setter should have exactly one param");
        }
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (expr, isBinding, checkClashes) {
      var _this = this;

      switch (expr.type) {
        case "ObjectPattern":
          expr.properties.forEach(function (prop) {
            _this.checkLVal(prop.type === "Property" ? prop.value : prop, isBinding, checkClashes, "object destructuring pattern");
          });
          break;
        default:
          for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
            args[_key - 3] = arguments[_key];
          }

          inner.call.apply(inner, [this, expr, isBinding, checkClashes].concat(args));
      }
    };
  });

  instance.extend("checkPropClash", function () {
    return function (prop, propHash) {
      if (prop.computed || !isSimpleProperty(prop)) return;

      var key = prop.key;
      // It is either an Identifier or a String/NumericLiteral
      var name = key.type === "Identifier" ? key.name : String(key.value);

      if (name === "__proto__") {
        if (propHash.proto) this.raise(key.start, "Redefinition of __proto__ property");
        propHash.proto = true;
      }
    };
  });

  instance.extend("isStrictBody", function () {
    return function (node, isExpression) {
      if (!isExpression && node.body.body.length > 0) {
        for (var _iterator = node.body.body, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
          var _ref2;

          if (_isArray) {
            if (_i >= _iterator.length) break;
            _ref2 = _iterator[_i++];
          } else {
            _i = _iterator.next();
            if (_i.done) break;
            _ref2 = _i.value;
          }

          var directive = _ref2;

          if (directive.type === "ExpressionStatement" && directive.expression.type === "Literal") {
            if (directive.expression.value === "use strict") return true;
          } else {
            // Break for the first non literal expression
            break;
          }
        }
      }

      return false;
    };
  });

  instance.extend("isValidDirective", function () {
    return function (stmt) {
      return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && (!stmt.expression.extra || !stmt.expression.extra.parenthesized);
    };
  });

  instance.extend("parseBlockBody", function (inner) {
    return function (node) {
      var _this2 = this;

      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      inner.call.apply(inner, [this, node].concat(args));

      node.directives.reverse().forEach(function (directive) {
        node.body.unshift(_this2.directiveToStmt(directive));
      });
      delete node.directives;
    };
  });

  instance.extend("parseClassMethod", function (inner) {
    return function (classBody) {
      for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      inner.call.apply(inner, [this, classBody].concat(args));

      var body = classBody.body;
      body[body.length - 1].type = "MethodDefinition";
    };
  });

  instance.extend("parseExprAtom", function (inner) {
    return function () {
      switch (this.state.type) {
        case types.regexp:
          return this.estreeParseRegExpLiteral(this.state.value);

        case types.num:
        case types.string:
          return this.estreeParseLiteral(this.state.value);

        case types._null:
          return this.estreeParseLiteral(null);

        case types._true:
          return this.estreeParseLiteral(true);

        case types._false:
          return this.estreeParseLiteral(false);

        default:
          for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
            args[_key4] = arguments[_key4];
          }

          return inner.call.apply(inner, [this].concat(args));
      }
    };
  });

  instance.extend("parseLiteral", function (inner) {
    return function () {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      node.raw = node.extra.raw;
      delete node.extra;

      return node;
    };
  });

  instance.extend("parseMethod", function (inner) {
    return function (node) {
      var funcNode = this.startNode();
      funcNode.kind = node.kind; // provide kind, so inner method correctly sets state

      for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }

      funcNode = inner.call.apply(inner, [this, funcNode].concat(args));
      delete funcNode.kind;
      node.value = this.finishNode(funcNode, "FunctionExpression");

      return node;
    };
  });

  instance.extend("parseObjectMethod", function (inner) {
    return function () {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        if (node.kind === "method") node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("parseObjectProperty", function (inner) {
    return function () {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      var node = inner.call.apply(inner, [this].concat(args));

      if (node) {
        node.kind = "init";
        node.type = "Property";
      }

      return node;
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding) {
      for (var _len9 = arguments.length, args = Array(_len9 > 2 ? _len9 - 2 : 0), _key9 = 2; _key9 < _len9; _key9++) {
        args[_key9 - 2] = arguments[_key9];
      }

      if (isSimpleProperty(node)) {
        this.toAssignable.apply(this, [node.value, isBinding].concat(args));

        return node;
      } else if (node.type === "ObjectExpression") {
        node.type = "ObjectPattern";
        for (var _iterator2 = node.properties, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
          var _ref3;

          if (_isArray2) {
            if (_i2 >= _iterator2.length) break;
            _ref3 = _iterator2[_i2++];
          } else {
            _i2 = _iterator2.next();
            if (_i2.done) break;
            _ref3 = _i2.value;
          }

          var prop = _ref3;

          if (prop.kind === "get" || prop.kind === "set") {
            this.raise(prop.key.start, "Object pattern can't contain getter or setter");
          } else if (prop.method) {
            this.raise(prop.key.start, "Object pattern can't contain methods");
          } else {
            this.toAssignable(prop, isBinding, "object destructuring pattern");
          }
        }

        return node;
      }

      return inner.call.apply(inner, [this, node, isBinding].concat(args));
    };
  });
};

/* eslint max-len: 0 */

var primitiveTypes = ["any", "mixed", "empty", "bool", "boolean", "number", "string", "void", "null"];

var pp$8 = Parser.prototype;

pp$8.flowParseTypeInitialiser = function (tok) {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(tok || types.colon);

  var type = this.flowParseType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParsePredicate = function () {
  var node = this.startNode();
  var moduloLoc = this.state.startLoc;
  var moduloPos = this.state.start;
  this.expect(types.modulo);
  var checksLoc = this.state.startLoc;
  this.expectContextual("checks");
  // Force '%' and 'checks' to be adjacent
  if (moduloLoc.line !== checksLoc.line || moduloLoc.column !== checksLoc.column - 1) {
    this.raise(moduloPos, "Spaces between % and checks are not allowed here.");
  }
  if (this.eat(types.parenL)) {
    node.value = this.parseExpression();
    this.expect(types.parenR);
    return this.finishNode(node, "DeclaredPredicate");
  } else {
    return this.finishNode(node, "InferredPredicate");
  }
};

pp$8.flowParseTypeAndPredicateInitialiser = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  this.expect(types.colon);
  var type = null;
  var predicate = null;
  if (this.match(types.modulo)) {
    this.state.inType = oldInType;
    predicate = this.flowParsePredicate();
  } else {
    type = this.flowParseType();
    this.state.inType = oldInType;
    if (this.match(types.modulo)) {
      predicate = this.flowParsePredicate();
    }
  }
  return [type, predicate];
};

pp$8.flowParseDeclareClass = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareClass");
};

pp$8.flowParseDeclareFunction = function (node) {
  this.next();

  var id = node.id = this.parseIdentifier();

  var typeNode = this.startNode();
  var typeContainer = this.startNode();

  if (this.isRelational("<")) {
    typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    typeNode.typeParameters = null;
  }

  this.expect(types.parenL);
  var tmp = this.flowParseFunctionTypeParams();
  typeNode.params = tmp.params;
  typeNode.rest = tmp.rest;
  this.expect(types.parenR);

  var _flowParseTypeAndPred = this.flowParseTypeAndPredicateInitialiser();

  typeNode.returnType = _flowParseTypeAndPred[0];
  node.predicate = _flowParseTypeAndPred[1];

  typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");

  id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");

  this.finishNode(id, id.type);

  this.semicolon();

  return this.finishNode(node, "DeclareFunction");
};

pp$8.flowParseDeclare = function (node) {
  if (this.match(types._class)) {
    return this.flowParseDeclareClass(node);
  } else if (this.match(types._function)) {
    return this.flowParseDeclareFunction(node);
  } else if (this.match(types._var)) {
    return this.flowParseDeclareVariable(node);
  } else if (this.isContextual("module")) {
    if (this.lookahead().type === types.dot) {
      return this.flowParseDeclareModuleExports(node);
    } else {
      return this.flowParseDeclareModule(node);
    }
  } else if (this.isContextual("type")) {
    return this.flowParseDeclareTypeAlias(node);
  } else if (this.isContextual("interface")) {
    return this.flowParseDeclareInterface(node);
  } else {
    this.unexpected();
  }
};

pp$8.flowParseDeclareVariable = function (node) {
  this.next();
  node.id = this.flowParseTypeAnnotatableIdentifier();
  this.semicolon();
  return this.finishNode(node, "DeclareVariable");
};

pp$8.flowParseDeclareModule = function (node) {
  this.next();

  if (this.match(types.string)) {
    node.id = this.parseExprAtom();
  } else {
    node.id = this.parseIdentifier();
  }

  var bodyNode = node.body = this.startNode();
  var body = bodyNode.body = [];
  this.expect(types.braceL);
  while (!this.match(types.braceR)) {
    var _bodyNode = this.startNode();

    if (this.match(types._import)) {
      var lookahead = this.lookahead();
      if (lookahead.value !== "type" && lookahead.value !== "typeof") {
        this.unexpected(null, "Imports within a `declare module` body must always be `import type` or `import typeof`");
      }

      this.parseImport(_bodyNode);
    } else {
      this.expectContextual("declare", "Only declares and type imports are allowed inside declare module");

      _bodyNode = this.flowParseDeclare(_bodyNode, true);
    }

    body.push(_bodyNode);
  }
  this.expect(types.braceR);

  this.finishNode(bodyNode, "BlockStatement");
  return this.finishNode(node, "DeclareModule");
};

pp$8.flowParseDeclareModuleExports = function (node) {
  this.expectContextual("module");
  this.expect(types.dot);
  this.expectContextual("exports");
  node.typeAnnotation = this.flowParseTypeAnnotation();
  this.semicolon();

  return this.finishNode(node, "DeclareModuleExports");
};

pp$8.flowParseDeclareTypeAlias = function (node) {
  this.next();
  this.flowParseTypeAlias(node);
  return this.finishNode(node, "DeclareTypeAlias");
};

pp$8.flowParseDeclareInterface = function (node) {
  this.next();
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "DeclareInterface");
};

// Interfaces

pp$8.flowParseInterfaceish = function (node) {
  node.id = this.parseIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.extends = [];
  node.mixins = [];

  if (this.eat(types._extends)) {
    do {
      node.extends.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  if (this.isContextual("mixins")) {
    this.next();
    do {
      node.mixins.push(this.flowParseInterfaceExtends());
    } while (this.eat(types.comma));
  }

  node.body = this.flowParseObjectType(true, false, false);
};

pp$8.flowParseInterfaceExtends = function () {
  var node = this.startNode();

  node.id = this.flowParseQualifiedTypeIdentifier();
  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  } else {
    node.typeParameters = null;
  }

  return this.finishNode(node, "InterfaceExtends");
};

pp$8.flowParseInterface = function (node) {
  this.flowParseInterfaceish(node);
  return this.finishNode(node, "InterfaceDeclaration");
};

pp$8.flowParseRestrictedIdentifier = function (liberal) {
  if (primitiveTypes.indexOf(this.state.value) > -1) {
    this.raise(this.state.start, "Cannot overwrite primitive type " + this.state.value);
  }

  return this.parseIdentifier(liberal);
};

// Type aliases

pp$8.flowParseTypeAlias = function (node) {
  node.id = this.flowParseRestrictedIdentifier();

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  } else {
    node.typeParameters = null;
  }

  node.right = this.flowParseTypeInitialiser(types.eq);
  this.semicolon();

  return this.finishNode(node, "TypeAlias");
};

// Type annotations

pp$8.flowParseTypeParameter = function () {
  var node = this.startNode();

  var variance = this.flowParseVariance();

  var ident = this.flowParseTypeAnnotatableIdentifier();
  node.name = ident.name;
  node.variance = variance;
  node.bound = ident.typeAnnotation;

  if (this.match(types.eq)) {
    this.eat(types.eq);
    node.default = this.flowParseType();
  }

  return this.finishNode(node, "TypeParameter");
};

pp$8.flowParseTypeParameterDeclaration = function () {
  var oldInType = this.state.inType;
  var node = this.startNode();
  node.params = [];

  this.state.inType = true;

  // istanbul ignore else: this condition is already checked at all call sites
  if (this.isRelational("<") || this.match(types.jsxTagStart)) {
    this.next();
  } else {
    this.unexpected();
  }

  do {
    node.params.push(this.flowParseTypeParameter());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  } while (!this.isRelational(">"));
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterDeclaration");
};

pp$8.flowParseTypeParameterInstantiation = function () {
  var node = this.startNode();
  var oldInType = this.state.inType;
  node.params = [];

  this.state.inType = true;

  this.expectRelational("<");
  while (!this.isRelational(">")) {
    node.params.push(this.flowParseType());
    if (!this.isRelational(">")) {
      this.expect(types.comma);
    }
  }
  this.expectRelational(">");

  this.state.inType = oldInType;

  return this.finishNode(node, "TypeParameterInstantiation");
};

pp$8.flowParseObjectPropertyKey = function () {
  return this.match(types.num) || this.match(types.string) ? this.parseExprAtom() : this.parseIdentifier(true);
};

pp$8.flowParseObjectTypeIndexer = function (node, isStatic, variance) {
  node.static = isStatic;

  this.expect(types.bracketL);
  if (this.lookahead().type === types.colon) {
    node.id = this.flowParseObjectPropertyKey();
    node.key = this.flowParseTypeInitialiser();
  } else {
    node.id = null;
    node.key = this.flowParseType();
  }
  this.expect(types.bracketR);
  node.value = this.flowParseTypeInitialiser();
  node.variance = variance;

  // Finish node first to not include a possible semicolon in the locations
  var indexer = this.finishNode(node, "ObjectTypeIndexer");
  this.flowObjectTypeSemicolon();

  return indexer;
};

pp$8.flowParseObjectTypeMethodish = function (node) {
  node.params = [];
  node.rest = null;
  node.typeParameters = null;

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterDeclaration();
  }

  this.expect(types.parenL);
  while (this.match(types.name)) {
    node.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }

  if (this.eat(types.ellipsis)) {
    node.rest = this.flowParseFunctionTypeParam();
  }
  this.expect(types.parenR);
  node.returnType = this.flowParseTypeInitialiser();

  return this.finishNode(node, "FunctionTypeAnnotation");
};

pp$8.flowParseObjectTypeMethod = function (startPos, startLoc, isStatic, key) {
  var node = this.startNodeAt(startPos, startLoc);
  node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(startPos, startLoc));
  node.static = isStatic;
  node.key = key;
  node.optional = false;
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeProperty");
};

pp$8.flowParseObjectTypeCallProperty = function (node, isStatic) {
  var valueNode = this.startNode();
  node.static = isStatic;
  node.value = this.flowParseObjectTypeMethodish(valueNode);
  this.flowObjectTypeSemicolon();
  return this.finishNode(node, "ObjectTypeCallProperty");
};

pp$8.flowParseObjectType = function (allowStatic, allowExact, allowSpread) {
  var oldInType = this.state.inType;
  this.state.inType = true;

  var nodeStart = this.startNode();
  var node = void 0;
  var propertyKey = void 0;
  var isStatic = false;

  nodeStart.callProperties = [];
  nodeStart.properties = [];
  nodeStart.indexers = [];

  var endDelim = void 0;
  var exact = void 0;
  if (allowExact && this.match(types.braceBarL)) {
    this.expect(types.braceBarL);
    endDelim = types.braceBarR;
    exact = true;
  } else {
    this.expect(types.braceL);
    endDelim = types.braceR;
    exact = false;
  }

  nodeStart.exact = exact;

  while (!this.match(endDelim)) {
    var optional = false;
    var startPos = this.state.start;
    var startLoc = this.state.startLoc;
    node = this.startNode();
    if (allowStatic && this.isContextual("static") && this.lookahead().type !== types.colon) {
      this.next();
      isStatic = true;
    }

    var variance = this.flowParseVariance();

    if (this.match(types.bracketL)) {
      nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
    } else if (this.match(types.parenL) || this.isRelational("<")) {
      if (variance) {
        this.unexpected(variance.start);
      }
      nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
    } else {
      if (this.match(types.ellipsis)) {
        if (!allowSpread) {
          this.unexpected(null, "Spread operator cannnot appear in class or interface definitions");
        }
        if (variance) {
          this.unexpected(variance.start, "Spread properties cannot have variance");
        }
        this.expect(types.ellipsis);
        node.argument = this.flowParseType();
        this.flowObjectTypeSemicolon();
        nodeStart.properties.push(this.finishNode(node, "ObjectTypeSpreadProperty"));
      } else {
        propertyKey = this.flowParseObjectPropertyKey();
        if (this.isRelational("<") || this.match(types.parenL)) {
          // This is a method property
          if (variance) {
            this.unexpected(variance.start);
          }
          nodeStart.properties.push(this.flowParseObjectTypeMethod(startPos, startLoc, isStatic, propertyKey));
        } else {
          if (this.eat(types.question)) {
            optional = true;
          }
          node.key = propertyKey;
          node.value = this.flowParseTypeInitialiser();
          node.optional = optional;
          node.static = isStatic;
          node.variance = variance;
          this.flowObjectTypeSemicolon();
          nodeStart.properties.push(this.finishNode(node, "ObjectTypeProperty"));
        }
      }
    }

    isStatic = false;
  }

  this.expect(endDelim);

  var out = this.finishNode(nodeStart, "ObjectTypeAnnotation");

  this.state.inType = oldInType;

  return out;
};

pp$8.flowObjectTypeSemicolon = function () {
  if (!this.eat(types.semi) && !this.eat(types.comma) && !this.match(types.braceR) && !this.match(types.braceBarR)) {
    this.unexpected();
  }
};

pp$8.flowParseQualifiedTypeIdentifier = function (startPos, startLoc, id) {
  startPos = startPos || this.state.start;
  startLoc = startLoc || this.state.startLoc;
  var node = id || this.parseIdentifier();

  while (this.eat(types.dot)) {
    var node2 = this.startNodeAt(startPos, startLoc);
    node2.qualification = node;
    node2.id = this.parseIdentifier();
    node = this.finishNode(node2, "QualifiedTypeIdentifier");
  }

  return node;
};

pp$8.flowParseGenericType = function (startPos, startLoc, id) {
  var node = this.startNodeAt(startPos, startLoc);

  node.typeParameters = null;
  node.id = this.flowParseQualifiedTypeIdentifier(startPos, startLoc, id);

  if (this.isRelational("<")) {
    node.typeParameters = this.flowParseTypeParameterInstantiation();
  }

  return this.finishNode(node, "GenericTypeAnnotation");
};

pp$8.flowParseTypeofType = function () {
  var node = this.startNode();
  this.expect(types._typeof);
  node.argument = this.flowParsePrimaryType();
  return this.finishNode(node, "TypeofTypeAnnotation");
};

pp$8.flowParseTupleType = function () {
  var node = this.startNode();
  node.types = [];
  this.expect(types.bracketL);
  // We allow trailing commas
  while (this.state.pos < this.input.length && !this.match(types.bracketR)) {
    node.types.push(this.flowParseType());
    if (this.match(types.bracketR)) break;
    this.expect(types.comma);
  }
  this.expect(types.bracketR);
  return this.finishNode(node, "TupleTypeAnnotation");
};

pp$8.flowParseFunctionTypeParam = function () {
  var name = null;
  var optional = false;
  var typeAnnotation = null;
  var node = this.startNode();
  var lh = this.lookahead();
  if (lh.type === types.colon || lh.type === types.question) {
    name = this.parseIdentifier();
    if (this.eat(types.question)) {
      optional = true;
    }
    typeAnnotation = this.flowParseTypeInitialiser();
  } else {
    typeAnnotation = this.flowParseType();
  }
  node.name = name;
  node.optional = optional;
  node.typeAnnotation = typeAnnotation;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.reinterpretTypeAsFunctionTypeParam = function (type) {
  var node = this.startNodeAt(type.start, type.loc);
  node.name = null;
  node.optional = false;
  node.typeAnnotation = type;
  return this.finishNode(node, "FunctionTypeParam");
};

pp$8.flowParseFunctionTypeParams = function () {
  var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

  var ret = { params: params, rest: null };
  while (!this.match(types.parenR) && !this.match(types.ellipsis)) {
    ret.params.push(this.flowParseFunctionTypeParam());
    if (!this.match(types.parenR)) {
      this.expect(types.comma);
    }
  }
  if (this.eat(types.ellipsis)) {
    ret.rest = this.flowParseFunctionTypeParam();
  }
  return ret;
};

pp$8.flowIdentToTypeAnnotation = function (startPos, startLoc, node, id) {
  switch (id.name) {
    case "any":
      return this.finishNode(node, "AnyTypeAnnotation");

    case "void":
      return this.finishNode(node, "VoidTypeAnnotation");

    case "bool":
    case "boolean":
      return this.finishNode(node, "BooleanTypeAnnotation");

    case "mixed":
      return this.finishNode(node, "MixedTypeAnnotation");

    case "empty":
      return this.finishNode(node, "EmptyTypeAnnotation");

    case "number":
      return this.finishNode(node, "NumberTypeAnnotation");

    case "string":
      return this.finishNode(node, "StringTypeAnnotation");

    default:
      return this.flowParseGenericType(startPos, startLoc, id);
  }
};

// The parsing of types roughly parallels the parsing of expressions, and
// primary types are kind of like primary expressions...they're the
// primitives with which other types are constructed.
pp$8.flowParsePrimaryType = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.startNode();
  var tmp = void 0;
  var type = void 0;
  var isGroupedType = false;
  var oldNoAnonFunctionType = this.state.noAnonFunctionType;

  switch (this.state.type) {
    case types.name:
      return this.flowIdentToTypeAnnotation(startPos, startLoc, node, this.parseIdentifier());

    case types.braceL:
      return this.flowParseObjectType(false, false, true);

    case types.braceBarL:
      return this.flowParseObjectType(false, true, true);

    case types.bracketL:
      return this.flowParseTupleType();

    case types.relational:
      if (this.state.value === "<") {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
        this.expect(types.parenL);
        tmp = this.flowParseFunctionTypeParams();
        node.params = tmp.params;
        node.rest = tmp.rest;
        this.expect(types.parenR);

        this.expect(types.arrow);

        node.returnType = this.flowParseType();

        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      break;

    case types.parenL:
      this.next();

      // Check to see if this is actually a grouped type
      if (!this.match(types.parenR) && !this.match(types.ellipsis)) {
        if (this.match(types.name)) {
          var token = this.lookahead().type;
          isGroupedType = token !== types.question && token !== types.colon;
        } else {
          isGroupedType = true;
        }
      }

      if (isGroupedType) {
        this.state.noAnonFunctionType = false;
        type = this.flowParseType();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;

        // A `,` or a `) =>` means this is an anonymous function type
        if (this.state.noAnonFunctionType || !(this.match(types.comma) || this.match(types.parenR) && this.lookahead().type === types.arrow)) {
          this.expect(types.parenR);
          return type;
        } else {
          // Eat a comma if there is one
          this.eat(types.comma);
        }
      }

      if (type) {
        tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
      } else {
        tmp = this.flowParseFunctionTypeParams();
      }

      node.params = tmp.params;
      node.rest = tmp.rest;

      this.expect(types.parenR);

      this.expect(types.arrow);

      node.returnType = this.flowParseType();

      node.typeParameters = null;

      return this.finishNode(node, "FunctionTypeAnnotation");

    case types.string:
      return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");

    case types._true:case types._false:
      node.value = this.match(types._true);
      this.next();
      return this.finishNode(node, "BooleanLiteralTypeAnnotation");

    case types.plusMin:
      if (this.state.value === "-") {
        this.next();
        if (!this.match(types.num)) this.unexpected(null, "Unexpected token, expected number");

        return this.parseLiteral(-this.state.value, "NumberLiteralTypeAnnotation", node.start, node.loc.start);
      }

      this.unexpected();
    case types.num:
      return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");

    case types._null:
      node.value = this.match(types._null);
      this.next();
      return this.finishNode(node, "NullLiteralTypeAnnotation");

    case types._this:
      node.value = this.match(types._this);
      this.next();
      return this.finishNode(node, "ThisTypeAnnotation");

    case types.star:
      this.next();
      return this.finishNode(node, "ExistsTypeAnnotation");

    default:
      if (this.state.type.keyword === "typeof") {
        return this.flowParseTypeofType();
      }
  }

  this.unexpected();
};

pp$8.flowParsePostfixType = function () {
  var startPos = this.state.start,
      startLoc = this.state.startLoc;
  var type = this.flowParsePrimaryType();
  while (!this.canInsertSemicolon() && this.match(types.bracketL)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.elementType = type;
    this.expect(types.bracketL);
    this.expect(types.bracketR);
    type = this.finishNode(node, "ArrayTypeAnnotation");
  }
  return type;
};

pp$8.flowParsePrefixType = function () {
  var node = this.startNode();
  if (this.eat(types.question)) {
    node.typeAnnotation = this.flowParsePrefixType();
    return this.finishNode(node, "NullableTypeAnnotation");
  } else {
    return this.flowParsePostfixType();
  }
};

pp$8.flowParseAnonFunctionWithoutParens = function () {
  var param = this.flowParsePrefixType();
  if (!this.state.noAnonFunctionType && this.eat(types.arrow)) {
    var node = this.startNodeAt(param.start, param.loc);
    node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
    node.rest = null;
    node.returnType = this.flowParseType();
    node.typeParameters = null;
    return this.finishNode(node, "FunctionTypeAnnotation");
  }
  return param;
};

pp$8.flowParseIntersectionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseAND);
  var type = this.flowParseAnonFunctionWithoutParens();
  node.types = [type];
  while (this.eat(types.bitwiseAND)) {
    node.types.push(this.flowParseAnonFunctionWithoutParens());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
};

pp$8.flowParseUnionType = function () {
  var node = this.startNode();
  this.eat(types.bitwiseOR);
  var type = this.flowParseIntersectionType();
  node.types = [type];
  while (this.eat(types.bitwiseOR)) {
    node.types.push(this.flowParseIntersectionType());
  }
  return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
};

pp$8.flowParseType = function () {
  var oldInType = this.state.inType;
  this.state.inType = true;
  var type = this.flowParseUnionType();
  this.state.inType = oldInType;
  return type;
};

pp$8.flowParseTypeAnnotation = function () {
  var node = this.startNode();
  node.typeAnnotation = this.flowParseTypeInitialiser();
  return this.finishNode(node, "TypeAnnotation");
};

pp$8.flowParseTypeAnnotatableIdentifier = function () {
  var ident = this.flowParseRestrictedIdentifier();
  if (this.match(types.colon)) {
    ident.typeAnnotation = this.flowParseTypeAnnotation();
    this.finishNode(ident, ident.type);
  }
  return ident;
};

pp$8.typeCastToParameter = function (node) {
  node.expression.typeAnnotation = node.typeAnnotation;

  return this.finishNodeAt(node.expression, node.expression.type, node.typeAnnotation.end, node.typeAnnotation.loc.end);
};

pp$8.flowParseVariance = function () {
  var variance = null;
  if (this.match(types.plusMin)) {
    variance = this.startNode();
    if (this.state.value === "+") {
      variance.kind = "plus";
    } else {
      variance.kind = "minus";
    }
    this.next();
    this.finishNode(variance, "Variance");
  }
  return variance;
};

var flowPlugin = function (instance) {
  // plain function return types: function name(): string {}
  instance.extend("parseFunctionBody", function (inner) {
    return function (node, allowExpression) {
      if (this.match(types.colon) && !allowExpression) {
        // if allowExpression is true then we're parsing an arrow function and if
        // there's a return type then it's been handled elsewhere
        var typeNode = this.startNode();

        var _flowParseTypeAndPred2 = this.flowParseTypeAndPredicateInitialiser();

        typeNode.typeAnnotation = _flowParseTypeAndPred2[0];
        node.predicate = _flowParseTypeAndPred2[1];


        node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
      }

      return inner.call(this, node, allowExpression);
    };
  });

  // interfaces
  instance.extend("parseStatement", function (inner) {
    return function (declaration, topLevel) {
      // strict mode handling of `interface` since it's a reserved word
      if (this.state.strict && this.match(types.name) && this.state.value === "interface") {
        var node = this.startNode();
        this.next();
        return this.flowParseInterface(node);
      } else {
        return inner.call(this, declaration, topLevel);
      }
    };
  });

  // declares, interfaces and type aliases
  instance.extend("parseExpressionStatement", function (inner) {
    return function (node, expr) {
      if (expr.type === "Identifier") {
        if (expr.name === "declare") {
          if (this.match(types._class) || this.match(types.name) || this.match(types._function) || this.match(types._var)) {
            return this.flowParseDeclare(node);
          }
        } else if (this.match(types.name)) {
          if (expr.name === "interface") {
            return this.flowParseInterface(node);
          } else if (expr.name === "type") {
            return this.flowParseTypeAlias(node);
          }
        }
      }

      return inner.call(this, node, expr);
    };
  });

  // export type
  instance.extend("shouldParseExportDeclaration", function (inner) {
    return function () {
      return this.isContextual("type") || this.isContextual("interface") || inner.call(this);
    };
  });

  instance.extend("parseConditional", function (inner) {
    return function (expr, noIn, startPos, startLoc, refNeedsArrowPos) {
      // only do the expensive clone if there is a question mark
      // and if we come from inside parens
      if (refNeedsArrowPos && this.match(types.question)) {
        var state = this.state.clone();
        try {
          return inner.call(this, expr, noIn, startPos, startLoc);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            refNeedsArrowPos.start = err.pos || this.state.start;
            return expr;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, expr, noIn, startPos, startLoc);
    };
  });

  instance.extend("parseParenItem", function (inner) {
    return function (node, startPos, startLoc) {
      node = inner.call(this, node, startPos, startLoc);
      if (this.eat(types.question)) {
        node.optional = true;
      }

      if (this.match(types.colon)) {
        var typeCastNode = this.startNodeAt(startPos, startLoc);
        typeCastNode.expression = node;
        typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();

        return this.finishNode(typeCastNode, "TypeCastExpression");
      }

      return node;
    };
  });

  instance.extend("parseExport", function (inner) {
    return function (node) {
      node = inner.call(this, node);
      if (node.type === "ExportNamedDeclaration") {
        node.exportKind = node.exportKind || "value";
      }
      return node;
    };
  });

  instance.extend("parseExportDeclaration", function (inner) {
    return function (node) {
      if (this.isContextual("type")) {
        node.exportKind = "type";

        var declarationNode = this.startNode();
        this.next();

        if (this.match(types.braceL)) {
          // export type { foo, bar };
          node.specifiers = this.parseExportSpecifiers();
          this.parseExportFrom(node);
          return null;
        } else {
          // export type Foo = Bar;
          return this.flowParseTypeAlias(declarationNode);
        }
      } else if (this.isContextual("interface")) {
        node.exportKind = "type";
        var _declarationNode = this.startNode();
        this.next();
        return this.flowParseInterface(_declarationNode);
      } else {
        return inner.call(this, node);
      }
    };
  });

  instance.extend("parseClassId", function (inner) {
    return function (node) {
      inner.apply(this, arguments);
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
    };
  });

  // don't consider `void` to be a keyword as then it'll use the void token type
  // and set startExpr
  instance.extend("isKeyword", function (inner) {
    return function (name) {
      if (this.state.inType && name === "void") {
        return false;
      } else {
        return inner.call(this, name);
      }
    };
  });

  // ensure that inside flow types, we bypass the jsx parser plugin
  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inType && (code === 62 || code === 60)) {
        return this.finishOp(types.relational, 1);
      } else {
        return inner.call(this, code);
      }
    };
  });

  // don't lex any token as a jsx one inside a flow type
  instance.extend("jsx_readToken", function (inner) {
    return function () {
      if (!this.state.inType) return inner.call(this);
    };
  });

  instance.extend("toAssignable", function (inner) {
    return function (node, isBinding, contextDescription) {
      if (node.type === "TypeCastExpression") {
        return inner.call(this, this.typeCastToParameter(node), isBinding, contextDescription);
      } else {
        return inner.call(this, node, isBinding, contextDescription);
      }
    };
  });

  // turn type casts that we found in function parameter head into type annotated params
  instance.extend("toAssignableList", function (inner) {
    return function (exprList, isBinding, contextDescription) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr.type === "TypeCastExpression") {
          exprList[i] = this.typeCastToParameter(expr);
        }
      }
      return inner.call(this, exprList, isBinding, contextDescription);
    };
  });

  // this is a list of nodes, from something like a call expression, we need to filter the
  // type casts that we've found that are illegal in this context
  instance.extend("toReferencedList", function () {
    return function (exprList) {
      for (var i = 0; i < exprList.length; i++) {
        var expr = exprList[i];
        if (expr && expr._exprListItem && expr.type === "TypeCastExpression") {
          this.raise(expr.start, "Unexpected type cast");
        }
      }

      return exprList;
    };
  });

  // parse an item inside a expression list eg. `(NODE, NODE)` where NODE represents
  // the position where this function is called
  instance.extend("parseExprListItem", function (inner) {
    return function () {
      var container = this.startNode();

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var node = inner.call.apply(inner, [this].concat(args));
      if (this.match(types.colon)) {
        container._exprListItem = true;
        container.expression = node;
        container.typeAnnotation = this.flowParseTypeAnnotation();
        return this.finishNode(container, "TypeCastExpression");
      } else {
        return node;
      }
    };
  });

  instance.extend("checkLVal", function (inner) {
    return function (node) {
      if (node.type !== "TypeCastExpression") {
        return inner.apply(this, arguments);
      }
    };
  });

  // parse class property type annotations
  instance.extend("parseClassProperty", function (inner) {
    return function (node) {
      if (this.match(types.colon)) {
        node.typeAnnotation = this.flowParseTypeAnnotation();
      }
      return inner.call(this, node);
    };
  });

  // determine whether or not we're currently in the position where a class method would appear
  instance.extend("isClassMethod", function (inner) {
    return function () {
      return this.isRelational("<") || inner.call(this);
    };
  });

  // determine whether or not we're currently in the position where a class property would appear
  instance.extend("isClassProperty", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // parse type parameters for class methods
  instance.extend("parseClassMethod", function (inner) {
    return function (classBody, method) {
      if (method.variance) {
        this.unexpected(method.variance.start);
      }
      delete method.variance;
      if (this.isRelational("<")) {
        method.typeParameters = this.flowParseTypeParameterDeclaration();
      }

      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      inner.call.apply(inner, [this, classBody, method].concat(args));
    };
  });

  // parse a the super class type parameters and implements
  instance.extend("parseClassSuper", function (inner) {
    return function (node, isStatement) {
      inner.call(this, node, isStatement);
      if (node.superClass && this.isRelational("<")) {
        node.superTypeParameters = this.flowParseTypeParameterInstantiation();
      }
      if (this.isContextual("implements")) {
        this.next();
        var implemented = node.implements = [];
        do {
          var _node = this.startNode();
          _node.id = this.parseIdentifier();
          if (this.isRelational("<")) {
            _node.typeParameters = this.flowParseTypeParameterInstantiation();
          } else {
            _node.typeParameters = null;
          }
          implemented.push(this.finishNode(_node, "ClassImplements"));
        } while (this.eat(types.comma));
      }
    };
  });

  instance.extend("parsePropertyName", function (inner) {
    return function (node) {
      var variance = this.flowParseVariance();
      var key = inner.call(this, node);
      node.variance = variance;
      return key;
    };
  });

  // parse type parameters for object method shorthand
  instance.extend("parseObjPropValue", function (inner) {
    return function (prop) {
      if (prop.variance) {
        this.unexpected(prop.variance.start);
      }
      delete prop.variance;

      var typeParameters = void 0;

      // method shorthand
      if (this.isRelational("<")) {
        typeParameters = this.flowParseTypeParameterDeclaration();
        if (!this.match(types.parenL)) this.unexpected();
      }

      inner.apply(this, arguments);

      // add typeParameters if we found them
      if (typeParameters) {
        (prop.value || prop).typeParameters = typeParameters;
      }
    };
  });

  instance.extend("parseAssignableListItemTypes", function () {
    return function (param) {
      if (this.eat(types.question)) {
        param.optional = true;
      }
      if (this.match(types.colon)) {
        param.typeAnnotation = this.flowParseTypeAnnotation();
      }
      this.finishNode(param, param.type);
      return param;
    };
  });

  instance.extend("parseMaybeDefault", function (inner) {
    return function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      var node = inner.apply(this, args);

      if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
        this.raise(node.typeAnnotation.start, "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`");
      }

      return node;
    };
  });

  // parse typeof and type imports
  instance.extend("parseImportSpecifiers", function (inner) {
    return function (node) {
      node.importKind = "value";

      var kind = null;
      if (this.match(types._typeof)) {
        kind = "typeof";
      } else if (this.isContextual("type")) {
        kind = "type";
      }
      if (kind) {
        var lh = this.lookahead();
        if (lh.type === types.name && lh.value !== "from" || lh.type === types.braceL || lh.type === types.star) {
          this.next();
          node.importKind = kind;
        }
      }

      inner.call(this, node);
    };
  });

  // parse import-type/typeof shorthand
  instance.extend("parseImportSpecifier", function () {
    return function (node) {
      var specifier = this.startNode();
      var firstIdentLoc = this.state.start;
      var firstIdent = this.parseIdentifier(true);

      var specifierTypeKind = null;
      if (firstIdent.name === "type") {
        specifierTypeKind = "type";
      } else if (firstIdent.name === "typeof") {
        specifierTypeKind = "typeof";
      }

      var isBinding = false;
      if (this.isContextual("as")) {
        var as_ident = this.parseIdentifier(true);
        if (specifierTypeKind !== null && !this.match(types.name) && !this.state.type.keyword) {
          // `import {type as ,` or `import {type as }`
          specifier.imported = as_ident;
          specifier.importKind = specifierTypeKind;
          specifier.local = as_ident.__clone();
        } else {
          // `import {type as foo`
          specifier.imported = firstIdent;
          specifier.importKind = null;
          specifier.local = this.parseIdentifier();
        }
      } else if (specifierTypeKind !== null && (this.match(types.name) || this.state.type.keyword)) {
        // `import {type foo`
        specifier.imported = this.parseIdentifier(true);
        specifier.importKind = specifierTypeKind;
        if (this.eatContextual("as")) {
          specifier.local = this.parseIdentifier();
        } else {
          isBinding = true;
          specifier.local = specifier.imported.__clone();
        }
      } else {
        isBinding = true;
        specifier.imported = firstIdent;
        specifier.importKind = null;
        specifier.local = specifier.imported.__clone();
      }

      if ((node.importKind === "type" || node.importKind === "typeof") && (specifier.importKind === "type" || specifier.importKind === "typeof")) {
        this.raise(firstIdentLoc, "`The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements`");
      }

      if (isBinding) this.checkReservedWord(specifier.local.name, specifier.start, true, true);

      this.checkLVal(specifier.local, true, undefined, "import specifier");
      node.specifiers.push(this.finishNode(specifier, "ImportSpecifier"));
    };
  });

  // parse function type parameters - function foo<T>() {}
  instance.extend("parseFunctionParams", function (inner) {
    return function (node) {
      if (this.isRelational("<")) {
        node.typeParameters = this.flowParseTypeParameterDeclaration();
      }
      inner.call(this, node);
    };
  });

  // parse flow type annotations on variable declarator heads - let foo: string = bar
  instance.extend("parseVarHead", function (inner) {
    return function (decl) {
      inner.call(this, decl);
      if (this.match(types.colon)) {
        decl.id.typeAnnotation = this.flowParseTypeAnnotation();
        this.finishNode(decl.id, decl.id.type);
      }
    };
  });

  // parse the return type of an async arrow function - let foo = (async (): number => {});
  instance.extend("parseAsyncArrowFromCallExpression", function (inner) {
    return function (node, call) {
      if (this.match(types.colon)) {
        var oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = true;
        node.returnType = this.flowParseTypeAnnotation();
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
      }

      return inner.call(this, node, call);
    };
  });

  // todo description
  instance.extend("shouldParseAsyncArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });

  // We need to support type parameter declarations for arrow functions. This
  // is tricky. There are three situations we need to handle
  //
  // 1. This is either JSX or an arrow function. We'll try JSX first. If that
  //    fails, we'll try an arrow function. If that fails, we'll throw the JSX
  //    error.
  // 2. This is an arrow function. We'll parse the type parameter declaration,
  //    parse the rest, make sure the rest is an arrow function, and go from
  //    there
  // 3. This is neither. Just call the inner function
  instance.extend("parseMaybeAssign", function (inner) {
    return function () {
      var jsxError = null;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (types.jsxTagStart && this.match(types.jsxTagStart)) {
        var state = this.state.clone();
        try {
          return inner.apply(this, args);
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
            jsxError = err;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      if (jsxError != null || this.isRelational("<")) {
        // Need to push something onto the context to stop
        // the JSX plugin from messing with the tokens
        this.state.context.push(types$1.parenExpression);
        var arrowExpression = void 0;
        var typeParameters = void 0;
        try {
          typeParameters = this.flowParseTypeParameterDeclaration();

          arrowExpression = inner.apply(this, args);
          arrowExpression.typeParameters = typeParameters;
          this.resetStartLocationFromNode(arrowExpression, typeParameters);
        } catch (err) {
          this.state.context.pop();

          throw jsxError || err;
        }

        this.state.context.pop();

        if (arrowExpression.type === "ArrowFunctionExpression") {
          return arrowExpression;
        } else if (jsxError != null) {
          throw jsxError;
        } else {
          this.raise(typeParameters.start, "Expected an arrow function after this type parameter declaration");
        }
      }

      return inner.apply(this, args);
    };
  });

  // handle return types for arrow functions
  instance.extend("parseArrow", function (inner) {
    return function (node) {
      if (this.match(types.colon)) {
        var state = this.state.clone();
        try {
          var oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;

          var typeNode = this.startNode();

          var _flowParseTypeAndPred3 = this.flowParseTypeAndPredicateInitialiser();

          typeNode.typeAnnotation = _flowParseTypeAndPred3[0];
          node.predicate = _flowParseTypeAndPred3[1];


          this.state.noAnonFunctionType = oldNoAnonFunctionType;

          if (this.canInsertSemicolon()) this.unexpected();
          if (!this.match(types.arrow)) this.unexpected();

          // assign after it is clear it is an arrow
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        } catch (err) {
          if (err instanceof SyntaxError) {
            this.state = state;
          } else {
            // istanbul ignore next: no such error is expected
            throw err;
          }
        }
      }

      return inner.call(this, node);
    };
  });

  instance.extend("shouldParseArrow", function (inner) {
    return function () {
      return this.match(types.colon) || inner.call(this);
    };
  });
};

var XHTMLEntities = {
  quot: "\"",
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: "\xA0",
  iexcl: "\xA1",
  cent: "\xA2",
  pound: "\xA3",
  curren: "\xA4",
  yen: "\xA5",
  brvbar: "\xA6",
  sect: "\xA7",
  uml: "\xA8",
  copy: "\xA9",
  ordf: "\xAA",
  laquo: "\xAB",
  not: "\xAC",
  shy: "\xAD",
  reg: "\xAE",
  macr: "\xAF",
  deg: "\xB0",
  plusmn: "\xB1",
  sup2: "\xB2",
  sup3: "\xB3",
  acute: "\xB4",
  micro: "\xB5",
  para: "\xB6",
  middot: "\xB7",
  cedil: "\xB8",
  sup1: "\xB9",
  ordm: "\xBA",
  raquo: "\xBB",
  frac14: "\xBC",
  frac12: "\xBD",
  frac34: "\xBE",
  iquest: "\xBF",
  Agrave: "\xC0",
  Aacute: "\xC1",
  Acirc: "\xC2",
  Atilde: "\xC3",
  Auml: "\xC4",
  Aring: "\xC5",
  AElig: "\xC6",
  Ccedil: "\xC7",
  Egrave: "\xC8",
  Eacute: "\xC9",
  Ecirc: "\xCA",
  Euml: "\xCB",
  Igrave: "\xCC",
  Iacute: "\xCD",
  Icirc: "\xCE",
  Iuml: "\xCF",
  ETH: "\xD0",
  Ntilde: "\xD1",
  Ograve: "\xD2",
  Oacute: "\xD3",
  Ocirc: "\xD4",
  Otilde: "\xD5",
  Ouml: "\xD6",
  times: "\xD7",
  Oslash: "\xD8",
  Ugrave: "\xD9",
  Uacute: "\xDA",
  Ucirc: "\xDB",
  Uuml: "\xDC",
  Yacute: "\xDD",
  THORN: "\xDE",
  szlig: "\xDF",
  agrave: "\xE0",
  aacute: "\xE1",
  acirc: "\xE2",
  atilde: "\xE3",
  auml: "\xE4",
  aring: "\xE5",
  aelig: "\xE6",
  ccedil: "\xE7",
  egrave: "\xE8",
  eacute: "\xE9",
  ecirc: "\xEA",
  euml: "\xEB",
  igrave: "\xEC",
  iacute: "\xED",
  icirc: "\xEE",
  iuml: "\xEF",
  eth: "\xF0",
  ntilde: "\xF1",
  ograve: "\xF2",
  oacute: "\xF3",
  ocirc: "\xF4",
  otilde: "\xF5",
  ouml: "\xF6",
  divide: "\xF7",
  oslash: "\xF8",
  ugrave: "\xF9",
  uacute: "\xFA",
  ucirc: "\xFB",
  uuml: "\xFC",
  yacute: "\xFD",
  thorn: "\xFE",
  yuml: "\xFF",
  OElig: "\u0152",
  oelig: "\u0153",
  Scaron: "\u0160",
  scaron: "\u0161",
  Yuml: "\u0178",
  fnof: "\u0192",
  circ: "\u02C6",
  tilde: "\u02DC",
  Alpha: "\u0391",
  Beta: "\u0392",
  Gamma: "\u0393",
  Delta: "\u0394",
  Epsilon: "\u0395",
  Zeta: "\u0396",
  Eta: "\u0397",
  Theta: "\u0398",
  Iota: "\u0399",
  Kappa: "\u039A",
  Lambda: "\u039B",
  Mu: "\u039C",
  Nu: "\u039D",
  Xi: "\u039E",
  Omicron: "\u039F",
  Pi: "\u03A0",
  Rho: "\u03A1",
  Sigma: "\u03A3",
  Tau: "\u03A4",
  Upsilon: "\u03A5",
  Phi: "\u03A6",
  Chi: "\u03A7",
  Psi: "\u03A8",
  Omega: "\u03A9",
  alpha: "\u03B1",
  beta: "\u03B2",
  gamma: "\u03B3",
  delta: "\u03B4",
  epsilon: "\u03B5",
  zeta: "\u03B6",
  eta: "\u03B7",
  theta: "\u03B8",
  iota: "\u03B9",
  kappa: "\u03BA",
  lambda: "\u03BB",
  mu: "\u03BC",
  nu: "\u03BD",
  xi: "\u03BE",
  omicron: "\u03BF",
  pi: "\u03C0",
  rho: "\u03C1",
  sigmaf: "\u03C2",
  sigma: "\u03C3",
  tau: "\u03C4",
  upsilon: "\u03C5",
  phi: "\u03C6",
  chi: "\u03C7",
  psi: "\u03C8",
  omega: "\u03C9",
  thetasym: "\u03D1",
  upsih: "\u03D2",
  piv: "\u03D6",
  ensp: "\u2002",
  emsp: "\u2003",
  thinsp: "\u2009",
  zwnj: "\u200C",
  zwj: "\u200D",
  lrm: "\u200E",
  rlm: "\u200F",
  ndash: "\u2013",
  mdash: "\u2014",
  lsquo: "\u2018",
  rsquo: "\u2019",
  sbquo: "\u201A",
  ldquo: "\u201C",
  rdquo: "\u201D",
  bdquo: "\u201E",
  dagger: "\u2020",
  Dagger: "\u2021",
  bull: "\u2022",
  hellip: "\u2026",
  permil: "\u2030",
  prime: "\u2032",
  Prime: "\u2033",
  lsaquo: "\u2039",
  rsaquo: "\u203A",
  oline: "\u203E",
  frasl: "\u2044",
  euro: "\u20AC",
  image: "\u2111",
  weierp: "\u2118",
  real: "\u211C",
  trade: "\u2122",
  alefsym: "\u2135",
  larr: "\u2190",
  uarr: "\u2191",
  rarr: "\u2192",
  darr: "\u2193",
  harr: "\u2194",
  crarr: "\u21B5",
  lArr: "\u21D0",
  uArr: "\u21D1",
  rArr: "\u21D2",
  dArr: "\u21D3",
  hArr: "\u21D4",
  forall: "\u2200",
  part: "\u2202",
  exist: "\u2203",
  empty: "\u2205",
  nabla: "\u2207",
  isin: "\u2208",
  notin: "\u2209",
  ni: "\u220B",
  prod: "\u220F",
  sum: "\u2211",
  minus: "\u2212",
  lowast: "\u2217",
  radic: "\u221A",
  prop: "\u221D",
  infin: "\u221E",
  ang: "\u2220",
  and: "\u2227",
  or: "\u2228",
  cap: "\u2229",
  cup: "\u222A",
  "int": "\u222B",
  there4: "\u2234",
  sim: "\u223C",
  cong: "\u2245",
  asymp: "\u2248",
  ne: "\u2260",
  equiv: "\u2261",
  le: "\u2264",
  ge: "\u2265",
  sub: "\u2282",
  sup: "\u2283",
  nsub: "\u2284",
  sube: "\u2286",
  supe: "\u2287",
  oplus: "\u2295",
  otimes: "\u2297",
  perp: "\u22A5",
  sdot: "\u22C5",
  lceil: "\u2308",
  rceil: "\u2309",
  lfloor: "\u230A",
  rfloor: "\u230B",
  lang: "\u2329",
  rang: "\u232A",
  loz: "\u25CA",
  spades: "\u2660",
  clubs: "\u2663",
  hearts: "\u2665",
  diams: "\u2666"
};

var HEX_NUMBER = /^[\da-fA-F]+$/;
var DECIMAL_NUMBER = /^\d+$/;

types$1.j_oTag = new TokContext("<tag", false);
types$1.j_cTag = new TokContext("</tag", false);
types$1.j_expr = new TokContext("<tag>...</tag>", true, true);

types.jsxName = new TokenType("jsxName");
types.jsxText = new TokenType("jsxText", { beforeExpr: true });
types.jsxTagStart = new TokenType("jsxTagStart", { startsExpr: true });
types.jsxTagEnd = new TokenType("jsxTagEnd");

types.jsxTagStart.updateContext = function () {
  this.state.context.push(types$1.j_expr); // treat as beginning of JSX expression
  this.state.context.push(types$1.j_oTag); // start opening tag context
  this.state.exprAllowed = false;
};

types.jsxTagEnd.updateContext = function (prevType) {
  var out = this.state.context.pop();
  if (out === types$1.j_oTag && prevType === types.slash || out === types$1.j_cTag) {
    this.state.context.pop();
    this.state.exprAllowed = this.curContext() === types$1.j_expr;
  } else {
    this.state.exprAllowed = true;
  }
};

var pp$9 = Parser.prototype;

// Reads inline JSX contents token.

pp$9.jsxReadToken = function () {
  var out = "";
  var chunkStart = this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated JSX contents");
    }

    var ch = this.input.charCodeAt(this.state.pos);

    switch (ch) {
      case 60: // "<"
      case 123:
        // "{"
        if (this.state.pos === this.state.start) {
          if (ch === 60 && this.state.exprAllowed) {
            ++this.state.pos;
            return this.finishToken(types.jsxTagStart);
          }
          return this.getTokenFromCode(ch);
        }
        out += this.input.slice(chunkStart, this.state.pos);
        return this.finishToken(types.jsxText, out);

      case 38:
        // "&"
        out += this.input.slice(chunkStart, this.state.pos);
        out += this.jsxReadEntity();
        chunkStart = this.state.pos;
        break;

      default:
        if (isNewLine(ch)) {
          out += this.input.slice(chunkStart, this.state.pos);
          out += this.jsxReadNewLine(true);
          chunkStart = this.state.pos;
        } else {
          ++this.state.pos;
        }
    }
  }
};

pp$9.jsxReadNewLine = function (normalizeCRLF) {
  var ch = this.input.charCodeAt(this.state.pos);
  var out = void 0;
  ++this.state.pos;
  if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
    ++this.state.pos;
    out = normalizeCRLF ? "\n" : "\r\n";
  } else {
    out = String.fromCharCode(ch);
  }
  ++this.state.curLine;
  this.state.lineStart = this.state.pos;

  return out;
};

pp$9.jsxReadString = function (quote) {
  var out = "";
  var chunkStart = ++this.state.pos;
  for (;;) {
    if (this.state.pos >= this.input.length) {
      this.raise(this.state.start, "Unterminated string constant");
    }

    var ch = this.input.charCodeAt(this.state.pos);
    if (ch === quote) break;
    if (ch === 38) {
      // "&"
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadEntity();
      chunkStart = this.state.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.state.pos);
      out += this.jsxReadNewLine(false);
      chunkStart = this.state.pos;
    } else {
      ++this.state.pos;
    }
  }
  out += this.input.slice(chunkStart, this.state.pos++);
  return this.finishToken(types.string, out);
};

pp$9.jsxReadEntity = function () {
  var str = "";
  var count = 0;
  var entity = void 0;
  var ch = this.input[this.state.pos];

  var startPos = ++this.state.pos;
  while (this.state.pos < this.input.length && count++ < 10) {
    ch = this.input[this.state.pos++];
    if (ch === ";") {
      if (str[0] === "#") {
        if (str[1] === "x") {
          str = str.substr(2);
          if (HEX_NUMBER.test(str)) entity = String.fromCodePoint(parseInt(str, 16));
        } else {
          str = str.substr(1);
          if (DECIMAL_NUMBER.test(str)) entity = String.fromCodePoint(parseInt(str, 10));
        }
      } else {
        entity = XHTMLEntities[str];
      }
      break;
    }
    str += ch;
  }
  if (!entity) {
    this.state.pos = startPos;
    return "&";
  }
  return entity;
};

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can"t contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

pp$9.jsxReadWord = function () {
  var ch = void 0;
  var start = this.state.pos;
  do {
    ch = this.input.charCodeAt(++this.state.pos);
  } while (isIdentifierChar(ch) || ch === 45); // "-"
  return this.finishToken(types.jsxName, this.input.slice(start, this.state.pos));
};

// Transforms JSX element name to string.

function getQualifiedJSXName(object) {
  if (object.type === "JSXIdentifier") {
    return object.name;
  }

  if (object.type === "JSXNamespacedName") {
    return object.namespace.name + ":" + object.name.name;
  }

  if (object.type === "JSXMemberExpression") {
    return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
  }
}

// Parse next token as JSX identifier

pp$9.jsxParseIdentifier = function () {
  var node = this.startNode();
  if (this.match(types.jsxName)) {
    node.name = this.state.value;
  } else if (this.state.type.keyword) {
    node.name = this.state.type.keyword;
  } else {
    this.unexpected();
  }
  this.next();
  return this.finishNode(node, "JSXIdentifier");
};

// Parse namespaced identifier.

pp$9.jsxParseNamespacedName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var name = this.jsxParseIdentifier();
  if (!this.eat(types.colon)) return name;

  var node = this.startNodeAt(startPos, startLoc);
  node.namespace = name;
  node.name = this.jsxParseIdentifier();
  return this.finishNode(node, "JSXNamespacedName");
};

// Parses element name in any form - namespaced, member
// or single identifier.

pp$9.jsxParseElementName = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  var node = this.jsxParseNamespacedName();
  while (this.eat(types.dot)) {
    var newNode = this.startNodeAt(startPos, startLoc);
    newNode.object = node;
    newNode.property = this.jsxParseIdentifier();
    node = this.finishNode(newNode, "JSXMemberExpression");
  }
  return node;
};

// Parses any type of JSX attribute value.

pp$9.jsxParseAttributeValue = function () {
  var node = void 0;
  switch (this.state.type) {
    case types.braceL:
      node = this.jsxParseExpressionContainer();
      if (node.expression.type === "JSXEmptyExpression") {
        this.raise(node.start, "JSX attributes must only be assigned a non-empty expression");
      } else {
        return node;
      }

    case types.jsxTagStart:
    case types.string:
      return this.parseExprAtom();

    default:
      this.raise(this.state.start, "JSX value should be either an expression or a quoted JSX text");
  }
};

// JSXEmptyExpression is unique type since it doesn't actually parse anything,
// and so it should start at the end of last read token (left brace) and finish
// at the beginning of the next one (right brace).

pp$9.jsxParseEmptyExpression = function () {
  var node = this.startNodeAt(this.state.lastTokEnd, this.state.lastTokEndLoc);
  return this.finishNodeAt(node, "JSXEmptyExpression", this.state.start, this.state.startLoc);
};

// Parse JSX spread child

pp$9.jsxParseSpreadChild = function () {
  var node = this.startNode();
  this.expect(types.braceL);
  this.expect(types.ellipsis);
  node.expression = this.parseExpression();
  this.expect(types.braceR);

  return this.finishNode(node, "JSXSpreadChild");
};

// Parses JSX expression enclosed into curly brackets.


pp$9.jsxParseExpressionContainer = function () {
  var node = this.startNode();
  this.next();
  if (this.match(types.braceR)) {
    node.expression = this.jsxParseEmptyExpression();
  } else {
    node.expression = this.parseExpression();
  }
  this.expect(types.braceR);
  return this.finishNode(node, "JSXExpressionContainer");
};

// Parses following JSX attribute name-value pair.

pp$9.jsxParseAttribute = function () {
  var node = this.startNode();
  if (this.eat(types.braceL)) {
    this.expect(types.ellipsis);
    node.argument = this.parseMaybeAssign();
    this.expect(types.braceR);
    return this.finishNode(node, "JSXSpreadAttribute");
  }
  node.name = this.jsxParseNamespacedName();
  node.value = this.eat(types.eq) ? this.jsxParseAttributeValue() : null;
  return this.finishNode(node, "JSXAttribute");
};

// Parses JSX opening tag starting after "<".

pp$9.jsxParseOpeningElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.attributes = [];
  node.name = this.jsxParseElementName();
  while (!this.match(types.slash) && !this.match(types.jsxTagEnd)) {
    node.attributes.push(this.jsxParseAttribute());
  }
  node.selfClosing = this.eat(types.slash);
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXOpeningElement");
};

// Parses JSX closing tag starting after "</".

pp$9.jsxParseClosingElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  node.name = this.jsxParseElementName();
  this.expect(types.jsxTagEnd);
  return this.finishNode(node, "JSXClosingElement");
};

// Parses entire JSX element, including it"s opening tag
// (starting after "<"), attributes, contents and closing tag.

pp$9.jsxParseElementAt = function (startPos, startLoc) {
  var node = this.startNodeAt(startPos, startLoc);
  var children = [];
  var openingElement = this.jsxParseOpeningElementAt(startPos, startLoc);
  var closingElement = null;

  if (!openingElement.selfClosing) {
    contents: for (;;) {
      switch (this.state.type) {
        case types.jsxTagStart:
          startPos = this.state.start;startLoc = this.state.startLoc;
          this.next();
          if (this.eat(types.slash)) {
            closingElement = this.jsxParseClosingElementAt(startPos, startLoc);
            break contents;
          }
          children.push(this.jsxParseElementAt(startPos, startLoc));
          break;

        case types.jsxText:
          children.push(this.parseExprAtom());
          break;

        case types.braceL:
          if (this.lookahead().type === types.ellipsis) {
            children.push(this.jsxParseSpreadChild());
          } else {
            children.push(this.jsxParseExpressionContainer());
          }

          break;

        // istanbul ignore next - should never happen
        default:
          this.unexpected();
      }
    }

    if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
      this.raise(closingElement.start, "Expected corresponding JSX closing tag for <" + getQualifiedJSXName(openingElement.name) + ">");
    }
  }

  node.openingElement = openingElement;
  node.closingElement = closingElement;
  node.children = children;
  if (this.match(types.relational) && this.state.value === "<") {
    this.raise(this.state.start, "Adjacent JSX elements must be wrapped in an enclosing tag");
  }
  return this.finishNode(node, "JSXElement");
};

// Parses entire JSX element from current position.

pp$9.jsxParseElement = function () {
  var startPos = this.state.start;
  var startLoc = this.state.startLoc;
  this.next();
  return this.jsxParseElementAt(startPos, startLoc);
};

var jsxPlugin = function (instance) {
  instance.extend("parseExprAtom", function (inner) {
    return function (refShortHandDefaultPos) {
      if (this.match(types.jsxText)) {
        return this.parseLiteral(this.state.value, "JSXText");
      } else if (this.match(types.jsxTagStart)) {
        return this.jsxParseElement();
      } else {
        return inner.call(this, refShortHandDefaultPos);
      }
    };
  });

  instance.extend("readToken", function (inner) {
    return function (code) {
      if (this.state.inPropertyName) return inner.call(this, code);

      var context = this.curContext();

      if (context === types$1.j_expr) {
        return this.jsxReadToken();
      }

      if (context === types$1.j_oTag || context === types$1.j_cTag) {
        if (isIdentifierStart(code)) {
          return this.jsxReadWord();
        }

        if (code === 62) {
          ++this.state.pos;
          return this.finishToken(types.jsxTagEnd);
        }

        if ((code === 34 || code === 39) && context === types$1.j_oTag) {
          return this.jsxReadString(code);
        }
      }

      if (code === 60 && this.state.exprAllowed) {
        ++this.state.pos;
        return this.finishToken(types.jsxTagStart);
      }

      return inner.call(this, code);
    };
  });

  instance.extend("updateContext", function (inner) {
    return function (prevType) {
      if (this.match(types.braceL)) {
        var curContext = this.curContext();
        if (curContext === types$1.j_oTag) {
          this.state.context.push(types$1.braceExpression);
        } else if (curContext === types$1.j_expr) {
          this.state.context.push(types$1.templateQuasi);
        } else {
          inner.call(this, prevType);
        }
        this.state.exprAllowed = true;
      } else if (this.match(types.slash) && prevType === types.jsxTagStart) {
        this.state.context.length -= 2; // do not consider JSX expr -> JSX open tag -> ... anymore
        this.state.context.push(types$1.j_cTag); // reconsider as closing tag context
        this.state.exprAllowed = false;
      } else {
        return inner.call(this, prevType);
      }
    };
  });
};

plugins.estree = estreePlugin;
plugins.flow = flowPlugin;
plugins.jsx = jsxPlugin;

function parse(input, options) {
  return new Parser(options, input).parse();
}

function parseExpression(input, options) {
  var parser = new Parser(options, input);
  if (parser.options.strictMode) {
    parser.state.strict = true;
  }
  return parser.getExpression();
}

exports.parse = parse;
exports.parseExpression = parseExpression;
exports.tokTypes = types;
});

function parseWithFlow(text) {
  // Inline the require to avoid loading all the JS if we don't use it
  const flowParser = flow_parser;

  const ast = flowParser.parse(text, {
    esproposal_class_instance_fields: true,
    esproposal_class_static_fields: true,
    esproposal_export_star_as: true
  });

  if (ast.errors.length > 0) {
    // Construct an error similar to the ones thrown by Babylon.
    const loc = {
      line: ast.errors[0].loc.start.line,
      column: ast.errors[0].loc.start.column
    };
    const msg =
      ast.errors[0].message + " (" + loc.line + ":" + loc.column + ")";
    const error = new SyntaxError(msg);
    error.loc = loc;
    throw error;
  }

  return ast;
}

function parseWithBabylon(text) {
  // Inline the require to avoid loading all the JS if we don't use it
  const babylon = index$34;

  return babylon.parse(text, {
    sourceType: "module",
    allowImportExportEverywhere: false,
    allowReturnOutsideFunction: false,
    plugins: [
      "jsx",
      "flow",
      "doExpressions",
      "objectRestSpread",
      "decorators",
      "classProperties",
      "exportExtensions",
      "asyncGenerators",
      "functionBind",
      "functionSent",
      "dynamicImport"
    ]
  });
}

function parseWithTypeScript(text) {
  // While we are working on typescript, we are putting it in devDependencies
  // so it shouldn't be picked up by static analysis
  const r = commonjsRequire;
  const parser = r("typescript-eslint-parser");
  return parser.parse(text, {
    loc: true,
    range: true,
    tokens: true,
    attachComment: true,
    ecmaFeatures: {
      jsx: true
    }
  });
}

var parser$1 = { parseWithFlow, parseWithBabylon, parseWithTypeScript };

function flattenDoc(doc) {
  if (doc.type === "concat") {
    var res = [];

    for (var i = 0; i < doc.parts.length; ++i) {
      const doc2 = doc.parts[i];
      if (typeof doc2 !== "string" && doc2.type === "concat") {
        [].push.apply(res, flattenDoc(doc2).parts);
      } else {
        const flattened = flattenDoc(doc2);
        if (flattened !== "") {
          res.push(flattened);
        }
      }
    }

    return Object.assign({}, doc, { parts: res });
  } else if (doc.type === "if-break") {
    return Object.assign({}, doc, {
      breakContents: doc.breakContents != null
        ? flattenDoc(doc.breakContents)
        : null,
      flatContents: doc.flatContents != null
        ? flattenDoc(doc.flatContents)
        : null
    });
  } else if (doc.type === "group") {
    return Object.assign({}, doc, {
      contents: flattenDoc(doc.contents),
      expandedStates: doc.expandedStates
        ? doc.expandedStates.map(flattenDoc)
        : doc.expandedStates
    });
  } else if (doc.contents) {
    return Object.assign({}, doc, { contents: flattenDoc(doc.contents) });
  } else {
    return doc;
  }
}

function printDoc(doc) {
  if (typeof doc === "string") {
    return JSON.stringify(doc);
  }

  if (doc.type === "line") {
    if (doc.literalline) {
      return "literalline";
    }
    if (doc.hard) {
      return "hardline";
    }
    if (doc.soft) {
      return "softline";
    }
    return "line";
  }

  if (doc.type === "break-parent") {
    return "breakParent";
  }

  if (doc.type === "concat") {
    return "[" + doc.parts.map(printDoc).join(", ") + "]";
  }

  if (doc.type === "indent") {
    return "indent(" + printDoc(doc.contents) + ")";
  }

  if (doc.type === "align") {
    return "align(" + doc.n + ", " + printDoc(doc.contents) + ")";
  }

  if (doc.type === "if-break") {
    return (
      "ifBreak(" +
      printDoc(doc.breakContents) +
      (doc.flatContents ? ", " + printDoc(doc.flatContents) : "") +
      ")"
    );
  }

  if (doc.type === "group") {
    if (doc.expandedStates) {
      return (
        "conditionalGroup(" +
        "[" +
        doc.expandedStates.map(printDoc).join(",") +
        "])"
      );
    }

    return (
      (doc.break ? "wrappedGroup" : "group") +
      "(" +
      printDoc(doc.contents) +
      ")"
    );
  }

  if (doc.type === "line-suffix") {
    return "lineSuffix(" + printDoc(doc.contents) + ")";
  }

  if (doc.type === "line-suffix-boundary") {
    return "lineSuffixBoundary";
  }

  throw new Error("Unknown doc type " + doc.type);
}

var docDebug = {
  printDocToDebug: function(doc) {
    return printDoc(flattenDoc(doc));
  }
};

var require$$2$10 = ( _package$1 && _package$1['default'] ) || _package$1;

const codeFrame = index$2;
const comments = comments$1;
const version = require$$2$10.version;
const printAstToDoc = printer.printAstToDoc;
const printDocToString = docPrinter.printDocToString;
const normalizeOptions = options.normalize;
const parser = parser$1;
const printDocToDebug = docDebug.printDocToDebug;

function guessLineEnding(text) {
  const index = text.indexOf("\n");
  if (index >= 0 && text.charAt(index - 1) === "\r") {
    return "\r\n";
  }
  return "\n";
}

function parse(text, opts) {
  let parseFunction;

  if (opts.parser === "flow") {
    parseFunction = parser.parseWithFlow;
  } else if (opts.parser === "typescript") {
    parseFunction = parser.parseWithTypeScript;
  } else {
    parseFunction = parser.parseWithBabylon;
  }

  try {
    return parseFunction(text);
  } catch (error) {
    const loc = error.loc;

    if (loc) {
      error.codeFrame = codeFrame(text, loc.line, loc.column + 1, {
        highlightCode: true
      });
      error.message += "\n" + error.codeFrame;
    }

    throw error;
  }
}

function attachComments(text, ast, opts) {
  const astComments = ast.comments;
  if (astComments) {
    delete ast.comments;
    comments.attach(astComments, ast, text, opts);
  }
  ast.tokens = [];
  opts.originalText = text.trimRight();
  return astComments;
}

function ensureAllCommentsPrinted(astComments) {
  for (let i = 0; i < astComments.length; ++i) {
    if (astComments[i].value.trim() === "prettier-ignore") {
      // If there's a prettier-ignore, we're not printing that sub-tree so we
      // don't know if the comments was printed or not.
      return;
    }
  }

  astComments.forEach(comment => {
    if (!comment.printed) {
      throw new Error(
        'Comment "' +
          comment.value.trim() +
          '" was not printed. Please report this error!'
      );
    }
    delete comment.printed;
  });
}

function format(text, opts) {
  const ast = parse(text, opts);
  const astComments = attachComments(text, ast, opts);
  const doc = printAstToDoc(ast, opts);
  opts.newLine = guessLineEnding(text);
  const str = printDocToString(doc, opts);
  ensureAllCommentsPrinted(astComments);
  return str;
}

function formatWithShebang(text, opts) {
  if (!text.startsWith("#!")) {
    return format(text, opts);
  }

  const index = text.indexOf("\n");
  const shebang = text.slice(0, index + 1);
  const programText = text.slice(index + 1);
  const nextChar = text.charAt(index + 1);
  const newLine = nextChar === "\n" ? "\n" : nextChar === "\r" ? "\r\n" : "";

  return shebang + newLine + format(programText, opts);
}

var index = {
  format: function(text, opts) {
    return formatWithShebang(text, normalizeOptions(opts));
  },
  check: function(text, opts) {
    try {
      const formatted = this.format(text, opts);
      return formatted === text;
    } catch (e) {
      return false;
    }
  },
  version: version,
  __debug: {
    formatAST: function(ast, opts) {
      opts = normalizeOptions(opts);
      const doc = printAstToDoc(ast, opts);
      const str = printDocToString(doc, opts);
      return str;
    },
    // Doesn't handle shebang for now
    formatDoc: function(doc, opts) {
      opts = normalizeOptions(opts);
      const debug = printDocToDebug(doc);
      const str = format(debug, opts);
      return str;
    },
    printToDoc: function(text, opts) {
      opts = normalizeOptions(opts);
      const ast = parse(text, opts);
      attachComments(text, ast, opts);
      const doc = printAstToDoc(ast, opts);
      return doc;
    },
    printDocToString: function(doc, opts) {
      opts = normalizeOptions(opts);
      const str = printDocToString(doc, opts);
      return str;
    }
  }
};

return index;

}());

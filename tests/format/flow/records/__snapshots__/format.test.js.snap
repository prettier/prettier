// Jest Snapshot v1, https://jestjs.io/docs/snapshot-testing

exports[`declaration.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
record Empty {}

record Basic {
  foo: string,
  default: boolean = false,
  42: number,
  'one-two': string,
  2n: bigint,
}

record DefaultValueParens {
  foo: number = (1, 2),
}

/**
 * It's a record.
 */
record Comments {
  /**
   * A string property.
   */
  foo: string,
  /**
   * A boolean property.
   */
  bar: boolean = false,
}

record CommentsEmpty {
  // Comment
}

export default record ExportDefault {
  a: number,
}

export record ExportNamed {
  a: number,
}

record Targs<T> {
  foo: T,
  bar: boolean = false,
  class: string,
}

record Implements implements Iface {
  foo: string,
}

record ImplementsMany<T> implements Iface, OtherIface<T> {
  foo: T,
}

record Methods {
  foo: string,

  equals(other: string) {
    return this.foo === other;
  }

  f_tparams<T>() {}

  static f_static(): void {}

  async f_async() {}

  *f_generator() {}

  async *f_async_generator() {}

  static *f_static_generator() {}

  static async f_static_async() {}

  static async *f_all() {}
}

record Static {
  static foo: string = "",
  static bar: boolean = false,
  static 42: number = 0,
  static 'one-two': string = '',
  static 2n: bigint = 0n,
}

=====================================output=====================================
record Empty {}

record Basic {
  foo: string,
  default: boolean = false,
  42: number,
  "one-two": string,
  2n: bigint,
}

record DefaultValueParens {
  foo: number = (1, 2),
}

/**
 * It's a record.
 */
record Comments {
  /**
   * A string property.
   */
  foo: string,
  /**
   * A boolean property.
   */
  bar: boolean = false,
}

record CommentsEmpty {
  // Comment
}

export default record ExportDefault {
  a: number,
};

export record ExportNamed {
  a: number,
}

record Targs<T> {
  foo: T,
  bar: boolean = false,
  class: string,
}

record Implements implements Iface {
  foo: string,
}

record ImplementsMany<T> implements Iface, OtherIface<T> {
  foo: T,
}

record Methods {
  foo: string,

  equals(other: string) {
    return this.foo === other;
  }

  f_tparams<T>() {}

  static f_static(): void {}

  async f_async() {}

  *f_generator() {}

  async *f_async_generator() {}

  static *f_static_generator() {}

  static async f_static_async() {}

  static async *f_all() {}
}

record Static {
  static foo: string = "",
  static bar: boolean = false,
  static 42: number = 0,
  static "one-two": string = "",
  static 2n: bigint = 0n,
}

================================================================================
`;

exports[`expression.js format 1`] = `
====================================options=====================================
parsers: ["flow"]
printWidth: 80
                                                                                | printWidth
=====================================input======================================
const empty = R {};

const basic = R {a: 1, b: 2};

const keysString = R {"one-key": 1, "another-key": 2};

const keysNumber = R {1: "one", 2: "two", 3: "three"};

const shorthand = R {a, b, c: 3};

const spread = R {...x, b: 2};

const typeArgsEmpty = R<> {a: 1};

const typeArgs = R<T, S> {a: 1};

function contextFunc() {
  return R {a: 1, b: 2};
}

const contextCall = foo(R {c: 3});

const contextArr = [R {d: 4}, R {e: 5}];

const contextObj = {nested: R {f: 6}};

class C extends not_parsed_as_a_record_expression {}

const memberIdent = Foo.Bart {a: 1};

const memberStr = Foo["one-two"] {a: 1};

const memberNum = Foo[0] {a: 1};

=====================================output=====================================
const empty = R {};

const basic = R { a: 1, b: 2 };

const keysString = R { "one-key": 1, "another-key": 2 };

const keysNumber = R { 1: "one", 2: "two", 3: "three" };

const shorthand = R { a, b, c: 3 };

const spread = R { ...x, b: 2 };

const typeArgsEmpty = R<> { a: 1 };

const typeArgs = R<T, S> { a: 1 };

function contextFunc() {
  return R { a: 1, b: 2 };
}

const contextCall = foo(R { c: 3 });

const contextArr = [R { d: 4 }, R { e: 5 }];

const contextObj = { nested: R { f: 6 } };

class C extends not_parsed_as_a_record_expression {}

const memberIdent = Foo.Bart { a: 1 };

const memberStr = Foo["one-two"] { a: 1 };

const memberNum = Foo[0] { a: 1 };

================================================================================
`;
